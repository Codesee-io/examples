import { createRequire as topLevelCreateRequire } from 'module';
const require = topLevelCreateRequire(import.meta.url);
import { fileURLToPath as topLevelFileUrlToPath } from "url"
const __dirname = topLevelFileUrlToPath(new URL(".", import.meta.url))

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// node_modules/dd-trace/packages/dd-trace/src/util.js
var require_util = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/util.js"(exports2, module2) {
    "use strict";
    function isTrue(str) {
      str = String(str).toLowerCase();
      return str === "true" || str === "1";
    }
    __name(isTrue, "isTrue");
    function isFalse(str) {
      str = String(str).toLowerCase();
      return str === "false" || str === "0";
    }
    __name(isFalse, "isFalse");
    function isError(value) {
      if (value instanceof Error) {
        return true;
      }
      if (value && value.message && value.stack) {
        return true;
      }
      return false;
    }
    __name(isError, "isError");
    function globMatch(pattern, subject) {
      let px = 0;
      let sx = 0;
      let nextPx = 0;
      let nextSx = 0;
      while (px < pattern.length || sx < subject.length) {
        if (px < pattern.length) {
          const c = pattern[px];
          switch (c) {
            default:
              if (sx < subject.length && subject[sx] === c) {
                px++;
                sx++;
                continue;
              }
              break;
            case "?":
              if (sx < subject.length) {
                px++;
                sx++;
                continue;
              }
              break;
            case "*":
              nextPx = px;
              nextSx = sx + 1;
              px++;
              continue;
          }
        }
        if (nextSx > 0 && nextSx <= subject.length) {
          px = nextPx;
          sx = nextSx;
          continue;
        }
        return false;
      }
      return true;
    }
    __name(globMatch, "globMatch");
    module2.exports = {
      isTrue,
      isFalse,
      isError,
      globMatch
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/noop/scope.js
var require_scope = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/noop/scope.js"(exports2, module2) {
    "use strict";
    var Scope = class {
      active() {
        return null;
      }
      activate(span, callback) {
        if (typeof callback !== "function")
          return callback;
        return callback();
      }
      bind(fn, span) {
        return fn;
      }
    };
    __name(Scope, "Scope");
    module2.exports = Scope;
  }
});

// node_modules/dd-trace/ext/priority.js
var require_priority = __commonJS({
  "node_modules/dd-trace/ext/priority.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      USER_REJECT: -1,
      AUTO_REJECT: 0,
      AUTO_KEEP: 1,
      USER_KEEP: 2
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js
var require_span_context = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/opentracing/span_context.js"(exports2, module2) {
    "use strict";
    var { AUTO_KEEP } = require_priority();
    var DatadogSpanContext = class {
      constructor(props) {
        props = props || {};
        this._traceId = props.traceId;
        this._spanId = props.spanId;
        this._parentId = props.parentId || null;
        this._name = props.name;
        this._isFinished = props.isFinished || false;
        this._tags = props.tags || {};
        this._sampling = props.sampling || {};
        this._baggageItems = props.baggageItems || {};
        this._traceparent = props.traceparent;
        this._tracestate = props.tracestate;
        this._noop = props.noop || null;
        this._trace = props.trace || {
          started: [],
          finished: [],
          tags: {}
        };
      }
      toTraceId() {
        return this._traceId.toString(10);
      }
      toSpanId() {
        return this._spanId.toString(10);
      }
      toTraceparent() {
        const flags = this._sampling.priority >= AUTO_KEEP ? "01" : "00";
        const traceId = this._traceId.toString(16).padStart(32, "0");
        const spanId = this._spanId.toString(16).padStart(16, "0");
        const version = this._traceparent && this._traceparent.version || "00";
        return `${version}-${traceId}-${spanId}-${flags}`;
      }
    };
    __name(DatadogSpanContext, "DatadogSpanContext");
    module2.exports = DatadogSpanContext;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js
var require_span_context2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/noop/span_context.js"(exports2, module2) {
    "use strict";
    var DatadogSpanContext = require_span_context();
    var priority = require_priority();
    var USER_REJECT = priority.USER_REJECT;
    var NoopSpanContext = class extends DatadogSpanContext {
      constructor(props) {
        super(props);
        this._sampling.priority = USER_REJECT;
      }
    };
    __name(NoopSpanContext, "NoopSpanContext");
    module2.exports = NoopSpanContext;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/id.js
var require_id = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/id.js"(exports2, module2) {
    "use strict";
    var { randomFillSync } = __require("crypto");
    var UINT_MAX = 4294967296;
    var data = new Uint8Array(8 * 8192);
    var zeroId = new Uint8Array(8);
    var map = Array.prototype.map;
    var pad = /* @__PURE__ */ __name((byte) => `${byte < 16 ? "0" : ""}${byte.toString(16)}`, "pad");
    var batch = 0;
    var Identifier = class {
      constructor(value, radix = 16) {
        this._isUint64BE = true;
        this._buffer = radix === 16 ? createBuffer(value) : fromString(value, radix);
      }
      toString(radix = 16) {
        return radix === 16 ? toHexString(this._buffer) : toNumberString(this._buffer, radix);
      }
      toBuffer() {
        return this._buffer;
      }
      toArray() {
        if (this._buffer.length === 8) {
          return this._buffer;
        }
        return this._buffer.slice(-8);
      }
      toJSON() {
        return this.toString();
      }
    };
    __name(Identifier, "Identifier");
    function createBuffer(value) {
      if (value === "0")
        return zeroId;
      if (!value)
        return pseudoRandom();
      const size = Math.ceil(value.length / 16) * 16;
      const bytes = size / 2;
      const buffer = new Array(bytes);
      value = value.padStart(size, "0");
      for (let i = 0; i < bytes; i++) {
        buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16);
      }
      return buffer;
    }
    __name(createBuffer, "createBuffer");
    function fromString(str, raddix) {
      const buffer = new Array(8);
      const len = str.length;
      let pos = 0;
      let high = 0;
      let low = 0;
      if (str[0] === "-")
        pos++;
      const sign = pos;
      while (pos < len) {
        const chr = parseInt(str[pos++], raddix);
        if (!(chr >= 0))
          break;
        low = low * raddix + chr;
        high = high * raddix + Math.floor(low / UINT_MAX);
        low %= UINT_MAX;
      }
      if (sign) {
        high = ~high;
        if (low) {
          low = UINT_MAX - low;
        } else {
          high++;
        }
      }
      writeUInt32BE(buffer, high, 0);
      writeUInt32BE(buffer, low, 4);
      return buffer;
    }
    __name(fromString, "fromString");
    function toNumberString(buffer, radix) {
      let high = readInt32(buffer, buffer.length - 8);
      let low = readInt32(buffer, buffer.length - 4);
      let str = "";
      radix = radix || 10;
      while (1) {
        const mod2 = high % radix * UINT_MAX + low;
        high = Math.floor(high / radix);
        low = Math.floor(mod2 / radix);
        str = (mod2 % radix).toString(radix) + str;
        if (!high && !low)
          break;
      }
      return str;
    }
    __name(toNumberString, "toNumberString");
    function toHexString(buffer) {
      return map.call(buffer, pad).join("");
    }
    __name(toHexString, "toHexString");
    function pseudoRandom() {
      if (batch === 0) {
        randomFillSync(data);
      }
      batch = (batch + 1) % 8192;
      const offset = batch * 8;
      return [
        data[offset] & 127,
        data[offset + 1],
        data[offset + 2],
        data[offset + 3],
        data[offset + 4],
        data[offset + 5],
        data[offset + 6],
        data[offset + 7]
      ];
    }
    __name(pseudoRandom, "pseudoRandom");
    function readInt32(buffer, offset) {
      return buffer[offset + 0] * 16777216 + (buffer[offset + 1] << 16) + (buffer[offset + 2] << 8) + buffer[offset + 3];
    }
    __name(readInt32, "readInt32");
    function writeUInt32BE(buffer, value, offset) {
      buffer[3 + offset] = value & 255;
      value = value >> 8;
      buffer[2 + offset] = value & 255;
      value = value >> 8;
      buffer[1 + offset] = value & 255;
      value = value >> 8;
      buffer[0 + offset] = value & 255;
    }
    __name(writeUInt32BE, "writeUInt32BE");
    module2.exports = (value, radix) => new Identifier(value, radix);
  }
});

// node_modules/dd-trace/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/dd-trace/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = /* @__PURE__ */ __name(function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      }, "debug");
    } else {
      debug = /* @__PURE__ */ __name(function() {
      }, "debug");
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    __name(parse, "parse");
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    __name(valid, "valid");
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    __name(clean, "clean");
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    __name(SemVer, "SemVer");
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    __name(inc, "inc");
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    __name(diff, "diff");
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    __name(compareIdentifiers, "compareIdentifiers");
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    __name(rcompareIdentifiers, "rcompareIdentifiers");
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    __name(major, "major");
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    __name(minor, "minor");
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    __name(patch, "patch");
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    __name(compare, "compare");
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    __name(compareLoose, "compareLoose");
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    __name(rcompare, "rcompare");
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    __name(sort, "sort");
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    __name(rsort, "rsort");
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    __name(gt, "gt");
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    __name(lt, "lt");
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    __name(eq, "eq");
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    __name(neq, "neq");
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    __name(gte, "gte");
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    __name(lte, "lte");
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    __name(cmp, "cmp");
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    __name(Comparator, "Comparator");
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    __name(Range, "Range");
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    __name(toComparators, "toComparators");
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    __name(parseComparator, "parseComparator");
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    __name(isX, "isX");
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    __name(replaceTildes, "replaceTildes");
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    __name(replaceTilde, "replaceTilde");
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    __name(replaceCarets, "replaceCarets");
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    __name(replaceCaret, "replaceCaret");
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    __name(replaceXRanges, "replaceXRanges");
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    __name(replaceXRange, "replaceXRange");
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[STAR], "");
    }
    __name(replaceStars, "replaceStars");
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    __name(hyphenReplace, "hyphenReplace");
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    __name(testSet, "testSet");
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    __name(satisfies, "satisfies");
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    __name(maxSatisfying, "maxSatisfying");
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    __name(minSatisfying, "minSatisfying");
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    __name(minVersion, "minVersion");
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    __name(validRange, "validRange");
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    __name(ltr, "ltr");
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    __name(gtr, "gtr");
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    __name(outside, "outside");
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    __name(prerelease, "prerelease");
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    __name(intersects, "intersects");
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
    __name(coerce, "coerce");
  }
});

// node_modules/dd-trace/packages/datadog-core/src/storage/async_resource.js
var require_async_resource = __commonJS({
  "node_modules/dd-trace/packages/datadog-core/src/storage/async_resource.js"(exports2, module2) {
    "use strict";
    var { createHook, executionAsyncResource } = __require("async_hooks");
    var { channel } = __require("diagnostics_channel");
    var beforeCh = channel("dd-trace:storage:before");
    var afterCh = channel("dd-trace:storage:after");
    var PrivateSymbol = Symbol;
    function makePrivateSymbol() {
      PrivateSymbol = new Function("name", "return %CreatePrivateSymbol(name)");
    }
    __name(makePrivateSymbol, "makePrivateSymbol");
    try {
      makePrivateSymbol();
    } catch (e) {
      try {
        const v8 = __require("v8");
        v8.setFlagsFromString("--allow-natives-syntax");
        makePrivateSymbol();
        v8.setFlagsFromString("--no-allow-natives-syntax");
      } catch (e2) {
      }
    }
    var AsyncResourceStorage = class {
      constructor() {
        this._ddResourceStore = PrivateSymbol("ddResourceStore");
        this._enabled = false;
        this._hook = createHook(this._createHook());
      }
      disable() {
        if (!this._enabled)
          return;
        this._hook.disable();
        this._enabled = false;
      }
      getStore() {
        if (!this._enabled)
          return;
        const resource = this._executionAsyncResource();
        return resource[this._ddResourceStore];
      }
      enterWith(store) {
        this._enable();
        const resource = this._executionAsyncResource();
        resource[this._ddResourceStore] = store;
      }
      run(store, callback, ...args) {
        this._enable();
        const resource = this._executionAsyncResource();
        const oldStore = resource[this._ddResourceStore];
        resource[this._ddResourceStore] = store;
        try {
          return callback(...args);
        } finally {
          resource[this._ddResourceStore] = oldStore;
        }
      }
      _createHook() {
        return {
          init: this._init.bind(this),
          before() {
            beforeCh.publish();
          },
          after() {
            afterCh.publish();
          }
        };
      }
      _enable() {
        if (this._enabled)
          return;
        this._enabled = true;
        this._hook.enable();
      }
      _init(asyncId, type, triggerAsyncId, resource) {
        const currentResource = this._executionAsyncResource();
        if (Object.prototype.hasOwnProperty.call(currentResource, this._ddResourceStore)) {
          resource[this._ddResourceStore] = currentResource[this._ddResourceStore];
        }
      }
      _executionAsyncResource() {
        return executionAsyncResource() || {};
      }
    };
    __name(AsyncResourceStorage, "AsyncResourceStorage");
    module2.exports = AsyncResourceStorage;
  }
});

// node_modules/dd-trace/packages/datadog-core/src/storage/async_hooks.js
var require_async_hooks = __commonJS({
  "node_modules/dd-trace/packages/datadog-core/src/storage/async_hooks.js"(exports2, module2) {
    "use strict";
    var { executionAsyncId } = __require("async_hooks");
    var AsyncResourceStorage = require_async_resource();
    var AsyncHooksStorage = class extends AsyncResourceStorage {
      constructor() {
        super();
        this._resources = /* @__PURE__ */ new Map();
      }
      disable() {
        super.disable();
        this._resources.clear();
      }
      _createHook() {
        return {
          ...super._createHook(),
          destroy: this._destroy.bind(this)
        };
      }
      _init(asyncId, type, triggerAsyncId, resource) {
        super._init.apply(this, arguments);
        this._resources.set(asyncId, resource);
      }
      _destroy(asyncId) {
        this._resources.delete(asyncId);
      }
      _executionAsyncResource() {
        const asyncId = executionAsyncId();
        let resource = this._resources.get(asyncId);
        if (!resource) {
          this._resources.set(asyncId, resource = {});
        }
        return resource;
      }
    };
    __name(AsyncHooksStorage, "AsyncHooksStorage");
    module2.exports = AsyncHooksStorage;
  }
});

// node_modules/dd-trace/packages/datadog-core/src/storage/index.js
var require_storage = __commonJS({
  "node_modules/dd-trace/packages/datadog-core/src/storage/index.js"(exports2, module2) {
    "use strict";
    var semver = require_semver();
    var hasJavaScriptAsyncHooks = semver.satisfies(process.versions.node, ">=14.5");
    if (hasJavaScriptAsyncHooks) {
      module2.exports = require_async_resource();
    } else {
      module2.exports = require_async_hooks();
    }
  }
});

// node_modules/dd-trace/packages/datadog-core/index.js
var require_datadog_core = __commonJS({
  "node_modules/dd-trace/packages/datadog-core/index.js"(exports2, module2) {
    "use strict";
    var LocalStorage = require_storage();
    var storage = new LocalStorage();
    module2.exports = { storage };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/noop/span.js
var require_span = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/noop/span.js"(exports2, module2) {
    "use strict";
    var NoopSpanContext = require_span_context2();
    var id = require_id();
    var { storage } = require_datadog_core();
    var NoopSpan = class {
      constructor(tracer2, parent) {
        this._store = storage.getStore();
        this._noopTracer = tracer2;
        this._noopContext = this._createContext(parent);
      }
      context() {
        return this._noopContext;
      }
      tracer() {
        return this._noopTracer;
      }
      setOperationName(name) {
        return this;
      }
      setBaggageItem(key, value) {
        return this;
      }
      getBaggageItem(key) {
      }
      setTag(key, value) {
        return this;
      }
      addTags(keyValueMap) {
        return this;
      }
      log() {
        return this;
      }
      logEvent() {
      }
      finish(finishTime) {
      }
      _createContext(parent) {
        const spanId = id();
        if (parent) {
          return new NoopSpanContext({
            noop: this,
            traceId: parent._traceId,
            spanId,
            parentId: parent._spanId,
            baggageItems: Object.assign({}, parent._baggageItems)
          });
        } else {
          return new NoopSpanContext({
            noop: this,
            traceId: spanId,
            spanId
          });
        }
      }
    };
    __name(NoopSpan, "NoopSpan");
    module2.exports = NoopSpan;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js
var require_tracer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/noop/tracer.js"(exports2, module2) {
    "use strict";
    var Scope = require_scope();
    var Span = require_span();
    var NoopTracer = class {
      constructor(config) {
        this._scope = new Scope();
        this._span = new Span(this);
      }
      trace(name, options, fn) {
        return fn(this._span, () => {
        });
      }
      wrap(name, options, fn) {
        return fn;
      }
      scope() {
        return this._scope;
      }
      getRumData() {
        return "";
      }
      setUrl() {
      }
      startSpan(name, options) {
        return this._span;
      }
      inject(spanContext, format, carrier) {
      }
      extract(format, carrier) {
        return this._span.context();
      }
      setUser() {
        return this;
      }
    };
    __name(NoopTracer, "NoopTracer");
    module2.exports = NoopTracer;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/noop.js
var require_noop = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/noop.js"(exports2, module2) {
    "use strict";
    var NoopAppsecSdk = class {
      trackUserLoginSuccessEvent() {
      }
      trackUserLoginFailureEvent() {
      }
      trackCustomEvent() {
      }
    };
    __name(NoopAppsecSdk, "NoopAppsecSdk");
    module2.exports = NoopAppsecSdk;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/noop/proxy.js
var require_proxy = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/noop/proxy.js"(exports2, module2) {
    "use strict";
    var NoopTracer = require_tracer();
    var NoopAppsecSdk = require_noop();
    var noop = new NoopTracer();
    var noopAppsec = new NoopAppsecSdk();
    var Tracer = class {
      constructor() {
        this._tracer = noop;
        this.appsec = noopAppsec;
      }
      init() {
        return this;
      }
      use() {
        return this;
      }
      trace(name, options, fn) {
        if (!fn) {
          fn = options;
          options = {};
        }
        if (typeof fn !== "function")
          return;
        options = options || {};
        return this._tracer.trace(name, options, fn);
      }
      wrap(name, options, fn) {
        if (!fn) {
          fn = options;
          options = {};
        }
        if (typeof fn !== "function")
          return fn;
        options = options || {};
        return this._tracer.wrap(name, options, fn);
      }
      setUrl() {
        this._tracer.setUrl.apply(this._tracer, arguments);
        return this;
      }
      startSpan() {
        return this._tracer.startSpan.apply(this._tracer, arguments);
      }
      inject() {
        return this._tracer.inject.apply(this._tracer, arguments);
      }
      extract() {
        return this._tracer.extract.apply(this._tracer, arguments);
      }
      scope() {
        return this._tracer.scope.apply(this._tracer, arguments);
      }
      getRumData() {
        return this._tracer.getRumData.apply(this._tracer, arguments);
      }
      setUser() {
        this._tracer.setUser.apply(this._tracer, arguments);
        return this;
      }
    };
    __name(Tracer, "Tracer");
    module2.exports = Tracer;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/log/channels.js
var require_channels = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/log/channels.js"(exports2, module2) {
    "use strict";
    var dc = __require("diagnostics_channel");
    var Level = {
      Debug: "debug",
      Info: "info",
      Warn: "warn",
      Error: "error"
    };
    var defaultLevel = Level.Debug;
    var LogChannel = class extends dc.Channel {
      constructor(name, logLevel) {
        super(`datadog:log:${name}`);
        this.logLevel = logLevel;
      }
    };
    __name(LogChannel, "LogChannel");
    var logChannels = {
      [Level.Debug]: new LogChannel(Level.Debug, 20),
      [Level.Info]: new LogChannel(Level.Info, 30),
      [Level.Warn]: new LogChannel(Level.Warn, 40),
      [Level.Error]: new LogChannel(Level.Error, 50)
    };
    function getChannelLogLevel(level) {
      let logChannel;
      if (level && typeof level === "string") {
        logChannel = logChannels[level.toLowerCase().trim()] || logChannels[defaultLevel];
      } else {
        logChannel = logChannels[defaultLevel];
      }
      return logChannel.logLevel;
    }
    __name(getChannelLogLevel, "getChannelLogLevel");
    module2.exports = {
      Level,
      getChannelLogLevel,
      debugChannel: logChannels[Level.Debug],
      infoChannel: logChannels[Level.Info],
      warnChannel: logChannels[Level.Warn],
      errorChannel: logChannels[Level.Error]
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/log/writer.js
var require_writer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/log/writer.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var { getChannelLogLevel, debugChannel, infoChannel, warnChannel, errorChannel } = require_channels();
    var defaultLogger = {
      debug: (msg) => console.debug(msg),
      info: (msg) => console.info(msg),
      warn: (msg) => console.warn(msg),
      error: (msg) => console.error(msg)
    };
    var enabled = false;
    var logger = defaultLogger;
    var logLevel = getChannelLogLevel();
    function withNoop(fn) {
      const store = storage.getStore();
      storage.enterWith({ noop: true });
      fn();
      storage.enterWith(store);
    }
    __name(withNoop, "withNoop");
    function unsubscribeAll() {
      if (debugChannel.hasSubscribers) {
        debugChannel.unsubscribe(onDebug);
      }
      if (infoChannel.hasSubscribers) {
        infoChannel.unsubscribe(onInfo);
      }
      if (warnChannel.hasSubscribers) {
        warnChannel.unsubscribe(onWarn);
      }
      if (errorChannel.hasSubscribers) {
        errorChannel.unsubscribe(onError);
      }
    }
    __name(unsubscribeAll, "unsubscribeAll");
    function toggleSubscription(enable) {
      unsubscribeAll();
      if (enable) {
        if (debugChannel.logLevel >= logLevel) {
          debugChannel.subscribe(onDebug);
        }
        if (infoChannel.logLevel >= logLevel) {
          infoChannel.subscribe(onInfo);
        }
        if (warnChannel.logLevel >= logLevel) {
          warnChannel.subscribe(onWarn);
        }
        if (errorChannel.logLevel >= logLevel) {
          errorChannel.subscribe(onError);
        }
      }
    }
    __name(toggleSubscription, "toggleSubscription");
    function toggle(enable, level) {
      if (level !== void 0) {
        logLevel = getChannelLogLevel(level);
      }
      enabled = enable;
      toggleSubscription(enabled);
    }
    __name(toggle, "toggle");
    function use(newLogger) {
      if (newLogger && newLogger.debug instanceof Function && newLogger.error instanceof Function) {
        logger = newLogger;
      }
    }
    __name(use, "use");
    function reset() {
      logger = defaultLogger;
      enabled = false;
      logLevel = getChannelLogLevel();
      toggleSubscription(false);
    }
    __name(reset, "reset");
    function onError(err) {
      if (enabled) {
        if (typeof err !== "object" || !err) {
          err = String(err);
        } else if (!err.stack) {
          err = String(err.message || err);
        }
        if (typeof err === "string") {
          err = new Error(err);
        }
        withNoop(() => logger.error(err));
      }
    }
    __name(onError, "onError");
    function onWarn(message) {
      if (!logger.warn)
        return onDebug(message);
      if (enabled) {
        withNoop(() => logger.warn(message));
      }
    }
    __name(onWarn, "onWarn");
    function onInfo(message) {
      if (!logger.info)
        return onDebug(message);
      if (enabled) {
        withNoop(() => logger.info(message));
      }
    }
    __name(onInfo, "onInfo");
    function onDebug(message) {
      if (enabled) {
        withNoop(() => logger.debug(message));
      }
    }
    __name(onDebug, "onDebug");
    module2.exports = { use, toggle, reset };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/log/index.js
var require_log = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/log/index.js"(exports2, module2) {
    "use strict";
    var { debugChannel, infoChannel, warnChannel, errorChannel } = require_channels();
    var logWriter = require_writer();
    var memoize = /* @__PURE__ */ __name((func) => {
      const cache = {};
      const memoized = /* @__PURE__ */ __name(function(key) {
        if (!cache[key]) {
          cache[key] = func.apply(this, arguments);
        }
        return cache[key];
      }, "memoized");
      return memoized;
    }, "memoize");
    function processMsg(msg) {
      return typeof msg === "function" ? msg() : msg;
    }
    __name(processMsg, "processMsg");
    var log = {
      use(logger) {
        logWriter.use(logger);
        return this;
      },
      toggle(enabled, logLevel) {
        logWriter.toggle(enabled, logLevel);
        return this;
      },
      reset() {
        logWriter.reset();
        this._deprecate = memoize((code, message) => {
          errorChannel.publish(message);
          return true;
        });
        return this;
      },
      debug(message) {
        if (debugChannel.hasSubscribers) {
          debugChannel.publish(processMsg(message));
        }
        return this;
      },
      info(message) {
        if (infoChannel.hasSubscribers) {
          infoChannel.publish(processMsg(message));
        }
        return this;
      },
      warn(message) {
        if (warnChannel.hasSubscribers) {
          warnChannel.publish(processMsg(message));
        }
        return this;
      },
      error(err) {
        if (errorChannel.hasSubscribers) {
          errorChannel.publish(processMsg(err));
        }
        return this;
      },
      deprecate(code, message) {
        return this._deprecate(code, message);
      }
    };
    log.reset();
    module2.exports = log;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/tagger.js
var require_tagger = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/tagger.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    function add(carrier, keyValuePairs) {
      if (!carrier || !keyValuePairs)
        return;
      if (Array.isArray(keyValuePairs)) {
        return keyValuePairs.forEach((tags) => add(carrier, tags));
      }
      try {
        if (typeof keyValuePairs === "string") {
          const segments = keyValuePairs.split(",");
          for (const segment of segments) {
            const separatorIndex = segment.indexOf(":");
            if (separatorIndex === -1)
              continue;
            const key = segment.slice(0, separatorIndex);
            const value = segment.slice(separatorIndex + 1);
            carrier[key.trim()] = value.trim();
          }
        } else {
          Object.assign(carrier, keyValuePairs);
        }
      } catch (e) {
        log.error(e);
      }
    }
    __name(add, "add");
    module2.exports = { add };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js
var require_docker = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporters/common/docker.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var uuidSource = "[0-9a-f]{8}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{12}";
    var containerSource = "[0-9a-f]{64}";
    var taskSource = "[0-9a-f]{32}-\\d+";
    var entityReg = new RegExp(`.*(${uuidSource}|${containerSource}|${taskSource})(?:\\.scope)?$`, "m");
    var entityId = getEntityId();
    function getEntityId() {
      const cgroup = readControlGroup() || "";
      const match = cgroup.trim().match(entityReg) || [];
      return match[1];
    }
    __name(getEntityId, "getEntityId");
    function readControlGroup() {
      try {
        return fs.readFileSync("/proc/self/cgroup").toString();
      } catch (err) {
      }
    }
    __name(readControlGroup, "readControlGroup");
    module2.exports = {
      id() {
        return entityId;
      }
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js
var require_request = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporters/common/request.js"(exports2, module2) {
    "use strict";
    var { Readable } = __require("stream");
    var http = __require("http");
    var https = __require("https");
    var { parse: urlParse } = __require("url");
    var docker = require_docker();
    var { storage } = require_datadog_core();
    var log = require_log();
    var keepAlive = true;
    var maxSockets = 1;
    var maxActiveRequests = 8;
    var httpAgent = new http.Agent({ keepAlive, maxSockets });
    var httpsAgent = new https.Agent({ keepAlive, maxSockets });
    var containerId = docker.id();
    var activeRequests = 0;
    function urlToOptions(url) {
      const agent = url.agent || http.globalAgent;
      const options = {
        protocol: url.protocol || agent.protocol,
        hostname: typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname || url.host || "localhost",
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: `${url.pathname || ""}${url.search || ""}`,
        href: url.href
      };
      if (url.port !== "") {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
      }
      return options;
    }
    __name(urlToOptions, "urlToOptions");
    function fromUrlString(url) {
      return typeof urlToHttpOptions === "function" ? urlToOptions(new URL(url)) : urlParse(url);
    }
    __name(fromUrlString, "fromUrlString");
    function request(data, options, callback) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.url) {
        const url = typeof options.url === "object" ? options.url : fromUrlString(options.url);
        if (url.protocol === "unix:") {
          options.socketPath = url.pathname;
        } else {
          if (!options.path)
            options.path = url.path;
          options.protocol = url.protocol;
          options.hostname = url.hostname;
          options.port = url.port;
        }
      }
      const isReadable = data instanceof Readable;
      const timeout = options.timeout || 2e3;
      const isSecure = options.protocol === "https:";
      const client = isSecure ? https : http;
      const dataArray = [].concat(data);
      if (!isReadable) {
        options.headers["Content-Length"] = byteLength(dataArray);
      }
      if (containerId) {
        options.headers["Datadog-Container-ID"] = containerId;
      }
      options.agent = isSecure ? httpsAgent : httpAgent;
      const onResponse = /* @__PURE__ */ __name((res) => {
        let responseData = "";
        res.setTimeout(timeout);
        res.on("data", (chunk) => {
          responseData += chunk;
        });
        res.on("end", () => {
          activeRequests--;
          if (res.statusCode >= 200 && res.statusCode <= 299) {
            callback(null, responseData, res.statusCode);
          } else {
            let errorMessage = "";
            try {
              const fullUrl = new URL(
                options.path,
                options.url || options.hostname || `http://localhost:${options.port}`
              ).href;
              errorMessage = `Error from ${fullUrl}: ${res.statusCode} ${http.STATUS_CODES[res.statusCode]}.`;
            } catch (e) {
            }
            if (responseData) {
              errorMessage += ` Response from the endpoint: "${responseData}"`;
            }
            const error = new Error(errorMessage);
            error.status = res.statusCode;
            callback(error, null, res.statusCode);
          }
        });
      }, "onResponse");
      const makeRequest = /* @__PURE__ */ __name((onError) => {
        if (!request.writable) {
          log.debug("Maximum number of active requests reached: payload is discarded.");
          return callback(null);
        }
        activeRequests++;
        const store = storage.getStore();
        storage.enterWith({ noop: true });
        const req = client.request(options, onResponse);
        req.once("error", (err) => {
          activeRequests--;
          onError(err);
        });
        req.setTimeout(timeout, req.abort);
        if (isReadable) {
          data.pipe(req);
        } else {
          dataArray.forEach((buffer) => req.write(buffer));
          req.end();
        }
        storage.enterWith(store);
      }, "makeRequest");
      makeRequest(() => setTimeout(() => makeRequest(callback)));
    }
    __name(request, "request");
    function byteLength(data) {
      return data.length > 0 ? data.reduce((prev, next) => prev + next.length, 0) : 0;
    }
    __name(byteLength, "byteLength");
    Object.defineProperty(request, "writable", {
      get() {
        return activeRequests < maxActiveRequests;
      }
    });
    module2.exports = request;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/dogstatsd.js
var require_dogstatsd = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/dogstatsd.js"(exports2, module2) {
    "use strict";
    var lookup = __require("dns").lookup;
    var request = require_request();
    var dgram = __require("dgram");
    var isIP = __require("net").isIP;
    var log = require_log();
    var MAX_BUFFER_SIZE = 1024;
    var Client = class {
      constructor(options) {
        options = options || {};
        if (options.metricsProxyUrl) {
          this._httpOptions = {
            url: options.metricsProxyUrl.toString(),
            path: "/dogstatsd/v2/proxy"
          };
        }
        this._host = options.host || "localhost";
        this._family = isIP(this._host);
        this._port = options.port || 8125;
        this._prefix = options.prefix || "";
        this._tags = options.tags || [];
        this._queue = [];
        this._buffer = "";
        this._offset = 0;
        this._udp4 = this._socket("udp4");
        this._udp6 = this._socket("udp6");
      }
      gauge(stat, value, tags) {
        this._add(stat, value, "g", tags);
      }
      increment(stat, value, tags) {
        this._add(stat, value, "c", tags);
      }
      flush() {
        const queue = this._enqueue();
        if (this._queue.length === 0)
          return;
        this._queue = [];
        if (this._httpOptions) {
          this._sendHttp(queue);
        } else {
          this._sendUdp(queue);
        }
      }
      _sendHttp(queue) {
        const buffer = Buffer.concat(queue);
        request(buffer, this._httpOptions, (err) => {
          if (err) {
            log.error("HTTP error from agent: " + err.stack);
            if (err.status) {
              if (err.status === 404) {
                this._httpOptions = null;
              }
              this._sendUdp(queue);
            }
          }
        });
      }
      _sendUdp(queue) {
        if (this._family !== 0) {
          this._sendUdpFromQueue(queue, this._host, this._family);
        } else {
          lookup(this._host, (err, address, family) => {
            if (err)
              return log.error(err);
            this._sendUdpFromQueue(queue, address, family);
          });
        }
      }
      _sendUdpFromQueue(queue, address, family) {
        const socket = family === 6 ? this._udp6 : this._udp4;
        queue.forEach((buffer) => {
          log.debug(`Sending to DogStatsD: ${buffer}`);
          socket.send(buffer, 0, buffer.length, this._port, address);
        });
      }
      _add(stat, value, type, tags) {
        const message = `${this._prefix + stat}:${value}|${type}`;
        tags = tags ? this._tags.concat(tags) : this._tags;
        if (tags.length > 0) {
          this._write(`${message}|#${tags.join(",")}
`);
        } else {
          this._write(`${message}
`);
        }
      }
      _write(message) {
        const offset = Buffer.byteLength(message);
        if (this._offset + offset > MAX_BUFFER_SIZE) {
          this._enqueue();
        }
        this._offset += offset;
        this._buffer += message;
      }
      _enqueue() {
        if (this._offset > 0) {
          this._queue.push(Buffer.from(this._buffer));
          this._buffer = "";
          this._offset = 0;
        }
        return this._queue;
      }
      _socket(type) {
        const socket = dgram.createSocket(type);
        socket.on("error", () => {
        });
        socket.unref();
        return socket;
      }
    };
    __name(Client, "Client");
    module2.exports = Client;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js
var require_util2 = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sumOfRange = void 0;
    var sumOfRange = /* @__PURE__ */ __name(function(array, start, end) {
      var sum = 0;
      for (var i = start; i <= end; i++) {
        sum += array[i];
      }
      return sum;
    }, "sumOfRange");
    exports2.sumOfRange = sumOfRange;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(/* @__PURE__ */ __name(function executor(resolve, reject) {
        params[offset] = /* @__PURE__ */ __name(function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        }, "callback");
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      }, "executor"));
    }
    __name(asPromise, "asPromise");
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = /* @__PURE__ */ __name(function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    }, "length");
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = /* @__PURE__ */ __name(function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    }, "encode");
    var invalidEncoding = "invalid encoding";
    base64.decode = /* @__PURE__ */ __name(function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    }, "decode");
    base64.test = /* @__PURE__ */ __name(function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    }, "test");
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    __name(EventEmitter, "EventEmitter");
    EventEmitter.prototype.on = /* @__PURE__ */ __name(function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    }, "on");
    EventEmitter.prototype.off = /* @__PURE__ */ __name(function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    }, "off");
    EventEmitter.prototype.emit = /* @__PURE__ */ __name(function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    }, "emit");
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          __name(writeFloat_f32_cpy, "writeFloat_f32_cpy");
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          __name(writeFloat_f32_rev, "writeFloat_f32_rev");
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          __name(readFloat_f32_cpy, "readFloat_f32_cpy");
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          __name(readFloat_f32_rev, "readFloat_f32_rev");
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          __name(writeFloat_ieee754, "writeFloat_ieee754");
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          __name(readFloat_ieee754, "readFloat_ieee754");
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          __name(writeDouble_f64_cpy, "writeDouble_f64_cpy");
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          __name(writeDouble_f64_rev, "writeDouble_f64_rev");
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          __name(readDouble_f64_cpy, "readDouble_f64_cpy");
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          __name(readDouble_f64_rev, "readDouble_f64_rev");
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          __name(writeDouble_ieee754, "writeDouble_ieee754");
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          __name(readDouble_ieee754, "readDouble_ieee754");
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    __name(factory, "factory");
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    __name(writeUintLE, "writeUintLE");
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    __name(writeUintBE, "writeUintBE");
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    __name(readUintLE, "readUintLE");
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
    __name(readUintBE, "readUintBE");
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
    __name(inquire, "inquire");
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = /* @__PURE__ */ __name(function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    }, "utf8_length");
    utf8.read = /* @__PURE__ */ __name(function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    }, "utf8_read");
    utf8.write = /* @__PURE__ */ __name(function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    }, "utf8_write");
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return /* @__PURE__ */ __name(function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      }, "pool_alloc");
    }
    __name(pool, "pool");
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    __name(LongBits, "LongBits");
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = /* @__PURE__ */ __name(function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    }, "fromNumber");
    LongBits.from = /* @__PURE__ */ __name(function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    }, "from");
    LongBits.prototype.toNumber = /* @__PURE__ */ __name(function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }, "toNumber");
    LongBits.prototype.toLong = /* @__PURE__ */ __name(function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    }, "toLong");
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = /* @__PURE__ */ __name(function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    }, "fromHash");
    LongBits.prototype.toHash = /* @__PURE__ */ __name(function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    }, "toHash");
    LongBits.prototype.zzEncode = /* @__PURE__ */ __name(function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    }, "zzEncode");
    LongBits.prototype.zzDecode = /* @__PURE__ */ __name(function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    }, "zzDecode");
    LongBits.prototype.length = /* @__PURE__ */ __name(function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }, "length");
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util.isInteger = Number.isInteger || /* @__PURE__ */ __name(function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }, "isInteger");
    util.isString = /* @__PURE__ */ __name(function isString(value) {
      return typeof value === "string" || value instanceof String;
    }, "isString");
    util.isObject = /* @__PURE__ */ __name(function isObject(value) {
      return value && typeof value === "object";
    }, "isObject");
    util.isset = util.isSet = /* @__PURE__ */ __name(function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    }, "isSet");
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = /* @__PURE__ */ __name(function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    }, "newBuffer");
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = /* @__PURE__ */ __name(function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    }, "longToHash");
    util.longFromHash = /* @__PURE__ */ __name(function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    }, "longFromHash");
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    __name(merge, "merge");
    util.merge = merge;
    util.lcFirst = /* @__PURE__ */ __name(function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    }, "lcFirst");
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      __name(CustomError, "CustomError");
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: /* @__PURE__ */ __name(function get() {
            return name;
          }, "get"),
          set: void 0,
          enumerable: false,
          configurable: true
        },
        toString: {
          value: /* @__PURE__ */ __name(function value() {
            return this.name + ": " + this.message;
          }, "value"),
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    __name(newError, "newError");
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = /* @__PURE__ */ __name(function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    }, "getOneOf");
    util.oneOfSetter = /* @__PURE__ */ __name(function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    }, "setOneOf");
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* @__PURE__ */ __name(function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      }, "Buffer_from");
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* @__PURE__ */ __name(function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      }, "Buffer_allocUnsafe");
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(Op, "Op");
    function noop() {
    }
    __name(noop, "noop");
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    __name(State, "State");
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    __name(Writer, "Writer");
    var create = /* @__PURE__ */ __name(function create2() {
      return util.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup() {
        return (Writer.create = /* @__PURE__ */ __name(function create_buffer() {
          return new BufferWriter();
        }, "create_buffer"))();
      }, "create_buffer_setup") : /* @__PURE__ */ __name(function create_array() {
        return new Writer();
      }, "create_array");
    }, "create");
    Writer.create = create();
    Writer.alloc = /* @__PURE__ */ __name(function alloc(size) {
      return new util.Array(size);
    }, "alloc");
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = /* @__PURE__ */ __name(function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    }, "push");
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    __name(writeByte, "writeByte");
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    __name(writeVarint32, "writeVarint32");
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(VarintOp, "VarintOp");
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = /* @__PURE__ */ __name(function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    }, "write_uint32");
    Writer.prototype.int32 = /* @__PURE__ */ __name(function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    }, "write_int32");
    Writer.prototype.sint32 = /* @__PURE__ */ __name(function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }, "write_sint32");
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    __name(writeVarint64, "writeVarint64");
    Writer.prototype.uint64 = /* @__PURE__ */ __name(function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    }, "write_uint64");
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = /* @__PURE__ */ __name(function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }, "write_sint64");
    Writer.prototype.bool = /* @__PURE__ */ __name(function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    }, "write_bool");
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    __name(writeFixed32, "writeFixed32");
    Writer.prototype.fixed32 = /* @__PURE__ */ __name(function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    }, "write_fixed32");
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = /* @__PURE__ */ __name(function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }, "write_fixed64");
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = /* @__PURE__ */ __name(function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    }, "write_float");
    Writer.prototype.double = /* @__PURE__ */ __name(function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    }, "write_double");
    var writeBytes = util.Array.prototype.set ? /* @__PURE__ */ __name(function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    }, "writeBytes_set") : /* @__PURE__ */ __name(function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    }, "writeBytes_for");
    Writer.prototype.bytes = /* @__PURE__ */ __name(function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    }, "write_bytes");
    Writer.prototype.string = /* @__PURE__ */ __name(function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    }, "write_string");
    Writer.prototype.fork = /* @__PURE__ */ __name(function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    }, "fork");
    Writer.prototype.reset = /* @__PURE__ */ __name(function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    }, "reset");
    Writer.prototype.ldelim = /* @__PURE__ */ __name(function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    }, "ldelim");
    Writer.prototype.finish = /* @__PURE__ */ __name(function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    }, "finish");
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer2();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    __name(BufferWriter, "BufferWriter");
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? /* @__PURE__ */ __name(function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      }, "writeBytesBuffer_set") : /* @__PURE__ */ __name(function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      }, "writeBytesBuffer_copy");
    };
    BufferWriter.prototype.bytes = /* @__PURE__ */ __name(function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    }, "write_bytes_buffer");
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    __name(writeStringBuffer, "writeStringBuffer");
    BufferWriter.prototype.string = /* @__PURE__ */ __name(function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    }, "write_string_buffer");
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    __name(indexOutOfRange, "indexOutOfRange");
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    __name(Reader, "Reader");
    var create_array = typeof Uint8Array !== "undefined" ? /* @__PURE__ */ __name(function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }, "create_typed_array") : /* @__PURE__ */ __name(function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }, "create_array");
    var create = /* @__PURE__ */ __name(function create2() {
      return util.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup(buffer) {
        return (Reader.create = /* @__PURE__ */ __name(function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        }, "create_buffer"))(buffer);
      }, "create_buffer_setup") : create_array;
    }, "create");
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
    Reader.prototype.uint32 = (/* @__PURE__ */ __name(function read_uint32_setup() {
      var value = 4294967295;
      return /* @__PURE__ */ __name(function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      }, "read_uint32");
    }, "read_uint32_setup"))();
    Reader.prototype.int32 = /* @__PURE__ */ __name(function read_int32() {
      return this.uint32() | 0;
    }, "read_int32");
    Reader.prototype.sint32 = /* @__PURE__ */ __name(function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    }, "read_sint32");
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    __name(readLongVarint, "readLongVarint");
    Reader.prototype.bool = /* @__PURE__ */ __name(function read_bool() {
      return this.uint32() !== 0;
    }, "read_bool");
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    __name(readFixed32_end, "readFixed32_end");
    Reader.prototype.fixed32 = /* @__PURE__ */ __name(function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    }, "read_fixed32");
    Reader.prototype.sfixed32 = /* @__PURE__ */ __name(function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    }, "read_sfixed32");
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    __name(readFixed64, "readFixed64");
    Reader.prototype.float = /* @__PURE__ */ __name(function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    }, "read_float");
    Reader.prototype.double = /* @__PURE__ */ __name(function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    }, "read_double");
    Reader.prototype.bytes = /* @__PURE__ */ __name(function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    }, "read_bytes");
    Reader.prototype.string = /* @__PURE__ */ __name(function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    }, "read_string");
    Reader.prototype.skip = /* @__PURE__ */ __name(function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    }, "skip");
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : "toNumber";
      util.merge(Reader.prototype, {
        int64: /* @__PURE__ */ __name(function read_int64() {
          return readLongVarint.call(this)[fn](false);
        }, "read_int64"),
        uint64: /* @__PURE__ */ __name(function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        }, "read_uint64"),
        sint64: /* @__PURE__ */ __name(function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        }, "read_sint64"),
        fixed64: /* @__PURE__ */ __name(function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        }, "read_fixed64"),
        sfixed64: /* @__PURE__ */ __name(function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }, "read_sfixed64")
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    __name(BufferReader, "BufferReader");
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = /* @__PURE__ */ __name(function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    }, "read_string_buffer");
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    __name(Service, "Service");
    Service.prototype.rpcCall = /* @__PURE__ */ __name(function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          /* @__PURE__ */ __name(function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(true);
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }, "rpcCallback")
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    }, "rpcCall");
    Service.prototype.end = /* @__PURE__ */ __name(function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    }, "end");
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    __name(configure, "configure");
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js
var require_compiled = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.DDSketch = function() {
      function DDSketch(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(DDSketch, "DDSketch");
      DDSketch.prototype.mapping = null;
      DDSketch.prototype.positiveValues = null;
      DDSketch.prototype.negativeValues = null;
      DDSketch.prototype.zeroCount = 0;
      DDSketch.create = /* @__PURE__ */ __name(function create(properties) {
        return new DDSketch(properties);
      }, "create");
      DDSketch.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.mapping != null && Object.hasOwnProperty.call(message, "mapping"))
          $root.IndexMapping.encode(message.mapping, writer.uint32(10).fork()).ldelim();
        if (message.positiveValues != null && Object.hasOwnProperty.call(message, "positiveValues"))
          $root.Store.encode(message.positiveValues, writer.uint32(18).fork()).ldelim();
        if (message.negativeValues != null && Object.hasOwnProperty.call(message, "negativeValues"))
          $root.Store.encode(message.negativeValues, writer.uint32(26).fork()).ldelim();
        if (message.zeroCount != null && Object.hasOwnProperty.call(message, "zeroCount"))
          writer.uint32(33).double(message.zeroCount);
        return writer;
      }, "encode");
      DDSketch.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      DDSketch.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.DDSketch();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mapping = $root.IndexMapping.decode(reader, reader.uint32());
              break;
            case 2:
              message.positiveValues = $root.Store.decode(reader, reader.uint32());
              break;
            case 3:
              message.negativeValues = $root.Store.decode(reader, reader.uint32());
              break;
            case 4:
              message.zeroCount = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      DDSketch.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      DDSketch.verify = /* @__PURE__ */ __name(function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.mapping != null && message.hasOwnProperty("mapping")) {
          var error = $root.IndexMapping.verify(message.mapping);
          if (error)
            return "mapping." + error;
        }
        if (message.positiveValues != null && message.hasOwnProperty("positiveValues")) {
          var error = $root.Store.verify(message.positiveValues);
          if (error)
            return "positiveValues." + error;
        }
        if (message.negativeValues != null && message.hasOwnProperty("negativeValues")) {
          var error = $root.Store.verify(message.negativeValues);
          if (error)
            return "negativeValues." + error;
        }
        if (message.zeroCount != null && message.hasOwnProperty("zeroCount")) {
          if (typeof message.zeroCount !== "number")
            return "zeroCount: number expected";
        }
        return null;
      }, "verify");
      DDSketch.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
        if (object instanceof $root.DDSketch)
          return object;
        var message = new $root.DDSketch();
        if (object.mapping != null) {
          if (typeof object.mapping !== "object")
            throw TypeError(".DDSketch.mapping: object expected");
          message.mapping = $root.IndexMapping.fromObject(object.mapping);
        }
        if (object.positiveValues != null) {
          if (typeof object.positiveValues !== "object")
            throw TypeError(".DDSketch.positiveValues: object expected");
          message.positiveValues = $root.Store.fromObject(object.positiveValues);
        }
        if (object.negativeValues != null) {
          if (typeof object.negativeValues !== "object")
            throw TypeError(".DDSketch.negativeValues: object expected");
          message.negativeValues = $root.Store.fromObject(object.negativeValues);
        }
        if (object.zeroCount != null)
          message.zeroCount = Number(object.zeroCount);
        return message;
      }, "fromObject");
      DDSketch.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.mapping = null;
          object.positiveValues = null;
          object.negativeValues = null;
          object.zeroCount = 0;
        }
        if (message.mapping != null && message.hasOwnProperty("mapping"))
          object.mapping = $root.IndexMapping.toObject(message.mapping, options);
        if (message.positiveValues != null && message.hasOwnProperty("positiveValues"))
          object.positiveValues = $root.Store.toObject(message.positiveValues, options);
        if (message.negativeValues != null && message.hasOwnProperty("negativeValues"))
          object.negativeValues = $root.Store.toObject(message.negativeValues, options);
        if (message.zeroCount != null && message.hasOwnProperty("zeroCount"))
          object.zeroCount = options.json && !isFinite(message.zeroCount) ? String(message.zeroCount) : message.zeroCount;
        return object;
      }, "toObject");
      DDSketch.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return DDSketch;
    }();
    $root.IndexMapping = function() {
      function IndexMapping(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(IndexMapping, "IndexMapping");
      IndexMapping.prototype.gamma = 0;
      IndexMapping.prototype.indexOffset = 0;
      IndexMapping.prototype.interpolation = 0;
      IndexMapping.create = /* @__PURE__ */ __name(function create(properties) {
        return new IndexMapping(properties);
      }, "create");
      IndexMapping.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.gamma != null && Object.hasOwnProperty.call(message, "gamma"))
          writer.uint32(9).double(message.gamma);
        if (message.indexOffset != null && Object.hasOwnProperty.call(message, "indexOffset"))
          writer.uint32(17).double(message.indexOffset);
        if (message.interpolation != null && Object.hasOwnProperty.call(message, "interpolation"))
          writer.uint32(24).int32(message.interpolation);
        return writer;
      }, "encode");
      IndexMapping.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      IndexMapping.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.IndexMapping();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gamma = reader.double();
              break;
            case 2:
              message.indexOffset = reader.double();
              break;
            case 3:
              message.interpolation = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      IndexMapping.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      IndexMapping.verify = /* @__PURE__ */ __name(function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.gamma != null && message.hasOwnProperty("gamma")) {
          if (typeof message.gamma !== "number")
            return "gamma: number expected";
        }
        if (message.indexOffset != null && message.hasOwnProperty("indexOffset")) {
          if (typeof message.indexOffset !== "number")
            return "indexOffset: number expected";
        }
        if (message.interpolation != null && message.hasOwnProperty("interpolation"))
          switch (message.interpolation) {
            default:
              return "interpolation: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
              break;
          }
        return null;
      }, "verify");
      IndexMapping.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
        if (object instanceof $root.IndexMapping)
          return object;
        var message = new $root.IndexMapping();
        if (object.gamma != null)
          message.gamma = Number(object.gamma);
        if (object.indexOffset != null)
          message.indexOffset = Number(object.indexOffset);
        switch (object.interpolation) {
          case "NONE":
          case 0:
            message.interpolation = 0;
            break;
          case "LINEAR":
          case 1:
            message.interpolation = 1;
            break;
          case "QUADRATIC":
          case 2:
            message.interpolation = 2;
            break;
          case "CUBIC":
          case 3:
            message.interpolation = 3;
            break;
        }
        return message;
      }, "fromObject");
      IndexMapping.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.gamma = 0;
          object.indexOffset = 0;
          object.interpolation = options.enums === String ? "NONE" : 0;
        }
        if (message.gamma != null && message.hasOwnProperty("gamma"))
          object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
        if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
          object.indexOffset = options.json && !isFinite(message.indexOffset) ? String(message.indexOffset) : message.indexOffset;
        if (message.interpolation != null && message.hasOwnProperty("interpolation"))
          object.interpolation = options.enums === String ? $root.IndexMapping.Interpolation[message.interpolation] : message.interpolation;
        return object;
      }, "toObject");
      IndexMapping.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      IndexMapping.Interpolation = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "LINEAR"] = 1;
        values[valuesById[2] = "QUADRATIC"] = 2;
        values[valuesById[3] = "CUBIC"] = 3;
        return values;
      }();
      return IndexMapping;
    }();
    $root.Store = function() {
      function Store(properties) {
        this.binCounts = {};
        this.contiguousBinCounts = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(Store, "Store");
      Store.prototype.binCounts = $util.emptyObject;
      Store.prototype.contiguousBinCounts = $util.emptyArray;
      Store.prototype.contiguousBinIndexOffset = 0;
      Store.create = /* @__PURE__ */ __name(function create(properties) {
        return new Store(properties);
      }, "create");
      Store.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.binCounts != null && Object.hasOwnProperty.call(message, "binCounts"))
          for (var keys = Object.keys(message.binCounts), i = 0; i < keys.length; ++i)
            writer.uint32(10).fork().uint32(8).sint32(keys[i]).uint32(17).double(message.binCounts[keys[i]]).ldelim();
        if (message.contiguousBinCounts != null && message.contiguousBinCounts.length) {
          writer.uint32(18).fork();
          for (var i = 0; i < message.contiguousBinCounts.length; ++i)
            writer.double(message.contiguousBinCounts[i]);
          writer.ldelim();
        }
        if (message.contiguousBinIndexOffset != null && Object.hasOwnProperty.call(message, "contiguousBinIndexOffset"))
          writer.uint32(24).sint32(message.contiguousBinIndexOffset);
        return writer;
      }, "encode");
      Store.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      Store.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Store(), key, value;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (message.binCounts === $util.emptyObject)
                message.binCounts = {};
              var end2 = reader.uint32() + reader.pos;
              key = 0;
              value = 0;
              while (reader.pos < end2) {
                var tag2 = reader.uint32();
                switch (tag2 >>> 3) {
                  case 1:
                    key = reader.sint32();
                    break;
                  case 2:
                    value = reader.double();
                    break;
                  default:
                    reader.skipType(tag2 & 7);
                    break;
                }
              }
              message.binCounts[key] = value;
              break;
            case 2:
              if (!(message.contiguousBinCounts && message.contiguousBinCounts.length))
                message.contiguousBinCounts = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.contiguousBinCounts.push(reader.double());
              } else
                message.contiguousBinCounts.push(reader.double());
              break;
            case 3:
              message.contiguousBinIndexOffset = reader.sint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      Store.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      Store.verify = /* @__PURE__ */ __name(function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.binCounts != null && message.hasOwnProperty("binCounts")) {
          if (!$util.isObject(message.binCounts))
            return "binCounts: object expected";
          var key = Object.keys(message.binCounts);
          for (var i = 0; i < key.length; ++i) {
            if (!$util.key32Re.test(key[i]))
              return "binCounts: integer key{k:sint32} expected";
            if (typeof message.binCounts[key[i]] !== "number")
              return "binCounts: number{k:sint32} expected";
          }
        }
        if (message.contiguousBinCounts != null && message.hasOwnProperty("contiguousBinCounts")) {
          if (!Array.isArray(message.contiguousBinCounts))
            return "contiguousBinCounts: array expected";
          for (var i = 0; i < message.contiguousBinCounts.length; ++i)
            if (typeof message.contiguousBinCounts[i] !== "number")
              return "contiguousBinCounts: number[] expected";
        }
        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty("contiguousBinIndexOffset")) {
          if (!$util.isInteger(message.contiguousBinIndexOffset))
            return "contiguousBinIndexOffset: integer expected";
        }
        return null;
      }, "verify");
      Store.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
        if (object instanceof $root.Store)
          return object;
        var message = new $root.Store();
        if (object.binCounts) {
          if (typeof object.binCounts !== "object")
            throw TypeError(".Store.binCounts: object expected");
          message.binCounts = {};
          for (var keys = Object.keys(object.binCounts), i = 0; i < keys.length; ++i)
            message.binCounts[keys[i]] = Number(object.binCounts[keys[i]]);
        }
        if (object.contiguousBinCounts) {
          if (!Array.isArray(object.contiguousBinCounts))
            throw TypeError(".Store.contiguousBinCounts: array expected");
          message.contiguousBinCounts = [];
          for (var i = 0; i < object.contiguousBinCounts.length; ++i)
            message.contiguousBinCounts[i] = Number(object.contiguousBinCounts[i]);
        }
        if (object.contiguousBinIndexOffset != null)
          message.contiguousBinIndexOffset = object.contiguousBinIndexOffset | 0;
        return message;
      }, "fromObject");
      Store.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.contiguousBinCounts = [];
        if (options.objects || options.defaults)
          object.binCounts = {};
        if (options.defaults)
          object.contiguousBinIndexOffset = 0;
        var keys2;
        if (message.binCounts && (keys2 = Object.keys(message.binCounts)).length) {
          object.binCounts = {};
          for (var j = 0; j < keys2.length; ++j)
            object.binCounts[keys2[j]] = options.json && !isFinite(message.binCounts[keys2[j]]) ? String(message.binCounts[keys2[j]]) : message.binCounts[keys2[j]];
        }
        if (message.contiguousBinCounts && message.contiguousBinCounts.length) {
          object.contiguousBinCounts = [];
          for (var j = 0; j < message.contiguousBinCounts.length; ++j)
            object.contiguousBinCounts[j] = options.json && !isFinite(message.contiguousBinCounts[j]) ? String(message.contiguousBinCounts[j]) : message.contiguousBinCounts[j];
        }
        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty("contiguousBinIndexOffset"))
          object.contiguousBinIndexOffset = message.contiguousBinIndexOffset;
        return object;
      }, "toObject");
      Store.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return Store;
    }();
    module2.exports = $root;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js
var require_DenseStore = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DenseStore = void 0;
    var util_1 = require_util2();
    var CHUNK_SIZE = 128;
    var DenseStore = function() {
      function DenseStore2(chunkSize) {
        if (chunkSize === void 0) {
          chunkSize = CHUNK_SIZE;
        }
        this.chunkSize = chunkSize;
        this.bins = [];
        this.count = 0;
        this.minKey = Infinity;
        this.maxKey = -Infinity;
        this.offset = 0;
      }
      __name(DenseStore2, "DenseStore");
      DenseStore2.prototype.add = function(key, weight) {
        if (weight === void 0) {
          weight = 1;
        }
        var index = this._getIndex(key);
        this.bins[index] += weight;
        this.count += weight;
      };
      DenseStore2.prototype.keyAtRank = function(rank, lower) {
        if (lower === void 0) {
          lower = true;
        }
        var runningCount = 0;
        for (var i = 0; i < this.length(); i++) {
          var bin = this.bins[i];
          runningCount += bin;
          if (lower && runningCount > rank || !lower && runningCount >= rank + 1) {
            return i + this.offset;
          }
        }
        return this.maxKey;
      };
      DenseStore2.prototype.merge = function(store) {
        if (store.count === 0) {
          return;
        }
        if (this.count === 0) {
          this.copy(store);
          return;
        }
        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {
          this._extendRange(store.minKey, store.maxKey);
        }
        var collapseStartIndex = store.minKey - store.offset;
        var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;
        if (collapseEndIndex > collapseStartIndex) {
          var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);
          this.bins[0] += collapseCount;
        } else {
          collapseEndIndex = collapseStartIndex;
        }
        for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {
          this.bins[key - this.offset] += store.bins[key - store.offset];
        }
        this.count += store.count;
      };
      DenseStore2.prototype.copy = function(store) {
        this.bins = __spreadArray([], store.bins, true);
        this.count = store.count;
        this.minKey = store.minKey;
        this.maxKey = store.maxKey;
        this.offset = store.offset;
      };
      DenseStore2.prototype.length = function() {
        return this.bins.length;
      };
      DenseStore2.prototype._getNewLength = function(newMinKey, newMaxKey) {
        var desiredLength = newMaxKey - newMinKey + 1;
        return this.chunkSize * Math.ceil(desiredLength / this.chunkSize);
      };
      DenseStore2.prototype._adjust = function(newMinKey, newMaxKey) {
        this._centerBins(newMinKey, newMaxKey);
        this.minKey = newMinKey;
        this.maxKey = newMaxKey;
      };
      DenseStore2.prototype._shiftBins = function(shift) {
        var _a, _b;
        if (shift > 0) {
          this.bins = this.bins.slice(0, -shift);
          (_a = this.bins).unshift.apply(_a, new Array(shift).fill(0));
        } else {
          this.bins = this.bins.slice(Math.abs(shift));
          (_b = this.bins).push.apply(_b, new Array(Math.abs(shift)).fill(0));
        }
        this.offset -= shift;
      };
      DenseStore2.prototype._centerBins = function(newMinKey, newMaxKey) {
        var middleKey = newMinKey + Math.floor((newMaxKey - newMinKey + 1) / 2);
        this._shiftBins(Math.floor(this.offset + this.length() / 2) - middleKey);
      };
      DenseStore2.prototype._extendRange = function(key, secondKey) {
        var _a;
        secondKey = secondKey || key;
        var newMinKey = Math.min(key, secondKey, this.minKey);
        var newMaxKey = Math.max(key, secondKey, this.maxKey);
        if (this.length() === 0) {
          this.bins = new Array(this._getNewLength(newMinKey, newMaxKey)).fill(0);
          this.offset = newMinKey;
          this._adjust(newMinKey, newMaxKey);
        } else if (newMinKey >= this.minKey && newMaxKey < this.offset + this.length()) {
          this.minKey = newMinKey;
          this.maxKey = newMaxKey;
        } else {
          var newLength = this._getNewLength(newMinKey, newMaxKey);
          if (newLength > this.length()) {
            (_a = this.bins).push.apply(_a, new Array(newLength - this.length()).fill(0));
          }
          this._adjust(newMinKey, newMaxKey);
        }
      };
      DenseStore2.prototype._getIndex = function(key) {
        if (key < this.minKey) {
          this._extendRange(key);
        } else if (key > this.maxKey) {
          this._extendRange(key);
        }
        return key - this.offset;
      };
      DenseStore2.prototype.toProto = function() {
        var ProtoStore = require_compiled().Store;
        return ProtoStore.create({
          contiguousBinCounts: this.bins,
          contiguousBinIndexOffset: this.offset
        });
      };
      DenseStore2.fromProto = function(protoStore) {
        if (!protoStore || protoStore.contiguousBinCounts == null || protoStore.contiguousBinIndexOffset == null) {
          throw Error("Failed to decode store from protobuf");
        }
        var store = new this();
        var index = protoStore.contiguousBinIndexOffset;
        store.offset = index;
        for (var _i = 0, _a = protoStore.contiguousBinCounts; _i < _a.length; _i++) {
          var count = _a[_i];
          store.add(index, count);
          index += 1;
        }
        return store;
      };
      return DenseStore2;
    }();
    exports2.DenseStore = DenseStore;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js
var require_CollapsingLowestDenseStore = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = /* @__PURE__ */ __name(function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      }, "extendStatics");
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CollapsingLowestDenseStore = void 0;
    var DenseStore_1 = require_DenseStore();
    var util_1 = require_util2();
    var CollapsingLowestDenseStore = function(_super) {
      __extends(CollapsingLowestDenseStore2, _super);
      function CollapsingLowestDenseStore2(binLimit, chunkSize) {
        var _this = _super.call(this, chunkSize) || this;
        _this.binLimit = binLimit;
        _this.isCollapsed = false;
        return _this;
      }
      __name(CollapsingLowestDenseStore2, "CollapsingLowestDenseStore");
      CollapsingLowestDenseStore2.prototype.merge = function(store) {
        if (store.count === 0) {
          return;
        }
        if (this.count === 0) {
          this.copy(store);
          return;
        }
        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {
          this._extendRange(store.minKey, store.maxKey);
        }
        var collapseStartIndex = store.minKey - store.offset;
        var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;
        if (collapseEndIndex > collapseStartIndex) {
          var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);
          this.bins[0] += collapseCount;
        } else {
          collapseEndIndex = collapseStartIndex;
        }
        for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {
          this.bins[key - this.offset] += store.bins[key - store.offset];
        }
        this.count += store.count;
      };
      CollapsingLowestDenseStore2.prototype.copy = function(store) {
        _super.prototype.copy.call(this, store);
        this.isCollapsed = store.isCollapsed;
      };
      CollapsingLowestDenseStore2.prototype._getNewLength = function(newMinKey, newMaxKey) {
        var desiredLength = newMaxKey - newMinKey + 1;
        return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);
      };
      CollapsingLowestDenseStore2.prototype._adjust = function(newMinKey, newMaxKey) {
        if (newMaxKey - newMinKey + 1 > this.length()) {
          newMinKey = newMaxKey - this.length() + 1;
          if (newMinKey >= this.maxKey) {
            this.offset = newMinKey;
            this.minKey = newMinKey;
            this.bins.fill(0);
            this.bins[0] = this.count;
          } else {
            var shift = this.offset - newMinKey;
            if (shift < 0) {
              var collapseStartIndex = this.minKey - this.offset;
              var collapseEndIndex = newMinKey - this.offset;
              var collapsedCount = (0, util_1.sumOfRange)(this.bins, collapseStartIndex, collapseEndIndex);
              this.bins.fill(0, collapseStartIndex, collapseEndIndex);
              this.bins[collapseEndIndex] += collapsedCount;
              this.minKey = newMinKey;
              this._shiftBins(shift);
            } else {
              this.minKey = newMinKey;
              this._shiftBins(shift);
            }
          }
          this.maxKey = newMaxKey;
          this.isCollapsed = true;
        } else {
          this._centerBins(newMinKey, newMaxKey);
          this.minKey = newMinKey;
          this.maxKey = newMaxKey;
        }
      };
      CollapsingLowestDenseStore2.prototype._getIndex = function(key) {
        if (key < this.minKey) {
          if (this.isCollapsed) {
            return 0;
          }
          this._extendRange(key);
          if (this.isCollapsed) {
            return 0;
          }
        } else if (key > this.maxKey) {
          this._extendRange(key);
        }
        return key - this.offset;
      };
      return CollapsingLowestDenseStore2;
    }(DenseStore_1.DenseStore);
    exports2.CollapsingLowestDenseStore = CollapsingLowestDenseStore;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js
var require_CollapsingHighestDenseStore = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = /* @__PURE__ */ __name(function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      }, "extendStatics");
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CollapsingHighestDenseStore = void 0;
    var DenseStore_1 = require_DenseStore();
    var util_1 = require_util2();
    var CollapsingHighestDenseStore = function(_super) {
      __extends(CollapsingHighestDenseStore2, _super);
      function CollapsingHighestDenseStore2(binLimit, chunkSize) {
        var _this = _super.call(this, chunkSize) || this;
        _this.binLimit = binLimit;
        _this.isCollapsed = false;
        return _this;
      }
      __name(CollapsingHighestDenseStore2, "CollapsingHighestDenseStore");
      CollapsingHighestDenseStore2.prototype.merge = function(store) {
        if (store.count === 0) {
          return;
        }
        if (this.count === 0) {
          this.copy(store);
          return;
        }
        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {
          this._extendRange(store.minKey, store.maxKey);
        }
        var collapseEndIndex = store.maxKey - store.offset + 1;
        var collapseStartIndex = Math.max(this.maxKey + 1, store.minKey) - store.offset;
        if (collapseEndIndex > collapseStartIndex) {
          var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);
          this.bins[this.length() - 1] += collapseCount;
        } else {
          collapseStartIndex = collapseEndIndex;
        }
        for (var key = store.minKey; key < collapseStartIndex + store.offset; key++) {
          this.bins[key - this.offset] += store.bins[key - store.offset];
        }
        this.count += store.count;
      };
      CollapsingHighestDenseStore2.prototype.copy = function(store) {
        _super.prototype.copy.call(this, store);
        this.isCollapsed = store.isCollapsed;
      };
      CollapsingHighestDenseStore2.prototype._getNewLength = function(newMinKey, newMaxKey) {
        var desiredLength = newMaxKey - newMinKey + 1;
        return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);
      };
      CollapsingHighestDenseStore2.prototype._adjust = function(newMinKey, newMaxKey) {
        if (newMaxKey - newMinKey + 1 > this.length()) {
          newMaxKey = newMinKey + this.length() + 1;
          if (newMaxKey <= this.minKey) {
            this.offset = newMinKey;
            this.maxKey = newMaxKey;
            this.bins.fill(0);
            this.bins[this.length() - 1] = this.count;
          } else {
            var shift = this.offset - newMinKey;
            if (shift > 0) {
              var collapseStartIndex = newMaxKey - this.offset + 1;
              var collapseEndIndex = this.maxKey - this.offset + 1;
              var collapsedCount = (0, util_1.sumOfRange)(this.bins, collapseStartIndex, collapseEndIndex);
              this.bins.fill(0, collapseStartIndex, collapseEndIndex);
              this.bins[collapseStartIndex - 1] += collapsedCount;
              this.maxKey = newMaxKey;
              this._shiftBins(shift);
            } else {
              this.maxKey = newMaxKey;
              this._shiftBins(shift);
            }
            this.minKey = newMinKey;
            this.isCollapsed = true;
          }
        } else {
          this._centerBins(newMinKey, newMaxKey);
          this.minKey = newMinKey;
          this.maxKey = newMaxKey;
        }
      };
      CollapsingHighestDenseStore2.prototype._getIndex = function(key) {
        if (key < this.minKey) {
          if (this.isCollapsed) {
            return this.length() - 1;
          }
          this._extendRange(key);
          if (this.isCollapsed) {
            return this.length() - 1;
          }
        } else if (key > this.maxKey) {
          this._extendRange(key);
        }
        return key - this.offset;
      };
      return CollapsingHighestDenseStore2;
    }(DenseStore_1.DenseStore);
    exports2.CollapsingHighestDenseStore = CollapsingHighestDenseStore;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/store/index.js
var require_store = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/store/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CollapsingHighestDenseStore = exports2.CollapsingLowestDenseStore = exports2.DenseStore = void 0;
    var DenseStore_1 = require_DenseStore();
    Object.defineProperty(exports2, "DenseStore", { enumerable: true, get: function() {
      return DenseStore_1.DenseStore;
    } });
    var CollapsingLowestDenseStore_1 = require_CollapsingLowestDenseStore();
    Object.defineProperty(exports2, "CollapsingLowestDenseStore", { enumerable: true, get: function() {
      return CollapsingLowestDenseStore_1.CollapsingLowestDenseStore;
    } });
    var CollapsingHighestDenseStore_1 = require_CollapsingHighestDenseStore();
    Object.defineProperty(exports2, "CollapsingHighestDenseStore", { enumerable: true, get: function() {
      return CollapsingHighestDenseStore_1.CollapsingHighestDenseStore;
    } });
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js
var require_KeyMapping = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyMapping = void 0;
    var index_1 = require_mapping();
    var MIN_SAFE_FLOAT = Math.pow(2, -1023);
    var MAX_SAFE_FLOAT = Number.MAX_VALUE;
    var KeyMapping = function() {
      function KeyMapping2(relativeAccuracy, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        if (relativeAccuracy <= 0 || relativeAccuracy >= 1) {
          throw Error("Relative accuracy must be between 0 and 1 when initializing a KeyMapping");
        }
        this.relativeAccuracy = relativeAccuracy;
        this._offset = offset;
        var gammaMantissa = 2 * relativeAccuracy / (1 - relativeAccuracy);
        this.gamma = 1 + gammaMantissa;
        this._multiplier = 1 / Math.log1p(gammaMantissa);
        this.minPossible = MIN_SAFE_FLOAT * this.gamma;
        this.maxPossible = MAX_SAFE_FLOAT / this.gamma;
      }
      __name(KeyMapping2, "KeyMapping");
      KeyMapping2.fromGammaOffset = function(gamma, indexOffset) {
        var relativeAccuracy = (gamma - 1) / (gamma + 1);
        return new this(relativeAccuracy, indexOffset);
      };
      KeyMapping2.prototype.key = function(value) {
        return Math.ceil(this._logGamma(value)) + this._offset;
      };
      KeyMapping2.prototype.value = function(key) {
        return this._powGamma(key - this._offset) * (2 / (1 + this.gamma));
      };
      KeyMapping2.prototype.toProto = function() {
        var ProtoIndexMapping = require_compiled().IndexMapping;
        return ProtoIndexMapping.create({
          gamma: this.gamma,
          indexOffset: this._offset,
          interpolation: this._protoInterpolation()
        });
      };
      KeyMapping2.fromProto = function(protoMapping) {
        if (!protoMapping || protoMapping.gamma == null || protoMapping.indexOffset == null) {
          throw Error("Failed to decode mapping from protobuf");
        }
        var Interpolation = require_compiled().IndexMapping.Interpolation;
        var interpolation = protoMapping.interpolation, gamma = protoMapping.gamma, indexOffset = protoMapping.indexOffset;
        switch (interpolation) {
          case Interpolation.NONE:
            return index_1.LogarithmicMapping.fromGammaOffset(gamma, indexOffset);
          case Interpolation.LINEAR:
            return index_1.LinearlyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);
          case Interpolation.CUBIC:
            return index_1.CubicallyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);
          default:
            throw Error("Unrecognized mapping when decoding from protobuf");
        }
      };
      KeyMapping2.prototype._logGamma = function(value) {
        return Math.log2(value) * this._multiplier;
      };
      KeyMapping2.prototype._powGamma = function(value) {
        return Math.pow(2, value / this._multiplier);
      };
      KeyMapping2.prototype._protoInterpolation = function() {
        var Interpolation = require_compiled().IndexMapping.Interpolation;
        return Interpolation.NONE;
      };
      return KeyMapping2;
    }();
    exports2.KeyMapping = KeyMapping;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js
var require_LogarithmicMapping = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = /* @__PURE__ */ __name(function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      }, "extendStatics");
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogarithmicMapping = void 0;
    var KeyMapping_1 = require_KeyMapping();
    var LogarithmicMapping = function(_super) {
      __extends(LogarithmicMapping2, _super);
      function LogarithmicMapping2(relativeAccuracy, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var _this = _super.call(this, relativeAccuracy, offset) || this;
        _this._multiplier *= Math.log(2);
        return _this;
      }
      __name(LogarithmicMapping2, "LogarithmicMapping");
      LogarithmicMapping2.prototype._logGamma = function(value) {
        return Math.log2(value) * this._multiplier;
      };
      LogarithmicMapping2.prototype._powGamma = function(value) {
        return Math.pow(2, value / this._multiplier);
      };
      LogarithmicMapping2.prototype._protoInterpolation = function() {
        var Interpolation = require_compiled().IndexMapping.Interpolation;
        return Interpolation.NONE;
      };
      return LogarithmicMapping2;
    }(KeyMapping_1.KeyMapping);
    exports2.LogarithmicMapping = LogarithmicMapping;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/math.js
var require_math = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/math.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ldexp = exports2.frexp = void 0;
    function frexp(value) {
      if (value === 0 || !Number.isFinite(value))
        return [value, 0];
      var absValue = Math.abs(value);
      var exponent = Math.max(-1023, Math.floor(Math.log2(absValue)) + 1);
      var mantissa = absValue * Math.pow(2, -exponent);
      while (mantissa < 0.5) {
        mantissa *= 2;
        exponent--;
      }
      while (mantissa >= 1) {
        mantissa *= 0.5;
        exponent++;
      }
      if (value < 0) {
        mantissa = -mantissa;
      }
      return [mantissa, exponent];
    }
    __name(frexp, "frexp");
    exports2.frexp = frexp;
    function ldexp(mantissa, exponent) {
      var iterations = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));
      var result = mantissa;
      for (var i = 0; i < iterations; i++) {
        result *= Math.pow(2, Math.floor((exponent + i) / iterations));
      }
      return result;
    }
    __name(ldexp, "ldexp");
    exports2.ldexp = ldexp;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js
var require_LinearlyInterpolatedMapping = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = /* @__PURE__ */ __name(function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      }, "extendStatics");
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinearlyInterpolatedMapping = void 0;
    var KeyMapping_1 = require_KeyMapping();
    var math_1 = require_math();
    var LinearlyInterpolatedMapping = function(_super) {
      __extends(LinearlyInterpolatedMapping2, _super);
      function LinearlyInterpolatedMapping2(relativeAccuracy, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return _super.call(this, relativeAccuracy, offset) || this;
      }
      __name(LinearlyInterpolatedMapping2, "LinearlyInterpolatedMapping");
      LinearlyInterpolatedMapping2.prototype._log2Approx = function(value) {
        var _a = (0, math_1.frexp)(value), mantissa = _a[0], exponent = _a[1];
        var significand = 2 * mantissa - 1;
        return significand + (exponent - 1);
      };
      LinearlyInterpolatedMapping2.prototype._exp2Approx = function(value) {
        var exponent = Math.floor(value) + 1;
        var mantissa = (value - exponent + 2) / 2;
        return (0, math_1.ldexp)(mantissa, exponent);
      };
      LinearlyInterpolatedMapping2.prototype._logGamma = function(value) {
        return Math.log2(value) * this._multiplier;
      };
      LinearlyInterpolatedMapping2.prototype._powGamma = function(value) {
        return Math.pow(2, value / this._multiplier);
      };
      LinearlyInterpolatedMapping2.prototype._protoInterpolation = function() {
        var Interpolation = require_compiled().IndexMapping.Interpolation;
        return Interpolation.LINEAR;
      };
      return LinearlyInterpolatedMapping2;
    }(KeyMapping_1.KeyMapping);
    exports2.LinearlyInterpolatedMapping = LinearlyInterpolatedMapping;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js
var require_CubicallyInterpolatedMapping = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = /* @__PURE__ */ __name(function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      }, "extendStatics");
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CubicallyInterpolatedMapping = void 0;
    var KeyMapping_1 = require_KeyMapping();
    var math_1 = require_math();
    var CubicallyInterpolatedMapping = function(_super) {
      __extends(CubicallyInterpolatedMapping2, _super);
      function CubicallyInterpolatedMapping2(relativeAccuracy, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var _this = _super.call(this, relativeAccuracy, offset) || this;
        _this.A = 6 / 35;
        _this.B = -3 / 5;
        _this.C = 10 / 7;
        _this._multiplier /= _this.C;
        return _this;
      }
      __name(CubicallyInterpolatedMapping2, "CubicallyInterpolatedMapping");
      CubicallyInterpolatedMapping2.prototype._cubicLog2Approx = function(value) {
        var _a = (0, math_1.frexp)(value), mantissa = _a[0], exponent = _a[1];
        var significand = 2 * mantissa - 1;
        return ((this.A * significand + this.B) * significand + this.C) * significand + (exponent - 1);
      };
      CubicallyInterpolatedMapping2.prototype._cubicExp2Approx = function(value) {
        var exponent = Math.floor(value);
        var delta0 = this.B * this.B - 3 * this.A * this.C;
        var delta1 = 2 * this.B * this.B * this.B - 9 * this.A * this.B * this.C - 27 * this.A * this.A * (value - exponent);
        var cardano = Math.cbrt((delta1 - Math.sqrt(delta1 * delta1 - 4 * delta0 * delta0 * delta0)) / 2);
        var significandPlusOne = -(this.B + cardano + delta0 / cardano) / (3 * this.A) + 1;
        var mantissa = significandPlusOne / 2;
        return (0, math_1.ldexp)(mantissa, exponent + 1);
      };
      CubicallyInterpolatedMapping2.prototype._logGamma = function(value) {
        return this._cubicLog2Approx(value) * this._multiplier;
      };
      CubicallyInterpolatedMapping2.prototype._powGamma = function(value) {
        return this._cubicExp2Approx(value / this._multiplier);
      };
      CubicallyInterpolatedMapping2.prototype._protoInterpolation = function() {
        var Interpolation = require_compiled().IndexMapping.Interpolation;
        return Interpolation.CUBIC;
      };
      return CubicallyInterpolatedMapping2;
    }(KeyMapping_1.KeyMapping);
    exports2.CubicallyInterpolatedMapping = CubicallyInterpolatedMapping;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/mapping/index.js
var require_mapping = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/mapping/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CubicallyInterpolatedMapping = exports2.LinearlyInterpolatedMapping = exports2.LogarithmicMapping = exports2.KeyMapping = void 0;
    var KeyMapping_1 = require_KeyMapping();
    Object.defineProperty(exports2, "KeyMapping", { enumerable: true, get: function() {
      return KeyMapping_1.KeyMapping;
    } });
    var LogarithmicMapping_1 = require_LogarithmicMapping();
    Object.defineProperty(exports2, "LogarithmicMapping", { enumerable: true, get: function() {
      return LogarithmicMapping_1.LogarithmicMapping;
    } });
    var LinearlyInterpolatedMapping_1 = require_LinearlyInterpolatedMapping();
    Object.defineProperty(exports2, "LinearlyInterpolatedMapping", { enumerable: true, get: function() {
      return LinearlyInterpolatedMapping_1.LinearlyInterpolatedMapping;
    } });
    var CubicallyInterpolatedMapping_1 = require_CubicallyInterpolatedMapping();
    Object.defineProperty(exports2, "CubicallyInterpolatedMapping", { enumerable: true, get: function() {
      return CubicallyInterpolatedMapping_1.CubicallyInterpolatedMapping;
    } });
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/DDSketch.js
var require_DDSketch = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/DDSketch.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = /* @__PURE__ */ __name(function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      }, "extendStatics");
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogCollapsingHighestDenseDDSketch = exports2.LogCollapsingLowestDenseDDSketch = exports2.DDSketch = void 0;
    var store_1 = require_store();
    var mapping_1 = require_mapping();
    var DEFAULT_RELATIVE_ACCURACY = 0.01;
    var DEFAULT_BIN_LIMIT = 2048;
    var BaseDDSketch = function() {
      function BaseDDSketch2(_a) {
        var mapping = _a.mapping, store = _a.store, negativeStore = _a.negativeStore, zeroCount = _a.zeroCount;
        this.mapping = mapping;
        this.store = store;
        this.negativeStore = negativeStore;
        this.zeroCount = zeroCount;
        this.count = this.negativeStore.count + this.zeroCount + this.store.count;
        this.min = Infinity;
        this.max = -Infinity;
        this.sum = 0;
      }
      __name(BaseDDSketch2, "BaseDDSketch");
      BaseDDSketch2.prototype.accept = function(value, weight) {
        if (weight === void 0) {
          weight = 1;
        }
        if (weight <= 0) {
          throw Error("Weight must be a positive number");
        }
        if (value > this.mapping.minPossible) {
          var key = this.mapping.key(value);
          this.store.add(key, weight);
        } else if (value < -this.mapping.minPossible) {
          var key = this.mapping.key(-value);
          this.negativeStore.add(key, weight);
        } else {
          this.zeroCount += weight;
        }
        this.count += weight;
        this.sum += value * weight;
        if (value < this.min) {
          this.min = value;
        }
        if (value > this.max) {
          this.max = value;
        }
      };
      BaseDDSketch2.prototype.getValueAtQuantile = function(quantile) {
        if (quantile < 0 || quantile > 1 || this.count === 0) {
          return NaN;
        }
        var rank = quantile * (this.count - 1);
        var quantileValue = 0;
        if (rank < this.negativeStore.count) {
          var reversedRank = this.negativeStore.count - rank - 1;
          var key = this.negativeStore.keyAtRank(reversedRank, false);
          quantileValue = -this.mapping.value(key);
        } else if (rank < this.zeroCount + this.negativeStore.count) {
          return 0;
        } else {
          var key = this.store.keyAtRank(rank - this.zeroCount - this.negativeStore.count);
          quantileValue = this.mapping.value(key);
        }
        return quantileValue;
      };
      BaseDDSketch2.prototype.merge = function(sketch) {
        if (!this.mergeable(sketch)) {
          throw new Error("Cannot merge two DDSketches with different `relativeAccuracy` parameters");
        }
        if (sketch.count === 0) {
          return;
        }
        if (this.count === 0) {
          this._copy(sketch);
          return;
        }
        this.store.merge(sketch.store);
        this.zeroCount += sketch.zeroCount;
        this.count += sketch.count;
        this.sum += sketch.sum;
        if (sketch.min < this.min) {
          this.min = sketch.min;
        }
        if (sketch.max > this.max) {
          this.max = sketch.max;
        }
      };
      BaseDDSketch2.prototype.mergeable = function(sketch) {
        return this.mapping.gamma === sketch.mapping.gamma;
      };
      BaseDDSketch2.prototype._copy = function(sketch) {
        this.store.copy(sketch.store);
        this.negativeStore.copy(sketch.negativeStore);
        this.zeroCount = sketch.zeroCount;
        this.min = sketch.min;
        this.max = sketch.max;
        this.count = sketch.count;
        this.sum = sketch.sum;
      };
      BaseDDSketch2.prototype.toProto = function() {
        var ProtoDDSketch = require_compiled().DDSketch;
        var message = ProtoDDSketch.create({
          mapping: this.mapping.toProto(),
          positiveValues: this.store.toProto(),
          negativeValues: this.negativeStore.toProto(),
          zeroCount: this.zeroCount
        });
        return ProtoDDSketch.encode(message).finish();
      };
      BaseDDSketch2.fromProto = function(buffer) {
        var ProtoDDSketch = require_compiled().DDSketch;
        var decoded = ProtoDDSketch.decode(buffer);
        var mapping = mapping_1.KeyMapping.fromProto(decoded.mapping);
        var store = store_1.DenseStore.fromProto(decoded.positiveValues);
        var negativeStore = store_1.DenseStore.fromProto(decoded.negativeValues);
        var zeroCount = decoded.zeroCount;
        return new BaseDDSketch2({ mapping, store, negativeStore, zeroCount });
      };
      return BaseDDSketch2;
    }();
    var defaultConfig = {
      relativeAccuracy: DEFAULT_RELATIVE_ACCURACY
    };
    var DDSketch = function(_super) {
      __extends(DDSketch2, _super);
      function DDSketch2(_a) {
        var _b = _a === void 0 ? defaultConfig : _a, _c = _b.relativeAccuracy, relativeAccuracy = _c === void 0 ? DEFAULT_RELATIVE_ACCURACY : _c;
        var mapping = new mapping_1.LogarithmicMapping(relativeAccuracy);
        var store = new store_1.DenseStore();
        var negativeStore = new store_1.DenseStore();
        return _super.call(this, { mapping, store, negativeStore, zeroCount: 0 }) || this;
      }
      __name(DDSketch2, "DDSketch");
      return DDSketch2;
    }(BaseDDSketch);
    exports2.DDSketch = DDSketch;
    var LogCollapsingLowestDenseDDSketch = function(_super) {
      __extends(LogCollapsingLowestDenseDDSketch2, _super);
      function LogCollapsingLowestDenseDDSketch2(_a) {
        var _b = _a === void 0 ? defaultConfig : _a, _c = _b.relativeAccuracy, relativeAccuracy = _c === void 0 ? DEFAULT_RELATIVE_ACCURACY : _c, _d = _b.binLimit, binLimit = _d === void 0 ? DEFAULT_BIN_LIMIT : _d;
        var mapping = new mapping_1.LogarithmicMapping(relativeAccuracy);
        var store = new store_1.CollapsingLowestDenseStore(binLimit);
        var negativeStore = new store_1.CollapsingLowestDenseStore(binLimit);
        return _super.call(this, { mapping, store, negativeStore, zeroCount: 0 }) || this;
      }
      __name(LogCollapsingLowestDenseDDSketch2, "LogCollapsingLowestDenseDDSketch");
      return LogCollapsingLowestDenseDDSketch2;
    }(BaseDDSketch);
    exports2.LogCollapsingLowestDenseDDSketch = LogCollapsingLowestDenseDDSketch;
    var LogCollapsingHighestDenseDDSketch = function(_super) {
      __extends(LogCollapsingHighestDenseDDSketch2, _super);
      function LogCollapsingHighestDenseDDSketch2(_a) {
        var _b = _a === void 0 ? defaultConfig : _a, _c = _b.relativeAccuracy, relativeAccuracy = _c === void 0 ? DEFAULT_RELATIVE_ACCURACY : _c, _d = _b.binLimit, binLimit = _d === void 0 ? DEFAULT_BIN_LIMIT : _d;
        var mapping = new mapping_1.LogarithmicMapping(relativeAccuracy);
        var store = new store_1.CollapsingHighestDenseStore(binLimit);
        var negativeStore = new store_1.CollapsingHighestDenseStore(binLimit);
        return _super.call(this, { mapping, store, negativeStore, zeroCount: 0 }) || this;
      }
      __name(LogCollapsingHighestDenseDDSketch2, "LogCollapsingHighestDenseDDSketch");
      return LogCollapsingHighestDenseDDSketch2;
    }(BaseDDSketch);
    exports2.LogCollapsingHighestDenseDDSketch = LogCollapsingHighestDenseDDSketch;
  }
});

// node_modules/@datadog/sketches-js/dist/ddsketch/index.js
var require_ddsketch = __commonJS({
  "node_modules/@datadog/sketches-js/dist/ddsketch/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_DDSketch(), exports2);
  }
});

// node_modules/@datadog/sketches-js/dist/index.js
var require_dist = __commonJS({
  "node_modules/@datadog/sketches-js/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ddsketch(), exports2);
  }
});

// node_modules/dd-trace/packages/dd-trace/src/histogram.js
var require_histogram = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/histogram.js"(exports2, module2) {
    "use strict";
    var { DDSketch } = require_dist();
    var Histogram = class {
      constructor() {
        this.reset();
      }
      get min() {
        return this._min;
      }
      get max() {
        return this._max;
      }
      get avg() {
        return this._count === 0 ? 0 : this._sum / this._count;
      }
      get sum() {
        return this._sum;
      }
      get count() {
        return this._count;
      }
      get median() {
        return this.percentile(50);
      }
      get p95() {
        return this.percentile(95);
      }
      percentile(percentile) {
        return this._histogram.getValueAtQuantile(percentile / 100) || 0;
      }
      record(value) {
        if (this._count === 0) {
          this._min = this._max = value;
        } else {
          this._min = Math.min(this._min, value);
          this._max = Math.max(this._max, value);
        }
        this._count++;
        this._sum += value;
        this._histogram.accept(value);
      }
      reset() {
        this._min = 0;
        this._max = 0;
        this._sum = 0;
        this._count = 0;
        this._histogram = new DDSketch();
      }
    };
    __name(Histogram, "Histogram");
    module2.exports = Histogram;
  }
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build = __commonJS({
  "node_modules/node-gyp-build/index.js"(exports2, module2) {
    var fs = __require("fs");
    var path = __require("path");
    var os = __require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : "node";
    var arch = os.arch();
    var platform = os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : process.config.variables.arm_version) || "";
    module2.exports = load;
    function load(dir) {
      return runtimeRequire(load.path(dir));
    }
    __name(load, "load");
    load.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"])
          dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug)
          return debug;
      }
      var names = [platform + "-" + arch];
      if (libc)
        names.push(platform + libc + "-" + arch);
      if ((arch === "arm" || arch === "arm64") && armv) {
        names.forEach(function(name2) {
          names.push(name2 + "-v" + armv);
        });
      }
      for (var i = names.length; i--; ) {
        var prebuild = getFirst(path.join(dir, "prebuilds/" + names[i]), matchPrebuild);
        if (prebuild)
          return prebuild;
        var napiRuntime = getFirst(path.join(dir, "prebuilds/" + names[i]), matchNapiRuntime);
        if (napiRuntime)
          return napiRuntime;
        var napi = getFirst(path.join(dir, "prebuilds/" + names[i]), matchNapi);
        if (napi)
          return napi;
      }
      throw new Error("No native build was found for runtime=" + runtime + " abi=" + abi + " platform=" + platform + libc + " arch=" + arch);
    };
    function getFirst(dir, filter) {
      try {
        var files = fs.readdirSync(dir).filter(filter);
        return files[0] && path.join(dir, files[0]);
      } catch (err) {
        return null;
      }
    }
    __name(getFirst, "getFirst");
    function matchNapiRuntime(name) {
      return name === runtime + "-napi.node";
    }
    __name(matchNapiRuntime, "matchNapiRuntime");
    function matchNapi(name) {
      return name === "node-napi.node";
    }
    __name(matchNapi, "matchNapi");
    function matchPrebuild(name) {
      var parts = name.split("-");
      return parts[0] === runtime && parts[1] === abi + ".node";
    }
    __name(matchPrebuild, "matchPrebuild");
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    __name(matchBuild, "matchBuild");
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    __name(isElectron, "isElectron");
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    __name(isAlpine, "isAlpine");
  }
});

// node_modules/@datadog/native-metrics/index.js
var require_native_metrics = __commonJS({
  "node_modules/@datadog/native-metrics/index.js"(exports2, module2) {
    "use strict";
    var nativeMetrics = require_node_gyp_build()(__dirname);
    module2.exports = nativeMetrics;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/metrics.js
var require_metrics = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/metrics.js"(exports2, module2) {
    "use strict";
    var { URL: URL2, format } = __require("url");
    var v8 = __require("v8");
    var os = __require("os");
    var Client = require_dogstatsd();
    var log = require_log();
    var Histogram = require_histogram();
    var INTERVAL = 10 * 1e3;
    var nativeMetrics = null;
    var interval;
    var client;
    var time;
    var cpuUsage;
    var gauges;
    var counters;
    var histograms;
    reset();
    module2.exports = {
      start(config) {
        const tags = [];
        Object.keys(config.tags).filter((key) => typeof config.tags[key] === "string").filter((key) => {
          if (key !== "runtime-id")
            return true;
          return config.experimental && config.experimental.runtimeId;
        }).forEach((key) => {
          const value = config.tags[key].replace(/[^a-z0-9_:./-]/ig, "_");
          tags.push(`${key}:${value}`);
        });
        try {
          nativeMetrics = require_native_metrics();
          nativeMetrics.start();
        } catch (e) {
          log.error(e);
          nativeMetrics = null;
        }
        const clientConfig = {
          host: config.dogstatsd.hostname,
          port: config.dogstatsd.port,
          tags
        };
        if (config.url) {
          clientConfig.metricsProxyUrl = config.url;
        } else if (config.port) {
          clientConfig.metricsProxyUrl = new URL2(format({
            protocol: "http:",
            hostname: config.hostname || "localhost",
            port: config.port
          }));
        }
        client = new Client(clientConfig);
        time = process.hrtime();
        if (nativeMetrics) {
          interval = setInterval(() => {
            captureCommonMetrics();
            captureNativeMetrics();
            client.flush();
          }, INTERVAL);
        } else {
          cpuUsage = process.cpuUsage();
          interval = setInterval(() => {
            captureCommonMetrics();
            captureCpuUsage();
            captureHeapSpace();
            client.flush();
          }, INTERVAL);
        }
        interval.unref();
      },
      stop() {
        if (nativeMetrics) {
          nativeMetrics.stop();
        }
        clearInterval(interval);
        reset();
      },
      track(span) {
        if (nativeMetrics) {
          const handle = nativeMetrics.track(span);
          return {
            finish: () => nativeMetrics.finish(handle)
          };
        }
        return { finish: () => {
        } };
      },
      boolean(name, value, tag) {
        this.gauge(name, value ? 1 : 0, tag);
      },
      histogram(name, value, tag) {
        if (!client)
          return;
        histograms[name] = histograms[name] || /* @__PURE__ */ new Map();
        if (!histograms[name].has(tag)) {
          histograms[name].set(tag, new Histogram());
        }
        histograms[name].get(tag).record(value);
      },
      count(name, count, tag, monotonic = false) {
        if (!client)
          return;
        if (typeof tag === "boolean") {
          monotonic = tag;
          tag = void 0;
        }
        const map = monotonic ? counters : gauges;
        map[name] = map[name] || /* @__PURE__ */ new Map();
        const value = map[name].get(tag) || 0;
        map[name].set(tag, value + count);
      },
      gauge(name, value, tag) {
        if (!client)
          return;
        gauges[name] = gauges[name] || /* @__PURE__ */ new Map();
        gauges[name].set(tag, value);
      },
      increment(name, tag, monotonic) {
        this.count(name, 1, tag, monotonic);
      },
      decrement(name, tag) {
        this.count(name, -1, tag);
      }
    };
    function reset() {
      interval = null;
      client = null;
      time = null;
      cpuUsage = null;
      gauges = {};
      counters = {};
      histograms = {};
      nativeMetrics = null;
    }
    __name(reset, "reset");
    function captureCpuUsage() {
      if (!process.cpuUsage)
        return;
      const elapsedTime = process.hrtime(time);
      const elapsedUsage = process.cpuUsage(cpuUsage);
      time = process.hrtime();
      cpuUsage = process.cpuUsage();
      const elapsedMs = elapsedTime[0] * 1e3 + elapsedTime[1] / 1e6;
      const userPercent = 100 * elapsedUsage.user / 1e3 / elapsedMs;
      const systemPercent = 100 * elapsedUsage.system / 1e3 / elapsedMs;
      const totalPercent = userPercent + systemPercent;
      client.gauge("runtime.node.cpu.system", systemPercent.toFixed(2));
      client.gauge("runtime.node.cpu.user", userPercent.toFixed(2));
      client.gauge("runtime.node.cpu.total", totalPercent.toFixed(2));
    }
    __name(captureCpuUsage, "captureCpuUsage");
    function captureMemoryUsage() {
      const stats = process.memoryUsage();
      client.gauge("runtime.node.mem.heap_total", stats.heapTotal);
      client.gauge("runtime.node.mem.heap_used", stats.heapUsed);
      client.gauge("runtime.node.mem.rss", stats.rss);
      client.gauge("runtime.node.mem.total", os.totalmem());
      client.gauge("runtime.node.mem.free", os.freemem());
      stats.external && client.gauge("runtime.node.mem.external", stats.external);
    }
    __name(captureMemoryUsage, "captureMemoryUsage");
    function captureProcess() {
      client.gauge("runtime.node.process.uptime", Math.round(process.uptime()));
    }
    __name(captureProcess, "captureProcess");
    function captureHeapStats() {
      const stats = v8.getHeapStatistics();
      client.gauge("runtime.node.heap.total_heap_size", stats.total_heap_size);
      client.gauge("runtime.node.heap.total_heap_size_executable", stats.total_heap_size_executable);
      client.gauge("runtime.node.heap.total_physical_size", stats.total_physical_size);
      client.gauge("runtime.node.heap.total_available_size", stats.total_available_size);
      client.gauge("runtime.node.heap.heap_size_limit", stats.heap_size_limit);
      stats.malloced_memory && client.gauge("runtime.node.heap.malloced_memory", stats.malloced_memory);
      stats.peak_malloced_memory && client.gauge("runtime.node.heap.peak_malloced_memory", stats.peak_malloced_memory);
    }
    __name(captureHeapStats, "captureHeapStats");
    function captureHeapSpace() {
      if (!v8.getHeapSpaceStatistics)
        return;
      const stats = v8.getHeapSpaceStatistics();
      for (let i = 0, l = stats.length; i < l; i++) {
        const tags = [`space:${stats[i].space_name}`];
        client.gauge("runtime.node.heap.size.by.space", stats[i].space_size, tags);
        client.gauge("runtime.node.heap.used_size.by.space", stats[i].space_used_size, tags);
        client.gauge("runtime.node.heap.available_size.by.space", stats[i].space_available_size, tags);
        client.gauge("runtime.node.heap.physical_size.by.space", stats[i].physical_space_size, tags);
      }
    }
    __name(captureHeapSpace, "captureHeapSpace");
    function captureGauges() {
      Object.keys(gauges).forEach((name) => {
        gauges[name].forEach((value, tag) => {
          client.gauge(name, value, tag && [tag]);
        });
      });
    }
    __name(captureGauges, "captureGauges");
    function captureCounters() {
      Object.keys(counters).forEach((name) => {
        counters[name].forEach((value, tag) => {
          client.increment(name, value, tag && [tag]);
        });
      });
      counters = {};
    }
    __name(captureCounters, "captureCounters");
    function captureHistograms() {
      Object.keys(histograms).forEach((name) => {
        histograms[name].forEach((stats, tag) => {
          histogram(name, stats, tag && [tag]);
          stats.reset();
        });
      });
    }
    __name(captureHistograms, "captureHistograms");
    function captureCommonMetrics() {
      captureMemoryUsage();
      captureProcess();
      captureHeapStats();
      captureGauges();
      captureCounters();
      captureHistograms();
    }
    __name(captureCommonMetrics, "captureCommonMetrics");
    function captureNativeMetrics() {
      const stats = nativeMetrics.stats();
      const spaces = stats.heap.spaces;
      const elapsedTime = process.hrtime(time);
      time = process.hrtime();
      const elapsedUs = elapsedTime[0] * 1e6 + elapsedTime[1] / 1e3;
      const userPercent = 100 * stats.cpu.user / elapsedUs;
      const systemPercent = 100 * stats.cpu.system / elapsedUs;
      const totalPercent = userPercent + systemPercent;
      client.gauge("runtime.node.cpu.system", systemPercent.toFixed(2));
      client.gauge("runtime.node.cpu.user", userPercent.toFixed(2));
      client.gauge("runtime.node.cpu.total", totalPercent.toFixed(2));
      histogram("runtime.node.event_loop.delay", stats.eventLoop);
      Object.keys(stats.gc).forEach((type) => {
        if (type === "all") {
          histogram("runtime.node.gc.pause", stats.gc[type]);
        } else {
          histogram("runtime.node.gc.pause.by.type", stats.gc[type], [`gc_type:${type}`]);
        }
      });
      for (let i = 0, l = spaces.length; i < l; i++) {
        const tags = [`heap_space:${spaces[i].space_name}`];
        client.gauge("runtime.node.heap.size.by.space", spaces[i].space_size, tags);
        client.gauge("runtime.node.heap.used_size.by.space", spaces[i].space_used_size, tags);
        client.gauge("runtime.node.heap.available_size.by.space", spaces[i].space_available_size, tags);
        client.gauge("runtime.node.heap.physical_size.by.space", spaces[i].physical_space_size, tags);
      }
    }
    __name(captureNativeMetrics, "captureNativeMetrics");
    function histogram(name, stats, tags) {
      tags = [].concat(tags);
      client.gauge(`${name}.min`, stats.min, tags);
      client.gauge(`${name}.max`, stats.max, tags);
      client.increment(`${name}.sum`, stats.sum, tags);
      client.increment(`${name}.total`, stats.sum, tags);
      client.gauge(`${name}.avg`, stats.avg, tags);
      client.increment(`${name}.count`, stats.count, tags);
      client.gauge(`${name}.median`, stats.median, tags);
      client.gauge(`${name}.95percentile`, stats.p95, tags);
    }
    __name(histogram, "histogram");
  }
});

// node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js
var require_span2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/opentracing/span.js"(exports2, module2) {
    "use strict";
    var { performance: performance2 } = __require("perf_hooks");
    var now = performance2.now.bind(performance2);
    var dateNow = Date.now;
    var semver = require_semver();
    var SpanContext = require_span_context();
    var id = require_id();
    var tagger = require_tagger();
    var metrics = require_metrics();
    var log = require_log();
    var { storage } = require_datadog_core();
    var {
      DD_TRACE_EXPERIMENTAL_STATE_TRACKING,
      DD_TRACE_EXPERIMENTAL_SPAN_COUNTS
    } = process.env;
    var unfinishedRegistry = createRegistry("unfinished");
    var finishedRegistry = createRegistry("finished");
    var DatadogSpan = class {
      constructor(tracer2, processor, prioritySampler, fields, debug) {
        const operationName = fields.operationName;
        const parent = fields.parent || null;
        const tags = Object.assign({}, fields.tags);
        const hostname = fields.hostname;
        this._parentTracer = tracer2;
        this._debug = debug;
        this._processor = processor;
        this._prioritySampler = prioritySampler;
        this._store = storage.getStore();
        this._name = operationName;
        this._spanContext = this._createContext(parent);
        this._spanContext._name = operationName;
        this._spanContext._tags = tags;
        this._spanContext._hostname = hostname;
        this._startTime = fields.startTime || this._getTime();
        if (DD_TRACE_EXPERIMENTAL_SPAN_COUNTS && finishedRegistry) {
          metrics.increment("runtime.node.spans.unfinished");
          metrics.increment("runtime.node.spans.unfinished.by.name", `span_name:${operationName}`);
          metrics.increment("runtime.node.spans.open");
          metrics.increment("runtime.node.spans.open.by.name", `span_name:${operationName}`);
          unfinishedRegistry.register(this, operationName, this);
        }
      }
      toString() {
        const spanContext = this.context();
        const resourceName = spanContext._tags["resource.name"];
        const resource = resourceName.length > 100 ? `${resourceName.substring(0, 97)}...` : resourceName;
        const json = JSON.stringify({
          traceId: spanContext._traceId,
          spanId: spanContext._spanId,
          parentId: spanContext._parentId,
          service: spanContext._tags["service.name"],
          name: spanContext._name,
          resource
        });
        return `Span${json}`;
      }
      context() {
        return this._spanContext;
      }
      tracer() {
        return this._parentTracer;
      }
      setOperationName(name) {
        this._spanContext._name = name;
        return this;
      }
      setBaggageItem(key, value) {
        this._spanContext._baggageItems[key] = value;
        return this;
      }
      getBaggageItem(key) {
        return this._spanContext._baggageItems[key];
      }
      setTag(key, value) {
        this._addTags({ [key]: value });
        return this;
      }
      addTags(keyValueMap) {
        this._addTags(keyValueMap);
        return this;
      }
      log() {
        return this;
      }
      logEvent() {
      }
      finish(finishTime) {
        if (this._duration !== void 0) {
          return;
        }
        if (DD_TRACE_EXPERIMENTAL_STATE_TRACKING === "true") {
          if (!this._spanContext._tags["service.name"]) {
            log.error(`Finishing invalid span: ${this}`);
          }
        }
        if (DD_TRACE_EXPERIMENTAL_SPAN_COUNTS && finishedRegistry) {
          metrics.decrement("runtime.node.spans.unfinished");
          metrics.decrement("runtime.node.spans.unfinished.by.name", `span_name:${this._name}`);
          metrics.increment("runtime.node.spans.finished");
          metrics.increment("runtime.node.spans.finished.by.name", `span_name:${this._name}`);
          metrics.decrement("runtime.node.spans.open");
          metrics.decrement("runtime.node.spans.open.by.name", `span_name:${this._name}`);
          unfinishedRegistry.unregister(this);
          finishedRegistry.register(this, this._name);
        }
        finishTime = parseFloat(finishTime) || this._getTime();
        this._duration = finishTime - this._startTime;
        this._spanContext._trace.finished.push(this);
        this._spanContext._isFinished = true;
        this._processor.process(this);
      }
      _createContext(parent) {
        let spanContext;
        if (parent) {
          spanContext = new SpanContext({
            traceId: parent._traceId,
            spanId: id(),
            parentId: parent._spanId,
            sampling: parent._sampling,
            baggageItems: Object.assign({}, parent._baggageItems),
            trace: parent._trace,
            tracestate: parent._tracestate
          });
        } else {
          const spanId = id();
          spanContext = new SpanContext({
            traceId: spanId,
            spanId
          });
        }
        spanContext._trace.started.push(this);
        spanContext._trace.startTime = spanContext._trace.startTime || dateNow();
        spanContext._trace.ticks = spanContext._trace.ticks || now();
        return spanContext;
      }
      _getTime() {
        const { startTime, ticks } = this._spanContext._trace;
        return startTime + now() - ticks;
      }
      _addTags(keyValuePairs) {
        tagger.add(this._spanContext._tags, keyValuePairs);
        this._prioritySampler.sample(this, false);
      }
    };
    __name(DatadogSpan, "DatadogSpan");
    function createRegistry(type) {
      if (!semver.satisfies(process.version, ">=14.6"))
        return;
      return new global.FinalizationRegistry((name) => {
        metrics.decrement(`runtime.node.spans.${type}`);
        metrics.decrement(`runtime.node.spans.${type}.by.name`, [`span_name:${name}`]);
      });
    }
    __name(createRegistry, "createRegistry");
    module2.exports = DatadogSpan;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/constants.js
var require_constants = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      SAMPLING_PRIORITY_KEY: "_sampling_priority_v1",
      ANALYTICS_KEY: "_dd1.sr.eausr",
      ORIGIN_KEY: "_dd.origin",
      HOSTNAME_KEY: "_dd.hostname",
      TOP_LEVEL_KEY: "_dd.top_level",
      SAMPLING_RULE_DECISION: "_dd.rule_psr",
      SAMPLING_LIMIT_DECISION: "_dd.limit_psr",
      SAMPLING_AGENT_DECISION: "_dd.agent_psr",
      SAMPLING_MECHANISM_DEFAULT: 0,
      SAMPLING_MECHANISM_AGENT: 1,
      SAMPLING_MECHANISM_RULE: 3,
      SAMPLING_MECHANISM_MANUAL: 4,
      SAMPLING_MECHANISM_APPSEC: 5,
      SAMPLING_MECHANISM_SPAN: 8,
      SPAN_SAMPLING_MECHANISM: "_dd.span_sampling.mechanism",
      SPAN_SAMPLING_RULE_RATE: "_dd.span_sampling.rule_rate",
      SPAN_SAMPLING_MAX_PER_SECOND: "_dd.span_sampling.max_per_second",
      DATADOG_LAMBDA_EXTENSION_PATH: "/opt/extensions/datadog-agent",
      DECISION_MAKER_KEY: "_dd.p.dm",
      PROCESS_ID: "process_id",
      ERROR_TYPE: "error.type",
      ERROR_MESSAGE: "error.message",
      ERROR_STACK: "error.stack",
      COMPONENT: "component"
    };
  }
});

// node_modules/dd-trace/ext/tags.js
var require_tags = __commonJS({
  "node_modules/dd-trace/ext/tags.js"(exports2, module2) {
    "use strict";
    var tags = {
      SERVICE_NAME: "service.name",
      RESOURCE_NAME: "resource.name",
      SPAN_TYPE: "span.type",
      SPAN_KIND: "span.kind",
      SAMPLING_PRIORITY: "sampling.priority",
      ANALYTICS: "_dd1.sr.eausr",
      ERROR: "error",
      MANUAL_KEEP: "manual.keep",
      MANUAL_DROP: "manual.drop",
      MEASURED: "_dd.measured",
      HTTP_URL: "http.url",
      HTTP_METHOD: "http.method",
      HTTP_STATUS_CODE: "http.status_code",
      HTTP_ROUTE: "http.route",
      HTTP_REQUEST_HEADERS: "http.request.headers",
      HTTP_RESPONSE_HEADERS: "http.response.headers",
      HTTP_USERAGENT: "http.useragent",
      HTTP_CLIENT_IP: "http.client_ip"
    };
    tags.ANALYTICS_SAMPLE_RATE = tags.ANALYTICS;
    module2.exports = tags;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/format.js
var require_format = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/format.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var tags = require_tags();
    var id = require_id();
    var { isError } = require_util();
    var SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY;
    var SAMPLING_RULE_DECISION = constants.SAMPLING_RULE_DECISION;
    var SAMPLING_LIMIT_DECISION = constants.SAMPLING_LIMIT_DECISION;
    var SAMPLING_AGENT_DECISION = constants.SAMPLING_AGENT_DECISION;
    var SPAN_SAMPLING_MECHANISM = constants.SPAN_SAMPLING_MECHANISM;
    var SPAN_SAMPLING_RULE_RATE = constants.SPAN_SAMPLING_RULE_RATE;
    var SPAN_SAMPLING_MAX_PER_SECOND = constants.SPAN_SAMPLING_MAX_PER_SECOND;
    var SAMPLING_MECHANISM_SPAN = constants.SAMPLING_MECHANISM_SPAN;
    var MEASURED = tags.MEASURED;
    var ORIGIN_KEY = constants.ORIGIN_KEY;
    var HOSTNAME_KEY = constants.HOSTNAME_KEY;
    var TOP_LEVEL_KEY = constants.TOP_LEVEL_KEY;
    var PROCESS_ID = constants.PROCESS_ID;
    var ERROR_MESSAGE = constants.ERROR_MESSAGE;
    var ERROR_STACK = constants.ERROR_STACK;
    var ERROR_TYPE = constants.ERROR_TYPE;
    var map = {
      "service.name": "service",
      "span.type": "type",
      "resource.name": "resource"
    };
    function format(span) {
      const formatted = formatSpan(span);
      extractRootTags(formatted, span);
      extractChunkTags(formatted, span);
      extractTags(formatted, span);
      return formatted;
    }
    __name(format, "format");
    function formatSpan(span) {
      const spanContext = span.context();
      return {
        trace_id: spanContext._traceId,
        span_id: spanContext._spanId,
        parent_id: spanContext._parentId || id("0"),
        name: String(spanContext._name),
        resource: String(spanContext._name),
        error: 0,
        meta: {},
        metrics: {},
        start: Math.round(span._startTime * 1e6),
        duration: Math.round(span._duration * 1e6)
      };
    }
    __name(formatSpan, "formatSpan");
    function setSingleSpanIngestionTags(span, options) {
      if (!options)
        return;
      addTag({}, span.metrics, SPAN_SAMPLING_MECHANISM, SAMPLING_MECHANISM_SPAN);
      addTag({}, span.metrics, SPAN_SAMPLING_RULE_RATE, options.sampleRate);
      addTag({}, span.metrics, SPAN_SAMPLING_MAX_PER_SECOND, options.maxPerSecond);
    }
    __name(setSingleSpanIngestionTags, "setSingleSpanIngestionTags");
    function extractTags(trace, span) {
      const context = span.context();
      const origin = context._trace.origin;
      const tags2 = context._tags;
      const hostname = context._hostname;
      const priority = context._sampling.priority;
      if (tags2["span.kind"] && tags2["span.kind"] !== "internal") {
        addTag({}, trace.metrics, MEASURED, 1);
      }
      for (const tag in tags2) {
        switch (tag) {
          case "service.name":
          case "span.type":
          case "resource.name":
            addTag(trace, {}, map[tag], tags2[tag]);
            break;
          case "http.status_code":
            addTag(trace.meta, {}, tag, tags2[tag] && String(tags2[tag]));
            break;
          case HOSTNAME_KEY:
          case MEASURED:
            addTag({}, trace.metrics, tag, tags2[tag] === void 0 || tags2[tag] ? 1 : 0);
            break;
          case "error":
            if (context._name !== "fs.operation") {
              extractError(trace, tags2[tag]);
            }
            break;
          case ERROR_TYPE:
          case ERROR_MESSAGE:
          case ERROR_STACK:
            if (context._name !== "fs.operation") {
              trace.error = 1;
            } else {
              break;
            }
          default:
            addTag(trace.meta, trace.metrics, tag, tags2[tag]);
        }
      }
      setSingleSpanIngestionTags(trace, context._sampling.spanSampling);
      addTag(trace.meta, trace.metrics, "language", "javascript");
      addTag(trace.meta, trace.metrics, PROCESS_ID, process.pid);
      addTag(trace.meta, trace.metrics, SAMPLING_PRIORITY_KEY, priority);
      addTag(trace.meta, trace.metrics, ORIGIN_KEY, origin);
      addTag(trace.meta, trace.metrics, HOSTNAME_KEY, hostname);
    }
    __name(extractTags, "extractTags");
    function extractRootTags(trace, span) {
      const context = span.context();
      const isLocalRoot = span === context._trace.started[0];
      const parentId = context._parentId;
      if (!isLocalRoot || parentId && parentId.toString(10) !== "0")
        return;
      addTag({}, trace.metrics, SAMPLING_RULE_DECISION, context._trace[SAMPLING_RULE_DECISION]);
      addTag({}, trace.metrics, SAMPLING_LIMIT_DECISION, context._trace[SAMPLING_LIMIT_DECISION]);
      addTag({}, trace.metrics, SAMPLING_AGENT_DECISION, context._trace[SAMPLING_AGENT_DECISION]);
      addTag({}, trace.metrics, TOP_LEVEL_KEY, 1);
    }
    __name(extractRootTags, "extractRootTags");
    function extractChunkTags(trace, span) {
      const context = span.context();
      const isLocalRoot = span === context._trace.started[0];
      if (!isLocalRoot)
        return;
      for (const key in context._trace.tags) {
        addTag(trace.meta, trace.metrics, key, context._trace.tags[key]);
      }
    }
    __name(extractChunkTags, "extractChunkTags");
    function extractError(trace, error) {
      if (!error)
        return;
      trace.error = 1;
      if (isError(error)) {
        addTag(trace.meta, trace.metrics, ERROR_MESSAGE, error.message);
        addTag(trace.meta, trace.metrics, ERROR_TYPE, error.name);
        addTag(trace.meta, trace.metrics, ERROR_STACK, error.stack);
      }
    }
    __name(extractError, "extractError");
    function addTag(meta, metrics, key, value, nested) {
      switch (typeof value) {
        case "string":
          if (!value)
            break;
          meta[key] = value;
          break;
        case "number":
          if (isNaN(value))
            break;
          metrics[key] = value;
          break;
        case "boolean":
          metrics[key] = value ? 1 : 0;
          break;
        case "undefined":
          break;
        case "object":
          if (value === null)
            break;
          if (isNodeBuffer(value) || isUrl(value)) {
            metrics[key] = value.toString();
          } else if (!Array.isArray(value) && !nested) {
            for (const prop in value) {
              if (!hasOwn(value, prop))
                continue;
              addTag(meta, metrics, `${key}.${prop}`, value[prop], true);
            }
          }
          break;
      }
    }
    __name(addTag, "addTag");
    function hasOwn(object, prop) {
      return Object.prototype.hasOwnProperty.call(object, prop);
    }
    __name(hasOwn, "hasOwn");
    function isNodeBuffer(obj) {
      return obj.constructor && obj.constructor.name === "Buffer" && typeof obj.readInt8 === "function" && typeof obj.toString === "function";
    }
    __name(isNodeBuffer, "isNodeBuffer");
    function isUrl(obj) {
      return obj.constructor && obj.constructor.name === "URL" && typeof obj.href === "string" && typeof obj.toString === "function";
    }
    __name(isUrl, "isUrl");
    module2.exports = format;
  }
});

// node_modules/dd-trace/ext/formats.js
var require_formats = __commonJS({
  "node_modules/dd-trace/ext/formats.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      TEXT_MAP: "text_map",
      HTTP_HEADERS: "http_headers",
      BINARY: "binary",
      LOG: "log"
    };
  }
});

// node_modules/dd-trace/ext/kinds.js
var require_kinds = __commonJS({
  "node_modules/dd-trace/ext/kinds.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      SERVER: "server",
      CLIENT: "client",
      PRODUCER: "producer",
      CONSUMER: "consumer"
    };
  }
});

// node_modules/dd-trace/ext/types.js
var require_types = __commonJS({
  "node_modules/dd-trace/ext/types.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      HTTP: "http",
      WEB: "web"
    };
  }
});

// node_modules/dd-trace/ext/exporters.js
var require_exporters = __commonJS({
  "node_modules/dd-trace/ext/exporters.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      LOG: "log",
      AGENT: "agent",
      DATADOG: "datadog",
      AGENT_PROXY: "agent_proxy"
    };
  }
});

// node_modules/dd-trace/ext/index.js
var require_ext = __commonJS({
  "node_modules/dd-trace/ext/index.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var kinds = require_kinds();
    var priority = require_priority();
    var tags = require_tags();
    var types = require_types();
    var exporters = require_exporters();
    module2.exports = {
      formats,
      kinds,
      priority,
      tags,
      types,
      exporters
    };
  }
});

// node_modules/limiter/lib/tokenBucket.js
var require_tokenBucket = __commonJS({
  "node_modules/limiter/lib/tokenBucket.js"(exports2, module2) {
    var TokenBucket = /* @__PURE__ */ __name(function(bucketSize, tokensPerInterval, interval, parentBucket) {
      this.bucketSize = bucketSize;
      this.tokensPerInterval = tokensPerInterval;
      if (typeof interval === "string") {
        switch (interval) {
          case "sec":
          case "second":
            this.interval = 1e3;
            break;
          case "min":
          case "minute":
            this.interval = 1e3 * 60;
            break;
          case "hr":
          case "hour":
            this.interval = 1e3 * 60 * 60;
            break;
          case "day":
            this.interval = 1e3 * 60 * 60 * 24;
            break;
          default:
            throw new Error("Invaid interval " + interval);
        }
      } else {
        this.interval = interval;
      }
      this.parentBucket = parentBucket;
      this.content = 0;
      this.lastDrip = +new Date();
    }, "TokenBucket");
    TokenBucket.prototype = {
      bucketSize: 1,
      tokensPerInterval: 1,
      interval: 1e3,
      parentBucket: null,
      content: 0,
      lastDrip: 0,
      removeTokens: function(count, callback) {
        var self2 = this;
        if (!this.bucketSize) {
          process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
          return true;
        }
        if (count > this.bucketSize) {
          process.nextTick(callback.bind(null, "Requested tokens " + count + " exceeds bucket size " + this.bucketSize, null));
          return false;
        }
        this.drip();
        if (count > this.content)
          return comeBackLater();
        if (this.parentBucket) {
          return this.parentBucket.removeTokens(count, function(err, remainingTokens) {
            if (err)
              return callback(err, null);
            if (count > self2.content)
              return comeBackLater();
            self2.content -= count;
            callback(null, Math.min(remainingTokens, self2.content));
          });
        } else {
          this.content -= count;
          process.nextTick(callback.bind(null, null, this.content));
          return true;
        }
        function comeBackLater() {
          var waitInterval = Math.ceil(
            (count - self2.content) * (self2.interval / self2.tokensPerInterval)
          );
          setTimeout(function() {
            self2.removeTokens(count, callback);
          }, waitInterval);
          return false;
        }
        __name(comeBackLater, "comeBackLater");
      },
      tryRemoveTokens: function(count) {
        if (!this.bucketSize)
          return true;
        if (count > this.bucketSize)
          return false;
        this.drip();
        if (count > this.content)
          return false;
        if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))
          return false;
        this.content -= count;
        return true;
      },
      drip: function() {
        if (!this.tokensPerInterval) {
          this.content = this.bucketSize;
          return;
        }
        var now = +new Date();
        var deltaMS = Math.max(now - this.lastDrip, 0);
        this.lastDrip = now;
        var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
        this.content = Math.min(this.content + dripAmount, this.bucketSize);
      }
    };
    module2.exports = TokenBucket;
  }
});

// node_modules/limiter/lib/clock.js
var require_clock = __commonJS({
  "node_modules/limiter/lib/clock.js"(exports2, module2) {
    var getMilliseconds = /* @__PURE__ */ __name(function() {
      if (typeof process !== "undefined" && process.hrtime) {
        var hrtime = process.hrtime();
        var seconds = hrtime[0];
        var nanoseconds = hrtime[1];
        return seconds * 1e3 + Math.floor(nanoseconds / 1e6);
      }
      return new Date().getTime();
    }, "getMilliseconds");
    module2.exports = getMilliseconds;
  }
});

// node_modules/limiter/lib/rateLimiter.js
var require_rateLimiter = __commonJS({
  "node_modules/limiter/lib/rateLimiter.js"(exports2, module2) {
    var TokenBucket = require_tokenBucket();
    var getMilliseconds = require_clock();
    var RateLimiter = /* @__PURE__ */ __name(function(tokensPerInterval, interval, fireImmediately) {
      this.tokenBucket = new TokenBucket(
        tokensPerInterval,
        tokensPerInterval,
        interval,
        null
      );
      this.tokenBucket.content = tokensPerInterval;
      this.curIntervalStart = getMilliseconds();
      this.tokensThisInterval = 0;
      this.fireImmediately = fireImmediately;
    }, "RateLimiter");
    RateLimiter.prototype = {
      tokenBucket: null,
      curIntervalStart: 0,
      tokensThisInterval: 0,
      fireImmediately: false,
      removeTokens: function(count, callback) {
        if (count > this.tokenBucket.bucketSize) {
          process.nextTick(callback.bind(
            null,
            "Requested tokens " + count + " exceeds maximum tokens per interval " + this.tokenBucket.bucketSize,
            null
          ));
          return false;
        }
        var self2 = this;
        var now = getMilliseconds();
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
          this.curIntervalStart = now;
          this.tokensThisInterval = 0;
        }
        if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
          if (this.fireImmediately) {
            process.nextTick(callback.bind(null, null, -1));
          } else {
            var waitInterval = Math.ceil(
              this.curIntervalStart + this.tokenBucket.interval - now
            );
            setTimeout(function() {
              self2.tokenBucket.removeTokens(count, afterTokensRemoved);
            }, waitInterval);
          }
          return false;
        }
        return this.tokenBucket.removeTokens(count, afterTokensRemoved);
        function afterTokensRemoved(err, tokensRemaining) {
          if (err)
            return callback(err, null);
          self2.tokensThisInterval += count;
          callback(null, tokensRemaining);
        }
        __name(afterTokensRemoved, "afterTokensRemoved");
      },
      tryRemoveTokens: function(count) {
        if (count > this.tokenBucket.bucketSize)
          return false;
        var now = getMilliseconds();
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
          this.curIntervalStart = now;
          this.tokensThisInterval = 0;
        }
        if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
          return false;
        var removed = this.tokenBucket.tryRemoveTokens(count);
        if (removed) {
          this.tokensThisInterval += count;
        }
        return removed;
      },
      getTokensRemaining: function() {
        this.tokenBucket.drip();
        return this.tokenBucket.content;
      }
    };
    module2.exports = RateLimiter;
  }
});

// node_modules/limiter/index.js
var require_limiter = __commonJS({
  "node_modules/limiter/index.js"(exports2) {
    exports2.RateLimiter = require_rateLimiter();
    exports2.TokenBucket = require_tokenBucket();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/rate_limiter.js
var require_rate_limiter = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/rate_limiter.js"(exports2, module2) {
    "use strict";
    var limiter = require_limiter();
    var RateLimiter = class {
      constructor(rateLimit) {
        this._rateLimit = parseInt(rateLimit);
        this._limiter = new limiter.RateLimiter(this._rateLimit, "second");
        this._tokensRequested = 0;
        this._prevIntervalTokens = 0;
        this._prevTokensRequested = 0;
      }
      isAllowed() {
        const curIntervalStart = this._limiter.curIntervalStart;
        const curIntervalTokens = this._limiter.tokensThisInterval;
        const allowed = this._isAllowed();
        if (curIntervalStart !== this._limiter.curIntervalStart) {
          this._prevIntervalTokens = curIntervalTokens;
          this._prevTokensRequested = this._tokensRequested;
          this._tokensRequested = 1;
        } else {
          this._tokensRequested++;
        }
        return allowed;
      }
      effectiveRate() {
        if (this._rateLimit < 0)
          return 1;
        if (this._rateLimit === 0)
          return 0;
        if (this._tokensRequested === 0)
          return 1;
        const allowed = this._prevIntervalTokens + this._limiter.tokensThisInterval;
        const requested = this._prevTokensRequested + this._tokensRequested;
        return allowed / requested;
      }
      _isAllowed() {
        if (this._rateLimit < 0)
          return true;
        if (this._rateLimit === 0)
          return false;
        return this._limiter.tryRemoveTokens(1);
      }
      _currentWindowRate() {
        if (this._rateLimit < 0)
          return 1;
        if (this._rateLimit === 0)
          return 0;
        if (this._tokensRequested === 0)
          return 1;
        return this._limiter.tokensThisInterval / this._tokensRequested;
      }
    };
    __name(RateLimiter, "RateLimiter");
    module2.exports = RateLimiter;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/span_sampler.js
var require_span_sampler = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/span_sampler.js"(exports2, module2) {
    "use strict";
    var { globMatch } = require_util();
    var { USER_KEEP, AUTO_KEEP } = require_ext().priority;
    var RateLimiter = require_rate_limiter();
    var SpanSampler = class {
      constructor({ spanSamplingRules = [] }) {
        this._rules = spanSamplingRules;
        this._limiters = {};
      }
      sample(spanContext) {
        const decision = spanContext._sampling.priority;
        if (decision === USER_KEEP || decision === AUTO_KEEP)
          return;
        const { started } = spanContext._trace;
        for (const span of started) {
          const service = span.tracer()._service;
          const name = span._name;
          const rule = findRule(this._rules, service, name);
          if (!rule)
            continue;
          const sampleRate = getSampleRate(rule.sampleRate);
          const maxPerSecond = getMaxPerSecond(rule.maxPerSecond);
          const sampled = sample(sampleRate);
          if (!sampled)
            continue;
          const key = `${service}:${name}`;
          const limiter = getLimiter(this._limiters, key, maxPerSecond);
          if (limiter.isAllowed()) {
            span.context()._sampling.spanSampling = {
              sampleRate,
              maxPerSecond
            };
          }
        }
      }
    };
    __name(SpanSampler, "SpanSampler");
    function findRule(rules, service, name) {
      for (const rule of rules) {
        const servicePattern = getService(rule.service);
        const namePattern = getName(rule.name);
        if (globMatch(servicePattern, service) && globMatch(namePattern, name)) {
          return rule;
        }
      }
    }
    __name(findRule, "findRule");
    function getLimiter(list, key, maxPerSecond) {
      if (typeof list[key] === "undefined") {
        list[key] = new RateLimiter(maxPerSecond);
      }
      return list[key];
    }
    __name(getLimiter, "getLimiter");
    function sample(sampleRate) {
      return Math.random() < sampleRate;
    }
    __name(sample, "sample");
    function getService(service) {
      return service || "*";
    }
    __name(getService, "getService");
    function getName(name) {
      return name || "*";
    }
    __name(getName, "getName");
    function getSampleRate(sampleRate) {
      return sampleRate || 1;
    }
    __name(getSampleRate, "getSampleRate");
    function getMaxPerSecond(maxPerSecond) {
      return maxPerSecond || Infinity;
    }
    __name(getMaxPerSecond, "getMaxPerSecond");
    module2.exports = SpanSampler;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/pkg.js
var require_pkg = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/pkg.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    function findRoot() {
      return __require.main && __require.main.filename ? path.dirname(__require.main.filename) : process.cwd();
    }
    __name(findRoot, "findRoot");
    function findPkg() {
      const cwd = findRoot();
      const directory = path.resolve(cwd);
      const res = path.parse(directory);
      if (!res)
        return {};
      const { root } = res;
      const filePath = findUp("package.json", root, directory);
      try {
        return JSON.parse(fs.readFileSync(filePath, "utf8"));
      } catch (e) {
        return {};
      }
    }
    __name(findPkg, "findPkg");
    function findUp(name, root, directory) {
      while (true) {
        const current = path.resolve(directory, name);
        if (fs.existsSync(current))
          return current;
        if (directory === root)
          return;
        directory = path.dirname(directory);
      }
    }
    __name(findUp, "findUp");
    module2.exports = Object.assign(findPkg(), { findRoot, findUp });
  }
});

// node_modules/dd-trace/package.json
var require_package = __commonJS({
  "node_modules/dd-trace/package.json"(exports2, module2) {
    module2.exports = {
      name: "dd-trace",
      version: "3.14.1",
      description: "Datadog APM tracing client for JavaScript",
      main: "index.js",
      typings: "index.d.ts",
      scripts: {
        preinstall: "node scripts/preinstall.js",
        bench: "node benchmark",
        "bench:profiler": "node benchmark/profiler",
        "bench:e2e": "SERVICES=mongo yarn services && cd benchmark/e2e && node benchmark-run.js --duration=30",
        "bench:e2e:ci-visibility": "node benchmark/e2e-ci/benchmark-run.js",
        "type:doc": "cd docs && yarn && yarn build",
        "type:test": "cd docs && yarn && yarn test",
        lint: "node scripts/check_licenses.js && eslint . && yarn audit --groups dependencies",
        services: "node ./scripts/install_plugin_modules && node packages/dd-trace/test/setup/services",
        tdd: "node scripts/tdd.js",
        test: "SERVICES=* yarn services && mocha --colors --exit --expose-gc 'packages/dd-trace/test/setup/node.js' 'packages/*/test/**/*.spec.js'",
        "test:trace:core": 'mocha --colors --exit --expose-gc --file packages/dd-trace/test/setup/core.js --exclude "packages/dd-trace/test/lambda/**/*.spec.js" --exclude "packages/dd-trace/test/profiling/**/*.spec.js" --exclude "packages/dd-trace/test/appsec/iast/**/*.plugin.spec.js" "packages/dd-trace/test/**/*.spec.js"',
        "test:trace:core:ci": 'nyc --no-clean --include "packages/dd-trace/src/**/*.js" --exclude "packages/dd-trace/src/lambda/**/*.spec.js" --exclude "packages/dd-trace/src/profiling/**/*.js" --exclude "packages/dd-trace/test/appsec/iast/**/*.plugin.spec.js" -- npm run test:trace:core -- --reporter mocha-multi-reporters --reporter-options configFile=mocha-reporter.json',
        "test:instrumentations": "mocha --colors --file 'packages/dd-trace/test/setup/core.js' 'packages/datadog-instrumentations/test/**/*.spec.js'",
        "test:instrumentations:ci": "nyc --no-clean --include 'packages/datadog-instrumentations/src/**/*.js' -- npm run test:instrumentations",
        "test:core": "mocha --colors --file packages/datadog-core/test/setup.js 'packages/datadog-core/test/**/*.spec.js'",
        "test:core:ci": "nyc --no-clean --include 'packages/datadog-core/src/**/*.js' -- npm run test:core",
        "test:lambda": 'mocha --colors --exit --file "packages/dd-trace/test/setup/core.js" "packages/dd-trace/test/lambda/**/*.spec.js"',
        "test:lambda:ci": 'nyc --no-clean --include "packages/dd-trace/src/lambda/**/*.js" -- npm run test:lambda',
        "test:plugins": 'mocha --colors --exit --file "packages/dd-trace/test/setup/core.js" "packages/datadog-instrumentations/test/@($(echo $PLUGINS)).spec.js" "packages/datadog-plugin-@($(echo $PLUGINS))/test/**/*.spec.js" "packages/dd-trace/test/appsec/iast/**/*.@($(echo $PLUGINS)).plugin.spec.js"',
        "test:plugins:ci": 'yarn services && nyc --no-clean --include "packages/datadog-instrumentations/src/@($(echo $PLUGINS)).js" --include "packages/datadog-instrumentations/src/@($(echo $PLUGINS))/**/*.js" --include "packages/datadog-plugin-@($(echo $PLUGINS))/src/**/*.js" --include "packages/dd-trace/test/appsec/iast/**/*.@($(echo $PLUGINS)).plugin.spec.js" -- npm run test:plugins',
        "test:plugins:upstream": "node ./packages/dd-trace/test/plugins/suite.js",
        "test:profiler": 'mocha --colors --exit --file "packages/dd-trace/test/setup/core.js" "packages/dd-trace/test/profiling/**/*.spec.js"',
        "test:profiler:ci": 'nyc --no-clean --include "packages/dd-trace/src/profiling/**/*.js" -- npm run test:profiler',
        "test:integration": 'mocha --colors --timeout 30000 "integration-tests/**/*.spec.js"',
        "test:shimmer": "mocha --colors 'packages/datadog-shimmer/test/**/*.spec.js'",
        "test:shimmer:ci": "nyc --no-clean --include 'packages/datadog-shimmer/src/**/*.js' -- npm run test:shimmer",
        "leak:core": "node ./scripts/install_plugin_modules && (cd packages/memwatch && yarn) && NODE_PATH=./packages/memwatch/node_modules node --no-warnings ./node_modules/.bin/tape 'packages/dd-trace/test/leak/**/*.js'",
        "leak:plugins": 'yarn services && (cd packages/memwatch && yarn) && NODE_PATH=./packages/memwatch/node_modules node --no-warnings ./node_modules/.bin/tape "packages/datadog-plugin-@($(echo $PLUGINS))/test/leak.js"',
        "junit:upload": "node ./scripts/junit_report.js"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/DataDog/dd-trace-js.git"
      },
      keywords: [
        "datadog",
        "trace",
        "tracing",
        "profile",
        "profiler",
        "profiling",
        "opentracing",
        "apm"
      ],
      author: "Datadog Inc. <info@datadoghq.com>",
      license: "BSD-3-Clause",
      bugs: {
        url: "https://github.com/DataDog/dd-trace-js/issues"
      },
      homepage: "https://github.com/DataDog/dd-trace-js#readme",
      engines: {
        node: ">=14"
      },
      dependencies: {
        "@datadog/native-appsec": "2.0.0",
        "@datadog/native-iast-rewriter": "1.1.2",
        "@datadog/native-iast-taint-tracking": "1.1.0",
        "@datadog/native-metrics": "^1.5.0",
        "@datadog/pprof": "^1.1.1",
        "@datadog/sketches-js": "^2.1.0",
        "crypto-randomuuid": "^1.0.0",
        diagnostics_channel: "^1.1.0",
        ignore: "^5.2.0",
        "import-in-the-middle": "^1.3.4",
        "ipaddr.js": "^2.0.1",
        "istanbul-lib-coverage": "3.2.0",
        koalas: "^1.0.2",
        limiter: "^1.1.4",
        "lodash.kebabcase": "^4.1.1",
        "lodash.pick": "^4.4.0",
        "lodash.sortby": "^4.7.0",
        "lodash.uniq": "^4.5.0",
        "lru-cache": "^7.14.0",
        methods: "^1.1.2",
        "module-details-from-path": "^1.0.3",
        "node-abort-controller": "^3.0.1",
        opentracing: ">=0.12.1",
        "path-to-regexp": "^0.1.2",
        protobufjs: "^7.1.2",
        retry: "^0.10.1",
        semver: "^5.5.0"
      },
      devDependencies: {
        "@types/node": ">=14",
        autocannon: "^4.5.2",
        axios: "^0.21.2",
        benchmark: "^2.1.4",
        "body-parser": "^1.18.2",
        chai: "^4.2.0",
        chalk: "^3.0.0",
        checksum: "^0.1.1",
        "cli-table3": "^0.5.1",
        dotenv: "8.2.0",
        eslint: "^8.23.0",
        "eslint-config-standard": "^11.0.0-beta.0",
        "eslint-plugin-import": "^2.8.0",
        "eslint-plugin-mocha": "^10.1.0",
        "eslint-plugin-node": "^5.2.1",
        "eslint-plugin-promise": "^3.6.0",
        "eslint-plugin-standard": "^3.0.1",
        express: "^4.16.2",
        "get-port": "^3.2.0",
        glob: "^7.1.6",
        graphql: "0.13.2",
        "int64-buffer": "^0.1.9",
        jszip: "^3.5.0",
        mkdirp: "^0.5.1",
        mocha: "8",
        "mocha-junit-reporter": "^2.1.0",
        "mocha-multi-reporters": "^1.5.1",
        "msgpack-lite": "^0.1.26",
        multer: "^1.4.5-lts.1",
        nock: "^11.3.3",
        nyc: "^15.1.0",
        proxyquire: "^1.8.0",
        rimraf: "^3.0.0",
        sinon: "^11.1.2",
        "sinon-chai": "^3.7.0",
        tape: "^4.9.1",
        "wait-on": "^5.0.0"
      }
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/encode/tags-processors.js
var require_tags_processors = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/encode/tags-processors.js"(exports2, module2) {
    var MAX_RESOURCE_NAME_LENGTH = 5e3;
    var MAX_META_KEY_LENGTH = 200;
    var MAX_META_VALUE_LENGTH = 25e3;
    var MAX_METRIC_KEY_LENGTH = MAX_META_KEY_LENGTH;
    var MAX_METRIC_VALUE_LENGTH = MAX_META_VALUE_LENGTH;
    var DEFAULT_SPAN_NAME = "unnamed_operation";
    var DEFAULT_SERVICE_NAME = "unnamed-service";
    var MAX_NAME_LENGTH = 100;
    var MAX_SERVICE_LENGTH = 100;
    var MAX_TYPE_LENGTH = 100;
    var fromEntries = Object.fromEntries || ((entries) => entries.reduce((obj, [k, v]) => Object.assign(obj, { [k]: v }), {}));
    function truncateToLength(value, maxLength) {
      if (!value) {
        return value;
      }
      if (value.length > maxLength) {
        return `${value.slice(0, maxLength)}...`;
      }
      return value;
    }
    __name(truncateToLength, "truncateToLength");
    function truncateSpan(span, shouldTruncateResourceName = true) {
      return fromEntries(Object.entries(span).map(([key, value]) => {
        switch (key) {
          case "resource":
            return ["resource", shouldTruncateResourceName ? truncateToLength(value, MAX_RESOURCE_NAME_LENGTH) : value];
          case "meta":
            return ["meta", fromEntries(Object.entries(value).map(
              ([metaKey, metaValue]) => [truncateToLength(metaKey, MAX_META_KEY_LENGTH), truncateToLength(metaValue, MAX_META_VALUE_LENGTH)]
            ))];
          case "metrics":
            return ["metrics", fromEntries(Object.entries(value).map(
              ([metricsKey, metricsValue]) => [truncateToLength(metricsKey, MAX_METRIC_KEY_LENGTH), truncateToLength(metricsValue, MAX_METRIC_VALUE_LENGTH)]
            ))];
          default:
            return [key, value];
        }
      }));
    }
    __name(truncateSpan, "truncateSpan");
    function normalizeSpan(span) {
      const normalizedSpan = fromEntries(Object.entries(span).map(([key, value]) => {
        switch (key) {
          case "service":
            if (!value) {
              return [key, DEFAULT_SERVICE_NAME];
            }
            if (value.length > MAX_SERVICE_LENGTH) {
              return [key, value.slice(0, MAX_SERVICE_LENGTH)];
            }
            break;
          case "name":
            if (!value) {
              return [key, DEFAULT_SPAN_NAME];
            }
            if (value.length > MAX_NAME_LENGTH) {
              return [key, value.slice(0, MAX_NAME_LENGTH)];
            }
            break;
          case "resource":
            if (!value) {
              return [key, span.name || DEFAULT_SPAN_NAME];
            }
            break;
          case "type":
            if (!value) {
              return [key, value];
            }
            if (value.length > MAX_TYPE_LENGTH) {
              return [key, value.slice(0, MAX_TYPE_LENGTH)];
            }
        }
        return [key, value];
      }));
      if (!normalizedSpan.service) {
        normalizedSpan.service = DEFAULT_SERVICE_NAME;
      }
      if (!normalizedSpan.name) {
        normalizedSpan.name = DEFAULT_SPAN_NAME;
      }
      return normalizedSpan;
    }
    __name(normalizeSpan, "normalizeSpan");
    module2.exports = {
      truncateSpan,
      normalizeSpan,
      MAX_META_KEY_LENGTH,
      MAX_META_VALUE_LENGTH,
      MAX_METRIC_KEY_LENGTH,
      MAX_METRIC_VALUE_LENGTH,
      MAX_NAME_LENGTH,
      MAX_SERVICE_LENGTH,
      MAX_TYPE_LENGTH,
      MAX_RESOURCE_NAME_LENGTH,
      DEFAULT_SPAN_NAME,
      DEFAULT_SERVICE_NAME
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/encode/chunk.js
var require_chunk = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/encode/chunk.js"(exports2, module2) {
    "use strict";
    var DEFAULT_MIN_SIZE = 2 * 1024 * 1024;
    var Chunk = class {
      constructor(minSize = DEFAULT_MIN_SIZE) {
        this.buffer = Buffer.allocUnsafe(minSize);
        this.length = 0;
        this._minSize = minSize;
      }
      write(value) {
        const length = Buffer.byteLength(value);
        const offset = this.length;
        if (length < 32) {
          this.reserve(length + 1);
          this.length += 1;
          this.buffer[offset] = length | 160;
        } else if (length < 4294967296) {
          this.reserve(length + 5);
          this.length += 5;
          this.buffer[offset] = 219;
          this.buffer[offset + 1] = length >> 24;
          this.buffer[offset + 2] = length >> 16;
          this.buffer[offset + 3] = length >> 8;
          this.buffer[offset + 4] = length;
        }
        this.length += this.buffer.utf8Write(value, this.length, length);
        return this.length - offset;
      }
      copy(target, sourceStart, sourceEnd) {
        target.set(new Uint8Array(this.buffer.buffer, sourceStart, sourceEnd - sourceStart));
      }
      set(array) {
        this.reserve(array.length);
        this.buffer.set(array, this.length);
        this.length += array.length;
      }
      reserve(size) {
        if (this.length + size > this.buffer.length) {
          this._resize(this._minSize * Math.ceil((this.length + size) / this._minSize));
        }
      }
      _resize(size) {
        const oldBuffer = this.buffer;
        this.buffer = Buffer.allocUnsafe(size);
        oldBuffer.copy(this.buffer, 0, 0, this.length);
      }
    };
    __name(Chunk, "Chunk");
    module2.exports = Chunk;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js
var require__ = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js"(exports2, module2) {
    "use strict";
    var { truncateSpan, normalizeSpan } = require_tags_processors();
    var Chunk = require_chunk();
    var log = require_log();
    var SOFT_LIMIT = 8 * 1024 * 1024;
    var float64Array = new Float64Array(1);
    var uInt8Float64Array = new Uint8Array(float64Array.buffer);
    float64Array[0] = -1;
    var bigEndian = uInt8Float64Array[7] === 0;
    function formatSpan(span) {
      return normalizeSpan(truncateSpan(span, false));
    }
    __name(formatSpan, "formatSpan");
    var AgentEncoder = class {
      constructor(writer, limit = SOFT_LIMIT) {
        this._limit = limit;
        this._traceBytes = new Chunk();
        this._stringBytes = new Chunk();
        this._writer = writer;
        this._reset();
      }
      count() {
        return this._traceCount;
      }
      encode(trace) {
        const bytes = this._traceBytes;
        const start = bytes.length;
        this._traceCount++;
        this._encode(bytes, trace);
        const end = bytes.length;
        log.debug(() => {
          const hex = bytes.buffer.subarray(start, end).toString("hex").match(/../g).join(" ");
          return `Adding encoded trace to buffer: ${hex}`;
        });
        if (this._traceBytes.length > this._limit || this._stringBytes.length > this._limit) {
          log.debug("Buffer went over soft limit, flushing");
          this._writer.flush();
        }
      }
      makePayload() {
        const traceSize = this._traceBytes.length + 5;
        const buffer = Buffer.allocUnsafe(traceSize);
        this._writeTraces(buffer);
        this._reset();
        return buffer;
      }
      reset() {
        this._reset();
      }
      _encode(bytes, trace) {
        this._encodeArrayPrefix(bytes, trace);
        for (let span of trace) {
          span = formatSpan(span);
          bytes.reserve(1);
          if (span.type) {
            bytes.buffer[bytes.length++] = 140;
            this._encodeString(bytes, "type");
            this._encodeString(bytes, span.type);
          } else {
            bytes.buffer[bytes.length++] = 139;
          }
          this._encodeString(bytes, "trace_id");
          this._encodeId(bytes, span.trace_id);
          this._encodeString(bytes, "span_id");
          this._encodeId(bytes, span.span_id);
          this._encodeString(bytes, "parent_id");
          this._encodeId(bytes, span.parent_id);
          this._encodeString(bytes, "name");
          this._encodeString(bytes, span.name);
          this._encodeString(bytes, "resource");
          this._encodeString(bytes, span.resource);
          this._encodeString(bytes, "service");
          this._encodeString(bytes, span.service);
          this._encodeString(bytes, "error");
          this._encodeInteger(bytes, span.error);
          this._encodeString(bytes, "start");
          this._encodeLong(bytes, span.start);
          this._encodeString(bytes, "duration");
          this._encodeLong(bytes, span.duration);
          this._encodeString(bytes, "meta");
          this._encodeMap(bytes, span.meta);
          this._encodeString(bytes, "metrics");
          this._encodeMap(bytes, span.metrics);
        }
      }
      _reset() {
        this._traceCount = 0;
        this._traceBytes.length = 0;
        this._stringCount = 0;
        this._stringBytes.length = 0;
        this._stringMap = {};
        this._cacheString("");
      }
      _encodeArrayPrefix(bytes, value) {
        const length = value.length;
        const offset = bytes.length;
        bytes.reserve(5);
        bytes.length += 5;
        bytes.buffer[offset] = 221;
        bytes.buffer[offset + 1] = length >> 24;
        bytes.buffer[offset + 2] = length >> 16;
        bytes.buffer[offset + 3] = length >> 8;
        bytes.buffer[offset + 4] = length;
      }
      _encodeMapPrefix(bytes, keysLength) {
        const offset = bytes.length;
        bytes.reserve(5);
        bytes.length += 5;
        bytes.buffer[offset] = 223;
        bytes.buffer[offset + 1] = keysLength >> 24;
        bytes.buffer[offset + 2] = keysLength >> 16;
        bytes.buffer[offset + 3] = keysLength >> 8;
        bytes.buffer[offset + 4] = keysLength;
      }
      _encodeByte(bytes, value) {
        bytes.reserve(1);
        bytes.buffer[bytes.length++] = value;
      }
      _encodeId(bytes, id) {
        const offset = bytes.length;
        bytes.reserve(9);
        bytes.length += 9;
        id = id.toArray();
        bytes.buffer[offset] = 207;
        bytes.buffer[offset + 1] = id[0];
        bytes.buffer[offset + 2] = id[1];
        bytes.buffer[offset + 3] = id[2];
        bytes.buffer[offset + 4] = id[3];
        bytes.buffer[offset + 5] = id[4];
        bytes.buffer[offset + 6] = id[5];
        bytes.buffer[offset + 7] = id[6];
        bytes.buffer[offset + 8] = id[7];
      }
      _encodeInteger(bytes, value) {
        const offset = bytes.length;
        bytes.reserve(5);
        bytes.length += 5;
        bytes.buffer[offset] = 206;
        bytes.buffer[offset + 1] = value >> 24;
        bytes.buffer[offset + 2] = value >> 16;
        bytes.buffer[offset + 3] = value >> 8;
        bytes.buffer[offset + 4] = value;
      }
      _encodeLong(bytes, value) {
        const offset = bytes.length;
        const hi = value / Math.pow(2, 32) >> 0;
        const lo = value >>> 0;
        bytes.reserve(9);
        bytes.length += 9;
        bytes.buffer[offset] = 207;
        bytes.buffer[offset + 1] = hi >> 24;
        bytes.buffer[offset + 2] = hi >> 16;
        bytes.buffer[offset + 3] = hi >> 8;
        bytes.buffer[offset + 4] = hi;
        bytes.buffer[offset + 5] = lo >> 24;
        bytes.buffer[offset + 6] = lo >> 16;
        bytes.buffer[offset + 7] = lo >> 8;
        bytes.buffer[offset + 8] = lo;
      }
      _encodeMap(bytes, value) {
        const keys = Object.keys(value);
        const validKeys = keys.filter((key) => typeof value[key] === "string" || typeof value[key] === "number");
        this._encodeMapPrefix(bytes, validKeys.length);
        for (const key of validKeys) {
          this._encodeString(bytes, key);
          this._encodeValue(bytes, value[key]);
        }
      }
      _encodeValue(bytes, value) {
        switch (typeof value) {
          case "string":
            this._encodeString(bytes, value);
            break;
          case "number":
            this._encodeFloat(bytes, value);
            break;
          default:
        }
      }
      _encodeString(bytes, value = "") {
        this._cacheString(value);
        const { start, end } = this._stringMap[value];
        this._stringBytes.copy(bytes, start, end);
      }
      _encodeFloat(bytes, value) {
        float64Array[0] = value;
        const offset = bytes.length;
        bytes.reserve(9);
        bytes.length += 9;
        bytes.buffer[offset] = 203;
        if (bigEndian) {
          for (let i = 0; i <= 7; i++) {
            bytes.buffer[offset + i + 1] = uInt8Float64Array[i];
          }
        } else {
          for (let i = 7; i >= 0; i--) {
            bytes.buffer[bytes.length - i - 1] = uInt8Float64Array[i];
          }
        }
      }
      _cacheString(value) {
        if (!(value in this._stringMap)) {
          this._stringCount++;
          this._stringMap[value] = {
            start: this._stringBytes.length,
            end: this._stringBytes.length + this._stringBytes.write(value)
          };
        }
      }
      _writeArrayPrefix(buffer, offset, count) {
        buffer[offset++] = 221;
        buffer.writeUInt32BE(count, offset);
        return offset + 4;
      }
      _writeTraces(buffer, offset = 0) {
        offset = this._writeArrayPrefix(buffer, offset, this._traceCount);
        offset += this._traceBytes.buffer.copy(buffer, offset, 0, this._traceBytes.length);
        return offset;
      }
    };
    __name(AgentEncoder, "AgentEncoder");
    module2.exports = { AgentEncoder };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/encode/span-stats.js
var require_span_stats = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/encode/span-stats.js"(exports2, module2) {
    "use strict";
    var { AgentEncoder } = require__();
    var {
      MAX_NAME_LENGTH,
      MAX_SERVICE_LENGTH,
      MAX_RESOURCE_NAME_LENGTH,
      MAX_TYPE_LENGTH,
      DEFAULT_SPAN_NAME,
      DEFAULT_SERVICE_NAME
    } = require_tags_processors();
    function truncate(value, maxLength, suffix = "") {
      if (!value) {
        return value;
      }
      if (value.length > maxLength) {
        return `${value.slice(0, maxLength)}${suffix}`;
      }
      return value;
    }
    __name(truncate, "truncate");
    var SpanStatsEncoder = class extends AgentEncoder {
      _encodeBool(bytes, value) {
        this._encodeByte(bytes, value ? 195 : 194);
      }
      makePayload() {
        const traceSize = this._traceBytes.length;
        const buffer = Buffer.allocUnsafe(traceSize);
        this._traceBytes.copy(buffer, 0, traceSize);
        this._reset();
        return buffer;
      }
      _encodeMapPrefix(bytes, length) {
        const offset = bytes.length;
        bytes.reserve(1);
        bytes.length += 1;
        bytes.buffer[offset] = 128 + length;
      }
      _encodeBuffer(bytes, buffer) {
        const length = buffer.length;
        const offset = bytes.length;
        bytes.reserve(5);
        bytes.length += 5;
        bytes.buffer[offset] = 198;
        bytes.buffer[offset + 1] = length >> 24;
        bytes.buffer[offset + 2] = length >> 16;
        bytes.buffer[offset + 3] = length >> 8;
        bytes.buffer[offset + 4] = length;
        buffer.copy(bytes.buffer, offset + 5);
        bytes.length += length;
      }
      _encodeStat(bytes, stat) {
        this._encodeMapPrefix(bytes, 12);
        this._encodeString(bytes, "Service");
        const service = stat.Service || DEFAULT_SERVICE_NAME;
        this._encodeString(bytes, truncate(service, MAX_SERVICE_LENGTH));
        this._encodeString(bytes, "Name");
        const name = stat.Name || DEFAULT_SPAN_NAME;
        this._encodeString(bytes, truncate(name, MAX_NAME_LENGTH));
        this._encodeString(bytes, "Resource");
        this._encodeString(bytes, truncate(stat.Resource, MAX_RESOURCE_NAME_LENGTH, "..."));
        this._encodeString(bytes, "HTTPStatusCode");
        this._encodeInteger(bytes, stat.HTTPStatusCode);
        this._encodeString(bytes, "Type");
        this._encodeString(bytes, truncate(stat.Type, MAX_TYPE_LENGTH));
        this._encodeString(bytes, "Hits");
        this._encodeLong(bytes, stat.Hits);
        this._encodeString(bytes, "Errors");
        this._encodeLong(bytes, stat.Errors);
        this._encodeString(bytes, "Duration");
        this._encodeLong(bytes, stat.Duration);
        this._encodeString(bytes, "OkSummary");
        this._encodeBuffer(bytes, stat.OkSummary);
        this._encodeString(bytes, "ErrorSummary");
        this._encodeBuffer(bytes, stat.ErrorSummary);
        this._encodeString(bytes, "Synthetics");
        this._encodeBool(bytes, stat.Synthetics);
        this._encodeString(bytes, "TopLevelHits");
        this._encodeLong(bytes, stat.TopLevelHits);
      }
      _encodeBucket(bytes, bucket) {
        this._encodeMapPrefix(bytes, 3);
        this._encodeString(bytes, "Start");
        this._encodeLong(bytes, bucket.Start);
        this._encodeString(bytes, "Duration");
        this._encodeLong(bytes, bucket.Duration);
        this._encodeString(bytes, "Stats");
        this._encodeArrayPrefix(bytes, bucket.Stats);
        for (const stat of bucket.Stats) {
          this._encodeStat(bytes, stat);
        }
      }
      _encode(bytes, stats) {
        this._encodeMapPrefix(bytes, 8);
        this._encodeString(bytes, "Hostname");
        this._encodeString(bytes, stats.Hostname);
        this._encodeString(bytes, "Env");
        this._encodeString(bytes, stats.Env);
        this._encodeString(bytes, "Version");
        this._encodeString(bytes, stats.Version);
        this._encodeString(bytes, "Stats");
        this._encodeArrayPrefix(bytes, stats.Stats);
        for (const bucket of stats.Stats) {
          this._encodeBucket(bytes, bucket);
        }
        this._encodeString(bytes, "Lang");
        this._encodeString(bytes, stats.Lang);
        this._encodeString(bytes, "TracerVersion");
        this._encodeString(bytes, stats.TracerVersion);
        this._encodeString(bytes, "RuntimeID");
        this._encodeString(bytes, stats.RuntimeID);
        this._encodeString(bytes, "Sequence");
        this._encodeLong(bytes, stats.Sequence);
      }
    };
    __name(SpanStatsEncoder, "SpanStatsEncoder");
    module2.exports = {
      SpanStatsEncoder
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/writer.js
var require_writer3 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporters/common/writer.js"(exports2, module2) {
    "use strict";
    var request = require_request();
    var log = require_log();
    var Writer = class {
      constructor({ url }) {
        this._url = url;
      }
      flush(done = () => {
      }) {
        const count = this._encoder.count();
        if (!request.writable) {
          this._encoder.reset();
          done();
        } else if (count > 0) {
          const payload2 = this._encoder.makePayload();
          this._sendPayload(payload2, count, done);
        } else {
          done();
        }
      }
      append(payload2) {
        if (!request.writable) {
          log.debug(() => `Maximum number of active requests reached. Payload discarded: ${JSON.stringify(payload2)}`);
          return;
        }
        log.debug(() => `Encoding payload: ${JSON.stringify(payload2)}`);
        this._encode(payload2);
      }
      _encode(payload2) {
        this._encoder.encode(payload2);
      }
      setUrl(url) {
        this._url = url;
      }
    };
    __name(Writer, "Writer");
    module2.exports = Writer;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporters/span-stats/writer.js
var require_writer4 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporters/span-stats/writer.js"(exports2, module2) {
    var { SpanStatsEncoder } = require_span_stats();
    var pkg = require_package();
    var BaseWriter = require_writer3();
    var request = require_request();
    var log = require_log();
    var Writer = class extends BaseWriter {
      constructor({ url }) {
        super(...arguments);
        this._url = url;
        this._encoder = new SpanStatsEncoder(this);
      }
      _sendPayload(data, _, done) {
        makeRequest(data, this._url, (err, res) => {
          if (err) {
            log.error(err);
            done();
            return;
          }
          log.debug(`Response from the intake: ${res}`);
          done();
        });
      }
    };
    __name(Writer, "Writer");
    function makeRequest(data, url, cb) {
      const options = {
        path: "/v0.6/stats",
        method: "PUT",
        headers: {
          "Datadog-Meta-Lang": "javascript",
          "Datadog-Meta-Tracer-Version": pkg.version,
          "Content-Type": "application/msgpack"
        }
      };
      options.protocol = url.protocol;
      options.hostname = url.hostname;
      options.port = url.port;
      log.debug(() => `Request to the intake: ${JSON.stringify(options)}`);
      request(data, options, (err, res) => {
        cb(err, res);
      });
    }
    __name(makeRequest, "makeRequest");
    module2.exports = {
      Writer
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporters/span-stats/index.js
var require_span_stats2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporters/span-stats/index.js"(exports2, module2) {
    var { URL: URL2, format } = __require("url");
    var { Writer } = require_writer4();
    var SpanStatsExporter = class {
      constructor(config) {
        const { hostname = "127.0.0.1", port = 8126, tags, url } = config;
        this._url = url || new URL2(format({
          protocol: "http:",
          hostname: hostname || "localhost",
          port
        }));
        this._writer = new Writer({ url: this._url, tags });
      }
      export(payload2) {
        this._writer.append(payload2);
        this._writer.flush();
      }
    };
    __name(SpanStatsExporter, "SpanStatsExporter");
    module2.exports = {
      SpanStatsExporter
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/span_stats.js
var require_span_stats3 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/span_stats.js"(exports2, module2) {
    var os = __require("os");
    var { version } = require_pkg();
    var pkg = require_package();
    var { LogCollapsingLowestDenseDDSketch } = require_dist();
    var { ORIGIN_KEY, TOP_LEVEL_KEY } = require_constants();
    var {
      MEASURED,
      HTTP_STATUS_CODE
    } = require_tags();
    var { SpanStatsExporter } = require_span_stats2();
    var {
      DEFAULT_SPAN_NAME,
      DEFAULT_SERVICE_NAME
    } = require_tags_processors();
    var SpanAggStats = class {
      constructor(aggKey) {
        this.aggKey = aggKey;
        this.hits = 0;
        this.topLevelHits = 0;
        this.errors = 0;
        this.duration = 0;
        this.okDistribution = new LogCollapsingLowestDenseDDSketch(775e-5);
        this.errorDistribution = new LogCollapsingLowestDenseDDSketch(775e-5);
      }
      record(span) {
        const durationNs = span._duration * 1e6;
        this.hits++;
        this.duration += durationNs;
        if (span.metrics[TOP_LEVEL_KEY]) {
          this.topLevelHits++;
        }
        if (span.error) {
          this.errors++;
          this.errorDistribution.accept(durationNs);
        } else {
          this.okDistribution.accept(durationNs);
        }
      }
      toJSON() {
        const {
          name,
          service,
          resource,
          type,
          statusCode,
          synthetics
        } = this.aggKey;
        return {
          Name: name,
          Service: service,
          Resource: resource,
          Type: type,
          HTTPStatusCode: statusCode,
          Synthetics: synthetics,
          Hits: this.hits,
          TopLevelHits: this.topLevelHits,
          Errors: this.errors,
          Duration: this.duration,
          OkSummary: this.okDistribution.toProto(),
          ErrorSummary: this.errorDistribution.toProto()
        };
      }
    };
    __name(SpanAggStats, "SpanAggStats");
    var SpanAggKey = class {
      constructor(span) {
        this.name = span.name || DEFAULT_SPAN_NAME;
        this.service = span.service || DEFAULT_SERVICE_NAME;
        this.resource = span.resource || "";
        this.type = span.type || "";
        this.statusCode = span.meta[HTTP_STATUS_CODE] || 0;
        this.synthetics = span.meta[ORIGIN_KEY] === "synthetics";
      }
      toString() {
        return [
          this.name,
          this.service,
          this.resource,
          this.type,
          this.statusCode,
          this.synthetics
        ].join(",");
      }
    };
    __name(SpanAggKey, "SpanAggKey");
    var SpanBuckets = class extends Map {
      forSpan(span) {
        const aggKey = new SpanAggKey(span);
        const key = aggKey.toString();
        if (!this.has(key)) {
          this.set(key, new SpanAggStats(aggKey));
        }
        return this.get(key);
      }
    };
    __name(SpanBuckets, "SpanBuckets");
    var TimeBuckets = class extends Map {
      forTime(time) {
        if (!this.has(time)) {
          this.set(time, new SpanBuckets());
        }
        return this.get(time);
      }
    };
    __name(TimeBuckets, "TimeBuckets");
    var SpanStatsProcessor = class {
      constructor({
        stats: {
          enabled = false,
          interval = 10
        },
        hostname,
        port,
        url,
        env,
        tags
      } = {}) {
        this.exporter = new SpanStatsExporter({
          hostname,
          port,
          tags,
          url
        });
        this.interval = interval;
        this.bucketSizeNs = interval * 1e9;
        this.buckets = new TimeBuckets();
        this.hostname = os.hostname();
        this.enabled = enabled;
        this.env = env;
        this.tags = tags || {};
        this.sequence = 0;
        if (enabled) {
          this.timer = setInterval(this.onInterval.bind(this), interval * 1e3);
          this.timer.unref();
        }
      }
      onInterval() {
        const serialized = this._serializeBuckets();
        if (!serialized)
          return;
        this.exporter.export({
          Hostname: this.hostname,
          Env: this.env,
          Version: version,
          Stats: serialized,
          Lang: "javascript",
          TracerVersion: pkg.version,
          RuntimeID: this.tags["runtime-id"],
          Sequence: ++this.sequence
        });
      }
      onSpanFinished(span) {
        if (!this.enabled)
          return;
        if (!span.metrics[TOP_LEVEL_KEY] && !span.metrics[MEASURED])
          return;
        const spanEndNs = span.startTime + span.duration;
        const bucketTime = spanEndNs - spanEndNs % this.bucketSizeNs;
        this.buckets.forTime(bucketTime).forSpan(span).record(span);
      }
      _serializeBuckets() {
        const { bucketSizeNs } = this;
        const serializedBuckets = [];
        for (const [timeNs, bucket] of this.buckets.entries()) {
          const bucketAggStats = [];
          for (const stats of bucket.values()) {
            bucketAggStats.push(stats.toJSON());
          }
          serializedBuckets.push({
            Start: timeNs,
            Duration: bucketSizeNs,
            Stats: bucketAggStats
          });
        }
        this.buckets.clear();
        return serializedBuckets;
      }
    };
    __name(SpanStatsProcessor, "SpanStatsProcessor");
    module2.exports = {
      SpanAggStats,
      SpanAggKey,
      SpanBuckets,
      TimeBuckets,
      SpanStatsProcessor
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/span_processor.js
var require_span_processor = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/span_processor.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var format = require_format();
    var SpanSampler = require_span_sampler();
    var { SpanStatsProcessor } = require_span_stats3();
    var startedSpans = /* @__PURE__ */ new WeakSet();
    var finishedSpans = /* @__PURE__ */ new WeakSet();
    var SpanProcessor = class {
      constructor(exporter, prioritySampler, config) {
        this._exporter = exporter;
        this._prioritySampler = prioritySampler;
        this._config = config;
        this._killAll = false;
        this._stats = new SpanStatsProcessor(config);
        this._spanSampler = new SpanSampler(config);
      }
      process(span) {
        const spanContext = span.context();
        const active = [];
        const formatted = [];
        const trace = spanContext._trace;
        const { flushMinSpans } = this._config;
        const { started, finished } = trace;
        if (trace.record === false)
          return;
        if (started.length === finished.length || finished.length >= flushMinSpans) {
          this._prioritySampler.sample(spanContext);
          this._spanSampler.sample(spanContext);
          for (const span2 of started) {
            if (span2._duration !== void 0) {
              const formattedSpan = format(span2);
              this._stats.onSpanFinished(formattedSpan);
              formatted.push(formattedSpan);
            } else {
              active.push(span2);
            }
          }
          if (formatted.length !== 0 && trace.isRecording !== false) {
            this._exporter.export(formatted);
          }
          this._erase(trace, active);
        }
        if (this._killAll) {
          started.map((startedSpan) => {
            if (!startedSpan._finished) {
              startedSpan.finish();
            }
          });
        }
      }
      killAll() {
        this._killAll = true;
      }
      _erase(trace, active) {
        if (process.env.DD_TRACE_EXPERIMENTAL_STATE_TRACKING === "true") {
          const started = /* @__PURE__ */ new Set();
          const startedIds = /* @__PURE__ */ new Set();
          const finished = /* @__PURE__ */ new Set();
          const finishedIds = /* @__PURE__ */ new Set();
          for (const span of trace.finished) {
            const context = span.context();
            const id = context.toSpanId();
            if (finished.has(span)) {
              log.error(`Span was already finished in the same trace: ${span}`);
            } else {
              finished.add(span);
              if (finishedIds.has(id)) {
                log.error(`Another span with the same ID was already finished in the same trace: ${span}`);
              } else {
                finishedIds.add(id);
              }
              if (context._trace !== trace) {
                log.error(`A span was finished in the wrong trace: ${span}.`);
              }
              if (finishedSpans.has(span)) {
                log.error(`Span was already finished in a different trace: ${span}`);
              } else {
                finishedSpans.add(span);
              }
            }
          }
          for (const span of trace.started) {
            const context = span.context();
            const id = context.toSpanId();
            if (started.has(span)) {
              log.error(`Span was already started in the same trace: ${span}`);
            } else {
              started.add(span);
              if (startedIds.has(id)) {
                log.error(`Another span with the same ID was already started in the same trace: ${span}`);
              } else {
                startedIds.add(id);
              }
              if (context._trace !== trace) {
                log.error(`A span was started in the wrong trace: ${span}.`);
              }
              if (startedSpans.has(span)) {
                log.error(`Span was already started in a different trace: ${span}`);
              } else {
                startedSpans.add(span);
              }
            }
            if (!finished.has(span)) {
              log.error(`Span started in one trace but was finished in another trace: ${span}`);
            }
          }
          for (const span of trace.finished) {
            if (!started.has(span)) {
              log.error(`Span finished in one trace but was started in another trace: ${span}`);
            }
          }
        }
        for (const span of trace.finished) {
          span.context()._tags = {};
        }
        trace.started = active;
        trace.finished = [];
      }
    };
    __name(SpanProcessor, "SpanProcessor");
    module2.exports = SpanProcessor;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/sampler.js
var require_sampler = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/sampler.js"(exports2, module2) {
    "use strict";
    var Sampler = class {
      constructor(rate) {
        this._rate = rate;
      }
      rate() {
        return this._rate;
      }
      isSampled() {
        return this._rate === 1 || Math.random() < this._rate;
      }
    };
    __name(Sampler, "Sampler");
    module2.exports = Sampler;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/startup-log.js
var require_startup_log = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/startup-log.js"(exports2, module2) {
    "use strict";
    var mainLogger = require_log();
    var os = __require("os");
    var { inspect } = __require("util");
    var tracerVersion = require_package().version;
    var logger = Object.create(mainLogger);
    logger.toggle(true);
    var config;
    var pluginManager;
    var samplingRules = [];
    var alreadyRan = false;
    function getIntegrationsAndAnalytics() {
      const integrations = /* @__PURE__ */ new Set();
      const extras = {};
      for (const pluginName in pluginManager._pluginsByName) {
        integrations.add(pluginName);
      }
      extras.integrations_loaded = Array.from(integrations);
      return extras;
    }
    __name(getIntegrationsAndAnalytics, "getIntegrationsAndAnalytics");
    function startupLog({ agentError } = {}) {
      if (!config || !pluginManager) {
        return;
      }
      if (alreadyRan) {
        return;
      }
      alreadyRan = true;
      if (!config.startupLogs) {
        return;
      }
      const url = config.url || `http://${config.hostname || "localhost"}:${config.port}`;
      const out = {
        [inspect.custom]() {
          return String(this);
        },
        toString() {
          return JSON.stringify(this);
        }
      };
      out.date = new Date().toISOString();
      out.os_name = os.type();
      out.os_version = os.release();
      out.architecture = os.arch();
      out.version = tracerVersion;
      out.lang = "nodejs";
      out.lang_version = process.versions.node;
      out.env = config.env;
      out.enabled = config.enabled;
      out.service = config.service;
      out.agent_url = url;
      if (agentError) {
        out.agent_error = agentError.message;
      }
      out.debug = !!config.debug;
      out.sample_rate = config.sampleRate;
      out.sampling_rules = samplingRules;
      out.tags = config.tags;
      if (config.tags && config.tags.version) {
        out.dd_version = config.tags.version;
      }
      out.log_injection_enabled = !!config.logInjection;
      out.runtime_metrics_enabled = !!config.runtimeMetrics;
      out.profiling_enabled = !!(config.profiling || {}).enabled;
      Object.assign(out, getIntegrationsAndAnalytics());
      out.appsec_enabled = !!config.appsec.enabled;
      logger.info("DATADOG TRACER CONFIGURATION - " + out);
      if (agentError) {
        logger.warn("DATADOG TRACER DIAGNOSTIC - Agent Error: " + agentError.message);
      }
      config = void 0;
      pluginManager = void 0;
      samplingRules = void 0;
    }
    __name(startupLog, "startupLog");
    function setStartupLogConfig(aConfig) {
      config = aConfig;
    }
    __name(setStartupLogConfig, "setStartupLogConfig");
    function setStartupLogPluginManager(thePluginManager) {
      pluginManager = thePluginManager;
    }
    __name(setStartupLogPluginManager, "setStartupLogPluginManager");
    function setSamplingRules(theRules) {
      samplingRules = theRules;
    }
    __name(setSamplingRules, "setSamplingRules");
    module2.exports = {
      startupLog,
      setStartupLogConfig,
      setStartupLogPluginManager,
      setSamplingRules
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js
var require_priority_sampler = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/priority_sampler.js"(exports2, module2) {
    "use strict";
    var RateLimiter = require_rate_limiter();
    var Sampler = require_sampler();
    var ext = require_ext();
    var { setSamplingRules } = require_startup_log();
    var {
      SAMPLING_MECHANISM_DEFAULT,
      SAMPLING_MECHANISM_AGENT,
      SAMPLING_MECHANISM_RULE,
      SAMPLING_MECHANISM_MANUAL,
      SAMPLING_RULE_DECISION,
      SAMPLING_LIMIT_DECISION,
      SAMPLING_AGENT_DECISION,
      DECISION_MAKER_KEY
    } = require_constants();
    var SERVICE_NAME = ext.tags.SERVICE_NAME;
    var SAMPLING_PRIORITY = ext.tags.SAMPLING_PRIORITY;
    var MANUAL_KEEP = ext.tags.MANUAL_KEEP;
    var MANUAL_DROP = ext.tags.MANUAL_DROP;
    var USER_REJECT = ext.priority.USER_REJECT;
    var AUTO_REJECT = ext.priority.AUTO_REJECT;
    var AUTO_KEEP = ext.priority.AUTO_KEEP;
    var USER_KEEP = ext.priority.USER_KEEP;
    var DEFAULT_KEY = "service:,env:";
    var defaultSampler = new Sampler(AUTO_KEEP);
    var PrioritySampler = class {
      constructor(env, { sampleRate, rateLimit = 100, rules = [] } = {}) {
        this._env = env;
        this._rules = this._normalizeRules(rules, sampleRate);
        this._limiter = new RateLimiter(rateLimit);
        setSamplingRules(this._rules);
        this.update({});
      }
      isSampled(span) {
        const priority = this._getPriorityFromAuto(span);
        return priority === USER_KEEP || priority === AUTO_KEEP;
      }
      sample(span, auto = true) {
        if (!span)
          return;
        const context = this._getContext(span);
        const root = context._trace.started[0];
        if (context._sampling.priority !== void 0)
          return;
        if (!root)
          return;
        const tag = this._getPriorityFromTags(context._tags);
        if (this.validate(tag)) {
          context._sampling.priority = tag;
          context._sampling.mechanism = SAMPLING_MECHANISM_MANUAL;
        } else if (auto) {
          context._sampling.priority = this._getPriorityFromAuto(root);
        } else {
          return;
        }
        this._addDecisionMaker(root);
      }
      update(rates) {
        const samplers = {};
        for (const key in rates) {
          const rate = rates[key];
          const sampler = new Sampler(rate);
          samplers[key] = sampler;
        }
        samplers[DEFAULT_KEY] = samplers[DEFAULT_KEY] || defaultSampler;
        this._samplers = samplers;
      }
      validate(samplingPriority) {
        switch (samplingPriority) {
          case USER_REJECT:
          case USER_KEEP:
          case AUTO_REJECT:
          case AUTO_KEEP:
            return true;
          default:
            return false;
        }
      }
      _getContext(span) {
        return typeof span.context === "function" ? span.context() : span;
      }
      _getPriorityFromAuto(span) {
        const context = this._getContext(span);
        const rule = this._findRule(context);
        return rule ? this._getPriorityByRule(context, rule) : this._getPriorityByAgent(context);
      }
      _getPriorityFromTags(tags) {
        if (hasOwn(tags, MANUAL_KEEP) && tags[MANUAL_KEEP] !== false) {
          return USER_KEEP;
        } else if (hasOwn(tags, MANUAL_DROP) && tags[MANUAL_DROP] !== false) {
          return USER_REJECT;
        } else {
          const priority = parseInt(tags[SAMPLING_PRIORITY], 10);
          if (priority === 1 || priority === 2) {
            return USER_KEEP;
          } else if (priority === 0 || priority === -1) {
            return USER_REJECT;
          }
        }
      }
      _getPriorityByRule(context, rule) {
        context._trace[SAMPLING_RULE_DECISION] = rule.sampleRate;
        context._sampling.mechanism = SAMPLING_MECHANISM_RULE;
        return rule.sampler.isSampled(context) && this._isSampledByRateLimit(context) ? USER_KEEP : USER_REJECT;
      }
      _isSampledByRateLimit(context) {
        const allowed = this._limiter.isAllowed();
        context._trace[SAMPLING_LIMIT_DECISION] = this._limiter.effectiveRate();
        return allowed;
      }
      _getPriorityByAgent(context) {
        const key = `service:${context._tags[SERVICE_NAME]},env:${this._env}`;
        const sampler = this._samplers[key] || this._samplers[DEFAULT_KEY];
        context._trace[SAMPLING_AGENT_DECISION] = sampler.rate();
        if (sampler === defaultSampler) {
          context._sampling.mechanism = SAMPLING_MECHANISM_DEFAULT;
        } else {
          context._sampling.mechanism = SAMPLING_MECHANISM_AGENT;
        }
        return sampler.isSampled(context) ? AUTO_KEEP : AUTO_REJECT;
      }
      _addDecisionMaker(span) {
        const context = span.context();
        const trace = context._trace;
        const priority = context._sampling.priority;
        const mechanism = context._sampling.mechanism;
        if (priority >= AUTO_KEEP) {
          if (!trace.tags[DECISION_MAKER_KEY]) {
            trace.tags[DECISION_MAKER_KEY] = `-${mechanism}`;
          }
        } else {
          delete trace.tags[DECISION_MAKER_KEY];
        }
      }
      _normalizeRules(rules, sampleRate) {
        rules = [].concat(rules || []);
        return rules.concat({ sampleRate }).map((rule) => ({ ...rule, sampleRate: parseFloat(rule.sampleRate) })).filter((rule) => !isNaN(rule.sampleRate)).map((rule) => ({ ...rule, sampler: new Sampler(rule.sampleRate) }));
      }
      _findRule(context) {
        for (let i = 0, l = this._rules.length; i < l; i++) {
          if (this._matchRule(context, this._rules[i]))
            return this._rules[i];
        }
      }
      _matchRule(context, rule) {
        const name = context._name;
        const service = context._tags["service.name"];
        if (rule.name instanceof RegExp && !rule.name.test(name))
          return false;
        if (typeof rule.name === "string" && rule.name !== name)
          return false;
        if (rule.service instanceof RegExp && !rule.service.test(service))
          return false;
        if (typeof rule.service === "string" && rule.service !== service)
          return false;
        return true;
      }
    };
    __name(PrioritySampler, "PrioritySampler");
    function hasOwn(object, prop) {
      return Object.prototype.hasOwnProperty.call(object, prop);
    }
    __name(hasOwn, "hasOwn");
    module2.exports = PrioritySampler;
  }
});

// node_modules/lodash.pick/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.pick/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    __name(apply, "apply");
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeMax = Math.max;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    __name(baseFlatten, "baseFlatten");
    function basePick(object, props) {
      object = Object(object);
      return basePickBy(object, props, function(value, key) {
        return key in object;
      });
    }
    __name(basePick, "basePick");
    function basePickBy(object, props, predicate) {
      var index = -1, length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    __name(basePickBy, "basePickBy");
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    __name(baseRest, "baseRest");
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    __name(isFlattenable, "isFlattenable");
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(toKey, "toKey");
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    __name(isArguments, "isArguments");
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    __name(isArrayLike, "isArrayLike");
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction, "isFunction");
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol, "isSymbol");
    var pick = baseRest(function(object, props) {
      return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
    });
    module2.exports = pick;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/tracestate.js
var require_tracestate = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/tracestate.js"(exports2, module2) {
    "use strict";
    var traceStateRegex = /[ \t]*([^=]+)=([ \t]*[^, \t]+)[ \t]*(,|$)/gim;
    var traceStateDataRegex = /([^:]+):([^;]+)(;|$)/gim;
    function fromString(Type, regex, value) {
      if (typeof value !== "string" || !value.length) {
        return new Type();
      }
      const values = [];
      for (const row of value.matchAll(regex)) {
        values.unshift(row.slice(1, 3));
      }
      return new Type(values);
    }
    __name(fromString, "fromString");
    function toString2(map, pairSeparator, fieldSeparator) {
      return Array.from(map.entries()).reverse().map((pair) => pair.join(pairSeparator)).join(fieldSeparator);
    }
    __name(toString2, "toString");
    var TraceStateData = class extends Map {
      constructor(...args) {
        super(...args);
        this.changed = false;
      }
      set(...args) {
        if (this.has(args[0]) && this.get(args[0]) === args[1]) {
          return;
        }
        this.changed = true;
        return super.set(...args);
      }
      delete(...args) {
        this.changed = true;
        return super.delete(...args);
      }
      clear(...args) {
        this.changed = true;
        return super.clear(...args);
      }
      static fromString(value) {
        return fromString(TraceStateData, traceStateDataRegex, value);
      }
      toString() {
        return toString2(this, ":", ";");
      }
    };
    __name(TraceStateData, "TraceStateData");
    var TraceState = class extends Map {
      set(key, value) {
        if (this.has(key)) {
          this.delete(key);
        }
        return super.set(key, value);
      }
      forVendor(vendor, handle) {
        const data = super.get(vendor);
        const state = TraceStateData.fromString(data);
        const result = handle(state);
        if (state.changed) {
          const value = state.toString();
          if (value) {
            this.set(vendor, state.toString());
          } else {
            this.delete(vendor);
          }
        }
        return result;
      }
      static fromString(value) {
        return fromString(TraceState, traceStateRegex, value);
      }
      toString() {
        return toString2(this, "=", ",");
      }
    };
    __name(TraceState, "TraceState");
    module2.exports = TraceState;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js
var require_text_map = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/text_map.js"(exports2, module2) {
    "use strict";
    var pick = require_lodash();
    var id = require_id();
    var DatadogSpanContext = require_span_context();
    var log = require_log();
    var TraceState = require_tracestate();
    var { AUTO_KEEP, AUTO_REJECT, USER_KEEP } = require_priority();
    var traceKey = "x-datadog-trace-id";
    var spanKey = "x-datadog-parent-id";
    var originKey = "x-datadog-origin";
    var samplingKey = "x-datadog-sampling-priority";
    var tagsKey = "x-datadog-tags";
    var baggagePrefix = "ot-baggage-";
    var b3TraceKey = "x-b3-traceid";
    var b3TraceExpr = /^([0-9a-f]{16}){1,2}$/i;
    var b3SpanKey = "x-b3-spanid";
    var b3SpanExpr = /^[0-9a-f]{16}$/i;
    var b3ParentKey = "x-b3-parentspanid";
    var b3SampledKey = "x-b3-sampled";
    var b3FlagsKey = "x-b3-flags";
    var b3HeaderKey = "b3";
    var sqsdHeaderHey = "x-aws-sqsd-attr-_datadog";
    var b3HeaderExpr = /^(([0-9a-f]{16}){1,2}-[0-9a-f]{16}(-[01d](-[0-9a-f]{16})?)?|[01d])$/i;
    var baggageExpr = new RegExp(`^${baggagePrefix}(.+)$`);
    var tagKeyExpr = /^_dd\.p\.[\x21-\x2b\x2d-\x7e]+$/;
    var tagValueExpr = /^[\x20-\x2b\x2d-\x7e]*$/;
    var ddKeys = [traceKey, spanKey, samplingKey, originKey];
    var b3Keys = [b3TraceKey, b3SpanKey, b3ParentKey, b3SampledKey, b3FlagsKey, b3HeaderKey];
    var logKeys = ddKeys.concat(b3Keys);
    var traceparentExpr = /^([a-f0-9]{2})-([a-f0-9]{32})-([a-f0-9]{16})-([a-f0-9]{2})(-.*)?$/i;
    var traceparentKey = "traceparent";
    var tracestateOriginFilter = /[^\x20-\x2b\x2d-\x3a\x3c-\x7d]/g;
    var tracestateTagKeyFilter = /[^\x21-\x2b\x2d-\x3c\x3e-\x7e]/g;
    var tracestateTagValueFilter = /[^\x20-\x2b\x2d-\x3a\x3c-\x7d]/g;
    var invalidSegment = /^0+$/;
    var TextMapPropagator = class {
      constructor(config) {
        this._config = config;
      }
      inject(spanContext, carrier) {
        this._injectBaggageItems(spanContext, carrier);
        this._injectDatadog(spanContext, carrier);
        this._injectB3MultipleHeaders(spanContext, carrier);
        this._injectB3SingleHeader(spanContext, carrier);
        this._injectTraceparent(spanContext, carrier);
        log.debug(() => `Inject into carrier: ${JSON.stringify(pick(carrier, logKeys))}.`);
      }
      extract(carrier) {
        const spanContext = this._extractSpanContext(carrier);
        if (!spanContext)
          return spanContext;
        log.debug(() => `Extract from carrier: ${JSON.stringify(pick(carrier, logKeys))}.`);
        return spanContext;
      }
      _injectDatadog(spanContext, carrier) {
        if (!this._hasPropagationStyle("inject", "datadog"))
          return;
        carrier[traceKey] = spanContext.toTraceId();
        carrier[spanKey] = spanContext.toSpanId();
        this._injectOrigin(spanContext, carrier);
        this._injectSamplingPriority(spanContext, carrier);
        this._injectTags(spanContext, carrier);
      }
      _injectOrigin(spanContext, carrier) {
        const origin = spanContext._trace.origin;
        if (origin) {
          carrier[originKey] = origin;
        }
      }
      _injectSamplingPriority(spanContext, carrier) {
        const priority = spanContext._sampling.priority;
        if (Number.isInteger(priority)) {
          carrier[samplingKey] = priority.toString();
        }
      }
      _injectBaggageItems(spanContext, carrier) {
        spanContext._baggageItems && Object.keys(spanContext._baggageItems).forEach((key) => {
          carrier[baggagePrefix + key] = String(spanContext._baggageItems[key]);
        });
      }
      _injectTags(spanContext, carrier) {
        const trace = spanContext._trace;
        if (this._config.tagsHeaderMaxLength === 0) {
          log.debug("Trace tag propagation is disabled, skipping injection.");
          return;
        }
        const tags = [];
        for (const key in trace.tags) {
          if (!trace.tags[key] || !key.startsWith("_dd.p."))
            continue;
          if (!this._validateTagKey(key) || !this._validateTagValue(trace.tags[key])) {
            log.error("Trace tags from span are invalid, skipping injection.");
            return;
          }
          tags.push(`${key}=${trace.tags[key]}`);
        }
        const header = tags.join(",");
        if (header.length > this._config.tagsHeaderMaxLength) {
          log.error("Trace tags from span are too large, skipping injection.");
        } else if (header) {
          carrier[tagsKey] = header;
        }
      }
      _injectB3MultipleHeaders(spanContext, carrier) {
        const hasB3 = this._hasPropagationStyle("inject", "b3");
        const hasB3multi = this._hasPropagationStyle("inject", "b3multi");
        if (!(hasB3 || hasB3multi))
          return;
        carrier[b3TraceKey] = spanContext._traceId.toString(16);
        carrier[b3SpanKey] = spanContext._spanId.toString(16);
        carrier[b3SampledKey] = spanContext._sampling.priority >= AUTO_KEEP ? "1" : "0";
        if (spanContext._sampling.priority > AUTO_KEEP) {
          carrier[b3FlagsKey] = "1";
        }
        if (spanContext._parentId) {
          carrier[b3ParentKey] = spanContext._parentId.toString(16);
        }
      }
      _injectB3SingleHeader(spanContext, carrier) {
        const hasB3SingleHeader = this._hasPropagationStyle("inject", "b3 single header");
        if (!hasB3SingleHeader)
          return null;
        const traceId = spanContext._traceId.toString(16);
        const spanId = spanContext._spanId.toString(16);
        const sampled = spanContext._sampling.priority >= AUTO_KEEP ? "1" : "0";
        carrier[b3HeaderKey] = `${traceId}-${spanId}-${sampled}`;
        if (spanContext._parentId) {
          carrier[b3HeaderKey] += "-" + spanContext._parentId.toString(16);
        }
      }
      _injectTraceparent(spanContext, carrier) {
        if (!this._hasPropagationStyle("inject", "tracecontext"))
          return;
        const {
          _sampling: { priority, mechanism },
          _tracestate: ts = new TraceState(),
          _trace: { origin, tags }
        } = spanContext;
        carrier[traceparentKey] = spanContext.toTraceparent();
        ts.forVendor("dd", (state) => {
          state.set("s", priority);
          if (mechanism) {
            state.set("t.dm", mechanism);
          }
          if (typeof origin === "string") {
            const originValue = origin.replace(tracestateOriginFilter, "_").replace(/[\x3d]/g, "~");
            state.set("o", originValue);
          }
          for (const key in tags) {
            if (!tags[key] || !key.startsWith("_dd.p."))
              continue;
            const tagKey = "t." + key.slice(6).replace(tracestateTagKeyFilter, "_");
            const tagValue = tags[key].toString().replace(tracestateTagValueFilter, "_").replace(/[\x3d]/g, "~");
            state.set(tagKey, tagValue);
          }
        });
        carrier.tracestate = ts.toString();
      }
      _hasPropagationStyle(mode, name) {
        return this._config.tracePropagationStyle[mode].includes(name);
      }
      _extractSpanContext(carrier) {
        for (const extractor of this._config.tracePropagationStyle.extract) {
          let spanContext = null;
          switch (extractor) {
            case "datadog":
              spanContext = this._extractDatadogContext(carrier);
              break;
            case "tracecontext":
              spanContext = this._extractTraceparentContext(carrier);
              break;
            case "b3":
            case "b3multi":
              spanContext = this._extractB3MultiContext(carrier);
              break;
            case "b3 single header":
              spanContext = this._extractB3SingleContext(carrier);
              break;
          }
          if (spanContext !== null) {
            return spanContext;
          }
        }
        return this._extractSqsdContext(carrier);
      }
      _extractDatadogContext(carrier) {
        const spanContext = this._extractGenericContext(carrier, traceKey, spanKey, 10);
        if (spanContext) {
          this._extractOrigin(carrier, spanContext);
          this._extractBaggageItems(carrier, spanContext);
          this._extractSamplingPriority(carrier, spanContext);
          this._extractTags(carrier, spanContext);
        }
        return spanContext;
      }
      _extractB3MultiContext(carrier) {
        const b3 = this._extractB3MultipleHeaders(carrier);
        if (!b3)
          return null;
        return this._extractB3Context(b3);
      }
      _extractB3SingleContext(carrier) {
        if (!b3HeaderExpr.test(carrier[b3HeaderKey]))
          return null;
        const b3 = this._extractB3SingleHeader(carrier);
        if (!b3)
          return null;
        return this._extractB3Context(b3);
      }
      _extractB3Context(b3) {
        const debug = b3[b3FlagsKey] === "1";
        const priority = this._getPriority(b3[b3SampledKey], debug);
        const spanContext = this._extractGenericContext(b3, b3TraceKey, b3SpanKey, 16);
        if (priority !== void 0) {
          if (!spanContext) {
            return new DatadogSpanContext({
              traceId: id(),
              spanId: null,
              sampling: { priority }
            });
          }
          spanContext._sampling.priority = priority;
        }
        return spanContext;
      }
      _extractSqsdContext(carrier) {
        const headerValue = carrier[sqsdHeaderHey];
        if (!headerValue) {
          return null;
        }
        let parsed;
        try {
          parsed = JSON.parse(headerValue);
        } catch (e) {
          return null;
        }
        return this._extractDatadogContext(parsed);
      }
      _extractTraceparentContext(carrier) {
        const headerValue = carrier[traceparentKey];
        if (!headerValue) {
          return null;
        }
        const matches = headerValue.trim().match(traceparentExpr);
        if (matches.length) {
          const [version, traceId, spanId, flags, tail] = matches.slice(1);
          const traceparent = { version };
          const tracestate = TraceState.fromString(carrier.tracestate);
          if (invalidSegment.test(traceId))
            return null;
          if (invalidSegment.test(spanId))
            return null;
          if (version === "ff")
            return null;
          if (tail && version === "00")
            return null;
          const spanContext = new DatadogSpanContext({
            traceId: id(traceId, 16),
            spanId: id(spanId, 16),
            sampling: { priority: parseInt(flags, 10) & 1 ? 1 : 0 },
            traceparent,
            tracestate
          });
          tracestate.forVendor("dd", (state) => {
            for (const [key, value] of state.entries()) {
              switch (key) {
                case "s": {
                  const priority = parseInt(value, 10);
                  if (!Number.isInteger(priority))
                    continue;
                  if (spanContext._sampling.priority === 1 && priority > 0 || spanContext._sampling.priority === 0 && priority < 0) {
                    spanContext._sampling.priority = priority;
                  }
                  break;
                }
                case "o":
                  spanContext._trace.origin = value;
                  break;
                case "t.dm": {
                  const mechanism = parseInt(value, 10);
                  if (Number.isInteger(mechanism)) {
                    spanContext._sampling.mechanism = mechanism;
                    spanContext._trace.tags["_dd.p.dm"] = mechanism;
                  }
                  break;
                }
                default:
                  if (!key.startsWith("t."))
                    continue;
                  spanContext._trace.tags[`_dd.p.${key.slice(2)}`] = value.replace(/[\x7e]/gm, "=");
              }
            }
          });
          this._extractBaggageItems(carrier, spanContext);
          return spanContext;
        }
        return null;
      }
      _extractGenericContext(carrier, traceKey2, spanKey2, radix) {
        if (carrier[traceKey2] && carrier[spanKey2]) {
          if (invalidSegment.test(carrier[traceKey2]))
            return null;
          return new DatadogSpanContext({
            traceId: id(carrier[traceKey2], radix),
            spanId: id(carrier[spanKey2], radix)
          });
        }
        return null;
      }
      _extractB3MultipleHeaders(carrier) {
        let empty = true;
        const b3 = {};
        if (b3TraceExpr.test(carrier[b3TraceKey]) && b3SpanExpr.test(carrier[b3SpanKey])) {
          b3[b3TraceKey] = carrier[b3TraceKey];
          b3[b3SpanKey] = carrier[b3SpanKey];
          empty = false;
        }
        if (carrier[b3SampledKey]) {
          b3[b3SampledKey] = carrier[b3SampledKey];
          empty = false;
        }
        if (carrier[b3FlagsKey]) {
          b3[b3FlagsKey] = carrier[b3FlagsKey];
          empty = false;
        }
        return empty ? null : b3;
      }
      _extractB3SingleHeader(carrier) {
        const header = carrier[b3HeaderKey];
        if (!header)
          return null;
        const parts = header.split("-");
        if (parts[0] === "d") {
          return {
            [b3SampledKey]: "1",
            [b3FlagsKey]: "1"
          };
        } else if (parts.length === 1) {
          return {
            [b3SampledKey]: parts[0]
          };
        } else {
          const b3 = {
            [b3TraceKey]: parts[0],
            [b3SpanKey]: parts[1]
          };
          if (parts[2]) {
            b3[b3SampledKey] = parts[2] !== "0" ? "1" : "0";
            if (parts[2] === "d") {
              b3[b3FlagsKey] = "1";
            }
          }
          return b3;
        }
      }
      _extractOrigin(carrier, spanContext) {
        const origin = carrier[originKey];
        if (typeof carrier[originKey] === "string") {
          spanContext._trace.origin = origin;
        }
      }
      _extractBaggageItems(carrier, spanContext) {
        Object.keys(carrier).forEach((key) => {
          const match = key.match(baggageExpr);
          if (match) {
            spanContext._baggageItems[match[1]] = carrier[key];
          }
        });
      }
      _extractSamplingPriority(carrier, spanContext) {
        const priority = parseInt(carrier[samplingKey], 10);
        if (Number.isInteger(priority)) {
          spanContext._sampling.priority = priority;
        }
      }
      _extractTags(carrier, spanContext) {
        if (!carrier[tagsKey])
          return;
        const trace = spanContext._trace;
        if (this._config.tagsHeaderMaxLength === 0) {
          log.debug("Trace tag propagation is disabled, skipping extraction.");
        } else if (carrier[tagsKey].length > this._config.tagsHeaderMaxLength) {
          log.error("Trace tags from carrier are too large, skipping extraction.");
        } else {
          const pairs = carrier[tagsKey].split(",");
          const tags = {};
          for (const pair of pairs) {
            const [key, ...rest] = pair.split("=");
            const value = rest.join("=");
            if (!this._validateTagKey(key) || !this._validateTagValue(value)) {
              log.error("Trace tags from carrier are invalid, skipping extraction.");
              return;
            }
            tags[key] = value;
          }
          Object.assign(trace.tags, tags);
        }
      }
      _validateTagKey(key) {
        return tagKeyExpr.test(key);
      }
      _validateTagValue(value) {
        return tagValueExpr.test(value);
      }
      _getPriority(sampled, debug) {
        if (debug) {
          return USER_KEEP;
        } else if (sampled === "1") {
          return AUTO_KEEP;
        } else if (sampled === "0") {
          return AUTO_REJECT;
        }
      }
    };
    __name(TextMapPropagator, "TextMapPropagator");
    module2.exports = TextMapPropagator;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/http.js
var require_http = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/http.js"(exports2, module2) {
    "use strict";
    var TextMapPropagator = require_text_map();
    var HttpPropagator = class extends TextMapPropagator {
    };
    __name(HttpPropagator, "HttpPropagator");
    module2.exports = HttpPropagator;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/binary.js
var require_binary = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/binary.js"(exports2, module2) {
    "use strict";
    var BinaryPropagator = class {
      inject(spanContext, carrier) {
      }
      extract(carrier) {
        return null;
      }
    };
    __name(BinaryPropagator, "BinaryPropagator");
    module2.exports = BinaryPropagator;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/log.js
var require_log2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/opentracing/propagation/log.js"(exports2, module2) {
    "use strict";
    var id = require_id();
    var DatadogSpanContext = require_span_context();
    var LogPropagator = class {
      constructor(config) {
        this._config = config;
      }
      inject(spanContext, carrier) {
        if (!carrier)
          return;
        carrier.dd = {};
        if (spanContext) {
          carrier.dd.trace_id = spanContext.toTraceId();
          carrier.dd.span_id = spanContext.toSpanId();
        }
        if (this._config.service)
          carrier.dd.service = this._config.service;
        if (this._config.version)
          carrier.dd.version = this._config.version;
        if (this._config.env)
          carrier.dd.env = this._config.env;
      }
      extract(carrier) {
        if (!carrier || !carrier.dd || !carrier.dd.trace_id || !carrier.dd.span_id) {
          return null;
        }
        const spanContext = new DatadogSpanContext({
          traceId: id(carrier.dd.trace_id, 10),
          spanId: id(carrier.dd.span_id, 10)
        });
        return spanContext;
      }
    };
    __name(LogPropagator, "LogPropagator");
    module2.exports = LogPropagator;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js
var require__2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/encode/0.5.js"(exports2, module2) {
    "use strict";
    var { truncateSpan, normalizeSpan } = require_tags_processors();
    var { AgentEncoder: BaseEncoder } = require__();
    var ARRAY_OF_TWO = 146;
    var ARRAY_OF_TWELVE = 156;
    function formatSpan(span) {
      return normalizeSpan(truncateSpan(span, false));
    }
    __name(formatSpan, "formatSpan");
    var AgentEncoder = class extends BaseEncoder {
      makePayload() {
        const prefixSize = 1;
        const stringSize = this._stringBytes.length + 5;
        const traceSize = this._traceBytes.length + 5;
        const buffer = Buffer.allocUnsafe(prefixSize + stringSize + traceSize);
        let offset = 0;
        buffer[offset++] = ARRAY_OF_TWO;
        offset = this._writeStrings(buffer, offset);
        offset = this._writeTraces(buffer, offset);
        this._reset();
        return buffer;
      }
      _encode(bytes, trace) {
        this._encodeArrayPrefix(bytes, trace);
        for (let span of trace) {
          span = formatSpan(span);
          this._encodeByte(bytes, ARRAY_OF_TWELVE);
          this._encodeString(bytes, span.service);
          this._encodeString(bytes, span.name);
          this._encodeString(bytes, span.resource);
          this._encodeId(bytes, span.trace_id);
          this._encodeId(bytes, span.span_id);
          this._encodeId(bytes, span.parent_id);
          this._encodeLong(bytes, span.start || 0);
          this._encodeLong(bytes, span.duration || 0);
          this._encodeInteger(bytes, span.error);
          this._encodeMap(bytes, span.meta || {});
          this._encodeMap(bytes, span.metrics || {});
          this._encodeString(bytes, span.type);
        }
      }
      _encodeString(bytes, value = "") {
        this._cacheString(value);
        this._encodeInteger(bytes, this._stringMap[value]);
      }
      _cacheString(value) {
        if (!(value in this._stringMap)) {
          this._stringMap[value] = this._stringCount++;
          this._stringBytes.write(value);
        }
      }
      _writeStrings(buffer, offset) {
        offset = this._writeArrayPrefix(buffer, offset, this._stringCount);
        offset += this._stringBytes.buffer.copy(buffer, offset, 0, this._stringBytes.length);
        return offset;
      }
    };
    __name(AgentEncoder, "AgentEncoder");
    module2.exports = { AgentEncoder };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js
var require_writer5 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporters/agent/writer.js"(exports2, module2) {
    "use strict";
    var request = require_request();
    var { startupLog } = require_startup_log();
    var metrics = require_metrics();
    var log = require_log();
    var tracerVersion = require_package().version;
    var BaseWriter = require_writer3();
    var METRIC_PREFIX = "datadog.tracer.node.exporter.agent";
    var Writer = class extends BaseWriter {
      constructor({ prioritySampler, lookup, protocolVersion, headers }) {
        super(...arguments);
        const AgentEncoder = getEncoder(protocolVersion);
        this._prioritySampler = prioritySampler;
        this._lookup = lookup;
        this._protocolVersion = protocolVersion;
        this._encoder = new AgentEncoder(this);
        this._headers = headers;
      }
      _sendPayload(data, count, done) {
        metrics.increment(`${METRIC_PREFIX}.requests`, true);
        const { _headers, _lookup, _protocolVersion, _url } = this;
        makeRequest(_protocolVersion, data, count, _url, _headers, _lookup, true, (err, res, status) => {
          if (status) {
            metrics.increment(`${METRIC_PREFIX}.responses`, true);
            metrics.increment(`${METRIC_PREFIX}.responses.by.status`, `status:${status}`, true);
          } else if (err) {
            metrics.increment(`${METRIC_PREFIX}.errors`, true);
            metrics.increment(`${METRIC_PREFIX}.errors.by.name`, `name:${err.name}`, true);
            if (err.code) {
              metrics.increment(`${METRIC_PREFIX}.errors.by.code`, `code:${err.code}`, true);
            }
          }
          startupLog({ agentError: err });
          if (err) {
            log.error(err);
            done();
            return;
          }
          log.debug(`Response from the agent: ${res}`);
          try {
            this._prioritySampler.update(JSON.parse(res).rate_by_service);
          } catch (e) {
            log.error(e);
            metrics.increment(`${METRIC_PREFIX}.errors`, true);
            metrics.increment(`${METRIC_PREFIX}.errors.by.name`, `name:${e.name}`, true);
          }
          done();
        });
      }
    };
    __name(Writer, "Writer");
    function setHeader(headers, key, value) {
      if (value) {
        headers[key] = value;
      }
    }
    __name(setHeader, "setHeader");
    function getEncoder(protocolVersion) {
      if (protocolVersion === "0.5") {
        return require__2().AgentEncoder;
      } else {
        return require__().AgentEncoder;
      }
    }
    __name(getEncoder, "getEncoder");
    function makeRequest(version, data, count, url, headers, lookup, needsStartupLog, cb) {
      const options = {
        path: `/v${version}/traces`,
        method: "PUT",
        headers: {
          ...headers,
          "Content-Type": "application/msgpack",
          "Datadog-Meta-Tracer-Version": tracerVersion,
          "X-Datadog-Trace-Count": String(count)
        },
        lookup,
        url
      };
      setHeader(options.headers, "Datadog-Meta-Lang", "nodejs");
      setHeader(options.headers, "Datadog-Meta-Lang-Version", process.version);
      setHeader(options.headers, "Datadog-Meta-Lang-Interpreter", process.jsEngine || "v8");
      log.debug(() => `Request to the agent: ${JSON.stringify(options)}`);
      request(data, options, (err, res, status) => {
        if (needsStartupLog) {
          startupLog({
            agentError: status !== 404 && status !== 200 ? err : void 0
          });
        }
        cb(err, res, status);
      });
    }
    __name(makeRequest, "makeRequest");
    module2.exports = Writer;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js
var require_agent = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporters/agent/index.js"(exports2, module2) {
    "use strict";
    var { URL: URL2, format } = __require("url");
    var log = require_log();
    var Writer = require_writer5();
    var AgentExporter = class {
      constructor(config, prioritySampler) {
        this._config = config;
        const { url, hostname, port, lookup, protocolVersion, stats = {} } = config;
        this._url = url || new URL2(format({
          protocol: "http:",
          hostname: hostname || "localhost",
          port
        }));
        const headers = {};
        if (stats.enabled) {
          headers["Datadog-Client-Computed-Stats"] = "yes";
        }
        this._writer = new Writer({
          url: this._url,
          prioritySampler,
          lookup,
          protocolVersion,
          headers
        });
        this._timer = void 0;
        process.once("beforeExit", () => this._writer.flush());
      }
      setUrl(url) {
        try {
          url = new URL2(url);
          this._url = url;
          this._writer.setUrl(url);
        } catch (e) {
          log.warn(e.stack);
        }
      }
      export(spans) {
        this._writer.append(spans);
        const { flushInterval } = this._config;
        if (flushInterval === 0) {
          this._writer.flush();
        } else if (flushInterval > 0 && !this._timer) {
          this._timer = setTimeout(() => {
            this._writer.flush();
            this._timer = clearTimeout(this._timer);
          }, flushInterval).unref();
        }
      }
      flush(done = () => {
      }) {
        this._writer.flush(done);
      }
    };
    __name(AgentExporter, "AgentExporter");
    module2.exports = AgentExporter;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporters/log/index.js
var require_log3 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporters/log/index.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var TRACE_PREFIX = '{"traces":[[';
    var TRACE_SUFFIX = "]]}\n";
    var TRACE_FORMAT_OVERHEAD = TRACE_PREFIX.length + TRACE_SUFFIX.length;
    var MAX_SIZE = 64 * 1024;
    var LogExporter = class {
      export(spans) {
        log.debug(() => `Adding trace to queue: ${JSON.stringify(spans)}`);
        let size = TRACE_FORMAT_OVERHEAD;
        let queue = [];
        for (const span of spans) {
          const spanStr = JSON.stringify(span);
          if (spanStr.length + TRACE_FORMAT_OVERHEAD > MAX_SIZE) {
            log.debug("Span too large to send to logs, dropping");
            continue;
          }
          if (spanStr.length + size > MAX_SIZE) {
            this._printSpans(queue);
            queue = [];
            size = TRACE_FORMAT_OVERHEAD;
          }
          size += spanStr.length + 1;
          queue.push(spanStr);
        }
        if (queue.length > 0) {
          this._printSpans(queue);
        }
      }
      _printSpans(queue) {
        let logLine = TRACE_PREFIX;
        let firstTrace = true;
        for (const spanStr of queue) {
          if (firstTrace) {
            firstTrace = false;
            logLine += spanStr;
          } else {
            logLine += "," + spanStr;
          }
        }
        logLine += TRACE_SUFFIX;
        process.stdout.write(logLine);
      }
    };
    __name(LogExporter, "LogExporter");
    module2.exports = LogExporter;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/encode/agentless-ci-visibility.js
var require_agentless_ci_visibility = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/encode/agentless-ci-visibility.js"(exports2, module2) {
    "use strict";
    var { truncateSpan, normalizeSpan } = require_tags_processors();
    var { AgentEncoder } = require__();
    var { version: ddTraceVersion } = require_package();
    var id = require_id();
    var ENCODING_VERSION = 1;
    var ALLOWED_CONTENT_TYPES = ["test_session_end", "test_module_end", "test_suite_end", "test"];
    var TEST_SUITE_KEYS_LENGTH = 12;
    var TEST_MODULE_KEYS_LENGTH = 11;
    var TEST_SESSION_KEYS_LENGTH = 10;
    var INTAKE_SOFT_LIMIT = 2 * 1024 * 1024;
    function formatSpan(span) {
      let encodingVersion = ENCODING_VERSION;
      if (span.type === "test" && span.meta && span.meta.test_session_id) {
        encodingVersion = 2;
      }
      return {
        type: ALLOWED_CONTENT_TYPES.includes(span.type) ? span.type : "span",
        version: encodingVersion,
        content: normalizeSpan(truncateSpan(span))
      };
    }
    __name(formatSpan, "formatSpan");
    var AgentlessCiVisibilityEncoder = class extends AgentEncoder {
      constructor(writer, { runtimeId, service, env }) {
        super(writer, INTAKE_SOFT_LIMIT);
        this.runtimeId = runtimeId;
        this.service = service;
        this.env = env;
        this._eventCount = 0;
        this.reset();
      }
      _encodeTestSuite(bytes, content) {
        this._encodeMapPrefix(bytes, TEST_SUITE_KEYS_LENGTH);
        this._encodeString(bytes, "type");
        this._encodeString(bytes, content.type);
        this._encodeString(bytes, "test_session_id");
        this._encodeId(bytes, content.trace_id);
        this._encodeString(bytes, "test_module_id");
        this._encodeId(bytes, content.parent_id);
        this._encodeString(bytes, "test_suite_id");
        this._encodeId(bytes, content.span_id);
        this._encodeString(bytes, "error");
        this._encodeNumber(bytes, content.error);
        this._encodeString(bytes, "name");
        this._encodeString(bytes, content.name);
        this._encodeString(bytes, "service");
        this._encodeString(bytes, content.service);
        this._encodeString(bytes, "resource");
        this._encodeString(bytes, content.resource);
        this._encodeString(bytes, "start");
        this._encodeNumber(bytes, content.start);
        this._encodeString(bytes, "duration");
        this._encodeNumber(bytes, content.duration);
        this._encodeString(bytes, "meta");
        this._encodeMap(bytes, content.meta);
        this._encodeString(bytes, "metrics");
        this._encodeMap(bytes, content.metrics);
      }
      _encodeTestModule(bytes, content) {
        this._encodeMapPrefix(bytes, TEST_MODULE_KEYS_LENGTH);
        this._encodeString(bytes, "type");
        this._encodeString(bytes, content.type);
        this._encodeString(bytes, "test_session_id");
        this._encodeId(bytes, content.trace_id);
        this._encodeString(bytes, "test_module_id");
        this._encodeId(bytes, content.span_id);
        this._encodeString(bytes, "error");
        this._encodeNumber(bytes, content.error);
        this._encodeString(bytes, "name");
        this._encodeString(bytes, content.name);
        this._encodeString(bytes, "service");
        this._encodeString(bytes, content.service);
        this._encodeString(bytes, "resource");
        this._encodeString(bytes, content.resource);
        this._encodeString(bytes, "start");
        this._encodeNumber(bytes, content.start);
        this._encodeString(bytes, "duration");
        this._encodeNumber(bytes, content.duration);
        this._encodeString(bytes, "meta");
        this._encodeMap(bytes, content.meta);
        this._encodeString(bytes, "metrics");
        this._encodeMap(bytes, content.metrics);
      }
      _encodeTestSession(bytes, content) {
        this._encodeMapPrefix(bytes, TEST_SESSION_KEYS_LENGTH);
        this._encodeString(bytes, "type");
        this._encodeString(bytes, content.type);
        this._encodeString(bytes, "test_session_id");
        this._encodeId(bytes, content.trace_id);
        this._encodeString(bytes, "error");
        this._encodeNumber(bytes, content.error);
        this._encodeString(bytes, "name");
        this._encodeString(bytes, content.name);
        this._encodeString(bytes, "service");
        this._encodeString(bytes, content.service);
        this._encodeString(bytes, "resource");
        this._encodeString(bytes, content.resource);
        this._encodeString(bytes, "start");
        this._encodeNumber(bytes, content.start);
        this._encodeString(bytes, "duration");
        this._encodeNumber(bytes, content.duration);
        this._encodeString(bytes, "meta");
        this._encodeMap(bytes, content.meta);
        this._encodeString(bytes, "metrics");
        this._encodeMap(bytes, content.metrics);
      }
      _encodeEventContent(bytes, content) {
        const keysLength = Object.keys(content).length;
        if (content.meta.test_session_id) {
          this._encodeMapPrefix(bytes, keysLength + 3);
        } else {
          this._encodeMapPrefix(bytes, keysLength);
        }
        if (content.type) {
          this._encodeString(bytes, "type");
          this._encodeString(bytes, content.type);
        }
        this._encodeString(bytes, "trace_id");
        this._encodeId(bytes, content.trace_id);
        this._encodeString(bytes, "span_id");
        this._encodeId(bytes, content.span_id);
        this._encodeString(bytes, "parent_id");
        this._encodeId(bytes, content.parent_id);
        this._encodeString(bytes, "name");
        this._encodeString(bytes, content.name);
        this._encodeString(bytes, "resource");
        this._encodeString(bytes, content.resource);
        this._encodeString(bytes, "service");
        this._encodeString(bytes, content.service);
        this._encodeString(bytes, "error");
        this._encodeNumber(bytes, content.error);
        this._encodeString(bytes, "start");
        this._encodeNumber(bytes, content.start);
        this._encodeString(bytes, "duration");
        this._encodeNumber(bytes, content.duration);
        if (content.meta.test_session_id) {
          this._encodeString(bytes, "test_session_id");
          this._encodeId(bytes, id(content.meta.test_session_id, 10));
          delete content.meta.test_session_id;
          this._encodeString(bytes, "test_module_id");
          this._encodeId(bytes, id(content.meta.test_module_id, 10));
          delete content.meta.test_module_id;
          this._encodeString(bytes, "test_suite_id");
          this._encodeId(bytes, id(content.meta.test_suite_id, 10));
          delete content.meta.test_suite_id;
        }
        this._encodeString(bytes, "meta");
        this._encodeMap(bytes, content.meta);
        this._encodeString(bytes, "metrics");
        this._encodeMap(bytes, content.metrics);
      }
      _encodeEvent(bytes, event) {
        this._encodeMapPrefix(bytes, Object.keys(event).length);
        this._encodeString(bytes, "type");
        this._encodeString(bytes, event.type);
        this._encodeString(bytes, "version");
        this._encodeNumber(bytes, event.version);
        this._encodeString(bytes, "content");
        if (event.type === "span" || event.type === "test") {
          this._encodeEventContent(bytes, event.content);
        } else if (event.type === "test_suite_end") {
          this._encodeTestSuite(bytes, event.content);
        } else if (event.type === "test_module_end") {
          this._encodeTestModule(bytes, event.content);
        } else if (event.type === "test_session_end") {
          this._encodeTestSession(bytes, event.content);
        }
      }
      _encodeNumber(bytes, value) {
        if (Math.floor(value) !== value) {
          return this._encodeFloat(bytes, value);
        }
        return this._encodeLong(bytes, value);
      }
      _encodeLong(bytes, value) {
        const isPositive = value >= 0;
        const hi = isPositive ? value / Math.pow(2, 32) >> 0 : Math.floor(value / Math.pow(2, 32));
        const lo = value >>> 0;
        const flag = isPositive ? 207 : 211;
        const offset = bytes.length;
        bytes.reserve(9);
        bytes.length += 9;
        bytes.buffer[offset] = flag;
        bytes.buffer[offset + 1] = hi >> 24;
        bytes.buffer[offset + 2] = hi >> 16;
        bytes.buffer[offset + 3] = hi >> 8;
        bytes.buffer[offset + 4] = hi;
        bytes.buffer[offset + 5] = lo >> 24;
        bytes.buffer[offset + 6] = lo >> 16;
        bytes.buffer[offset + 7] = lo >> 8;
        bytes.buffer[offset + 8] = lo;
      }
      _encode(bytes, trace) {
        const rawEvents = trace.map(formatSpan);
        const testSessionEvents = rawEvents.filter(
          (event) => event.type === "test_session_end" || event.type === "test_suite_end" || event.type === "test_module_end"
        );
        const isTestSessionTrace = !!testSessionEvents.length;
        const events = isTestSessionTrace ? testSessionEvents : rawEvents;
        this._eventCount += events.length;
        for (const event of events) {
          this._encodeEvent(bytes, event);
        }
      }
      makePayload() {
        const bytes = this._traceBytes;
        const eventsOffset = this._eventsOffset;
        const eventsCount = this._eventCount;
        bytes.buffer[eventsOffset] = 221;
        bytes.buffer[eventsOffset + 1] = eventsCount >> 24;
        bytes.buffer[eventsOffset + 2] = eventsCount >> 16;
        bytes.buffer[eventsOffset + 3] = eventsCount >> 8;
        bytes.buffer[eventsOffset + 4] = eventsCount;
        const traceSize = bytes.length;
        const buffer = Buffer.allocUnsafe(traceSize);
        bytes.buffer.copy(buffer, 0, 0, traceSize);
        this.reset();
        return buffer;
      }
      _encodePayloadStart(bytes) {
        const payload2 = {
          version: ENCODING_VERSION,
          metadata: {
            "*": {
              "language": "javascript",
              "library_version": ddTraceVersion
            }
          },
          events: []
        };
        if (this.env) {
          payload2.metadata["*"].env = this.env;
        }
        if (this.runtimeId) {
          payload2.metadata["*"]["runtime-id"] = this.runtimeId;
        }
        this._encodeMapPrefix(bytes, Object.keys(payload2).length);
        this._encodeString(bytes, "version");
        this._encodeNumber(bytes, payload2.version);
        this._encodeString(bytes, "metadata");
        this._encodeMapPrefix(bytes, Object.keys(payload2.metadata).length);
        this._encodeString(bytes, "*");
        this._encodeMap(bytes, payload2.metadata["*"]);
        this._encodeString(bytes, "events");
        this._eventsOffset = bytes.length;
        bytes.reserve(5);
        bytes.length += 5;
      }
      reset() {
        this._reset();
        this._eventCount = 0;
        this._encodePayloadStart(this._traceBytes);
      }
    };
    __name(AgentlessCiVisibilityEncoder, "AgentlessCiVisibilityEncoder");
    module2.exports = { AgentlessCiVisibilityEncoder };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js
var require_writer6 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js"(exports2, module2) {
    "use strict";
    var request = require_request();
    var log = require_log();
    var { AgentlessCiVisibilityEncoder } = require_agentless_ci_visibility();
    var BaseWriter = require_writer3();
    function safeJSONStringify(value) {
      return JSON.stringify(
        value,
        (key, value2) => key !== "dd-api-key" ? value2 : void 0
      );
    }
    __name(safeJSONStringify, "safeJSONStringify");
    var Writer = class extends BaseWriter {
      constructor({ url, tags, evpProxyPrefix = "" }) {
        super(...arguments);
        const { "runtime-id": runtimeId, env, service } = tags;
        this._url = url;
        this._encoder = new AgentlessCiVisibilityEncoder(this, { runtimeId, env, service });
        this._evpProxyPrefix = evpProxyPrefix;
      }
      _sendPayload(data, _, done) {
        const options = {
          path: "/api/v2/citestcycle",
          method: "POST",
          headers: {
            "dd-api-key": process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
            "Content-Type": "application/msgpack"
          },
          timeout: 15e3,
          url: this._url
        };
        if (this._evpProxyPrefix) {
          options.path = `${this._evpProxyPrefix}/api/v2/citestcycle`;
          delete options.headers["dd-api-key"];
          options.headers["X-Datadog-EVP-Subdomain"] = "citestcycle-intake";
        }
        log.debug(() => `Request to the intake: ${safeJSONStringify(options)}`);
        request(data, options, (err, res) => {
          if (err) {
            log.error(err);
            done();
            return;
          }
          log.debug(`Response from the intake: ${res}`);
          done();
        });
      }
    };
    __name(Writer, "Writer");
    module2.exports = Writer;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/form-data.js
var require_form_data = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporters/common/form-data.js"(exports2, module2) {
    "use strict";
    var { Readable } = __require("stream");
    var id = require_id();
    var FormData = class extends Readable {
      constructor() {
        super();
        this._boundary = id().toString();
        this._data = [];
      }
      append(key, value, options = {}) {
        this._appendBoundary();
        if (options.filename) {
          this._appendFile(key, value, options);
        } else {
          this._appendMetadata(key, value, options);
        }
      }
      getHeaders() {
        return { "Content-Type": "multipart/form-data; boundary=" + this._boundary };
      }
      _appendBoundary() {
        this._data.push(`--${this._boundary}\r
`);
      }
      _appendMetadata(key, value) {
        this._data.push(`Content-Disposition: form-data; name="${key}"\r
\r
${value}\r
`);
      }
      _appendFile(key, value, { filename, contentType = "application/octet-stream" }) {
        this._data.push(`Content-Disposition: form-data; name="${key}"; filename="${filename}"\r
`);
        this._data.push(`Content-Type: ${contentType}\r
\r
`);
        this._data.push(value);
        this._data.push("\r\n");
      }
      _read() {
        this.push(this._data.shift());
        if (this._data.length === 0) {
          this.push(`--${this._boundary}--\r
`);
          this.push(null);
        }
      }
    };
    __name(FormData, "FormData");
    module2.exports = FormData;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/encode/coverage-ci-visibility.js
var require_coverage_ci_visibility = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/encode/coverage-ci-visibility.js"(exports2, module2) {
    "use strict";
    var { AgentEncoder } = require__();
    var Chunk = require_chunk();
    var FormData = require_form_data();
    var COVERAGE_PAYLOAD_VERSION = 2;
    var COVERAGE_KEYS_LENGTH = 2;
    var CoverageCIVisibilityEncoder = class extends AgentEncoder {
      constructor() {
        super(...arguments);
        this._coverageBytes = new Chunk();
        this.form = new FormData();
        this._coveragesCount = 0;
        this.reset();
      }
      count() {
        return this._coveragesCount;
      }
      encode(coverage) {
        this._coveragesCount++;
        this.encodeCodeCoverage(this._coverageBytes, coverage);
      }
      encodeCodeCoverage(bytes, coverage) {
        this._encodeMapPrefix(bytes, 3);
        this._encodeString(bytes, "test_session_id");
        this._encodeId(bytes, coverage.traceId);
        this._encodeString(bytes, "test_suite_id");
        this._encodeId(bytes, coverage.spanId);
        this._encodeString(bytes, "files");
        this._encodeArrayPrefix(bytes, coverage.files);
        for (const filename of coverage.files) {
          this._encodeMapPrefix(bytes, 1);
          this._encodeString(bytes, "filename");
          this._encodeString(bytes, filename);
        }
      }
      reset() {
        this._reset();
        if (this._coverageBytes) {
          this._coverageBytes.length = 0;
        }
        this._coveragesCount = 0;
        this._encodePayloadStart(this._coverageBytes);
      }
      _encodePayloadStart(bytes) {
        const payload2 = {
          version: COVERAGE_PAYLOAD_VERSION,
          coverages: []
        };
        this._encodeMapPrefix(bytes, COVERAGE_KEYS_LENGTH);
        this._encodeString(bytes, "version");
        this._encodeInteger(bytes, payload2.version);
        this._encodeString(bytes, "coverages");
        this._coveragesOffset = bytes.length;
        bytes.reserve(5);
        bytes.length += 5;
      }
      makePayload() {
        const bytes = this._coverageBytes;
        const coveragesOffset = this._coveragesOffset;
        const coveragesCount = this._coveragesCount;
        bytes.buffer[coveragesOffset] = 221;
        bytes.buffer[coveragesOffset + 1] = coveragesCount >> 24;
        bytes.buffer[coveragesOffset + 2] = coveragesCount >> 16;
        bytes.buffer[coveragesOffset + 3] = coveragesCount >> 8;
        bytes.buffer[coveragesOffset + 4] = coveragesCount;
        const traceSize = bytes.length;
        const buffer = Buffer.allocUnsafe(traceSize);
        bytes.buffer.copy(buffer, 0, 0, bytes.length);
        this.form.append(
          "coverage1",
          buffer,
          {
            filename: `coverage1.msgpack`,
            contentType: "application/msgpack"
          }
        );
        this.form.append(
          "event",
          JSON.stringify({ dummy: true }),
          { filename: "event.json", contentType: "application/json" }
        );
        const form = this.form;
        this.form = new FormData();
        this.reset();
        return form;
      }
    };
    __name(CoverageCIVisibilityEncoder, "CoverageCIVisibilityEncoder");
    module2.exports = { CoverageCIVisibilityEncoder };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/coverage-writer.js
var require_coverage_writer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/coverage-writer.js"(exports2, module2) {
    "use strict";
    var request = require_request();
    var log = require_log();
    var { CoverageCIVisibilityEncoder } = require_coverage_ci_visibility();
    var BaseWriter = require_writer3();
    function safeJSONStringify(value) {
      return JSON.stringify(
        value,
        (key, value2) => key !== "dd-api-key" ? value2 : void 0
      );
    }
    __name(safeJSONStringify, "safeJSONStringify");
    var Writer = class extends BaseWriter {
      constructor({ url, evpProxyPrefix = "" }) {
        super(...arguments);
        this._url = url;
        this._encoder = new CoverageCIVisibilityEncoder(this);
        this._evpProxyPrefix = evpProxyPrefix;
      }
      _sendPayload(form, _, done) {
        const options = {
          path: "/api/v2/citestcov",
          method: "POST",
          headers: {
            "dd-api-key": process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
            ...form.getHeaders()
          },
          timeout: 15e3,
          url: this._url
        };
        if (this._evpProxyPrefix) {
          options.path = `${this._evpProxyPrefix}/api/v2/citestcov`;
          delete options.headers["dd-api-key"];
          options.headers["X-Datadog-EVP-Subdomain"] = "event-platform-intake";
        }
        log.debug(() => `Request to the intake: ${safeJSONStringify(options)}`);
        request(form, options, (err, res) => {
          if (err) {
            log.error(err);
            done();
            return;
          }
          log.debug(`Response from the intake: ${res}`);
          done();
        });
      }
    };
    __name(Writer, "Writer");
    module2.exports = Writer;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/exec.js
var require_exec = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/exec.js"(exports2, module2) {
    var { execSync } = __require("child_process");
    var sanitizedExec = /* @__PURE__ */ __name((cmd, options = {}) => {
      try {
        return execSync(cmd, options).toString().replace(/(\r\n|\n|\r)/gm, "");
      } catch (e) {
        return "";
      }
    }, "sanitizedExec");
    module2.exports = { sanitizedExec };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js
var require_tags2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/tags.js"(exports2, module2) {
    var GIT_COMMIT_SHA = "git.commit.sha";
    var GIT_BRANCH = "git.branch";
    var GIT_REPOSITORY_URL = "git.repository_url";
    var GIT_TAG = "git.tag";
    var GIT_COMMIT_MESSAGE = "git.commit.message";
    var GIT_COMMIT_COMMITTER_DATE = "git.commit.committer.date";
    var GIT_COMMIT_COMMITTER_EMAIL = "git.commit.committer.email";
    var GIT_COMMIT_COMMITTER_NAME = "git.commit.committer.name";
    var GIT_COMMIT_AUTHOR_DATE = "git.commit.author.date";
    var GIT_COMMIT_AUTHOR_EMAIL = "git.commit.author.email";
    var GIT_COMMIT_AUTHOR_NAME = "git.commit.author.name";
    var CI_PIPELINE_ID = "ci.pipeline.id";
    var CI_PIPELINE_NAME = "ci.pipeline.name";
    var CI_PIPELINE_NUMBER = "ci.pipeline.number";
    var CI_PIPELINE_URL = "ci.pipeline.url";
    var CI_PROVIDER_NAME = "ci.provider.name";
    var CI_WORKSPACE_PATH = "ci.workspace_path";
    var CI_JOB_URL = "ci.job.url";
    var CI_JOB_NAME = "ci.job.name";
    var CI_STAGE_NAME = "ci.stage.name";
    var CI_ENV_VARS = "_dd.ci.env_vars";
    module2.exports = {
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_COMMITTER_DATE,
      GIT_COMMIT_COMMITTER_EMAIL,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      CI_PIPELINE_ID,
      CI_PIPELINE_NAME,
      CI_PIPELINE_NUMBER,
      CI_PIPELINE_URL,
      CI_PROVIDER_NAME,
      CI_WORKSPACE_PATH,
      CI_JOB_URL,
      CI_JOB_NAME,
      CI_STAGE_NAME,
      CI_ENV_VARS
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/git.js
var require_git = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/git.js"(exports2, module2) {
    var { execSync } = __require("child_process");
    var os = __require("os");
    var path = __require("path");
    var log = require_log();
    var { sanitizedExec } = require_exec();
    var {
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_COMMITTER_DATE,
      GIT_COMMIT_COMMITTER_EMAIL,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      CI_WORKSPACE_PATH
    } = require_tags2();
    var GIT_REV_LIST_MAX_BUFFER = 8 * 1024 * 1024;
    function getRepositoryUrl() {
      return sanitizedExec("git config --get remote.origin.url", { stdio: "pipe" });
    }
    __name(getRepositoryUrl, "getRepositoryUrl");
    function getLatestCommits() {
      try {
        return execSync('git log --format=%H -n 1000 --since="1 month ago"', { stdio: "pipe" }).toString().split("\n").filter((commit) => commit);
      } catch (err) {
        log.error(err);
        return [];
      }
    }
    __name(getLatestCommits, "getLatestCommits");
    function getCommitsToUpload(commitsToExclude) {
      let gitCommandToGetCommitsToUpload = 'git rev-list --objects --no-object-names --filter=blob:none --since="1 month ago" HEAD';
      commitsToExclude.forEach((commit) => {
        gitCommandToGetCommitsToUpload = `${gitCommandToGetCommitsToUpload} ^${commit}`;
      });
      try {
        return execSync(gitCommandToGetCommitsToUpload, { stdio: "pipe", maxBuffer: GIT_REV_LIST_MAX_BUFFER }).toString().split("\n").filter((commit) => commit);
      } catch (err) {
        log.error(err);
        return [];
      }
    }
    __name(getCommitsToUpload, "getCommitsToUpload");
    function generatePackFilesForCommits(commitsToUpload) {
      const tmpFolder = os.tmpdir();
      const randomPrefix = String(Math.floor(Math.random() * 1e4));
      const temporaryPath = path.join(tmpFolder, randomPrefix);
      const cwdPath = path.join(process.cwd(), randomPrefix);
      function execGitPackObjects(targetPath) {
        return execSync(
          `git pack-objects --compression=9 --max-pack-size=3m ${targetPath}`,
          { input: commitsToUpload.join("\n") }
        ).toString().split("\n").filter((commit) => commit).map((commit) => `${targetPath}-${commit}.pack`);
      }
      __name(execGitPackObjects, "execGitPackObjects");
      try {
        return execGitPackObjects(temporaryPath, commitsToUpload);
      } catch (err) {
        log.error(err);
        try {
          return execGitPackObjects(cwdPath, commitsToUpload);
        } catch (err2) {
          log.error(err2);
        }
        return [];
      }
    }
    __name(generatePackFilesForCommits, "generatePackFilesForCommits");
    function getGitMetadata(ciMetadata) {
      const {
        commitSHA,
        branch,
        repositoryUrl,
        tag,
        commitMessage,
        authorName: ciAuthorName,
        authorEmail: ciAuthorEmail,
        ciWorkspacePath
      } = ciMetadata;
      const [
        authorName,
        authorEmail,
        authorDate,
        committerName,
        committerEmail,
        committerDate
      ] = sanitizedExec("git show -s --format=%an,%ae,%aI,%cn,%ce,%cI", { stdio: "pipe" }).split(",");
      return {
        [GIT_REPOSITORY_URL]: repositoryUrl || sanitizedExec("git ls-remote --get-url", { stdio: "pipe" }),
        [GIT_COMMIT_MESSAGE]: commitMessage || sanitizedExec("git show -s --format=%s", { stdio: "pipe" }),
        [GIT_COMMIT_AUTHOR_DATE]: authorDate,
        [GIT_COMMIT_AUTHOR_NAME]: ciAuthorName || authorName,
        [GIT_COMMIT_AUTHOR_EMAIL]: ciAuthorEmail || authorEmail,
        [GIT_COMMIT_COMMITTER_DATE]: committerDate,
        [GIT_COMMIT_COMMITTER_NAME]: committerName,
        [GIT_COMMIT_COMMITTER_EMAIL]: committerEmail,
        [GIT_BRANCH]: branch || sanitizedExec("git rev-parse --abbrev-ref HEAD", { stdio: "pipe" }),
        [GIT_COMMIT_SHA]: commitSHA || sanitizedExec("git rev-parse HEAD", { stdio: "pipe" }),
        [GIT_TAG]: tag,
        [CI_WORKSPACE_PATH]: ciWorkspacePath || sanitizedExec("git rev-parse --show-toplevel", { stdio: "pipe" })
      };
    }
    __name(getGitMetadata, "getGitMetadata");
    module2.exports = {
      getGitMetadata,
      getLatestCommits,
      getRepositoryUrl,
      generatePackFilesForCommits,
      getCommitsToUpload,
      GIT_REV_LIST_MAX_BUFFER
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/git/git_metadata.js
var require_git_metadata = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/git/git_metadata.js"(exports2, module2) {
    var fs = __require("fs");
    var path = __require("path");
    var FormData = require_form_data();
    var request = require_request();
    var log = require_log();
    var {
      getLatestCommits,
      getRepositoryUrl,
      generatePackFilesForCommits,
      getCommitsToUpload
    } = require_git();
    var isValidSha = /* @__PURE__ */ __name((sha) => /[0-9a-f]{40}/.test(sha), "isValidSha");
    function sanitizeCommits(commits) {
      return commits.map(({ id: commitSha, type }) => {
        if (type !== "commit") {
          throw new Error("Invalid commit type response");
        }
        const sanitizedCommit = commitSha.replace(/[^0-9a-f]+/g, "");
        if (sanitizedCommit !== commitSha || !isValidSha(sanitizedCommit)) {
          throw new Error("Invalid commit format");
        }
        return sanitizedCommit;
      });
    }
    __name(sanitizeCommits, "sanitizeCommits");
    function getCommonRequestOptions(url) {
      return {
        method: "POST",
        headers: {
          "dd-api-key": process.env.DATADOG_API_KEY || process.env.DD_API_KEY
        },
        timeout: 15e3,
        url
      };
    }
    __name(getCommonRequestOptions, "getCommonRequestOptions");
    function getCommitsToExclude({ url, isEvpProxy, repositoryUrl }, callback) {
      const latestCommits = getLatestCommits();
      const [headCommit] = latestCommits;
      const commonOptions = getCommonRequestOptions(url);
      const options = {
        ...commonOptions,
        headers: {
          ...commonOptions.headers,
          "Content-Type": "application/json"
        },
        path: "/api/v2/git/repository/search_commits"
      };
      if (isEvpProxy) {
        options.path = "/evp_proxy/v2/api/v2/git/repository/search_commits";
        options.headers["X-Datadog-EVP-Subdomain"] = "api";
        delete options.headers["dd-api-key"];
      }
      const localCommitData = JSON.stringify({
        meta: {
          repository_url: repositoryUrl
        },
        data: latestCommits.map((commit) => ({
          id: commit,
          type: "commit"
        }))
      });
      request(localCommitData, options, (err, response) => {
        if (err) {
          const error = new Error(`Error fetching commits to exclude: ${err.message}`);
          return callback(error);
        }
        let commitsToExclude;
        try {
          commitsToExclude = sanitizeCommits(JSON.parse(response).data);
        } catch (e) {
          return callback(new Error(`Can't parse commits to exclude response: ${e.message}`));
        }
        callback(null, commitsToExclude, headCommit);
      });
    }
    __name(getCommitsToExclude, "getCommitsToExclude");
    function uploadPackFile({ url, isEvpProxy, packFileToUpload, repositoryUrl, headCommit }, callback) {
      const form = new FormData();
      const pushedSha = JSON.stringify({
        data: {
          id: headCommit,
          type: "commit"
        },
        meta: {
          repository_url: repositoryUrl
        }
      });
      form.append("pushedSha", pushedSha, { contentType: "application/json" });
      try {
        const packFileContent = fs.readFileSync(packFileToUpload);
        const [, filename] = path.basename(packFileToUpload).split("-");
        form.append("packfile", packFileContent, {
          filename,
          contentType: "application/octet-stream"
        });
      } catch (e) {
        callback(new Error(`Could not read "${packFileToUpload}"`));
        return;
      }
      const commonOptions = getCommonRequestOptions(url);
      const options = {
        ...commonOptions,
        path: "/api/v2/git/repository/packfile",
        headers: {
          ...commonOptions.headers,
          ...form.getHeaders()
        }
      };
      if (isEvpProxy) {
        options.path = "/evp_proxy/v2/api/v2/git/repository/packfile";
        options.headers["X-Datadog-EVP-Subdomain"] = "api";
        delete options.headers["dd-api-key"];
      }
      request(form, options, (err, _, statusCode) => {
        if (err) {
          const error = new Error(`Could not upload packfiles: status code ${statusCode}: ${err.message}`);
          return callback(error);
        }
        callback(null);
      });
    }
    __name(uploadPackFile, "uploadPackFile");
    function sendGitMetadata(url, isEvpProxy, callback) {
      const repositoryUrl = getRepositoryUrl();
      if (!repositoryUrl) {
        return callback(new Error("Repository URL is empty"));
      }
      getCommitsToExclude({ url, repositoryUrl, isEvpProxy }, (err, commitsToExclude, headCommit) => {
        if (err) {
          return callback(err);
        }
        const commitsToUpload = getCommitsToUpload(commitsToExclude);
        if (!commitsToUpload.length) {
          log.debug("No commits to upload");
          return callback(null);
        }
        const packFilesToUpload = generatePackFilesForCommits(commitsToUpload);
        if (!packFilesToUpload.length) {
          return callback(new Error("Failed to generate packfiles"));
        }
        let packFileIndex = 0;
        const uploadPackFileCallback = /* @__PURE__ */ __name((err2) => {
          if (err2 || packFileIndex === packFilesToUpload.length) {
            return callback(err2);
          }
          return uploadPackFile(
            {
              packFileToUpload: packFilesToUpload[packFileIndex++],
              url,
              isEvpProxy,
              repositoryUrl,
              headCommit
            },
            uploadPackFileCallback
          );
        }, "uploadPackFileCallback");
        uploadPackFile(
          {
            packFileToUpload: packFilesToUpload[packFileIndex++],
            url,
            isEvpProxy,
            repositoryUrl,
            headCommit
          },
          uploadPackFileCallback
        );
      });
    }
    __name(sendGitMetadata, "sendGitMetadata");
    module2.exports = {
      sendGitMetadata
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/intelligent-test-runner/get-itr-configuration.js
var require_get_itr_configuration = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/ci-visibility/intelligent-test-runner/get-itr-configuration.js"(exports2, module2) {
    var request = require_request();
    var id = require_id();
    function getItrConfiguration({
      url,
      isEvpProxy,
      env,
      service,
      repositoryUrl,
      sha,
      osVersion,
      osPlatform,
      osArchitecture,
      runtimeName,
      runtimeVersion,
      branch
    }, done) {
      const options = {
        path: "/api/v2/libraries/tests/services/setting",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        url
      };
      if (isEvpProxy) {
        options.path = "/evp_proxy/v2/api/v2/libraries/tests/services/setting";
        options.headers["X-Datadog-EVP-Subdomain"] = "api";
        options.headers["X-Datadog-NeedsAppKey"] = "true";
      } else {
        const apiKey = process.env.DATADOG_API_KEY || process.env.DD_API_KEY;
        const appKey = process.env.DATADOG_APP_KEY || process.env.DD_APP_KEY || process.env.DATADOG_APPLICATION_KEY || process.env.DD_APPLICATION_KEY;
        if (!apiKey || !appKey) {
          return done(new Error("App key or API key undefined"));
        }
        options.headers["dd-api-key"] = apiKey;
        options.headers["dd-application-key"] = appKey;
      }
      const data = JSON.stringify({
        data: {
          id: id().toString(10),
          type: "ci_app_test_service_libraries_settings",
          attributes: {
            test_level: "suite",
            configurations: {
              "os.platform": osPlatform,
              "os.version": osVersion,
              "os.architecture": osArchitecture,
              "runtime.name": runtimeName,
              "runtime.version": runtimeVersion
            },
            service,
            env,
            repository_url: repositoryUrl,
            sha,
            branch
          }
        }
      });
      request(data, options, (err, res) => {
        if (err) {
          done(err);
        } else {
          try {
            const {
              data: {
                attributes: {
                  code_coverage: isCodeCoverageEnabled,
                  tests_skipping: isSuitesSkippingEnabled
                }
              }
            } = JSON.parse(res);
            done(null, { isCodeCoverageEnabled, isSuitesSkippingEnabled });
          } catch (err2) {
            done(err2);
          }
        }
      });
    }
    __name(getItrConfiguration, "getItrConfiguration");
    module2.exports = { getItrConfiguration };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/intelligent-test-runner/get-skippable-suites.js
var require_get_skippable_suites = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/ci-visibility/intelligent-test-runner/get-skippable-suites.js"(exports2, module2) {
    var request = require_request();
    function getSkippableSuites({
      url,
      isEvpProxy,
      env,
      service,
      repositoryUrl,
      sha,
      osVersion,
      osPlatform,
      osArchitecture,
      runtimeName,
      runtimeVersion
    }, done) {
      const options = {
        path: "/api/v2/ci/tests/skippable",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        timeout: 2e4,
        url
      };
      if (isEvpProxy) {
        options.path = "/evp_proxy/v2/api/v2/ci/tests/skippable";
        options.headers["X-Datadog-EVP-Subdomain"] = "api";
        options.headers["X-Datadog-NeedsAppKey"] = "true";
      } else {
        const apiKey = process.env.DATADOG_API_KEY || process.env.DD_API_KEY;
        const appKey = process.env.DATADOG_APP_KEY || process.env.DD_APP_KEY || process.env.DATADOG_APPLICATION_KEY || process.env.DD_APPLICATION_KEY;
        if (!apiKey || !appKey) {
          return done(new Error("App key or API key undefined"));
        }
        options.headers["dd-api-key"] = apiKey;
        options.headers["dd-application-key"] = appKey;
      }
      const data = JSON.stringify({
        data: {
          type: "test_params",
          attributes: {
            test_level: "suite",
            configurations: {
              "os.platform": osPlatform,
              "os.version": osVersion,
              "os.architecture": osArchitecture,
              "runtime.name": runtimeName,
              "runtime.version": runtimeVersion
            },
            service,
            env,
            repository_url: repositoryUrl,
            sha
          }
        }
      });
      request(data, options, (err, res) => {
        if (err) {
          done(err);
        } else {
          let skippableSuites = [];
          try {
            skippableSuites = JSON.parse(res).data.filter(({ type }) => type === "suite").map(({ attributes: { suite } }) => suite);
            done(null, skippableSuites);
          } catch (err2) {
            done(err2);
          }
        }
      });
    }
    __name(getSkippableSuites, "getSkippableSuites");
    module2.exports = { getSkippableSuites };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporters/common/agent-info-exporter.js
var require_agent_info_exporter = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporters/common/agent-info-exporter.js"(exports2, module2) {
    var { URL: URL2, format } = __require("url");
    var request = require_request();
    function fetchAgentInfo(url, callback) {
      request("", {
        path: "/info",
        url
      }, (err, res) => {
        if (err) {
          return callback(err);
        }
        try {
          const response = JSON.parse(res);
          return callback(null, response);
        } catch (e) {
          return callback(e);
        }
      });
    }
    __name(fetchAgentInfo, "fetchAgentInfo");
    var AgentInfoExporter = class {
      constructor(tracerConfig) {
        this._config = tracerConfig;
        const { url, hostname, port } = this._config;
        this._url = url || new URL2(format({
          protocol: "http:",
          hostname: hostname || "localhost",
          port
        }));
        this._traceBuffer = [];
        this._isInitialized = false;
      }
      getAgentInfo(onReceivedInfo) {
        fetchAgentInfo(this._url, onReceivedInfo);
      }
      export(trace) {
        if (!this._isInitialized) {
          this._traceBuffer.push(trace);
          return;
        }
        this._export(trace);
      }
      _export(payload2, writer = this._writer, timerKey = "_timer") {
        writer.append(payload2);
        const { flushInterval } = this._config;
        if (flushInterval === 0) {
          writer.flush();
        } else if (flushInterval > 0 && !this[timerKey]) {
          this[timerKey] = setTimeout(() => {
            writer.flush();
            this[timerKey] = clearTimeout(this[timerKey]);
          }, flushInterval).unref();
        }
      }
      getUncodedTraces() {
        return this._traceBuffer;
      }
      exportUncodedTraces() {
        this.getUncodedTraces().forEach((uncodedTrace) => {
          this.export(uncodedTrace);
        });
        this.resetUncodedTraces();
      }
      resetUncodedTraces() {
        this._traceBuffer = [];
      }
    };
    __name(AgentInfoExporter, "AgentInfoExporter");
    module2.exports = AgentInfoExporter;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/ci-visibility-exporter.js
var require_ci_visibility_exporter = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/ci-visibility-exporter.js"(exports2, module2) {
    "use strict";
    var URL2 = __require("url").URL;
    var { sendGitMetadata: sendGitMetadataRequest } = require_git_metadata();
    var { getItrConfiguration: getItrConfigurationRequest } = require_get_itr_configuration();
    var { getSkippableSuites: getSkippableSuitesRequest } = require_get_skippable_suites();
    var log = require_log();
    var AgentInfoExporter = require_agent_info_exporter();
    function getIsTestSessionTrace(trace) {
      return trace.some(
        (span) => span.type === "test_session_end" || span.type === "test_suite_end" || span.type === "test_module_end"
      );
    }
    __name(getIsTestSessionTrace, "getIsTestSessionTrace");
    var GIT_UPLOAD_TIMEOUT = 6e4;
    var CAN_USE_CI_VIS_PROTOCOL_TIMEOUT = GIT_UPLOAD_TIMEOUT;
    var CiVisibilityExporter = class extends AgentInfoExporter {
      constructor(config) {
        super(config);
        this._timer = void 0;
        this._coverageTimer = void 0;
        this._coverageBuffer = [];
        this._canUseCiVisProtocol = false;
        const gitUploadTimeoutId = setTimeout(() => {
          this._resolveGit(new Error("Timeout while uploading git metadata"));
        }, GIT_UPLOAD_TIMEOUT).unref();
        const canUseCiVisProtocolTimeoutId = setTimeout(() => {
          this._resolveCanUseCiVisProtocol(false);
        }, CAN_USE_CI_VIS_PROTOCOL_TIMEOUT).unref();
        this._gitUploadPromise = new Promise((resolve) => {
          this._resolveGit = (err) => {
            clearTimeout(gitUploadTimeoutId);
            resolve(err);
          };
        });
        this._canUseCiVisProtocolPromise = new Promise((resolve) => {
          this._resolveCanUseCiVisProtocol = (canUseCiVisProtocol) => {
            clearTimeout(canUseCiVisProtocolTimeoutId);
            this._canUseCiVisProtocol = canUseCiVisProtocol;
            resolve(canUseCiVisProtocol);
          };
        });
        process.once("beforeExit", () => {
          if (this._writer) {
            this._writer.flush();
          }
          if (this._coverageWriter) {
            this._coverageWriter.flush();
          }
        });
      }
      shouldRequestSkippableSuites() {
        return !!(this._config.isIntelligentTestRunnerEnabled && this._canUseCiVisProtocol && this._itrConfig && this._itrConfig.isSuitesSkippingEnabled);
      }
      shouldRequestItrConfiguration() {
        return this._config.isIntelligentTestRunnerEnabled;
      }
      canReportSessionTraces() {
        return this._canUseCiVisProtocol;
      }
      canReportCodeCoverage() {
        return this._canUseCiVisProtocol;
      }
      getSkippableSuites(testConfiguration, callback) {
        if (!this.shouldRequestSkippableSuites()) {
          return callback(null, []);
        }
        this._gitUploadPromise.then((gitUploadError) => {
          if (gitUploadError) {
            return callback(gitUploadError, []);
          }
          const configuration = {
            url: this._getApiUrl(),
            site: this._config.site,
            env: this._config.env,
            service: this._config.service,
            isEvpProxy: !!this._isUsingEvpProxy,
            ...testConfiguration
          };
          getSkippableSuitesRequest(configuration, callback);
        });
      }
      getItrConfiguration(testConfiguration, callback) {
        this.sendGitMetadata();
        if (!this.shouldRequestItrConfiguration()) {
          return callback(null, {});
        }
        this._canUseCiVisProtocolPromise.then((canUseCiVisProtocol) => {
          if (!canUseCiVisProtocol) {
            return callback(null, {});
          }
          const configuration = {
            url: this._getApiUrl(),
            env: this._config.env,
            service: this._config.service,
            isEvpProxy: !!this._isUsingEvpProxy,
            ...testConfiguration
          };
          getItrConfigurationRequest(configuration, (err, itrConfig) => {
            this._itrConfig = itrConfig;
            callback(err, itrConfig);
          });
        });
      }
      sendGitMetadata() {
        if (!this._config.isGitUploadEnabled) {
          return;
        }
        this._canUseCiVisProtocolPromise.then((canUseCiVisProtocol) => {
          if (!canUseCiVisProtocol) {
            return;
          }
          sendGitMetadataRequest(this._getApiUrl(), !!this._isUsingEvpProxy, (err) => {
            if (err) {
              log.error(`Error uploading git metadata: ${err.message}`);
            } else {
              log.debug("Successfully uploaded git metadata");
            }
            this._resolveGit(err);
          });
        });
      }
      export(trace) {
        if (!this._isInitialized) {
          this._traceBuffer.push(trace);
          return;
        }
        if (!this.canReportSessionTraces() && getIsTestSessionTrace(trace)) {
          return;
        }
        this._export(trace);
      }
      exportCoverage(coveragePayload) {
        if (!this._isInitialized) {
          this._coverageBuffer.push(coveragePayload);
          return;
        }
        if (!this.canReportCodeCoverage()) {
          return;
        }
        const { span, coverageFiles } = coveragePayload;
        const formattedCoverage = {
          traceId: span.context()._traceId,
          spanId: span.context()._spanId,
          files: coverageFiles
        };
        this._export(formattedCoverage, this._coverageWriter, "_coverageTimer");
      }
      flush(done = () => {
      }) {
        if (!this._isInitialized) {
          return done();
        }
        this._writer.flush(() => {
          if (this._coverageWriter) {
            this._coverageWriter.flush(done);
          } else {
            done();
          }
        });
      }
      exportUncodedCoverages() {
        this._coverageBuffer.forEach((oldCoveragePayload) => {
          this.exportCoverage(oldCoveragePayload);
        });
        this._coverageBuffer = [];
      }
      _setUrl(url, coverageUrl = url) {
        try {
          url = new URL2(url);
          coverageUrl = new URL2(coverageUrl);
          this._url = url;
          this._coverageUrl = coverageUrl;
          this._writer.setUrl(url);
          this._coverageWriter.setUrl(coverageUrl);
        } catch (e) {
          log.error(e);
        }
      }
      _getApiUrl() {
        return this._url;
      }
    };
    __name(CiVisibilityExporter, "CiVisibilityExporter");
    module2.exports = CiVisibilityExporter;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/index.js
var require_agentless = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agentless/index.js"(exports2, module2) {
    "use strict";
    var URL2 = __require("url").URL;
    var Writer = require_writer6();
    var CoverageWriter = require_coverage_writer();
    var CiVisibilityExporter = require_ci_visibility_exporter();
    var log = require_log();
    var AgentlessCiVisibilityExporter = class extends CiVisibilityExporter {
      constructor(config) {
        super(config);
        const { tags, site, url } = config;
        this._isInitialized = true;
        this._resolveCanUseCiVisProtocol(true);
        this._url = url || new URL2(`https://citestcycle-intake.${site}`);
        this._writer = new Writer({ url: this._url, tags });
        this._coverageUrl = url || new URL2(`https://event-platform-intake.${site}`);
        this._coverageWriter = new CoverageWriter({ url: this._coverageUrl });
        this._apiUrl = url || new URL2(`https://api.${site}`);
      }
      setUrl(url, coverageUrl = url, apiUrl = url) {
        this._setUrl(url, coverageUrl);
        try {
          apiUrl = new URL2(apiUrl);
          this._apiUrl = apiUrl;
        } catch (e) {
          log.error(e);
        }
      }
      _getApiUrl() {
        return this._apiUrl;
      }
    };
    __name(AgentlessCiVisibilityExporter, "AgentlessCiVisibilityExporter");
    module2.exports = AgentlessCiVisibilityExporter;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agent-proxy/index.js
var require_agent_proxy = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/ci-visibility/exporters/agent-proxy/index.js"(exports2, module2) {
    "use strict";
    var AgentWriter = require_writer5();
    var AgentlessWriter = require_writer6();
    var CoverageWriter = require_coverage_writer();
    var CiVisibilityExporter = require_ci_visibility_exporter();
    var AGENT_EVP_PROXY_PATH = "/evp_proxy/v2";
    function getIsEvpCompatible(err, agentInfo) {
      return !err && agentInfo.endpoints.some((url) => url.includes(AGENT_EVP_PROXY_PATH));
    }
    __name(getIsEvpCompatible, "getIsEvpCompatible");
    var AgentProxyCiVisibilityExporter = class extends CiVisibilityExporter {
      constructor(config) {
        super(config);
        const {
          tags,
          prioritySampler,
          lookup,
          protocolVersion,
          headers
        } = config;
        this.getAgentInfo((err, agentInfo) => {
          this._isInitialized = true;
          const isEvpCompatible = getIsEvpCompatible(err, agentInfo);
          if (isEvpCompatible) {
            this._isUsingEvpProxy = true;
            this._writer = new AgentlessWriter({
              url: this._url,
              tags,
              evpProxyPrefix: AGENT_EVP_PROXY_PATH
            });
            this._coverageWriter = new CoverageWriter({
              url: this._url,
              evpProxyPrefix: AGENT_EVP_PROXY_PATH
            });
          } else {
            this._writer = new AgentWriter({
              url: this._url,
              prioritySampler,
              lookup,
              protocolVersion,
              headers
            });
            this._coverageBuffer = [];
          }
          this._resolveCanUseCiVisProtocol(isEvpCompatible);
          this.exportUncodedTraces();
          this.exportUncodedCoverages();
        });
      }
      setUrl(url, coverageUrl) {
        this._setUrl(url, coverageUrl);
      }
    };
    __name(AgentProxyCiVisibilityExporter, "AgentProxyCiVisibilityExporter");
    module2.exports = AgentProxyCiVisibilityExporter;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/exporter.js
var require_exporter = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/exporter.js"(exports2, module2) {
    "use strict";
    var AgentExporter = require_agent();
    var LogExporter = require_log3();
    var AgentlessCiVisibilityExporter = require_agentless();
    var AgentProxyCiVisibilityExporter = require_agent_proxy();
    var exporters = require_exporters();
    var fs = __require("fs");
    var constants = require_constants();
    module2.exports = (name) => {
      const inAWSLambda = process.env.AWS_LAMBDA_FUNCTION_NAME !== void 0;
      const usingLambdaExtension = inAWSLambda && fs.existsSync(constants.DATADOG_LAMBDA_EXTENSION_PATH);
      switch (name) {
        case exporters.LOG:
          return LogExporter;
        case exporters.AGENT:
          return AgentExporter;
        case exporters.DATADOG:
          return AgentlessCiVisibilityExporter;
        case exporters.AGENT_PROXY:
          return AgentProxyCiVisibilityExporter;
        default:
          return inAWSLambda && !usingLambdaExtension ? LogExporter : AgentExporter;
      }
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js
var require_tracer2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/opentracing/tracer.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var Span = require_span2();
    var SpanProcessor = require_span_processor();
    var PrioritySampler = require_priority_sampler();
    var TextMapPropagator = require_text_map();
    var HttpPropagator = require_http();
    var BinaryPropagator = require_binary();
    var LogPropagator = require_log2();
    var formats = require_formats();
    var log = require_log();
    var metrics = require_metrics();
    var getExporter = require_exporter();
    var SpanContext = require_span_context();
    var REFERENCE_CHILD_OF = "child_of";
    var REFERENCE_FOLLOWS_FROM = "follows_from";
    var DatadogTracer = class {
      constructor(config) {
        const Exporter = getExporter(config.experimental.exporter);
        this._service = config.service;
        this._version = config.version;
        this._env = config.env;
        this._tags = config.tags;
        this._logInjection = config.logInjection;
        this._debug = config.debug;
        this._prioritySampler = new PrioritySampler(config.env, config.sampler);
        this._exporter = new Exporter(config, this._prioritySampler);
        this._processor = new SpanProcessor(this._exporter, this._prioritySampler, config);
        this._url = this._exporter._url;
        this._enableGetRumData = config.experimental.enableGetRumData;
        this._propagators = {
          [formats.TEXT_MAP]: new TextMapPropagator(config),
          [formats.HTTP_HEADERS]: new HttpPropagator(config),
          [formats.BINARY]: new BinaryPropagator(config),
          [formats.LOG]: new LogPropagator(config)
        };
        if (config.reportHostname) {
          this._hostname = os.hostname();
        }
      }
      startSpan(name, options = {}) {
        const parent = options.childOf ? getContext(options.childOf) : getParent(options.references);
        const tags = {
          "service.name": this._service
        };
        const span = new Span(this, this._processor, this._prioritySampler, {
          operationName: options.operationName || name,
          parent,
          tags,
          startTime: options.startTime,
          hostname: this._hostname
        }, this._debug);
        span.addTags(this._tags);
        span.addTags(options.tags);
        return span;
      }
      inject(spanContext, format, carrier) {
        if (spanContext instanceof Span) {
          spanContext = spanContext.context();
        }
        try {
          this._prioritySampler.sample(spanContext);
          this._propagators[format].inject(spanContext, carrier);
        } catch (e) {
          log.error(e);
          metrics.increment("datadog.tracer.node.inject.errors", true);
        }
      }
      extract(format, carrier) {
        try {
          return this._propagators[format].extract(carrier);
        } catch (e) {
          log.error(e);
          metrics.increment("datadog.tracer.node.extract.errors", true);
          return null;
        }
      }
    };
    __name(DatadogTracer, "DatadogTracer");
    function getContext(spanContext) {
      if (spanContext instanceof Span) {
        spanContext = spanContext.context();
      }
      if (!(spanContext instanceof SpanContext)) {
        spanContext = null;
      }
      return spanContext;
    }
    __name(getContext, "getContext");
    function getParent(references = []) {
      let parent = null;
      for (let i = 0; i < references.length; i++) {
        const ref = references[i];
        const type = ref.type();
        if (type === REFERENCE_CHILD_OF) {
          parent = ref.referencedContext();
          break;
        } else if (type === REFERENCE_FOLLOWS_FROM) {
          if (!parent) {
            parent = ref.referencedContext();
          }
        }
      }
      return parent;
    }
    __name(getParent, "getParent");
    module2.exports = DatadogTracer;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/scope.js
var require_scope2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/scope.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var originals = /* @__PURE__ */ new WeakMap();
    var Scope = class {
      active() {
        const store = storage.getStore();
        return store && store.span || null;
      }
      activate(span, callback) {
        if (typeof callback !== "function")
          return callback;
        const oldStore = storage.getStore();
        const newStore = span ? span._store : oldStore;
        storage.enterWith({ ...newStore, span });
        try {
          return callback();
        } catch (e) {
          if (span && typeof span.setTag === "function") {
            span.setTag("error", e);
          }
          throw e;
        } finally {
          storage.enterWith(oldStore);
        }
      }
      bind(fn, span) {
        if (typeof fn !== "function")
          return fn;
        const scope = this;
        const spanOrActive = this._spanOrActive(span);
        const bound = /* @__PURE__ */ __name(function() {
          return scope.activate(spanOrActive, () => {
            return fn.apply(this, arguments);
          });
        }, "bound");
        originals.set(bound, fn);
        return bound;
      }
      _spanOrActive(span) {
        return span !== void 0 ? span : this.active();
      }
      _isPromise(promise) {
        return promise && typeof promise.then === "function";
      }
    };
    __name(Scope, "Scope");
    module2.exports = Scope;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/tracer.js
var require_tracer3 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/tracer.js"(exports2, module2) {
    "use strict";
    var Tracer = require_tracer2();
    var tags = require_tags();
    var Scope = require_scope2();
    var { storage } = require_datadog_core();
    var { isError } = require_util();
    var { setStartupLogConfig } = require_startup_log();
    var { ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK } = require_constants();
    var SPAN_TYPE = tags.SPAN_TYPE;
    var RESOURCE_NAME = tags.RESOURCE_NAME;
    var SERVICE_NAME = tags.SERVICE_NAME;
    var MEASURED = tags.MEASURED;
    var DatadogTracer = class extends Tracer {
      constructor(config) {
        super(config);
        this._scope = new Scope();
        setStartupLogConfig(config);
      }
      trace(name, options, fn) {
        options = Object.assign({
          childOf: this.scope().active()
        }, options);
        if (!options.childOf && options.orphanable === false) {
          return fn(null, () => {
          });
        }
        const span = this.startSpan(name, options);
        addTags(span, options);
        try {
          if (fn.length > 1) {
            return this.scope().activate(span, () => fn(span, (err) => {
              addError(span, err);
              span.finish();
            }));
          }
          const result = this.scope().activate(span, () => fn(span));
          if (result && typeof result.then === "function") {
            return result.then(
              (value) => {
                span.finish();
                return value;
              },
              (err) => {
                addError(span, err);
                span.finish();
                throw err;
              }
            );
          } else {
            span.finish();
          }
          return result;
        } catch (e) {
          addError(span, e);
          span.finish();
          throw e;
        }
      }
      wrap(name, options, fn) {
        const tracer2 = this;
        return function() {
          const store = storage.getStore();
          if (store && store.noop)
            return fn.apply(this, arguments);
          let optionsObj = options;
          if (typeof optionsObj === "function" && typeof fn === "function") {
            optionsObj = optionsObj.apply(this, arguments);
          }
          if (optionsObj && optionsObj.orphanable === false && !tracer2.scope().active()) {
            return fn.apply(this, arguments);
          }
          const lastArgId = arguments.length - 1;
          const cb = arguments[lastArgId];
          if (typeof cb === "function") {
            const scopeBoundCb = tracer2.scope().bind(cb);
            return tracer2.trace(name, optionsObj, (span, done) => {
              arguments[lastArgId] = function(err) {
                done(err);
                return scopeBoundCb.apply(this, arguments);
              };
              return fn.apply(this, arguments);
            });
          } else {
            return tracer2.trace(name, optionsObj, () => fn.apply(this, arguments));
          }
        };
      }
      setUrl(url) {
        this._exporter.setUrl(url);
      }
      scope() {
        return this._scope;
      }
      getRumData() {
        if (!this._enableGetRumData) {
          return "";
        }
        const span = this.scope().active().context();
        const traceId = span.toTraceId();
        const traceTime = Date.now();
        return `<meta name="dd-trace-id" content="${traceId}" /><meta name="dd-trace-time" content="${traceTime}" />`;
      }
      setUser(user) {
        if (!user || !user.id)
          return this;
        const span = this.scope().active();
        if (!span)
          return this;
        const rootSpan = span._spanContext._trace.started[0];
        if (!rootSpan)
          return this;
        for (const k of Object.keys(user)) {
          rootSpan.setTag(`usr.${k}`, "" + user[k]);
        }
        return this;
      }
    };
    __name(DatadogTracer, "DatadogTracer");
    function addError(span, error) {
      if (isError(error)) {
        span.addTags({
          [ERROR_TYPE]: error.name,
          [ERROR_MESSAGE]: error.message,
          [ERROR_STACK]: error.stack
        });
      }
    }
    __name(addError, "addError");
    function addTags(span, options) {
      const tags2 = {};
      if (options.type)
        tags2[SPAN_TYPE] = options.type;
      if (options.service)
        tags2[SERVICE_NAME] = options.service;
      if (options.resource)
        tags2[RESOURCE_NAME] = options.resource;
      tags2[MEASURED] = options.measured;
      span.addTags(tags2);
    }
    __name(addTags, "addTags");
    module2.exports = DatadogTracer;
  }
});

// node_modules/koalas/index.js
var require_koalas = __commonJS({
  "node_modules/koalas/index.js"(exports2, module2) {
    "use strict";
    function koalas() {
      var len = arguments.length;
      var arg;
      for (var i = 0; i < len; i++) {
        arg = arguments[i];
        if (hasValue(arg)) {
          return arg;
        }
      }
      return arg;
    }
    __name(koalas, "koalas");
    function hasValue(val) {
      return val != null && val === val;
    }
    __name(hasValue, "hasValue");
    module2.exports = koalas;
  }
});

// node_modules/crypto-randomuuid/validators.js
var require_validators = __commonJS({
  "node_modules/crypto-randomuuid/validators.js"(exports2, module2) {
    "use strict";
    var assert = __require("assert");
    var util = __require("util");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var ERR_OPERATION_FAILED = class extends TypeError {
      constructor(message) {
        super(`Operation failed: ${message}`);
        this.code = this.constructor.name;
        Object.defineProperties(this, {
          toString: {
            value() {
              return `${this.name} [${this.code}]: ${this.message}`;
            },
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
    __name(ERR_OPERATION_FAILED, "ERR_OPERATION_FAILED");
    var ERR_INVALID_ARG_TYPE = class extends TypeError {
      constructor(name, expected, actual) {
        super();
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          const type = name.includes(".") ? "property" : "argument";
          msg += `"${name}" ${type} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(
            typeof value === "string",
            "All expected entries have to be of type string"
          );
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(
              value !== "object",
              'The value "object" should be written as "Object"'
            );
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
          } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
          } else {
            msg += `of type ${types[0]}`;
          }
          if (instances.length > 0 || other.length > 0)
            msg += " or ";
        }
        if (instances.length > 0) {
          if (instances.length > 2) {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
              msg += ` or ${instances[1]}`;
            }
          }
          if (other.length > 0)
            msg += " or ";
        }
        if (other.length > 0) {
          if (other.length > 2) {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
          } else {
            if (other[0].toLowerCase() !== other[0])
              msg += "an ";
            msg += `${other[0]}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          if (actual.constructor && actual.constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = util.inspect(actual, { depth: -1 });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = util.inspect(actual, { colors: false });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        this.code = this.constructor.name;
        Object.defineProperties(this, {
          message: {
            value: msg,
            enumerable: false,
            writable: true,
            configurable: true
          },
          toString: {
            value() {
              return `${this.name} [${this.code}]: ${this.message}`;
            },
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
    __name(ERR_INVALID_ARG_TYPE, "ERR_INVALID_ARG_TYPE");
    function validateBoolean(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    __name(validateBoolean, "validateBoolean");
    function validateObject(value, name, {
      nullable = false,
      allowArray = false,
      allowFunction = false
    } = {}) {
      if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    }
    __name(validateObject, "validateObject");
    module2.exports = {
      validateBoolean,
      validateObject,
      codes: {
        ERR_OPERATION_FAILED
      }
    };
  }
});

// node_modules/crypto-randomuuid/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/crypto-randomuuid/polyfill.js"(exports2, module2) {
    "use strict";
    var crypto2 = __require("crypto");
    var {
      validateBoolean,
      validateObject,
      codes: {
        ERR_OPERATION_FAILED
      }
    } = require_validators();
    var { randomFillSync } = crypto2;
    function secureBuffer(size) {
      const buf = Buffer.alloc(size);
      return randomFillSync(buf);
    }
    __name(secureBuffer, "secureBuffer");
    var kBatchSize = 128;
    var uuidData;
    var uuidNotBuffered;
    var uuidBatch = 0;
    var hexBytesCache;
    function getHexBytes() {
      if (hexBytesCache === void 0) {
        hexBytesCache = new Array(256);
        for (let i = 0; i < hexBytesCache.length; i++) {
          const hex = i.toString(16);
          hexBytesCache[i] = hex.padStart(2, "0");
        }
      }
      return hexBytesCache;
    }
    __name(getHexBytes, "getHexBytes");
    function serializeUUID(buf, offset = 0) {
      const kHexBytes = getHexBytes();
      return kHexBytes[buf[offset]] + kHexBytes[buf[offset + 1]] + kHexBytes[buf[offset + 2]] + kHexBytes[buf[offset + 3]] + "-" + kHexBytes[buf[offset + 4]] + kHexBytes[buf[offset + 5]] + "-" + kHexBytes[buf[offset + 6] & 15 | 64] + kHexBytes[buf[offset + 7]] + "-" + kHexBytes[buf[offset + 8] & 63 | 128] + kHexBytes[buf[offset + 9]] + "-" + kHexBytes[buf[offset + 10]] + kHexBytes[buf[offset + 11]] + kHexBytes[buf[offset + 12]] + kHexBytes[buf[offset + 13]] + kHexBytes[buf[offset + 14]] + kHexBytes[buf[offset + 15]];
    }
    __name(serializeUUID, "serializeUUID");
    function getBufferedUUID() {
      if (!uuidData)
        uuidData = secureBuffer(16 * kBatchSize);
      if (uuidData === void 0)
        throw new ERR_OPERATION_FAILED("Out of memory");
      if (uuidBatch === 0)
        randomFillSync(uuidData);
      uuidBatch = (uuidBatch + 1) % kBatchSize;
      return serializeUUID(uuidData, uuidBatch * 16);
    }
    __name(getBufferedUUID, "getBufferedUUID");
    function getUnbufferedUUID() {
      if (!uuidNotBuffered)
        uuidNotBuffered = secureBuffer(16 * kBatchSize);
      if (uuidNotBuffered === void 0)
        throw new ERR_OPERATION_FAILED("Out of memory");
      randomFillSync(uuidNotBuffered);
      return serializeUUID(uuidNotBuffered);
    }
    __name(getUnbufferedUUID, "getUnbufferedUUID");
    function randomUUID(options) {
      if (options !== void 0)
        validateObject(options, "options");
      const {
        disableEntropyCache = false
      } = options || {};
      validateBoolean(disableEntropyCache, "options.disableEntropyCache");
      return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();
    }
    __name(randomUUID, "randomUUID");
    module2.exports = randomUUID;
  }
});

// node_modules/crypto-randomuuid/index.js
var require_crypto_randomuuid = __commonJS({
  "node_modules/crypto-randomuuid/index.js"(exports2, module2) {
    "use strict";
    var crypto2 = __require("crypto");
    module2.exports = typeof crypto2.randomUUID === "function" ? crypto2.randomUUID : require_polyfill();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/config.js
var require_config = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/config.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var os = __require("os");
    var URL2 = __require("url").URL;
    var log = require_log();
    var pkg = require_pkg();
    var coalesce = require_koalas();
    var tagger = require_tagger();
    var { isTrue, isFalse } = require_util();
    var uuid = require_crypto_randomuuid();
    var path = __require("path");
    var fromEntries = Object.fromEntries || ((entries) => entries.reduce((obj, [k, v]) => Object.assign(obj, { [k]: v }), {}));
    var qsRegex = '(?:p(?:ass)?w(?:or)?d|pass(?:_?phrase)?|secret|(?:api_?|private_?|public_?|access_?|secret_?)key(?:_?id)?|token|consumer_?(?:id|key|secret)|sign(?:ed|ature)?|auth(?:entication|orization)?)(?:(?:\\s|%20)*(?:=|%3D)[^&]+|(?:"|%22)(?:\\s|%20)*(?::|%3A)(?:\\s|%20)*(?:"|%22)(?:%2[^2]|%[^2]|[^"%])+(?:"|%22))|bearer(?:\\s|%20)+[a-z0-9\\._\\-]+|token(?::|%3A)[a-z0-9]{13}|gh[opsu]_[0-9a-zA-Z]{36}|ey[I-L](?:[\\w=-]|%3D)+\\.ey[I-L](?:[\\w=-]|%3D)+(?:\\.(?:[\\w.+\\/=-]|%3D|%2F|%2B)+)?|[\\-]{5}BEGIN(?:[a-z\\s]|%20)+PRIVATE(?:\\s|%20)KEY[\\-]{5}[^\\-]+[\\-]{5}END(?:[a-z\\s]|%20)+PRIVATE(?:\\s|%20)KEY|ssh-rsa(?:\\s|%20)*(?:[a-z0-9\\/\\.+]|%2F|%5C|%2B){100,}';
    function maybeFile(filepath) {
      if (!filepath)
        return;
      try {
        return fs.readFileSync(filepath, "utf8");
      } catch (e) {
        return void 0;
      }
    }
    __name(maybeFile, "maybeFile");
    function maybePath(filepath) {
      if (!filepath)
        return;
      try {
        fs.openSync(filepath, "r");
        return filepath;
      } catch (e) {
        return void 0;
      }
    }
    __name(maybePath, "maybePath");
    function safeJsonParse(input) {
      try {
        return JSON.parse(input);
      } catch (err) {
        return void 0;
      }
    }
    __name(safeJsonParse, "safeJsonParse");
    function remapify(input, mappings) {
      if (!input)
        return;
      const output = {};
      for (const [key, value] of Object.entries(input)) {
        output[key in mappings ? mappings[key] : key] = value;
      }
      return output;
    }
    __name(remapify, "remapify");
    function propagationStyle(key, option, defaultValue) {
      if (typeof option === "object" && !Array.isArray(option)) {
        option = option[key];
      }
      if (Array.isArray(option))
        return option.map((v) => v.toLowerCase());
      if (typeof option !== "undefined") {
        log.warn("Unexpected input for config.tracePropagationStyle");
      }
      const envKey = `DD_TRACE_PROPAGATION_STYLE_${key.toUpperCase()}`;
      const envVar = coalesce(process.env[envKey], process.env.DD_TRACE_PROPAGATION_STYLE);
      if (typeof envVar !== "undefined") {
        return envVar.split(",").filter((v) => v !== "").map((v) => v.trim().toLowerCase());
      }
      return defaultValue;
    }
    __name(propagationStyle, "propagationStyle");
    var Config = class {
      constructor(options) {
        options = options || {};
        this.debug = isTrue(coalesce(
          process.env.DD_TRACE_DEBUG,
          false
        ));
        this.logger = options.logger;
        this.logLevel = coalesce(
          options.logLevel,
          process.env.DD_TRACE_LOG_LEVEL,
          "debug"
        );
        log.use(this.logger);
        log.toggle(this.debug, this.logLevel, this);
        this.tags = {};
        tagger.add(this.tags, process.env.DD_TAGS);
        tagger.add(this.tags, process.env.DD_TRACE_TAGS);
        tagger.add(this.tags, process.env.DD_TRACE_GLOBAL_TAGS);
        tagger.add(this.tags, options.tags);
        const DD_TRACING_ENABLED = coalesce(
          process.env.DD_TRACING_ENABLED,
          true
        );
        const DD_PROFILING_ENABLED = coalesce(
          options.profiling,
          process.env.DD_EXPERIMENTAL_PROFILING_ENABLED,
          process.env.DD_PROFILING_ENABLED,
          false
        );
        const DD_PROFILING_EXPORTERS = coalesce(
          process.env.DD_PROFILING_EXPORTERS,
          "agent"
        );
        const DD_PROFILING_SOURCE_MAP = process.env.DD_PROFILING_SOURCE_MAP;
        const DD_LOGS_INJECTION = coalesce(
          options.logInjection,
          process.env.DD_LOGS_INJECTION,
          false
        );
        const DD_RUNTIME_METRICS_ENABLED = coalesce(
          options.runtimeMetrics,
          process.env.DD_RUNTIME_METRICS_ENABLED,
          false
        );
        const DD_DBM_PROPAGATION_MODE = coalesce(
          options.dbmPropagationMode,
          process.env.DD_DBM_PROPAGATION_MODE,
          "disabled"
        );
        const DD_AGENT_HOST = coalesce(
          options.hostname,
          process.env.DD_AGENT_HOST,
          process.env.DD_TRACE_AGENT_HOSTNAME,
          "127.0.0.1"
        );
        const DD_TRACE_AGENT_PORT = coalesce(
          options.port,
          process.env.DD_TRACE_AGENT_PORT,
          "8126"
        );
        const DD_TRACE_AGENT_URL = coalesce(
          options.url,
          process.env.DD_TRACE_AGENT_URL,
          process.env.DD_TRACE_URL,
          null
        );
        const DD_IS_CIVISIBILITY = coalesce(
          options.isCiVisibility,
          false
        );
        const DD_CIVISIBILITY_AGENTLESS_URL = process.env.DD_CIVISIBILITY_AGENTLESS_URL;
        const DD_CIVISIBILITY_ITR_ENABLED = coalesce(
          process.env.DD_CIVISIBILITY_ITR_ENABLED,
          false
        );
        const DD_SERVICE = options.service || process.env.DD_SERVICE || process.env.DD_SERVICE_NAME || this.tags.service || process.env.AWS_LAMBDA_FUNCTION_NAME || pkg.name || "node";
        const DD_SERVICE_MAPPING = coalesce(
          options.serviceMapping,
          process.env.DD_SERVICE_MAPPING ? fromEntries(
            process.env.DD_SERVICE_MAPPING.split(",").map((x) => x.trim().split(":"))
          ) : {}
        );
        const DD_ENV = coalesce(
          options.env,
          process.env.DD_ENV,
          this.tags.env
        );
        const DD_VERSION = coalesce(
          options.version,
          process.env.DD_VERSION,
          this.tags.version,
          pkg.version
        );
        const DD_TRACE_STARTUP_LOGS = coalesce(
          options.startupLogs,
          process.env.DD_TRACE_STARTUP_LOGS,
          false
        );
        const DD_TRACE_TELEMETRY_ENABLED = coalesce(
          process.env.DD_TRACE_TELEMETRY_ENABLED,
          !process.env.AWS_LAMBDA_FUNCTION_NAME
        );
        const DD_TRACE_AGENT_PROTOCOL_VERSION = coalesce(
          options.protocolVersion,
          process.env.DD_TRACE_AGENT_PROTOCOL_VERSION,
          "0.4"
        );
        const DD_TRACE_PARTIAL_FLUSH_MIN_SPANS = coalesce(
          parseInt(options.flushMinSpans),
          parseInt(process.env.DD_TRACE_PARTIAL_FLUSH_MIN_SPANS),
          1e3
        );
        const DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP = coalesce(
          process.env.DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP,
          qsRegex
        );
        const DD_TRACE_CLIENT_IP_ENABLED = coalesce(
          options.clientIpEnabled,
          process.env.DD_TRACE_CLIENT_IP_ENABLED && isTrue(process.env.DD_TRACE_CLIENT_IP_ENABLED),
          false
        );
        const DD_TRACE_CLIENT_IP_HEADER = coalesce(
          options.clientIpHeader,
          process.env.DD_TRACE_CLIENT_IP_HEADER,
          null
        );
        const DD_TRACE_B3_ENABLED = coalesce(
          options.experimental && options.experimental.b3,
          process.env.DD_TRACE_EXPERIMENTAL_B3_ENABLED,
          false
        );
        const defaultPropagationStyle = ["tracecontext", "datadog"];
        if (isTrue(DD_TRACE_B3_ENABLED)) {
          defaultPropagationStyle.push("b3");
          defaultPropagationStyle.push("b3 single header");
        }
        if (process.env.DD_TRACE_PROPAGATION_STYLE && (process.env.DD_TRACE_PROPAGATION_STYLE_INJECT || process.env.DD_TRACE_PROPAGATION_STYLE_EXTRACT)) {
          log.warn(
            "Use either the DD_TRACE_PROPAGATION_STYLE environment variable or separate DD_TRACE_PROPAGATION_STYLE_INJECT and DD_TRACE_PROPAGATION_STYLE_EXTRACT environment variables"
          );
        }
        const DD_TRACE_PROPAGATION_STYLE_INJECT = propagationStyle(
          "inject",
          options.tracePropagationStyle,
          defaultPropagationStyle
        );
        const DD_TRACE_PROPAGATION_STYLE_EXTRACT = propagationStyle(
          "extract",
          options.tracePropagationStyle,
          defaultPropagationStyle
        );
        const DD_TRACE_RUNTIME_ID_ENABLED = coalesce(
          options.experimental && options.experimental.runtimeId,
          process.env.DD_TRACE_EXPERIMENTAL_RUNTIME_ID_ENABLED,
          false
        );
        const DD_TRACE_EXPORTER = coalesce(
          options.experimental && options.experimental.exporter,
          process.env.DD_TRACE_EXPERIMENTAL_EXPORTER
        );
        const DD_TRACE_GET_RUM_DATA_ENABLED = coalesce(
          options.experimental && options.experimental.enableGetRumData,
          process.env.DD_TRACE_EXPERIMENTAL_GET_RUM_DATA_ENABLED,
          false
        );
        const DD_TRACE_X_DATADOG_TAGS_MAX_LENGTH = coalesce(
          process.env.DD_TRACE_X_DATADOG_TAGS_MAX_LENGTH,
          "512"
        );
        const DD_TRACE_STATS_COMPUTATION_ENABLED = coalesce(
          options.stats,
          process.env.DD_TRACE_STATS_COMPUTATION_ENABLED,
          false
        );
        let appsec = options.appsec != null ? options.appsec : options.experimental && options.experimental.appsec;
        if (typeof appsec === "boolean") {
          appsec = {
            enabled: appsec
          };
        } else if (appsec == null) {
          appsec = {};
        }
        const DD_APPSEC_ENABLED = coalesce(
          appsec.enabled,
          process.env.DD_APPSEC_ENABLED && isTrue(process.env.DD_APPSEC_ENABLED)
        );
        const DD_APPSEC_RULES = coalesce(
          appsec.rules,
          process.env.DD_APPSEC_RULES
        );
        const DD_APPSEC_TRACE_RATE_LIMIT = coalesce(
          parseInt(appsec.rateLimit),
          parseInt(process.env.DD_APPSEC_TRACE_RATE_LIMIT),
          100
        );
        const DD_APPSEC_WAF_TIMEOUT = coalesce(
          parseInt(appsec.wafTimeout),
          parseInt(process.env.DD_APPSEC_WAF_TIMEOUT),
          5e3
        );
        const DD_APPSEC_OBFUSCATION_PARAMETER_KEY_REGEXP = coalesce(
          appsec.obfuscatorKeyRegex,
          process.env.DD_APPSEC_OBFUSCATION_PARAMETER_KEY_REGEXP,
          `(?i)(?:p(?:ass)?w(?:or)?d|pass(?:_?phrase)?|secret|(?:api_?|private_?|public_?)key)|token|consumer_?(?:id|key|secret)|sign(?:ed|ature)|bearer|authorization`
        );
        const DD_APPSEC_OBFUSCATION_PARAMETER_VALUE_REGEXP = coalesce(
          appsec.obfuscatorValueRegex,
          process.env.DD_APPSEC_OBFUSCATION_PARAMETER_VALUE_REGEXP,
          `(?i)(?:p(?:ass)?w(?:or)?d|pass(?:_?phrase)?|secret|(?:api_?|private_?|public_?|access_?|secret_?)key(?:_?id)?|token|consumer_?(?:id|key|secret)|sign(?:ed|ature)?|auth(?:entication|orization)?)(?:\\s*=[^;]|"\\s*:\\s*"[^"]+")|bearer\\s+[a-z0-9\\._\\-]+|token:[a-z0-9]{13}|gh[opsu]_[0-9a-zA-Z]{36}|ey[I-L][\\w=-]+\\.ey[I-L][\\w=-]+(?:\\.[\\w.+\\/=-]+)?|[\\-]{5}BEGIN[a-z\\s]+PRIVATE\\sKEY[\\-]{5}[^\\-]+[\\-]{5}END[a-z\\s]+PRIVATE\\sKEY|ssh-rsa\\s*[a-z0-9\\/\\.+]{100,}`
        );
        const DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML = coalesce(
          maybePath(appsec.blockedTemplateHtml),
          maybePath(process.env.DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML),
          path.join(__dirname, "appsec", "templates", "blocked.html")
        );
        const DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON = coalesce(
          maybePath(appsec.blockedTemplateJson),
          maybePath(process.env.DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON),
          path.join(__dirname, "appsec", "templates", "blocked.json")
        );
        const inAWSLambda = process.env.AWS_LAMBDA_FUNCTION_NAME !== void 0;
        const remoteConfigOptions = options.remoteConfig || {};
        const DD_REMOTE_CONFIGURATION_ENABLED = coalesce(
          process.env.DD_REMOTE_CONFIGURATION_ENABLED && isTrue(process.env.DD_REMOTE_CONFIGURATION_ENABLED),
          !inAWSLambda
        );
        const DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS = coalesce(
          parseInt(remoteConfigOptions.pollInterval),
          parseInt(process.env.DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS),
          5
        );
        const iastOptions = options.experimental && options.experimental.iast;
        const DD_IAST_ENABLED = coalesce(
          iastOptions && (iastOptions === true || iastOptions.enabled === true),
          process.env.DD_IAST_ENABLED,
          false
        );
        const defaultIastRequestSampling = 30;
        const iastRequestSampling = coalesce(
          parseInt(iastOptions && iastOptions.requestSampling),
          parseInt(process.env.DD_IAST_REQUEST_SAMPLING),
          defaultIastRequestSampling
        );
        const DD_IAST_REQUEST_SAMPLING = iastRequestSampling < 0 || iastRequestSampling > 100 ? defaultIastRequestSampling : iastRequestSampling;
        const DD_IAST_MAX_CONCURRENT_REQUESTS = coalesce(
          parseInt(iastOptions && iastOptions.maxConcurrentRequests),
          parseInt(process.env.DD_IAST_MAX_CONCURRENT_REQUESTS),
          2
        );
        const DD_IAST_MAX_CONTEXT_OPERATIONS = coalesce(
          parseInt(iastOptions && iastOptions.maxContextOperations),
          parseInt(process.env.DD_IAST_MAX_CONTEXT_OPERATIONS),
          2
        );
        const DD_CIVISIBILITY_GIT_UPLOAD_ENABLED = coalesce(
          process.env.DD_CIVISIBILITY_GIT_UPLOAD_ENABLED,
          false
        );
        const ingestion = options.ingestion || {};
        const dogstatsd = coalesce(options.dogstatsd, {});
        const sampler = {
          sampleRate: coalesce(
            options.sampleRate,
            process.env.DD_TRACE_SAMPLE_RATE,
            ingestion.sampleRate
          ),
          rateLimit: coalesce(options.rateLimit, process.env.DD_TRACE_RATE_LIMIT, ingestion.rateLimit),
          rules: coalesce(
            options.samplingRules,
            safeJsonParse(process.env.DD_TRACE_SAMPLING_RULES),
            []
          ).map((rule) => {
            return remapify(rule, {
              sample_rate: "sampleRate"
            });
          }),
          spanSamplingRules: coalesce(
            options.spanSamplingRules,
            safeJsonParse(maybeFile(process.env.DD_SPAN_SAMPLING_RULES_FILE)),
            safeJsonParse(process.env.DD_SPAN_SAMPLING_RULES),
            []
          ).map((rule) => {
            return remapify(rule, {
              sample_rate: "sampleRate",
              max_per_second: "maxPerSecond"
            });
          })
        };
        const defaultFlushInterval = inAWSLambda ? 0 : 2e3;
        this.tracing = !isFalse(DD_TRACING_ENABLED);
        this.dbmPropagationMode = DD_DBM_PROPAGATION_MODE;
        this.logInjection = isTrue(DD_LOGS_INJECTION);
        this.env = DD_ENV;
        this.url = DD_CIVISIBILITY_AGENTLESS_URL ? new URL2(DD_CIVISIBILITY_AGENTLESS_URL) : getAgentUrl(DD_TRACE_AGENT_URL, options);
        this.site = coalesce(options.site, process.env.DD_SITE, "datadoghq.com");
        this.hostname = DD_AGENT_HOST || this.url && this.url.hostname;
        this.port = String(DD_TRACE_AGENT_PORT || this.url && this.url.port);
        this.flushInterval = coalesce(parseInt(options.flushInterval, 10), defaultFlushInterval);
        this.flushMinSpans = DD_TRACE_PARTIAL_FLUSH_MIN_SPANS;
        this.sampleRate = coalesce(Math.min(Math.max(sampler.sampleRate, 0), 1), 1);
        this.queryStringObfuscation = DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP;
        this.clientIpEnabled = DD_TRACE_CLIENT_IP_ENABLED;
        this.clientIpHeader = DD_TRACE_CLIENT_IP_HEADER;
        this.plugins = !!coalesce(options.plugins, true);
        this.service = DD_SERVICE;
        this.serviceMapping = DD_SERVICE_MAPPING;
        this.version = DD_VERSION;
        this.dogstatsd = {
          hostname: coalesce(dogstatsd.hostname, process.env.DD_DOGSTATSD_HOSTNAME, this.hostname),
          port: String(coalesce(dogstatsd.port, process.env.DD_DOGSTATSD_PORT, 8125))
        };
        this.runtimeMetrics = isTrue(DD_RUNTIME_METRICS_ENABLED);
        this.tracePropagationStyle = {
          inject: DD_TRACE_PROPAGATION_STYLE_INJECT,
          extract: DD_TRACE_PROPAGATION_STYLE_EXTRACT
        };
        this.experimental = {
          runtimeId: isTrue(DD_TRACE_RUNTIME_ID_ENABLED),
          exporter: DD_TRACE_EXPORTER,
          enableGetRumData: isTrue(DD_TRACE_GET_RUM_DATA_ENABLED)
        };
        this.sampler = sampler;
        this.reportHostname = isTrue(coalesce(options.reportHostname, process.env.DD_TRACE_REPORT_HOSTNAME, false));
        this.scope = process.env.DD_TRACE_SCOPE;
        this.profiling = {
          enabled: isTrue(DD_PROFILING_ENABLED),
          sourceMap: !isFalse(DD_PROFILING_SOURCE_MAP),
          exporters: DD_PROFILING_EXPORTERS
        };
        this.lookup = options.lookup;
        this.startupLogs = isTrue(DD_TRACE_STARTUP_LOGS);
        this.telemetryEnabled = DD_TRACE_EXPORTER !== "datadog" && isTrue(DD_TRACE_TELEMETRY_ENABLED);
        this.protocolVersion = DD_TRACE_AGENT_PROTOCOL_VERSION;
        this.tagsHeaderMaxLength = parseInt(DD_TRACE_X_DATADOG_TAGS_MAX_LENGTH);
        this.appsec = {
          enabled: DD_APPSEC_ENABLED,
          rules: DD_APPSEC_RULES,
          rateLimit: DD_APPSEC_TRACE_RATE_LIMIT,
          wafTimeout: DD_APPSEC_WAF_TIMEOUT,
          obfuscatorKeyRegex: DD_APPSEC_OBFUSCATION_PARAMETER_KEY_REGEXP,
          obfuscatorValueRegex: DD_APPSEC_OBFUSCATION_PARAMETER_VALUE_REGEXP,
          blockedTemplateHtml: DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML,
          blockedTemplateJson: DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON
        };
        this.remoteConfig = {
          enabled: DD_REMOTE_CONFIGURATION_ENABLED,
          pollInterval: DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS
        };
        this.iast = {
          enabled: isTrue(DD_IAST_ENABLED),
          requestSampling: DD_IAST_REQUEST_SAMPLING,
          maxConcurrentRequests: DD_IAST_MAX_CONCURRENT_REQUESTS,
          maxContextOperations: DD_IAST_MAX_CONTEXT_OPERATIONS
        };
        this.isCiVisibility = isTrue(DD_IS_CIVISIBILITY);
        this.isIntelligentTestRunnerEnabled = this.isCiVisibility && isTrue(DD_CIVISIBILITY_ITR_ENABLED);
        this.isGitUploadEnabled = this.isCiVisibility && (this.isIntelligentTestRunnerEnabled || isTrue(DD_CIVISIBILITY_GIT_UPLOAD_ENABLED));
        this.stats = {
          enabled: isTrue(DD_TRACE_STATS_COMPUTATION_ENABLED)
        };
        tagger.add(this.tags, {
          service: this.service,
          env: this.env,
          version: this.version,
          "runtime-id": uuid()
        });
      }
    };
    __name(Config, "Config");
    function getAgentUrl(url, options) {
      if (url)
        return new URL2(url);
      if (os.type() === "Windows_NT")
        return;
      if (!options.hostname && !options.port && !process.env.DD_AGENT_HOST && !process.env.DD_TRACE_AGENT_HOSTNAME && !process.env.DD_TRACE_AGENT_PORT && fs.existsSync("/var/run/datadog/apm.socket")) {
        return new URL2("unix:///var/run/datadog/apm.socket");
      }
    }
    __name(getAgentUrl, "getAgentUrl");
    module2.exports = Config;
  }
});

// node_modules/module-details-from-path/index.js
var require_module_details_from_path = __commonJS({
  "node_modules/module-details-from-path/index.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    module2.exports = function(file) {
      var segments = file.split(path.sep);
      var index = segments.lastIndexOf("node_modules");
      if (index === -1)
        return;
      if (!segments[index + 1])
        return;
      var scoped = segments[index + 1][0] === "@";
      var name = scoped ? segments[index + 1] + "/" + segments[index + 2] : segments[index + 1];
      var offset = scoped ? 3 : 2;
      return {
        name,
        basedir: segments.slice(0, index + offset).join(path.sep),
        path: segments.slice(index + offset).join(path.sep)
      };
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/require-package-json.js
var require_require_package_json = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/require-package-json.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var fs = __require("fs");
    function requirePackageJson(name, module3) {
      if (path.isAbsolute(name)) {
        const candidate = path.join(name, "package.json");
        return JSON.parse(fs.readFileSync(candidate, "utf8"));
      }
      for (const modulePath of module3.paths) {
        const candidate = path.join(modulePath, name, "package.json");
        try {
          return JSON.parse(fs.readFileSync(candidate, "utf8"));
        } catch (e) {
          continue;
        }
      }
      throw new Error(`could not find ${name}/package.json`);
    }
    __name(requirePackageJson, "requirePackageJson");
    module2.exports = requirePackageJson;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/telemetry/send-data.js
var require_send_data = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/telemetry/send-data.js"(exports2, module2) {
    var request = require_request();
    var seqId = 0;
    function sendData(config, application, host, reqType, payload2 = {}) {
      const {
        hostname,
        port,
        url
      } = config;
      const { logger, tags, serviceMapping, ...trimmedPayload } = payload2;
      const options = {
        url,
        hostname,
        port,
        method: "POST",
        path: "/telemetry/proxy/api/v2/apmtelemetry",
        headers: {
          "content-type": "application/json",
          "dd-telemetry-api-version": "v1",
          "dd-telemetry-request-type": reqType
        }
      };
      const data = JSON.stringify({
        api_version: "v1",
        request_type: reqType,
        tracer_time: Math.floor(Date.now() / 1e3),
        runtime_id: config.tags["runtime-id"],
        seq_id: ++seqId,
        payload: trimmedPayload,
        application,
        host
      });
      request(data, options, () => {
      });
    }
    __name(sendData, "sendData");
    module2.exports = { sendData };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/telemetry/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/telemetry/dependencies.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var parse = require_module_details_from_path();
    var requirePackageJson = require_require_package_json();
    var { sendData } = require_send_data();
    var dc = __require("diagnostics_channel");
    var { fileURLToPath } = __require("url");
    var savedDependencies = /* @__PURE__ */ new Set();
    var detectedDependencyNames = /* @__PURE__ */ new Set();
    var FILE_URI_START = `file://`;
    var moduleLoadStartChannel = dc.channel("dd-trace:moduleLoadStart");
    var immediate;
    var config;
    var application;
    var host;
    function waitAndSend(config2, application2, host2) {
      if (!immediate) {
        immediate = setImmediate(() => {
          immediate = null;
          if (savedDependencies.size > 0) {
            const dependencies = Array.from(savedDependencies.values()).splice(0, 1e3).map((pair) => {
              savedDependencies.delete(pair);
              const [name, version] = pair.split(" ");
              return { name, version };
            });
            sendData(config2, application2, host2, "app-dependencies-loaded", { dependencies });
            if (savedDependencies.size > 0) {
              waitAndSend(config2, application2, host2);
            }
          }
        });
        immediate.unref();
      }
    }
    __name(waitAndSend, "waitAndSend");
    function onModuleLoad(data) {
      if (data) {
        let filename = data.filename;
        if (filename && filename.startsWith(FILE_URI_START)) {
          try {
            filename = fileURLToPath(filename);
          } catch (e) {
          }
        }
        const parseResult = filename && parse(filename);
        const request = data.request || parseResult && parseResult.name;
        if (filename && request && isDependency(filename, request) && !detectedDependencyNames.has(request)) {
          detectedDependencyNames.add(request);
          if (parseResult) {
            const { name, basedir } = parseResult;
            if (basedir) {
              try {
                const { version } = requirePackageJson(basedir, module2);
                savedDependencies.add(`${name} ${version}`);
                waitAndSend(config, application, host);
              } catch (e) {
              }
            }
          }
        }
      }
    }
    __name(onModuleLoad, "onModuleLoad");
    function start(_config, _application, _host) {
      config = _config;
      application = _application;
      host = _host;
      moduleLoadStartChannel.subscribe(onModuleLoad);
    }
    __name(start, "start");
    function isDependency(filename, request) {
      const isDependencyWithSlash = isDependencyWithSeparator(filename, request, "/");
      if (isDependencyWithSlash && process.platform === "win32") {
        return isDependencyWithSeparator(filename, request, path.sep);
      }
      return isDependencyWithSlash;
    }
    __name(isDependency, "isDependency");
    function isDependencyWithSeparator(filename, request, sep) {
      return request.indexOf(`..${sep}`) !== 0 && request.indexOf(`.${sep}`) !== 0 && request.indexOf(sep) !== 0 && request.indexOf(`:${sep}`) !== 1;
    }
    __name(isDependencyWithSeparator, "isDependencyWithSeparator");
    function stop() {
      config = null;
      application = null;
      host = null;
      detectedDependencyNames.clear();
      savedDependencies.clear();
      if (moduleLoadStartChannel.hasSubscribers) {
        moduleLoadStartChannel.unsubscribe(onModuleLoad);
      }
    }
    __name(stop, "stop");
    module2.exports = { start, stop };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/telemetry/index.js
var require_telemetry = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/telemetry/index.js"(exports2, module2) {
    "use strict";
    var tracerVersion = require_package().version;
    var os = __require("os");
    var dependencies = require_dependencies();
    var { sendData } = require_send_data();
    var HEARTBEAT_INTERVAL = process.env.DD_TELEMETRY_HEARTBEAT_INTERVAL ? Number(process.env.DD_TELEMETRY_HEARTBEAT_INTERVAL) * 1e3 : 6e4;
    var config;
    var pluginManager;
    var application;
    var host;
    var interval;
    var sentIntegrations = /* @__PURE__ */ new Set();
    function getIntegrations() {
      const newIntegrations = [];
      for (const pluginName in pluginManager._pluginsByName) {
        if (sentIntegrations.has(pluginName)) {
          continue;
        }
        newIntegrations.push({
          name: pluginName,
          enabled: pluginManager._pluginsByName[pluginName]._enabled,
          auto_enabled: true
        });
        sentIntegrations.add(pluginName);
      }
      return newIntegrations;
    }
    __name(getIntegrations, "getIntegrations");
    function flatten(input, result = [], prefix = [], traversedObjects = null) {
      traversedObjects = traversedObjects || /* @__PURE__ */ new WeakSet();
      if (traversedObjects.has(input)) {
        return;
      }
      traversedObjects.add(input);
      for (const [key, value] of Object.entries(input)) {
        if (typeof value === "object" && value !== null) {
          flatten(value, result, [...prefix, key], traversedObjects);
        } else {
          result.push({ name: [...prefix, key].join("."), value });
        }
      }
      return result;
    }
    __name(flatten, "flatten");
    function appStarted() {
      return {
        integrations: getIntegrations(),
        dependencies: [],
        configuration: flatten(config),
        additional_payload: []
      };
    }
    __name(appStarted, "appStarted");
    function onBeforeExit() {
      process.removeListener("beforeExit", onBeforeExit);
      sendData(config, application, host, "app-closing");
    }
    __name(onBeforeExit, "onBeforeExit");
    function createAppObject() {
      return {
        service_name: config.service,
        env: config.env,
        service_version: config.version,
        tracer_version: tracerVersion,
        language_name: "nodejs",
        language_version: process.versions.node
      };
    }
    __name(createAppObject, "createAppObject");
    function createHostObject() {
      const osName = os.type();
      if (osName === "Linux" || osName === "Darwin") {
        return {
          hostname: os.hostname(),
          os: osName,
          architecture: os.arch(),
          kernel_version: os.version(),
          kernel_release: os.release(),
          kernel_name: osName
        };
      }
      if (osName === "Windows_NT") {
        return {
          hostname: os.hostname(),
          os: osName,
          architecture: os.arch(),
          os_version: os.version()
        };
      }
      return {
        hostname: os.hostname(),
        os: osName
      };
    }
    __name(createHostObject, "createHostObject");
    function start(aConfig, thePluginManager) {
      if (!aConfig.telemetryEnabled) {
        return;
      }
      config = aConfig;
      pluginManager = thePluginManager;
      application = createAppObject();
      host = createHostObject();
      dependencies.start(config, application, host);
      sendData(config, application, host, "app-started", appStarted());
      interval = setInterval(() => {
        sendData(config, application, host, "app-heartbeat");
      }, HEARTBEAT_INTERVAL);
      interval.unref();
      process.on("beforeExit", onBeforeExit);
    }
    __name(start, "start");
    function stop() {
      if (!config) {
        return;
      }
      clearInterval(interval);
      process.removeListener("beforeExit", onBeforeExit);
    }
    __name(stop, "stop");
    function updateIntegrations() {
      if (!config || !config.telemetryEnabled) {
        return;
      }
      const integrations = getIntegrations();
      if (integrations.length === 0) {
        return;
      }
      sendData(config, application, host, "app-integrations-change", { integrations });
    }
    __name(updateIntegrations, "updateIntegrations");
    module2.exports = {
      start,
      stop,
      updateIntegrations
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js
var require_plugin = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/plugin.js"(exports2, module2) {
    "use strict";
    var dc = __require("diagnostics_channel");
    var { storage } = require_datadog_core();
    var Subscription = class {
      constructor(event, handler2) {
        this._channel = dc.channel(event);
        this._handler = (message, name) => {
          const store = storage.getStore();
          if (!store || !store.noop) {
            handler2(message, name);
          }
        };
      }
      enable() {
        this._channel.subscribe(this._handler);
      }
      disable() {
        this._channel.unsubscribe(this._handler);
      }
    };
    __name(Subscription, "Subscription");
    module2.exports = /* @__PURE__ */ __name(class Plugin {
      constructor(tracer2) {
        this._subscriptions = [];
        this._enabled = false;
        this._tracer = tracer2;
      }
      get tracer() {
        return this._tracer._tracer;
      }
      enter(span, store) {
        store = store || storage.getStore();
        storage.enterWith({ ...store, span });
      }
      skip() {
        storage.enterWith({ noop: true });
      }
      addSub(channelName, handler2) {
        this._subscriptions.push(new Subscription(channelName, handler2));
      }
      addError(error) {
        const store = storage.getStore();
        if (!store || !store.span)
          return;
        if (!store.span._spanContext._tags["error"]) {
          store.span.setTag("error", error || 1);
        }
      }
      configure(config) {
        if (typeof config === "boolean") {
          config = { enabled: config };
        }
        this.config = config;
        if (config.enabled && !this._enabled) {
          this._enabled = true;
          this._subscriptions.forEach((sub) => sub.enable());
        } else if (!config.enabled && this._enabled) {
          this._enabled = false;
          this._subscriptions.forEach((sub) => sub.disable());
        }
      }
    }, "Plugin");
  }
});

// node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js
var require_analytics_sampler = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/analytics_sampler.js"(exports2, module2) {
    "use strict";
    var { MEASURED } = require_tags();
    module2.exports = {
      sample(span, measured, measuredByDefault) {
        if (typeof measured === "object") {
          this.sample(span, measured[span.context()._name], measuredByDefault);
        } else if (measured !== void 0) {
          span.setTag(MEASURED, !!measured);
        } else if (measuredByDefault) {
          span.setTag(MEASURED, true);
        }
      }
    };
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/base.js
var require_base = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/base.js"(exports2, module2) {
    "use strict";
    var analyticsSampler = require_analytics_sampler();
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var BaseAwsSdkPlugin = class extends Plugin {
      get serviceIdentifier() {
        const id = this.constructor.name.toLowerCase();
        Object.defineProperty(this, "serviceIdentifier", {
          configurable: true,
          writable: true,
          enumerable: true,
          value: id
        });
        return id;
      }
      constructor(...args) {
        super(...args);
        this.addSub(`apm:aws:request:start:${this.serviceIdentifier}`, ({
          request,
          operation,
          awsRegion,
          awsService
        }) => {
          if (!this.isEnabled(request)) {
            return;
          }
          const serviceName = this.getServiceName();
          const childOf = this.tracer.scope().active();
          const tags = {
            "span.kind": "client",
            "service.name": serviceName,
            "aws.operation": operation,
            "aws.region": awsRegion,
            "aws.service": awsService,
            "component": "aws-sdk"
          };
          if (this.requestTags)
            this.requestTags.set(request, tags);
          const span = this.tracer.startSpan("aws.request", { childOf, tags });
          analyticsSampler.sample(span, this.config.measured);
          this.requestInject(span, request);
          const store = storage.getStore();
          this.enter(span, store);
        });
        this.addSub(`apm:aws:request:region:${this.serviceIdentifier}`, (region) => {
          const store = storage.getStore();
          if (!store)
            return;
          const { span } = store;
          if (!span)
            return;
          span.setTag("aws.region", region);
        });
        this.addSub(`apm:aws:request:complete:${this.serviceIdentifier}`, ({ response }) => {
          const store = storage.getStore();
          if (!store)
            return;
          const { span } = store;
          if (!span)
            return;
          this.addResponseTags(span, response);
          this.finish(span, response, response.error);
        });
      }
      requestInject(span, request) {
      }
      isEnabled(request) {
        return true;
      }
      addResponseTags(span, response) {
        if (!span || !response.request)
          return;
        const params = response.request.params;
        const operation = response.request.operation;
        const extraTags = this.generateTags(params, operation, response) || {};
        const tags = Object.assign({
          "aws.response.request_id": response.requestId,
          "resource.name": operation,
          "span.kind": "client"
        }, extraTags);
        span.addTags(tags);
      }
      generateTags() {
      }
      finish(span, response, err) {
        if (err) {
          span.setTag("error", err);
          if (err.requestId) {
            span.addTags({ "aws.response.request_id": err.requestId });
          }
        }
        if (response) {
          this.config.hooks.request(span, response);
        }
        span.finish();
      }
      configure(config) {
        super.configure(normalizeConfig(config, this.serviceIdentifier));
      }
      getServiceName() {
        return this.config.service ? this.config.service : `${this.tracer._service}-aws-${this.serviceIdentifier}`;
      }
    };
    __name(BaseAwsSdkPlugin, "BaseAwsSdkPlugin");
    function normalizeConfig(config, serviceIdentifier) {
      const hooks = getHooks(config);
      let specificConfig = config[serviceIdentifier];
      switch (typeof specificConfig) {
        case "undefined":
          specificConfig = {};
          break;
        case "boolean":
          specificConfig = { enabled: specificConfig };
          break;
      }
      return Object.assign({}, config, specificConfig, {
        splitByAwsService: config.splitByAwsService !== false,
        hooks
      });
    }
    __name(normalizeConfig, "normalizeConfig");
    function getHooks(config) {
      const noop = /* @__PURE__ */ __name(() => {
      }, "noop");
      const request = config.hooks && config.hooks.request || noop;
      return { request };
    }
    __name(getHooks, "getHooks");
    module2.exports = BaseAwsSdkPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js
var require_cloudwatchlogs = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base();
    var CloudwatchLogs = class extends BaseAwsSdkPlugin {
      generateTags(params, operation) {
        const tags = {};
        if (!params || !params.logGroupName)
          return tags;
        return Object.assign(tags, {
          "resource.name": `${operation} ${params.logGroupName}`,
          "aws.cloudwatch.logs.log_group_name": params.logGroupName
        });
      }
    };
    __name(CloudwatchLogs, "CloudwatchLogs");
    module2.exports = CloudwatchLogs;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js
var require_dynamodb = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/dynamodb.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base();
    var DynamoDb = class extends BaseAwsSdkPlugin {
      generateTags(params, operation, response) {
        const tags = {};
        if (params) {
          if (params.TableName) {
            Object.assign(tags, {
              "resource.name": `${operation} ${params.TableName}`,
              "aws.dynamodb.table_name": params.TableName
            });
          }
          if (params.RequestItems) {
            if (typeof params.RequestItems === "object") {
              if (Object.keys(params.RequestItems).length === 1) {
                const tableName = Object.keys(params.RequestItems)[0];
                Object.assign(tags, {
                  "resource.name": `${operation} ${tableName}`,
                  "aws.dynamodb.table_name": tableName
                });
              }
            }
          }
        }
        Object.assign(tags, {
          "span.type": "dynamodb"
        });
        return tags;
      }
    };
    __name(DynamoDb, "DynamoDb");
    module2.exports = DynamoDb;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/eventbridge.js
var require_eventbridge = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/eventbridge.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var BaseAwsSdkPlugin = require_base();
    var EventBridge = class extends BaseAwsSdkPlugin {
      generateTags(params, operation, response) {
        if (!params || !params.source)
          return {};
        return {
          "resource.name": `${operation} ${params.source}`,
          "aws.eventbridge.source": params.source
        };
      }
      requestInject(span, request) {
        const operation = request.operation;
        if (operation === "putEvents" && request.params && request.params.Entries && request.params.Entries.length > 0 && request.params.Entries[0].Detail) {
          try {
            const details = JSON.parse(request.params.Entries[0].Detail);
            details._datadog = {};
            this.tracer.inject(span, "text_map", details._datadog);
            const finalData = JSON.stringify(details);
            const byteSize = Buffer.byteLength(finalData);
            if (byteSize >= 1024 * 256) {
              log.info("Payload size too large to pass context");
              return;
            }
            request.params.Entries[0].Detail = finalData;
          } catch (e) {
            log.error(e);
          }
        }
      }
    };
    __name(EventBridge, "EventBridge");
    module2.exports = EventBridge;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js
var require_kinesis = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/kinesis.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var BaseAwsSdkPlugin = require_base();
    var Kinesis = class extends BaseAwsSdkPlugin {
      generateTags(params, operation, response) {
        if (!params || !params.StreamName)
          return {};
        return {
          "resource.name": `${operation} ${params.StreamName}`,
          "aws.kinesis.stream_name": params.StreamName
        };
      }
      _tryParse(body) {
        try {
          return JSON.parse(body);
        } catch (e) {
          log.info("Not JSON string. Trying Base64 encoded JSON string");
        }
        try {
          return JSON.parse(Buffer.from(body, "base64").toString("ascii"), true);
        } catch (e) {
          return null;
        }
      }
      requestInject(span, request) {
        const operation = request.operation;
        if (operation === "putRecord" || operation === "putRecords") {
          if (!request.params) {
            return;
          }
          const traceData = {};
          this.tracer.inject(span, "text_map", traceData);
          let injectPath;
          if (request.params.Records && request.params.Records.length > 0) {
            injectPath = request.params.Records[0];
          } else if (request.params.Data) {
            injectPath = request.params;
          } else {
            log.error("No valid payload passed, unable to pass trace context");
            return;
          }
          const parsedData = this._tryParse(injectPath.Data);
          if (parsedData) {
            parsedData._datadog = traceData;
            const finalData = Buffer.from(JSON.stringify(parsedData));
            const byteSize = finalData.length;
            if (byteSize >= 1048576) {
              log.info("Payload size too large to pass context");
              return;
            }
            injectPath.Data = finalData;
          } else {
            log.error("Unable to parse payload, unable to pass trace context");
          }
        }
      }
    };
    __name(Kinesis, "Kinesis");
    module2.exports = Kinesis;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/lambda.js
var require_lambda = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/lambda.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var BaseAwsSdkPlugin = require_base();
    var Lambda = class extends BaseAwsSdkPlugin {
      generateTags(params, operation, response) {
        const tags = {};
        if (!params || !params.FunctionName)
          return tags;
        return Object.assign(tags, {
          "resource.name": `${operation} ${params.FunctionName}`,
          "aws.lambda": params.FunctionName
        });
      }
      requestInject(span, request) {
        const operation = request.operation;
        if (operation === "invoke") {
          if (!request.params) {
            request.params = {};
          }
          const isSyncInvocation = !request.params.InvocationType || request.params.InvocationType === "RequestResponse";
          if (isSyncInvocation) {
            try {
              let clientContext = {};
              if (request.params.ClientContext) {
                const clientContextJson = Buffer.from(request.params.ClientContext, "base64").toString("utf-8");
                clientContext = JSON.parse(clientContextJson);
              }
              if (!clientContext.custom) {
                clientContext.custom = {};
              }
              this.tracer.inject(span, "text_map", clientContext.custom);
              const newContextBase64 = Buffer.from(JSON.stringify(clientContext)).toString("base64");
              request.params.ClientContext = newContextBase64;
            } catch (err) {
              log.error(err);
            }
          }
        }
      }
    };
    __name(Lambda, "Lambda");
    module2.exports = Lambda;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js
var require_redshift = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/redshift.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base();
    var Redshift = class extends BaseAwsSdkPlugin {
      generateTags(params, operation, response) {
        const tags = {};
        if (!params || !params.ClusterIdentifier)
          return tags;
        return Object.assign(tags, {
          "resource.name": `${operation} ${params.ClusterIdentifier}`,
          "aws.redshift.cluster_identifier": params.ClusterIdentifier
        });
      }
    };
    __name(Redshift, "Redshift");
    module2.exports = Redshift;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js
var require_s3 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/s3.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base();
    var S3 = class extends BaseAwsSdkPlugin {
      generateTags(params, operation, response) {
        const tags = {};
        if (!params || !params.Bucket)
          return tags;
        return Object.assign(tags, {
          "resource.name": `${operation} ${params.Bucket}`,
          "aws.s3.bucket_name": params.Bucket
        });
      }
    };
    __name(S3, "S3");
    module2.exports = S3;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js
var require_sns = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sns.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var BaseAwsSdkPlugin = require_base();
    var Sns = class extends BaseAwsSdkPlugin {
      generateTags(params, operation, response) {
        if (!params)
          return {};
        if (!params.TopicArn && !(response.data && response.data.TopicArn))
          return {};
        return {
          "resource.name": `${operation} ${params.TopicArn || response.data.TopicArn}`,
          "aws.sns.topic_arn": params.TopicArn || response.data.TopicArn
        };
      }
      requestInject(span, request) {
        const { operation, params } = request;
        if (!params)
          return;
        switch (operation) {
          case "publish":
            this._injectMessageAttributes(span, params);
            break;
          case "publishBatch":
            if (params.PublishBatchRequestEntries && params.PublishBatchRequestEntries.length > 0) {
              this._injectMessageAttributes(span, params.PublishBatchRequestEntries[0]);
            }
            break;
        }
      }
      _injectMessageAttributes(span, params) {
        if (!params.MessageAttributes) {
          params.MessageAttributes = {};
        }
        if (Object.keys(params.MessageAttributes).length >= 10) {
          log.info("Message attributes full, skipping trace context injection");
          return;
        }
        const ddInfo = {};
        this.tracer.inject(span, "text_map", ddInfo);
        params.MessageAttributes._datadog = {
          DataType: "Binary",
          BinaryValue: Buffer.from(JSON.stringify(ddInfo))
        };
      }
    };
    __name(Sns, "Sns");
    module2.exports = Sns;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js
var require_sqs = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/sqs.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var BaseAwsSdkPlugin = require_base();
    var { storage } = require_datadog_core();
    var Sqs = class extends BaseAwsSdkPlugin {
      constructor(...args) {
        super(...args);
        this.requestTags = /* @__PURE__ */ new WeakMap();
        this.addSub("apm:aws:response:start:sqs", (obj) => {
          const { request, response } = obj;
          const store = storage.getStore();
          const plugin = this;
          const maybeChildOf = this.responseExtract(request.params, request.operation, response);
          if (maybeChildOf) {
            obj.needsFinish = true;
            const options = {
              childOf: maybeChildOf,
              tags: Object.assign(
                {},
                this.requestTags.get(request) || {},
                { "span.kind": "server" }
              )
            };
            const span = plugin.tracer.startSpan("aws.response", options);
            this.enter(span, store);
          }
        });
        this.addSub("apm:aws:response:finish:sqs", (err) => {
          const { span } = storage.getStore();
          this.finish(span, null, err);
        });
      }
      isEnabled(request) {
        const config = this.config;
        switch (request.operation) {
          case "receiveMessage":
            return config.consumer !== false;
          case "sendMessage":
          case "sendMessageBatch":
            return config.producer !== false;
          default:
            return true;
        }
      }
      generateTags(params, operation, response) {
        const tags = {};
        if (!params || !params.QueueName && !params.QueueUrl)
          return tags;
        Object.assign(tags, {
          "resource.name": `${operation} ${params.QueueName || params.QueueUrl}`,
          "aws.sqs.queue_name": params.QueueName || params.QueueUrl
        });
        switch (operation) {
          case "receiveMessage":
            tags["span.type"] = "worker";
            tags["span.kind"] = "consumer";
            break;
          case "sendMessage":
          case "sendMessageBatch":
            tags["span.kind"] = "producer";
            break;
        }
        return tags;
      }
      responseExtract(params, operation, response) {
        if (operation !== "receiveMessage")
          return;
        if (params.MaxNumberOfMessages && params.MaxNumberOfMessages !== 1)
          return;
        if (!response || !response.Messages || !response.Messages[0])
          return;
        let message = response.Messages[0];
        if (message.Body) {
          try {
            const body = JSON.parse(message.Body);
            if (body.Type === "Notification") {
              message = body;
            }
          } catch (e) {
          }
        }
        if (!message.MessageAttributes || !message.MessageAttributes._datadog)
          return;
        const datadogAttribute = message.MessageAttributes._datadog;
        try {
          if (datadogAttribute.StringValue) {
            const textMap = datadogAttribute.StringValue;
            return this.tracer.extract("text_map", JSON.parse(textMap));
          } else if (datadogAttribute.Type === "Binary") {
            const buffer = Buffer.from(datadogAttribute.Value, "base64");
            return this.tracer.extract("text_map", JSON.parse(buffer));
          }
        } catch (e) {
          log.error(e);
        }
      }
      requestInject(span, request) {
        const operation = request.operation;
        if (operation === "sendMessage") {
          if (!request.params) {
            request.params = {};
          }
          if (!request.params.MessageAttributes) {
            request.params.MessageAttributes = {};
          } else if (Object.keys(request.params.MessageAttributes).length >= 10) {
            return;
          }
          const ddInfo = {};
          this.tracer.inject(span, "text_map", ddInfo);
          request.params.MessageAttributes._datadog = {
            DataType: "String",
            StringValue: JSON.stringify(ddInfo)
          };
        }
      }
    };
    __name(Sqs, "Sqs");
    module2.exports = Sqs;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/default.js
var require_default = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/default.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base();
    var Default = class extends BaseAwsSdkPlugin {
    };
    __name(Default, "Default");
    module2.exports = Default;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/index.js
var require_services = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/services/index.js"(exports2) {
    "use strict";
    exports2.cloudwatchlogs = require_cloudwatchlogs();
    exports2.dynamodb = require_dynamodb();
    exports2.eventbridge = require_eventbridge();
    exports2.kinesis = require_kinesis();
    exports2.lambda = require_lambda();
    exports2.redshift = require_redshift();
    exports2.s3 = require_s3();
    exports2.sns = require_sns();
    exports2.sqs = require_sqs();
    exports2.default = require_default();
  }
});

// node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js
var require_src = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-aws-sdk/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var services = require_services();
    var AwsSdkPlugin = class extends Plugin {
      static get name() {
        return "aws-sdk";
      }
      constructor(...args) {
        super(...args);
        this.services = {};
        for (const name in services) {
          const ServicePlugin = services[name];
          this.services[name] = new ServicePlugin(...args);
        }
      }
      configure(config) {
        for (const service of Object.values(this.services)) {
          service.configure(config);
        }
      }
    };
    module2.exports = AwsSdkPlugin;
  }
});

// node_modules/istanbul-lib-coverage/lib/percent.js
var require_percent = __commonJS({
  "node_modules/istanbul-lib-coverage/lib/percent.js"(exports2, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ __name(function percent(covered, total) {
      let tmp;
      if (total > 0) {
        tmp = 1e3 * 100 * covered / total;
        return Math.floor(tmp / 10) / 100;
      } else {
        return 100;
      }
    }, "percent");
  }
});

// node_modules/istanbul-lib-coverage/lib/data-properties.js
var require_data_properties = __commonJS({
  "node_modules/istanbul-lib-coverage/lib/data-properties.js"(exports2, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ __name(function dataProperties(klass, properties) {
      properties.forEach((p) => {
        Object.defineProperty(klass.prototype, p, {
          enumerable: true,
          get() {
            return this.data[p];
          }
        });
      });
    }, "dataProperties");
  }
});

// node_modules/istanbul-lib-coverage/lib/coverage-summary.js
var require_coverage_summary = __commonJS({
  "node_modules/istanbul-lib-coverage/lib/coverage-summary.js"(exports2, module2) {
    "use strict";
    var percent = require_percent();
    var dataProperties = require_data_properties();
    function blankSummary() {
      const empty = /* @__PURE__ */ __name(() => ({
        total: 0,
        covered: 0,
        skipped: 0,
        pct: "Unknown"
      }), "empty");
      return {
        lines: empty(),
        statements: empty(),
        functions: empty(),
        branches: empty(),
        branchesTrue: empty()
      };
    }
    __name(blankSummary, "blankSummary");
    function assertValidSummary(obj) {
      const valid = obj && obj.lines && obj.statements && obj.functions && obj.branches;
      if (!valid) {
        throw new Error(
          "Invalid summary coverage object, missing keys, found:" + Object.keys(obj).join(",")
        );
      }
    }
    __name(assertValidSummary, "assertValidSummary");
    var CoverageSummary = class {
      constructor(obj) {
        if (!obj) {
          this.data = blankSummary();
        } else if (obj instanceof CoverageSummary) {
          this.data = obj.data;
        } else {
          this.data = obj;
        }
        assertValidSummary(this.data);
      }
      merge(obj) {
        const keys = [
          "lines",
          "statements",
          "branches",
          "functions",
          "branchesTrue"
        ];
        keys.forEach((key) => {
          if (obj[key]) {
            this[key].total += obj[key].total;
            this[key].covered += obj[key].covered;
            this[key].skipped += obj[key].skipped;
            this[key].pct = percent(this[key].covered, this[key].total);
          }
        });
        return this;
      }
      toJSON() {
        return this.data;
      }
      isEmpty() {
        return this.lines.total === 0;
      }
    };
    __name(CoverageSummary, "CoverageSummary");
    dataProperties(CoverageSummary, [
      "lines",
      "statements",
      "functions",
      "branches",
      "branchesTrue"
    ]);
    module2.exports = {
      CoverageSummary
    };
  }
});

// node_modules/istanbul-lib-coverage/lib/file-coverage.js
var require_file_coverage = __commonJS({
  "node_modules/istanbul-lib-coverage/lib/file-coverage.js"(exports2, module2) {
    "use strict";
    var percent = require_percent();
    var dataProperties = require_data_properties();
    var { CoverageSummary } = require_coverage_summary();
    function emptyCoverage(filePath, reportLogic) {
      const cov = {
        path: filePath,
        statementMap: {},
        fnMap: {},
        branchMap: {},
        s: {},
        f: {},
        b: {}
      };
      if (reportLogic)
        cov.bT = {};
      return cov;
    }
    __name(emptyCoverage, "emptyCoverage");
    function assertValidObject(obj) {
      const valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;
      if (!valid) {
        throw new Error(
          "Invalid file coverage object, missing keys, found:" + Object.keys(obj).join(",")
        );
      }
    }
    __name(assertValidObject, "assertValidObject");
    var keyFromLoc = /* @__PURE__ */ __name(({ start, end }) => `${start.line}|${start.column}|${end.line}|${end.column}`, "keyFromLoc");
    var mergeProp = /* @__PURE__ */ __name((aHits, aMap, bHits, bMap, itemKey = keyFromLoc) => {
      const aItems = {};
      for (const [key, itemHits] of Object.entries(aHits)) {
        const item = aMap[key];
        aItems[itemKey(item)] = [itemHits, item];
      }
      for (const [key, bItemHits] of Object.entries(bHits)) {
        const bItem = bMap[key];
        const k = itemKey(bItem);
        if (aItems[k]) {
          const aPair = aItems[k];
          if (bItemHits.forEach) {
            bItemHits.forEach((hits2, h) => {
              if (aPair[0][h] !== void 0)
                aPair[0][h] += hits2;
              else
                aPair[0][h] = hits2;
            });
          } else {
            aPair[0] += bItemHits;
          }
        } else {
          aItems[k] = [bItemHits, bItem];
        }
      }
      const hits = {};
      const map = {};
      Object.values(aItems).forEach(([itemHits, item], i) => {
        hits[i] = itemHits;
        map[i] = item;
      });
      return [hits, map];
    }, "mergeProp");
    var FileCoverage = class {
      constructor(pathOrObj, reportLogic = false) {
        if (!pathOrObj) {
          throw new Error(
            "Coverage must be initialized with a path or an object"
          );
        }
        if (typeof pathOrObj === "string") {
          this.data = emptyCoverage(pathOrObj, reportLogic);
        } else if (pathOrObj instanceof FileCoverage) {
          this.data = pathOrObj.data;
        } else if (typeof pathOrObj === "object") {
          this.data = pathOrObj;
        } else {
          throw new Error("Invalid argument to coverage constructor");
        }
        assertValidObject(this.data);
      }
      getLineCoverage() {
        const statementMap = this.data.statementMap;
        const statements = this.data.s;
        const lineMap = /* @__PURE__ */ Object.create(null);
        Object.entries(statements).forEach(([st, count]) => {
          if (!statementMap[st]) {
            return;
          }
          const { line } = statementMap[st].start;
          const prevVal = lineMap[line];
          if (prevVal === void 0 || prevVal < count) {
            lineMap[line] = count;
          }
        });
        return lineMap;
      }
      getUncoveredLines() {
        const lc = this.getLineCoverage();
        const ret = [];
        Object.entries(lc).forEach(([l, hits]) => {
          if (hits === 0) {
            ret.push(l);
          }
        });
        return ret;
      }
      getBranchCoverageByLine() {
        const branchMap = this.branchMap;
        const branches = this.b;
        const ret = {};
        Object.entries(branchMap).forEach(([k, map]) => {
          const line = map.line || map.loc.start.line;
          const branchData = branches[k];
          ret[line] = ret[line] || [];
          ret[line].push(...branchData);
        });
        Object.entries(ret).forEach(([k, dataArray]) => {
          const covered = dataArray.filter((item) => item > 0);
          const coverage = covered.length / dataArray.length * 100;
          ret[k] = {
            covered: covered.length,
            total: dataArray.length,
            coverage
          };
        });
        return ret;
      }
      toJSON() {
        return this.data;
      }
      merge(other) {
        if (other.all === true) {
          return;
        }
        if (this.all === true) {
          this.data = other.data;
          return;
        }
        let [hits, map] = mergeProp(
          this.s,
          this.statementMap,
          other.s,
          other.statementMap
        );
        this.data.s = hits;
        this.data.statementMap = map;
        const keyFromLocProp = /* @__PURE__ */ __name((x) => keyFromLoc(x.loc), "keyFromLocProp");
        const keyFromLocationsProp = /* @__PURE__ */ __name((x) => keyFromLoc(x.locations[0]), "keyFromLocationsProp");
        [hits, map] = mergeProp(
          this.f,
          this.fnMap,
          other.f,
          other.fnMap,
          keyFromLocProp
        );
        this.data.f = hits;
        this.data.fnMap = map;
        [hits, map] = mergeProp(
          this.b,
          this.branchMap,
          other.b,
          other.branchMap,
          keyFromLocationsProp
        );
        this.data.b = hits;
        this.data.branchMap = map;
        if (this.bT && other.bT) {
          [hits, map] = mergeProp(
            this.bT,
            this.branchMap,
            other.bT,
            other.branchMap,
            keyFromLocationsProp
          );
          this.data.bT = hits;
        }
      }
      computeSimpleTotals(property) {
        let stats = this[property];
        if (typeof stats === "function") {
          stats = stats.call(this);
        }
        const ret = {
          total: Object.keys(stats).length,
          covered: Object.values(stats).filter((v) => !!v).length,
          skipped: 0
        };
        ret.pct = percent(ret.covered, ret.total);
        return ret;
      }
      computeBranchTotals(property) {
        const stats = this[property];
        const ret = { total: 0, covered: 0, skipped: 0 };
        Object.values(stats).forEach((branches) => {
          ret.covered += branches.filter((hits) => hits > 0).length;
          ret.total += branches.length;
        });
        ret.pct = percent(ret.covered, ret.total);
        return ret;
      }
      resetHits() {
        const statements = this.s;
        const functions = this.f;
        const branches = this.b;
        const branchesTrue = this.bT;
        Object.keys(statements).forEach((s) => {
          statements[s] = 0;
        });
        Object.keys(functions).forEach((f) => {
          functions[f] = 0;
        });
        Object.keys(branches).forEach((b) => {
          branches[b].fill(0);
        });
        if (branchesTrue) {
          Object.keys(branchesTrue).forEach((bT) => {
            branchesTrue[bT].fill(0);
          });
        }
      }
      toSummary() {
        const ret = {};
        ret.lines = this.computeSimpleTotals("getLineCoverage");
        ret.functions = this.computeSimpleTotals("f", "fnMap");
        ret.statements = this.computeSimpleTotals("s", "statementMap");
        ret.branches = this.computeBranchTotals("b");
        if (this["bt"]) {
          ret.branchesTrue = this.computeBranchTotals("bT");
        }
        return new CoverageSummary(ret);
      }
    };
    __name(FileCoverage, "FileCoverage");
    dataProperties(FileCoverage, [
      "path",
      "statementMap",
      "fnMap",
      "branchMap",
      "s",
      "f",
      "b",
      "bT",
      "all"
    ]);
    module2.exports = {
      FileCoverage
    };
  }
});

// node_modules/istanbul-lib-coverage/lib/coverage-map.js
var require_coverage_map = __commonJS({
  "node_modules/istanbul-lib-coverage/lib/coverage-map.js"(exports2, module2) {
    "use strict";
    var { FileCoverage } = require_file_coverage();
    var { CoverageSummary } = require_coverage_summary();
    function maybeConstruct(obj, klass) {
      if (obj instanceof klass) {
        return obj;
      }
      return new klass(obj);
    }
    __name(maybeConstruct, "maybeConstruct");
    function loadMap(source) {
      const data = /* @__PURE__ */ Object.create(null);
      if (!source) {
        return data;
      }
      Object.entries(source).forEach(([k, cov]) => {
        data[k] = maybeConstruct(cov, FileCoverage);
      });
      return data;
    }
    __name(loadMap, "loadMap");
    var CoverageMap = class {
      constructor(obj) {
        if (obj instanceof CoverageMap) {
          this.data = obj.data;
        } else {
          this.data = loadMap(obj);
        }
      }
      merge(obj) {
        const other = maybeConstruct(obj, CoverageMap);
        Object.values(other.data).forEach((fc) => {
          this.addFileCoverage(fc);
        });
      }
      filter(callback) {
        Object.keys(this.data).forEach((k) => {
          if (!callback(k)) {
            delete this.data[k];
          }
        });
      }
      toJSON() {
        return this.data;
      }
      files() {
        return Object.keys(this.data);
      }
      fileCoverageFor(file) {
        const fc = this.data[file];
        if (!fc) {
          throw new Error(`No file coverage available for: ${file}`);
        }
        return fc;
      }
      addFileCoverage(fc) {
        const cov = new FileCoverage(fc);
        const { path } = cov;
        if (this.data[path]) {
          this.data[path].merge(cov);
        } else {
          this.data[path] = cov;
        }
      }
      getCoverageSummary() {
        const ret = new CoverageSummary();
        Object.values(this.data).forEach((fc) => {
          ret.merge(fc.toSummary());
        });
        return ret;
      }
    };
    __name(CoverageMap, "CoverageMap");
    module2.exports = {
      CoverageMap
    };
  }
});

// node_modules/istanbul-lib-coverage/index.js
var require_istanbul_lib_coverage = __commonJS({
  "node_modules/istanbul-lib-coverage/index.js"(exports2, module2) {
    "use strict";
    var { FileCoverage } = require_file_coverage();
    var { CoverageMap } = require_coverage_map();
    var { CoverageSummary } = require_coverage_summary();
    module2.exports = {
      createCoverageSummary(obj) {
        if (obj && obj instanceof CoverageSummary) {
          return obj;
        }
        return new CoverageSummary(obj);
      },
      createCoverageMap(obj) {
        if (obj && obj instanceof CoverageMap) {
          return obj;
        }
        return new CoverageMap(obj);
      },
      createFileCoverage(obj) {
        if (obj && obj instanceof FileCoverage) {
          return obj;
        }
        return new FileCoverage(obj);
      }
    };
    module2.exports.classes = {
      FileCoverage
    };
  }
});

// node_modules/ignore/index.js
var require_ignore = __commonJS({
  "node_modules/ignore/index.js"(exports2, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    __name(makeArray, "makeArray");
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define2 = /* @__PURE__ */ __name((object, key, value) => Object.defineProperty(object, key, { value }), "define");
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = /* @__PURE__ */ __name(() => false, "RETURN_FALSE");
    var sanitizeRange = /* @__PURE__ */ __name((range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    ), "sanitizeRange");
    var cleanRangeBackSlash = /* @__PURE__ */ __name((slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    }, "cleanRangeBackSlash");
    var REPLACERS = [
      [
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      [
        /\\\s/g,
        () => SPACE
      ],
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      [
        /^\//,
        () => "^"
      ],
      [
        /\//g,
        () => "\\/"
      ],
      [
        /^\^*\\\*\\\*\\\//,
        () => "^(?:.*\\/)?"
      ],
      [
        /^(?=[^^])/,
        /* @__PURE__ */ __name(function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }, "startingReplacer")
      ],
      [
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      [
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        /\\\\/g,
        () => ESCAPE
      ],
      [
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      [
        /(?:[^*])$/,
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = /* @__PURE__ */ __name((pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    }, "makeRegex");
    var isString = /* @__PURE__ */ __name((subject) => typeof subject === "string", "isString");
    var checkPattern = /* @__PURE__ */ __name((pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0, "checkPattern");
    var splitPattern = /* @__PURE__ */ __name((pattern) => pattern.split(REGEX_SPLITALL_CRLF), "splitPattern");
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    __name(IgnoreRule, "IgnoreRule");
    var createRule = /* @__PURE__ */ __name((pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    }, "createRule");
    var throwError = /* @__PURE__ */ __name((message, Ctor) => {
      throw new Ctor(message);
    }, "throwError");
    var checkPath = /* @__PURE__ */ __name((path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    }, "checkPath");
    var isNotRelative = /* @__PURE__ */ __name((path) => REGEX_TEST_INVALID_PATH.test(path), "isNotRelative");
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      addPattern(pattern) {
        return this.add(pattern);
      }
      _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(
          path,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path, cache, checkUnignored, slices);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._testOne(path, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    __name(Ignore, "Ignore");
    var factory = /* @__PURE__ */ __name((options) => new Ignore(options), "factory");
    var isPathValid = /* @__PURE__ */ __name((path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE), "isPathValid");
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
      const makePosix = /* @__PURE__ */ __name((str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/"), "makePosix");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    }
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/ci.js
var require_ci = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/ci.js"(exports2, module2) {
    var URL2 = __require("url").URL;
    var {
      GIT_BRANCH,
      GIT_COMMIT_SHA,
      GIT_TAG,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_REPOSITORY_URL,
      CI_PIPELINE_ID,
      CI_PIPELINE_NAME,
      CI_PIPELINE_NUMBER,
      CI_PIPELINE_URL,
      CI_PROVIDER_NAME,
      CI_WORKSPACE_PATH,
      CI_JOB_URL,
      CI_JOB_NAME,
      CI_STAGE_NAME,
      CI_ENV_VARS,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_COMMITTER_EMAIL
    } = require_tags2();
    function parseEmailAndName(emailAndName) {
      if (!emailAndName) {
        return { name: "", email: "" };
      }
      let name = "";
      let email = "";
      const matchNameAndEmail = emailAndName.match(/(?:"?([^"]*)"?\s)?(?:<?(.+@[^>]+)>?)/);
      if (matchNameAndEmail) {
        name = matchNameAndEmail[1];
        email = matchNameAndEmail[2];
      }
      return { name, email };
    }
    __name(parseEmailAndName, "parseEmailAndName");
    function removeEmptyValues(tags) {
      return Object.keys(tags).reduce((filteredTags, tag) => {
        if (!tags[tag]) {
          return filteredTags;
        }
        return {
          ...filteredTags,
          [tag]: tags[tag]
        };
      }, {});
    }
    __name(removeEmptyValues, "removeEmptyValues");
    function normalizeTag(targetTags, tagKey, normalize) {
      if (targetTags[tagKey]) {
        targetTags[tagKey] = normalize(targetTags[tagKey]);
      }
    }
    __name(normalizeTag, "normalizeTag");
    function normalizeRef(ref) {
      if (!ref) {
        return ref;
      }
      return ref.replace(/origin\/|refs\/heads\/|tags\//gm, "");
    }
    __name(normalizeRef, "normalizeRef");
    function filterSensitiveInfoFromRepository(repositoryUrl) {
      if (repositoryUrl.startsWith("git@")) {
        return repositoryUrl;
      }
      try {
        const { protocol, hostname, pathname } = new URL2(repositoryUrl);
        return `${protocol}//${hostname}${pathname}`;
      } catch (e) {
        return repositoryUrl;
      }
    }
    __name(filterSensitiveInfoFromRepository, "filterSensitiveInfoFromRepository");
    function resolveTilde(filePath) {
      if (!filePath || typeof filePath !== "string") {
        return "";
      }
      if (filePath[0] === "~" && (filePath[1] === "/" || filePath.length === 1)) {
        return filePath.replace("~", process.env.HOME);
      }
      return filePath;
    }
    __name(resolveTilde, "resolveTilde");
    module2.exports = {
      normalizeRef,
      getCIMetadata() {
        const { env } = process;
        let tags = {};
        if (env.JENKINS_URL) {
          const {
            WORKSPACE,
            BUILD_TAG,
            JOB_NAME,
            BUILD_NUMBER,
            BUILD_URL,
            GIT_BRANCH: JENKINS_GIT_BRANCH,
            GIT_COMMIT: JENKINS_GIT_COMMIT,
            GIT_URL: JENKINS_GIT_REPOSITORY_URL,
            GIT_URL_1: JENKINS_GIT_REPOSITORY_URL_1,
            DD_CUSTOM_TRACE_ID
          } = env;
          tags = {
            [CI_PIPELINE_ID]: BUILD_TAG,
            [CI_PIPELINE_NUMBER]: BUILD_NUMBER,
            [CI_PIPELINE_URL]: BUILD_URL,
            [CI_PROVIDER_NAME]: "jenkins",
            [GIT_COMMIT_SHA]: JENKINS_GIT_COMMIT,
            [GIT_REPOSITORY_URL]: JENKINS_GIT_REPOSITORY_URL || JENKINS_GIT_REPOSITORY_URL_1,
            [CI_WORKSPACE_PATH]: WORKSPACE,
            [CI_ENV_VARS]: JSON.stringify({ DD_CUSTOM_TRACE_ID })
          };
          const isTag = JENKINS_GIT_BRANCH && JENKINS_GIT_BRANCH.includes("tags/");
          const refKey = isTag ? GIT_TAG : GIT_BRANCH;
          const ref = normalizeRef(JENKINS_GIT_BRANCH);
          tags[refKey] = ref;
          let finalPipelineName = "";
          if (JOB_NAME) {
            const jobNameAndParams = JOB_NAME.split("/");
            if (jobNameAndParams.length > 1 && jobNameAndParams[1].includes("=")) {
              finalPipelineName = jobNameAndParams[0];
            } else {
              finalPipelineName = JOB_NAME.replace(`/${ref}`, "");
            }
            tags[CI_PIPELINE_NAME] = finalPipelineName;
          }
        }
        if (env.GITLAB_CI) {
          const {
            CI_PIPELINE_ID: GITLAB_PIPELINE_ID,
            CI_PROJECT_PATH,
            CI_PIPELINE_IID,
            CI_PIPELINE_URL: GITLAB_PIPELINE_URL,
            CI_PROJECT_DIR,
            CI_COMMIT_REF_NAME,
            CI_COMMIT_TAG,
            CI_COMMIT_SHA,
            CI_REPOSITORY_URL,
            CI_JOB_URL: GITLAB_CI_JOB_URL,
            CI_JOB_STAGE,
            CI_JOB_NAME: GITLAB_CI_JOB_NAME,
            CI_COMMIT_MESSAGE,
            CI_COMMIT_TIMESTAMP,
            CI_COMMIT_AUTHOR,
            CI_PROJECT_URL: GITLAB_PROJECT_URL,
            CI_JOB_ID: GITLAB_CI_JOB_ID
          } = env;
          const { name, email } = parseEmailAndName(CI_COMMIT_AUTHOR);
          tags = {
            [CI_PIPELINE_ID]: GITLAB_PIPELINE_ID,
            [CI_PIPELINE_NAME]: CI_PROJECT_PATH,
            [CI_PIPELINE_NUMBER]: CI_PIPELINE_IID,
            [CI_PROVIDER_NAME]: "gitlab",
            [GIT_COMMIT_SHA]: CI_COMMIT_SHA,
            [GIT_REPOSITORY_URL]: CI_REPOSITORY_URL,
            [CI_JOB_URL]: GITLAB_CI_JOB_URL,
            [GIT_TAG]: CI_COMMIT_TAG,
            [GIT_BRANCH]: CI_COMMIT_REF_NAME,
            [CI_WORKSPACE_PATH]: CI_PROJECT_DIR,
            [CI_PIPELINE_URL]: GITLAB_PIPELINE_URL && GITLAB_PIPELINE_URL.replace("/-/pipelines/", "/pipelines/"),
            [CI_STAGE_NAME]: CI_JOB_STAGE,
            [CI_JOB_NAME]: GITLAB_CI_JOB_NAME,
            [GIT_COMMIT_MESSAGE]: CI_COMMIT_MESSAGE,
            [GIT_COMMIT_AUTHOR_NAME]: name,
            [GIT_COMMIT_AUTHOR_EMAIL]: email,
            [GIT_COMMIT_AUTHOR_DATE]: CI_COMMIT_TIMESTAMP,
            [CI_ENV_VARS]: JSON.stringify({
              CI_PROJECT_URL: GITLAB_PROJECT_URL,
              CI_PIPELINE_ID: GITLAB_PIPELINE_ID,
              CI_JOB_ID: GITLAB_CI_JOB_ID
            })
          };
        }
        if (env.CIRCLECI) {
          const {
            CIRCLE_WORKFLOW_ID,
            CIRCLE_PROJECT_REPONAME,
            CIRCLE_BUILD_URL,
            CIRCLE_WORKING_DIRECTORY,
            CIRCLE_BRANCH,
            CIRCLE_TAG,
            CIRCLE_SHA1,
            CIRCLE_REPOSITORY_URL,
            CIRCLE_JOB,
            CIRCLE_BUILD_NUM
          } = env;
          const pipelineUrl = `https://app.circleci.com/pipelines/workflows/${CIRCLE_WORKFLOW_ID}`;
          tags = {
            [CI_PIPELINE_ID]: CIRCLE_WORKFLOW_ID,
            [CI_PIPELINE_NAME]: CIRCLE_PROJECT_REPONAME,
            [CI_PIPELINE_URL]: pipelineUrl,
            [CI_JOB_NAME]: CIRCLE_JOB,
            [CI_PROVIDER_NAME]: "circleci",
            [GIT_COMMIT_SHA]: CIRCLE_SHA1,
            [GIT_REPOSITORY_URL]: CIRCLE_REPOSITORY_URL,
            [CI_JOB_URL]: CIRCLE_BUILD_URL,
            [CI_WORKSPACE_PATH]: CIRCLE_WORKING_DIRECTORY,
            [GIT_TAG]: CIRCLE_TAG,
            [GIT_BRANCH]: CIRCLE_BRANCH,
            [CI_ENV_VARS]: JSON.stringify({
              CIRCLE_WORKFLOW_ID,
              CIRCLE_BUILD_NUM
            })
          };
        }
        if (env.GITHUB_ACTIONS || env.GITHUB_ACTION) {
          const {
            GITHUB_RUN_ID,
            GITHUB_WORKFLOW,
            GITHUB_RUN_NUMBER,
            GITHUB_WORKSPACE,
            GITHUB_HEAD_REF,
            GITHUB_REF,
            GITHUB_SHA,
            GITHUB_REPOSITORY,
            GITHUB_SERVER_URL,
            GITHUB_RUN_ATTEMPT,
            GITHUB_JOB
          } = env;
          const repositoryURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git`;
          let pipelineURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`;
          if (GITHUB_RUN_ATTEMPT) {
            pipelineURL = `${pipelineURL}/attempts/${GITHUB_RUN_ATTEMPT}`;
          }
          const jobUrl = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}/checks`;
          const ref = GITHUB_HEAD_REF || GITHUB_REF || "";
          const refKey = ref.includes("tags/") ? GIT_TAG : GIT_BRANCH;
          tags = {
            [CI_PIPELINE_ID]: GITHUB_RUN_ID,
            [CI_PIPELINE_NAME]: GITHUB_WORKFLOW,
            [CI_PIPELINE_NUMBER]: GITHUB_RUN_NUMBER,
            [CI_PIPELINE_URL]: pipelineURL,
            [CI_PROVIDER_NAME]: "github",
            [GIT_COMMIT_SHA]: GITHUB_SHA,
            [GIT_REPOSITORY_URL]: repositoryURL,
            [CI_JOB_URL]: jobUrl,
            [CI_JOB_NAME]: GITHUB_JOB,
            [CI_WORKSPACE_PATH]: GITHUB_WORKSPACE,
            [refKey]: ref,
            [CI_ENV_VARS]: JSON.stringify({
              GITHUB_SERVER_URL,
              GITHUB_REPOSITORY,
              GITHUB_RUN_ID,
              GITHUB_RUN_ATTEMPT
            })
          };
        }
        if (env.APPVEYOR) {
          const {
            APPVEYOR_REPO_NAME,
            APPVEYOR_REPO_PROVIDER,
            APPVEYOR_BUILD_FOLDER,
            APPVEYOR_BUILD_ID,
            APPVEYOR_BUILD_NUMBER,
            APPVEYOR_REPO_COMMIT,
            APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH,
            APPVEYOR_REPO_BRANCH,
            APPVEYOR_REPO_TAG_NAME,
            APPVEYOR_REPO_COMMIT_AUTHOR,
            APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,
            APPVEYOR_REPO_COMMIT_MESSAGE,
            APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED
          } = env;
          const pipelineUrl = `https://ci.appveyor.com/project/${APPVEYOR_REPO_NAME}/builds/${APPVEYOR_BUILD_ID}`;
          tags = {
            [CI_PROVIDER_NAME]: "appveyor",
            [CI_PIPELINE_URL]: pipelineUrl,
            [CI_PIPELINE_ID]: APPVEYOR_BUILD_ID,
            [CI_PIPELINE_NAME]: APPVEYOR_REPO_NAME,
            [CI_PIPELINE_NUMBER]: APPVEYOR_BUILD_NUMBER,
            [CI_JOB_URL]: pipelineUrl,
            [CI_WORKSPACE_PATH]: APPVEYOR_BUILD_FOLDER,
            [GIT_COMMIT_AUTHOR_NAME]: APPVEYOR_REPO_COMMIT_AUTHOR,
            [GIT_COMMIT_AUTHOR_EMAIL]: APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,
            [GIT_COMMIT_MESSAGE]: APPVEYOR_REPO_COMMIT_MESSAGE + "\n" + APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED
          };
          if (APPVEYOR_REPO_PROVIDER === "github") {
            tags = {
              ...tags,
              [GIT_REPOSITORY_URL]: `https://github.com/${APPVEYOR_REPO_NAME}.git`,
              [GIT_COMMIT_SHA]: APPVEYOR_REPO_COMMIT,
              [GIT_TAG]: APPVEYOR_REPO_TAG_NAME,
              [GIT_BRANCH]: APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || APPVEYOR_REPO_BRANCH
            };
          }
        }
        if (env.TF_BUILD) {
          const {
            BUILD_SOURCESDIRECTORY,
            BUILD_BUILDID,
            BUILD_DEFINITIONNAME,
            SYSTEM_TEAMFOUNDATIONSERVERURI,
            SYSTEM_TEAMPROJECTID,
            SYSTEM_JOBID,
            SYSTEM_TASKINSTANCEID,
            SYSTEM_PULLREQUEST_SOURCEBRANCH,
            BUILD_SOURCEBRANCH,
            BUILD_SOURCEBRANCHNAME,
            SYSTEM_PULLREQUEST_SOURCECOMMITID,
            SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI,
            BUILD_REPOSITORY_URI,
            BUILD_SOURCEVERSION,
            BUILD_REQUESTEDFORID,
            BUILD_REQUESTEDFOREMAIL,
            BUILD_SOURCEVERSIONMESSAGE,
            SYSTEM_STAGEDISPLAYNAME,
            SYSTEM_JOBDISPLAYNAME
          } = env;
          const ref = SYSTEM_PULLREQUEST_SOURCEBRANCH || BUILD_SOURCEBRANCH || BUILD_SOURCEBRANCHNAME;
          const refKey = (ref || "").includes("tags/") ? GIT_TAG : GIT_BRANCH;
          tags = {
            [CI_PROVIDER_NAME]: "azurepipelines",
            [CI_PIPELINE_ID]: BUILD_BUILDID,
            [CI_PIPELINE_NAME]: BUILD_DEFINITIONNAME,
            [CI_PIPELINE_NUMBER]: BUILD_BUILDID,
            [GIT_COMMIT_SHA]: SYSTEM_PULLREQUEST_SOURCECOMMITID || BUILD_SOURCEVERSION,
            [CI_WORKSPACE_PATH]: BUILD_SOURCESDIRECTORY,
            [GIT_REPOSITORY_URL]: SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI || BUILD_REPOSITORY_URI,
            [refKey]: ref,
            [GIT_COMMIT_AUTHOR_NAME]: BUILD_REQUESTEDFORID,
            [GIT_COMMIT_AUTHOR_EMAIL]: BUILD_REQUESTEDFOREMAIL,
            [GIT_COMMIT_MESSAGE]: BUILD_SOURCEVERSIONMESSAGE,
            [CI_STAGE_NAME]: SYSTEM_STAGEDISPLAYNAME,
            [CI_JOB_NAME]: SYSTEM_JOBDISPLAYNAME,
            [CI_ENV_VARS]: JSON.stringify({ SYSTEM_TEAMPROJECTID, BUILD_BUILDID, SYSTEM_JOBID })
          };
          if (SYSTEM_TEAMFOUNDATIONSERVERURI && SYSTEM_TEAMPROJECTID && BUILD_BUILDID) {
            const baseUrl = `${SYSTEM_TEAMFOUNDATIONSERVERURI}${SYSTEM_TEAMPROJECTID}/_build/results?buildId=${BUILD_BUILDID}`;
            const pipelineUrl = baseUrl;
            const jobUrl = `${baseUrl}&view=logs&j=${SYSTEM_JOBID}&t=${SYSTEM_TASKINSTANCEID}`;
            tags = {
              ...tags,
              [CI_PIPELINE_URL]: pipelineUrl,
              [CI_JOB_URL]: jobUrl
            };
          }
        }
        if (env.BITBUCKET_COMMIT) {
          const {
            BITBUCKET_REPO_FULL_NAME,
            BITBUCKET_BUILD_NUMBER,
            BITBUCKET_BRANCH,
            BITBUCKET_COMMIT,
            BITBUCKET_GIT_SSH_ORIGIN,
            BITBUCKET_TAG,
            BITBUCKET_PIPELINE_UUID,
            BITBUCKET_CLONE_DIR
          } = env;
          const url = `https://bitbucket.org/${BITBUCKET_REPO_FULL_NAME}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER}`;
          tags = {
            [CI_PROVIDER_NAME]: "bitbucket",
            [GIT_COMMIT_SHA]: BITBUCKET_COMMIT,
            [CI_PIPELINE_NUMBER]: BITBUCKET_BUILD_NUMBER,
            [CI_PIPELINE_NAME]: BITBUCKET_REPO_FULL_NAME,
            [CI_JOB_URL]: url,
            [CI_PIPELINE_URL]: url,
            [GIT_BRANCH]: BITBUCKET_BRANCH,
            [GIT_TAG]: BITBUCKET_TAG,
            [GIT_REPOSITORY_URL]: BITBUCKET_GIT_SSH_ORIGIN,
            [CI_WORKSPACE_PATH]: BITBUCKET_CLONE_DIR,
            [CI_PIPELINE_ID]: BITBUCKET_PIPELINE_UUID && BITBUCKET_PIPELINE_UUID.replace(/{|}/gm, "")
          };
        }
        if (env.BITRISE_BUILD_SLUG) {
          const {
            BITRISE_GIT_COMMIT,
            GIT_CLONE_COMMIT_HASH,
            BITRISEIO_GIT_BRANCH_DEST,
            BITRISE_GIT_BRANCH,
            BITRISE_BUILD_SLUG,
            BITRISE_TRIGGERED_WORKFLOW_ID,
            BITRISE_BUILD_NUMBER,
            BITRISE_BUILD_URL,
            BITRISE_SOURCE_DIR,
            GIT_REPOSITORY_URL: BITRISE_GIT_REPOSITORY_URL,
            BITRISE_GIT_TAG,
            BITRISE_GIT_MESSAGE
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "bitrise",
            [CI_PIPELINE_ID]: BITRISE_BUILD_SLUG,
            [CI_PIPELINE_NAME]: BITRISE_TRIGGERED_WORKFLOW_ID,
            [CI_PIPELINE_NUMBER]: BITRISE_BUILD_NUMBER,
            [CI_PIPELINE_URL]: BITRISE_BUILD_URL,
            [GIT_COMMIT_SHA]: BITRISE_GIT_COMMIT || GIT_CLONE_COMMIT_HASH,
            [GIT_REPOSITORY_URL]: BITRISE_GIT_REPOSITORY_URL,
            [CI_WORKSPACE_PATH]: BITRISE_SOURCE_DIR,
            [GIT_TAG]: BITRISE_GIT_TAG,
            [GIT_BRANCH]: BITRISEIO_GIT_BRANCH_DEST || BITRISE_GIT_BRANCH,
            [GIT_COMMIT_MESSAGE]: BITRISE_GIT_MESSAGE
          };
        }
        if (env.BUILDKITE) {
          const {
            BUILDKITE_BRANCH,
            BUILDKITE_COMMIT,
            BUILDKITE_REPO,
            BUILDKITE_TAG,
            BUILDKITE_BUILD_ID,
            BUILDKITE_PIPELINE_SLUG,
            BUILDKITE_BUILD_NUMBER,
            BUILDKITE_BUILD_URL,
            BUILDKITE_JOB_ID,
            BUILDKITE_BUILD_CHECKOUT_PATH,
            BUILDKITE_BUILD_AUTHOR,
            BUILDKITE_BUILD_AUTHOR_EMAIL,
            BUILDKITE_MESSAGE
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "buildkite",
            [CI_PIPELINE_ID]: BUILDKITE_BUILD_ID,
            [CI_PIPELINE_NAME]: BUILDKITE_PIPELINE_SLUG,
            [CI_PIPELINE_NUMBER]: BUILDKITE_BUILD_NUMBER,
            [CI_PIPELINE_URL]: BUILDKITE_BUILD_URL,
            [CI_JOB_URL]: `${BUILDKITE_BUILD_URL}#${BUILDKITE_JOB_ID}`,
            [GIT_COMMIT_SHA]: BUILDKITE_COMMIT,
            [CI_WORKSPACE_PATH]: BUILDKITE_BUILD_CHECKOUT_PATH,
            [GIT_REPOSITORY_URL]: BUILDKITE_REPO,
            [GIT_TAG]: BUILDKITE_TAG,
            [GIT_BRANCH]: BUILDKITE_BRANCH,
            [GIT_COMMIT_AUTHOR_NAME]: BUILDKITE_BUILD_AUTHOR,
            [GIT_COMMIT_AUTHOR_EMAIL]: BUILDKITE_BUILD_AUTHOR_EMAIL,
            [GIT_COMMIT_MESSAGE]: BUILDKITE_MESSAGE,
            [CI_ENV_VARS]: JSON.stringify({
              BUILDKITE_BUILD_ID,
              BUILDKITE_JOB_ID
            })
          };
        }
        if (env.TRAVIS) {
          const {
            TRAVIS_PULL_REQUEST_BRANCH,
            TRAVIS_BRANCH,
            TRAVIS_COMMIT,
            TRAVIS_REPO_SLUG,
            TRAVIS_TAG,
            TRAVIS_JOB_WEB_URL,
            TRAVIS_BUILD_ID,
            TRAVIS_BUILD_NUMBER,
            TRAVIS_BUILD_WEB_URL,
            TRAVIS_BUILD_DIR,
            TRAVIS_COMMIT_MESSAGE
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "travisci",
            [CI_JOB_URL]: TRAVIS_JOB_WEB_URL,
            [CI_PIPELINE_ID]: TRAVIS_BUILD_ID,
            [CI_PIPELINE_NAME]: TRAVIS_REPO_SLUG,
            [CI_PIPELINE_NUMBER]: TRAVIS_BUILD_NUMBER,
            [CI_PIPELINE_URL]: TRAVIS_BUILD_WEB_URL,
            [GIT_COMMIT_SHA]: TRAVIS_COMMIT,
            [GIT_REPOSITORY_URL]: `https://github.com/${TRAVIS_REPO_SLUG}.git`,
            [CI_WORKSPACE_PATH]: TRAVIS_BUILD_DIR,
            [GIT_TAG]: TRAVIS_TAG,
            [GIT_BRANCH]: TRAVIS_PULL_REQUEST_BRANCH || TRAVIS_BRANCH,
            [GIT_COMMIT_MESSAGE]: TRAVIS_COMMIT_MESSAGE
          };
        }
        if (env.BUDDY) {
          const {
            BUDDY_EXECUTION_BRANCH,
            BUDDY_EXECUTION_ID,
            BUDDY_EXECUTION_REVISION,
            BUDDY_EXECUTION_REVISION_COMMITTER_EMAIL,
            BUDDY_EXECUTION_REVISION_COMMITTER_NAME,
            BUDDY_EXECUTION_REVISION_MESSAGE,
            BUDDY_EXECUTION_TAG,
            BUDDY_EXECUTION_URL,
            BUDDY_PIPELINE_ID,
            BUDDY_PIPELINE_NAME,
            BUDDY_SCM_URL
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "buddy",
            [CI_PIPELINE_ID]: `${BUDDY_PIPELINE_ID}/${BUDDY_EXECUTION_ID}`,
            [CI_PIPELINE_NAME]: BUDDY_PIPELINE_NAME,
            [CI_PIPELINE_NUMBER]: BUDDY_EXECUTION_ID,
            [CI_PIPELINE_URL]: BUDDY_EXECUTION_URL,
            [GIT_COMMIT_SHA]: BUDDY_EXECUTION_REVISION,
            [GIT_REPOSITORY_URL]: BUDDY_SCM_URL,
            [GIT_BRANCH]: BUDDY_EXECUTION_BRANCH,
            [GIT_TAG]: BUDDY_EXECUTION_TAG,
            [GIT_COMMIT_MESSAGE]: BUDDY_EXECUTION_REVISION_MESSAGE,
            [GIT_COMMIT_COMMITTER_NAME]: BUDDY_EXECUTION_REVISION_COMMITTER_NAME,
            [GIT_COMMIT_COMMITTER_EMAIL]: BUDDY_EXECUTION_REVISION_COMMITTER_EMAIL
          };
        }
        normalizeTag(tags, CI_WORKSPACE_PATH, resolveTilde);
        normalizeTag(tags, GIT_REPOSITORY_URL, filterSensitiveInfoFromRepository);
        normalizeTag(tags, GIT_BRANCH, normalizeRef);
        normalizeTag(tags, GIT_TAG, normalizeRef);
        return removeEmptyValues(tags);
      }
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/user-provided-git.js
var require_user_provided_git = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/user-provided-git.js"(exports2, module2) {
    var {
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_COMMITTER_DATE,
      GIT_COMMIT_COMMITTER_EMAIL,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME
    } = require_tags2();
    var { normalizeRef } = require_ci();
    function removeEmptyValues(tags) {
      return Object.keys(tags).reduce((filteredTags, tag) => {
        if (!tags[tag]) {
          return filteredTags;
        }
        return {
          ...filteredTags,
          [tag]: tags[tag]
        };
      }, {});
    }
    __name(removeEmptyValues, "removeEmptyValues");
    function filterSensitiveInfoFromRepository(repositoryUrl) {
      try {
        if (repositoryUrl.startsWith("git@")) {
          return repositoryUrl;
        }
        const { protocol, hostname, pathname } = new URL(repositoryUrl);
        return `${protocol}//${hostname}${pathname}`;
      } catch (e) {
        return repositoryUrl;
      }
    }
    __name(filterSensitiveInfoFromRepository, "filterSensitiveInfoFromRepository");
    function getUserProviderGitMetadata() {
      const {
        DD_GIT_COMMIT_SHA,
        DD_GIT_BRANCH,
        DD_GIT_REPOSITORY_URL,
        DD_GIT_TAG,
        DD_GIT_COMMIT_MESSAGE,
        DD_GIT_COMMIT_COMMITTER_NAME,
        DD_GIT_COMMIT_COMMITTER_EMAIL,
        DD_GIT_COMMIT_COMMITTER_DATE,
        DD_GIT_COMMIT_AUTHOR_NAME,
        DD_GIT_COMMIT_AUTHOR_EMAIL,
        DD_GIT_COMMIT_AUTHOR_DATE
      } = process.env;
      const branch = normalizeRef(DD_GIT_BRANCH);
      let tag = normalizeRef(DD_GIT_TAG);
      if ((DD_GIT_BRANCH || "").includes("origin/tags") || (DD_GIT_BRANCH || "").includes("refs/heads/tags")) {
        tag = normalizeRef(DD_GIT_BRANCH);
      }
      return removeEmptyValues({
        [GIT_COMMIT_SHA]: DD_GIT_COMMIT_SHA,
        [GIT_BRANCH]: branch,
        [GIT_REPOSITORY_URL]: filterSensitiveInfoFromRepository(DD_GIT_REPOSITORY_URL),
        [GIT_TAG]: tag,
        [GIT_COMMIT_MESSAGE]: DD_GIT_COMMIT_MESSAGE,
        [GIT_COMMIT_COMMITTER_NAME]: DD_GIT_COMMIT_COMMITTER_NAME,
        [GIT_COMMIT_COMMITTER_DATE]: DD_GIT_COMMIT_COMMITTER_DATE,
        [GIT_COMMIT_COMMITTER_EMAIL]: DD_GIT_COMMIT_COMMITTER_EMAIL,
        [GIT_COMMIT_AUTHOR_NAME]: DD_GIT_COMMIT_AUTHOR_NAME,
        [GIT_COMMIT_AUTHOR_EMAIL]: DD_GIT_COMMIT_AUTHOR_EMAIL,
        [GIT_COMMIT_AUTHOR_DATE]: DD_GIT_COMMIT_AUTHOR_DATE
      });
    }
    __name(getUserProviderGitMetadata, "getUserProviderGitMetadata");
    module2.exports = { getUserProviderGitMetadata };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/env.js
var require_env = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/env.js"(exports2, module2) {
    var os = __require("os");
    var OS_PLATFORM = "os.platform";
    var OS_VERSION = "os.version";
    var OS_ARCHITECTURE = "os.architecture";
    var RUNTIME_NAME = "runtime.name";
    var RUNTIME_VERSION = "runtime.version";
    function getRuntimeAndOSMetadata() {
      return {
        [RUNTIME_VERSION]: process.version,
        [OS_ARCHITECTURE]: process.arch,
        [OS_PLATFORM]: process.platform,
        [RUNTIME_NAME]: "node",
        [OS_VERSION]: os.release()
      };
    }
    __name(getRuntimeAndOSMetadata, "getRuntimeAndOSMetadata");
    module2.exports = {
      getRuntimeAndOSMetadata,
      OS_PLATFORM,
      OS_VERSION,
      OS_ARCHITECTURE,
      RUNTIME_NAME,
      RUNTIME_VERSION
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js
var require_test = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/test.js"(exports2, module2) {
    var path = __require("path");
    var fs = __require("fs");
    var istanbul = require_istanbul_lib_coverage();
    var ignore = require_ignore();
    var { getGitMetadata } = require_git();
    var { getUserProviderGitMetadata } = require_user_provided_git();
    var { getCIMetadata } = require_ci();
    var { getRuntimeAndOSMetadata } = require_env();
    var {
      GIT_BRANCH,
      GIT_COMMIT_SHA,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      GIT_COMMIT_MESSAGE,
      CI_WORKSPACE_PATH
    } = require_tags2();
    var id = require_id();
    var { SPAN_TYPE, RESOURCE_NAME, SAMPLING_PRIORITY } = require_tags();
    var { SAMPLING_RULE_DECISION } = require_constants();
    var { AUTO_KEEP } = require_priority();
    var { version: ddTraceVersion } = require_package();
    var TEST_FRAMEWORK = "test.framework";
    var TEST_FRAMEWORK_VERSION = "test.framework_version";
    var TEST_TYPE = "test.type";
    var TEST_NAME = "test.name";
    var TEST_SUITE = "test.suite";
    var TEST_STATUS = "test.status";
    var TEST_PARAMETERS = "test.parameters";
    var TEST_SKIP_REASON = "test.skip_reason";
    var TEST_IS_RUM_ACTIVE = "test.is_rum_active";
    var TEST_CODE_OWNERS = "test.codeowners";
    var TEST_SOURCE_FILE = "test.source.file";
    var LIBRARY_VERSION = "library_version";
    var TEST_COMMAND = "test.command";
    var TEST_BUNDLE = "test.bundle";
    var TEST_SESSION_ID = "test_session_id";
    var TEST_MODULE_ID = "test_module_id";
    var TEST_SUITE_ID = "test_suite_id";
    var CI_APP_ORIGIN = "ciapp-test";
    var JEST_TEST_RUNNER = "test.jest.test_runner";
    var TEST_ITR_TESTS_SKIPPED = "_dd.ci.itr.tests_skipped";
    var TEST_SESSION_ITR_SKIPPING_ENABLED = "test_session.itr.tests_skipping.enabled";
    var TEST_SESSION_CODE_COVERAGE_ENABLED = "test_session.code_coverage.enabled";
    var TEST_MODULE_ITR_SKIPPING_ENABLED = "test_module.itr.tests_skipping.enabled";
    var TEST_MODULE_CODE_COVERAGE_ENABLED = "test_module.code_coverage.enabled";
    var TEST_CODE_COVERAGE_LINES_TOTAL = "test.codecov_lines_total";
    module2.exports = {
      TEST_CODE_OWNERS,
      TEST_FRAMEWORK,
      TEST_FRAMEWORK_VERSION,
      JEST_TEST_RUNNER,
      TEST_TYPE,
      TEST_NAME,
      TEST_SUITE,
      TEST_STATUS,
      TEST_PARAMETERS,
      TEST_SKIP_REASON,
      TEST_IS_RUM_ACTIVE,
      TEST_SOURCE_FILE,
      CI_APP_ORIGIN,
      LIBRARY_VERSION,
      getTestEnvironmentMetadata,
      getTestParametersString,
      finishAllTraceSpans,
      getTestParentSpan,
      getTestSuitePath,
      getCodeOwnersFileEntries,
      getCodeOwnersForFilename,
      getTestCommonTags,
      getTestSessionCommonTags,
      getTestModuleCommonTags,
      getTestSuiteCommonTags,
      TEST_COMMAND,
      TEST_SESSION_ID,
      TEST_MODULE_ID,
      TEST_SUITE_ID,
      TEST_ITR_TESTS_SKIPPED,
      TEST_BUNDLE,
      TEST_SESSION_ITR_SKIPPING_ENABLED,
      TEST_SESSION_CODE_COVERAGE_ENABLED,
      TEST_MODULE_ITR_SKIPPING_ENABLED,
      TEST_MODULE_CODE_COVERAGE_ENABLED,
      TEST_CODE_COVERAGE_LINES_TOTAL,
      addIntelligentTestRunnerSpanTags,
      getCoveredFilenamesFromCoverage,
      resetCoverage,
      mergeCoverage,
      fromCoverageMapToCoverage
    };
    function getTestEnvironmentMetadata(testFramework, config) {
      const ciMetadata = getCIMetadata();
      const {
        [GIT_COMMIT_SHA]: commitSHA,
        [GIT_BRANCH]: branch,
        [GIT_REPOSITORY_URL]: repositoryUrl,
        [GIT_TAG]: tag,
        [GIT_COMMIT_AUTHOR_NAME]: authorName,
        [GIT_COMMIT_AUTHOR_EMAIL]: authorEmail,
        [GIT_COMMIT_MESSAGE]: commitMessage,
        [CI_WORKSPACE_PATH]: ciWorkspacePath
      } = ciMetadata;
      const gitMetadata = getGitMetadata({
        commitSHA,
        branch,
        repositoryUrl,
        tag,
        authorName,
        authorEmail,
        commitMessage,
        ciWorkspacePath
      });
      const userProvidedGitMetadata = getUserProviderGitMetadata();
      const runtimeAndOSMetadata = getRuntimeAndOSMetadata();
      const metadata = {
        [TEST_FRAMEWORK]: testFramework,
        ...gitMetadata,
        ...ciMetadata,
        ...userProvidedGitMetadata,
        ...runtimeAndOSMetadata
      };
      if (config && config.service) {
        metadata["service.name"] = config.service;
      }
      return metadata;
    }
    __name(getTestEnvironmentMetadata, "getTestEnvironmentMetadata");
    function getTestParametersString(parametersByTestName, testName) {
      if (!parametersByTestName[testName]) {
        return "";
      }
      try {
        const testParameters = parametersByTestName[testName].shift();
        return JSON.stringify({ arguments: testParameters, metadata: {} });
      } catch (e) {
        return "";
      }
    }
    __name(getTestParametersString, "getTestParametersString");
    function finishAllTraceSpans(span) {
      span.context()._trace.started.forEach((traceSpan) => {
        if (traceSpan !== span) {
          traceSpan.finish();
        }
      });
    }
    __name(finishAllTraceSpans, "finishAllTraceSpans");
    function getTestParentSpan(tracer2) {
      return tracer2.extract("text_map", {
        "x-datadog-trace-id": id().toString(10),
        "x-datadog-parent-id": "0000000000000000"
      });
    }
    __name(getTestParentSpan, "getTestParentSpan");
    function getTestCommonTags(name, suite, version) {
      return {
        [SPAN_TYPE]: "test",
        [TEST_TYPE]: "test",
        [SAMPLING_RULE_DECISION]: 1,
        [SAMPLING_PRIORITY]: AUTO_KEEP,
        [TEST_NAME]: name,
        [TEST_SUITE]: suite,
        [TEST_SOURCE_FILE]: suite,
        [RESOURCE_NAME]: `${suite}.${name}`,
        [TEST_FRAMEWORK_VERSION]: version,
        [LIBRARY_VERSION]: ddTraceVersion
      };
    }
    __name(getTestCommonTags, "getTestCommonTags");
    function getTestSuitePath(testSuiteAbsolutePath, sourceRoot) {
      if (!testSuiteAbsolutePath) {
        return sourceRoot;
      }
      const testSuitePath = testSuiteAbsolutePath === sourceRoot ? testSuiteAbsolutePath : path.relative(sourceRoot, testSuiteAbsolutePath);
      return testSuitePath.replace(path.sep, "/");
    }
    __name(getTestSuitePath, "getTestSuitePath");
    var POSSIBLE_CODEOWNERS_LOCATIONS = [
      "CODEOWNERS",
      ".github/CODEOWNERS",
      "docs/CODEOWNERS",
      ".gitlab/CODEOWNERS"
    ];
    function getCodeOwnersFileEntries(rootDir = process.cwd()) {
      let codeOwnersContent;
      POSSIBLE_CODEOWNERS_LOCATIONS.forEach((location) => {
        try {
          codeOwnersContent = fs.readFileSync(`${rootDir}/${location}`).toString();
        } catch (e) {
        }
      });
      if (!codeOwnersContent) {
        return null;
      }
      const entries = [];
      const lines = codeOwnersContent.split("\n");
      for (const line of lines) {
        const [content] = line.split("#");
        const trimmed = content.trim();
        if (trimmed === "")
          continue;
        const [pattern, ...owners] = trimmed.split(/\s+/);
        entries.push({ pattern, owners });
      }
      return entries.reverse();
    }
    __name(getCodeOwnersFileEntries, "getCodeOwnersFileEntries");
    function getCodeOwnersForFilename(filename, entries) {
      if (!entries) {
        return null;
      }
      for (const entry of entries) {
        try {
          const isResponsible = ignore().add(entry.pattern).ignores(filename);
          if (isResponsible) {
            return JSON.stringify(entry.owners);
          }
        } catch (e) {
          return null;
        }
      }
      return null;
    }
    __name(getCodeOwnersForFilename, "getCodeOwnersForFilename");
    function getTestLevelCommonTags(command, testFrameworkVersion) {
      return {
        [TEST_FRAMEWORK_VERSION]: testFrameworkVersion,
        [LIBRARY_VERSION]: ddTraceVersion,
        [TEST_COMMAND]: command,
        [TEST_TYPE]: "test"
      };
    }
    __name(getTestLevelCommonTags, "getTestLevelCommonTags");
    function getTestSessionCommonTags(command, testFrameworkVersion) {
      return {
        [SPAN_TYPE]: "test_session_end",
        [RESOURCE_NAME]: `test_session.${command}`,
        ...getTestLevelCommonTags(command, testFrameworkVersion)
      };
    }
    __name(getTestSessionCommonTags, "getTestSessionCommonTags");
    function getTestModuleCommonTags(command, testFrameworkVersion) {
      return {
        [SPAN_TYPE]: "test_module_end",
        [RESOURCE_NAME]: `test_module.${command}`,
        [TEST_BUNDLE]: command,
        ...getTestLevelCommonTags(command, testFrameworkVersion)
      };
    }
    __name(getTestModuleCommonTags, "getTestModuleCommonTags");
    function getTestSuiteCommonTags(command, testFrameworkVersion, testSuite) {
      return {
        [SPAN_TYPE]: "test_suite_end",
        [RESOURCE_NAME]: `test_suite.${testSuite}`,
        [TEST_BUNDLE]: command,
        [TEST_SUITE]: testSuite,
        ...getTestLevelCommonTags(command, testFrameworkVersion)
      };
    }
    __name(getTestSuiteCommonTags, "getTestSuiteCommonTags");
    function addIntelligentTestRunnerSpanTags(testSessionSpan, testModuleSpan, { isSuitesSkipped, isSuitesSkippingEnabled, isCodeCoverageEnabled, testCodeCoverageLinesTotal }) {
      testSessionSpan.setTag(TEST_ITR_TESTS_SKIPPED, isSuitesSkipped ? "true" : "false");
      testSessionSpan.setTag(TEST_SESSION_ITR_SKIPPING_ENABLED, isSuitesSkippingEnabled ? "true" : "false");
      testSessionSpan.setTag(TEST_SESSION_CODE_COVERAGE_ENABLED, isCodeCoverageEnabled ? "true" : "false");
      testModuleSpan.setTag(TEST_ITR_TESTS_SKIPPED, isSuitesSkipped ? "true" : "false");
      testModuleSpan.setTag(TEST_MODULE_ITR_SKIPPING_ENABLED, isSuitesSkippingEnabled ? "true" : "false");
      testModuleSpan.setTag(TEST_MODULE_CODE_COVERAGE_ENABLED, isCodeCoverageEnabled ? "true" : "false");
      if (testCodeCoverageLinesTotal !== void 0 && !isSuitesSkipped) {
        testSessionSpan.setTag(TEST_CODE_COVERAGE_LINES_TOTAL, testCodeCoverageLinesTotal);
        testModuleSpan.setTag(TEST_CODE_COVERAGE_LINES_TOTAL, testCodeCoverageLinesTotal);
      }
    }
    __name(addIntelligentTestRunnerSpanTags, "addIntelligentTestRunnerSpanTags");
    function getCoveredFilenamesFromCoverage(coverage) {
      const coverageMap = istanbul.createCoverageMap(coverage);
      return coverageMap.files().filter((filename) => {
        const fileCoverage = coverageMap.fileCoverageFor(filename);
        const lineCoverage = fileCoverage.getLineCoverage();
        const isAnyLineExecuted = Object.entries(lineCoverage).some(([, numExecutions]) => !!numExecutions);
        return isAnyLineExecuted;
      });
    }
    __name(getCoveredFilenamesFromCoverage, "getCoveredFilenamesFromCoverage");
    function resetCoverage(coverage) {
      const coverageMap = istanbul.createCoverageMap(coverage);
      return coverageMap.files().forEach((filename) => {
        const fileCoverage = coverageMap.fileCoverageFor(filename);
        fileCoverage.resetHits();
      });
    }
    __name(resetCoverage, "resetCoverage");
    function mergeCoverage(coverage, targetCoverage) {
      const coverageMap = istanbul.createCoverageMap(coverage);
      return coverageMap.files().forEach((filename) => {
        const fileCoverage = coverageMap.fileCoverageFor(filename);
        if (!targetCoverage.data[filename]) {
          targetCoverage.addFileCoverage(istanbul.createFileCoverage(filename));
        }
        targetCoverage.addFileCoverage(fileCoverage);
        const targetFileCoverage = targetCoverage.fileCoverageFor(filename);
        Object.entries(targetFileCoverage.data.b).forEach(([key, value]) => {
          targetFileCoverage.data.b[key] = [...value];
        });
      });
    }
    __name(mergeCoverage, "mergeCoverage");
    function fromCoverageMapToCoverage(coverageMap) {
      return Object.entries(coverageMap.data).reduce((acc, [filename, fileCoverage]) => {
        acc[filename] = fileCoverage.data;
        return acc;
      }, {});
    }
    __name(fromCoverageMapToCoverage, "fromCoverageMapToCoverage");
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/ci_plugin.js
var require_ci_plugin = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/ci_plugin.js"(exports2, module2) {
    var {
      getTestEnvironmentMetadata,
      getCodeOwnersFileEntries,
      getTestParentSpan,
      getTestCommonTags,
      getCodeOwnersForFilename,
      TEST_CODE_OWNERS,
      CI_APP_ORIGIN,
      getTestSessionCommonTags,
      getTestModuleCommonTags,
      TEST_SUITE_ID,
      TEST_MODULE_ID,
      TEST_SESSION_ID,
      TEST_COMMAND,
      TEST_BUNDLE
    } = require_test();
    var Plugin = require_plugin();
    var { COMPONENT } = require_constants();
    var log = require_log();
    module2.exports = /* @__PURE__ */ __name(class CiPlugin extends Plugin {
      constructor(...args) {
        super(...args);
        this.addSub(`ci:${this.constructor.name}:itr-configuration`, ({ onDone }) => {
          if (!this.tracer._exporter || !this.tracer._exporter.getItrConfiguration) {
            return onDone({ err: new Error("CI Visibility was not initialized correctly") });
          }
          this.tracer._exporter.getItrConfiguration(this.testConfiguration, (err, itrConfig) => {
            if (err) {
              log.error(`Error fetching intelligent test runner configuration: ${err.message}`);
            } else {
              this.itrConfig = itrConfig;
            }
            onDone({ err, itrConfig });
          });
        });
        this.addSub(`ci:${this.constructor.name}:test-suite:skippable`, ({ onDone }) => {
          if (!this.tracer._exporter || !this.tracer._exporter.getSkippableSuites) {
            return onDone({ err: new Error("CI Visibility was not initialized correctly") });
          }
          this.tracer._exporter.getSkippableSuites(this.testConfiguration, (err, skippableSuites) => {
            if (err) {
              log.error(`Error fetching skippable suites: ${err.message}`);
            }
            onDone({ err, skippableSuites });
          });
        });
        this.addSub(`ci:${this.constructor.name}:session:start`, ({ command, frameworkVersion, rootDir }) => {
          const childOf = getTestParentSpan(this.tracer);
          const testSessionSpanMetadata = getTestSessionCommonTags(command, frameworkVersion);
          const testModuleSpanMetadata = getTestModuleCommonTags(command, frameworkVersion);
          this.command = command;
          this.frameworkVersion = frameworkVersion;
          this.rootDir = rootDir;
          this.testSessionSpan = this.tracer.startSpan(`${this.constructor.name}.test_session`, {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.name,
              ...this.testEnvironmentMetadata,
              ...testSessionSpanMetadata
            }
          });
          this.testModuleSpan = this.tracer.startSpan(`${this.constructor.name}.test_module`, {
            childOf: this.testSessionSpan,
            tags: {
              [COMPONENT]: this.constructor.name,
              ...this.testEnvironmentMetadata,
              ...testModuleSpanMetadata
            }
          });
        });
      }
      configure(config) {
        super.configure(config);
        this.testEnvironmentMetadata = getTestEnvironmentMetadata(this.constructor.name, this.config);
        this.codeOwnersEntries = getCodeOwnersFileEntries();
        const {
          "git.repository_url": repositoryUrl,
          "git.commit.sha": sha,
          "os.version": osVersion,
          "os.platform": osPlatform,
          "os.architecture": osArchitecture,
          "runtime.name": runtimeName,
          "runtime.version": runtimeVersion,
          "git.branch": branch
        } = this.testEnvironmentMetadata;
        this.testConfiguration = {
          repositoryUrl,
          sha,
          osVersion,
          osPlatform,
          osArchitecture,
          runtimeName,
          runtimeVersion,
          branch
        };
      }
      startTestSpan(testName, testSuite, testSuiteSpan, extraTags = {}) {
        const childOf = getTestParentSpan(this.tracer);
        let testTags = {
          ...getTestCommonTags(testName, testSuite, this.frameworkVersion),
          [COMPONENT]: this.constructor.name,
          ...extraTags
        };
        const codeOwners = getCodeOwnersForFilename(testSuite, this.codeOwnersEntries);
        if (codeOwners) {
          testTags[TEST_CODE_OWNERS] = codeOwners;
        }
        if (testSuiteSpan) {
          childOf._trace.startTime = testSuiteSpan.context()._trace.startTime;
          childOf._trace.ticks = testSuiteSpan.context()._trace.ticks;
          const suiteTags = {
            [TEST_SUITE_ID]: testSuiteSpan.context().toSpanId(),
            [TEST_SESSION_ID]: testSuiteSpan.context().toTraceId(),
            [TEST_MODULE_ID]: testSuiteSpan.context()._parentId.toString(10),
            [TEST_COMMAND]: testSuiteSpan.context()._tags[TEST_COMMAND],
            [TEST_BUNDLE]: testSuiteSpan.context()._tags[TEST_COMMAND]
          };
          testTags = {
            ...testTags,
            ...suiteTags
          };
        }
        const testSpan = this.tracer.startSpan(`${this.constructor.name}.test`, {
          childOf,
          tags: {
            ...this.testEnvironmentMetadata,
            ...testTags
          }
        });
        testSpan.context()._trace.origin = CI_APP_ORIGIN;
        return testSpan;
      }
    }, "CiPlugin");
  }
});

// node_modules/dd-trace/packages/datadog-plugin-cucumber/src/index.js
var require_src2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-cucumber/src/index.js"(exports2, module2) {
    "use strict";
    var CiPlugin = require_ci_plugin();
    var { storage } = require_datadog_core();
    var {
      TEST_SKIP_REASON,
      TEST_STATUS,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestSuiteCommonTags
    } = require_test();
    var { RESOURCE_NAME } = require_tags();
    var { COMPONENT, ERROR_MESSAGE } = require_constants();
    var CucumberPlugin = class extends CiPlugin {
      static get name() {
        return "cucumber";
      }
      constructor(...args) {
        super(...args);
        this.sourceRoot = process.cwd();
        this.addSub("ci:cucumber:session:finish", (status) => {
          this.testSessionSpan.setTag(TEST_STATUS, status);
          this.testModuleSpan.setTag(TEST_STATUS, status);
          this.testModuleSpan.finish();
          this.testSessionSpan.finish();
          finishAllTraceSpans(this.testSessionSpan);
          this.tracer._exporter.flush();
        });
        this.addSub("ci:cucumber:test-suite:start", (testSuiteFullPath) => {
          const testSuiteMetadata = getTestSuiteCommonTags(
            this.command,
            this.frameworkVersion,
            getTestSuitePath(testSuiteFullPath, this.sourceRoot)
          );
          this.testSuiteSpan = this.tracer.startSpan("cucumber.test_suite", {
            childOf: this.testModuleSpan,
            tags: {
              [COMPONENT]: this.constructor.name,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata
            }
          });
        });
        this.addSub("ci:cucumber:test-suite:finish", (status) => {
          this.testSuiteSpan.setTag(TEST_STATUS, status);
          this.testSuiteSpan.finish();
        });
        this.addSub("ci:cucumber:test:start", ({ testName, fullTestSuite }) => {
          const store = storage.getStore();
          const testSuite = getTestSuitePath(fullTestSuite, this.sourceRoot);
          const testSpan = this.startTestSpan(testName, testSuite);
          this.enter(testSpan, store);
        });
        this.addSub("ci:cucumber:test-step:start", ({ resource }) => {
          const store = storage.getStore();
          const childOf = store ? store.span : store;
          const span = this.tracer.startSpan("cucumber.step", {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.name,
              "cucumber.step": resource,
              [RESOURCE_NAME]: resource
            }
          });
          this.enter(span, store);
        });
        this.addSub("ci:cucumber:test:finish", ({ isStep, status, skipReason, errorMessage }) => {
          const span = storage.getStore().span;
          const statusTag = isStep ? "step.status" : TEST_STATUS;
          span.setTag(statusTag, status);
          if (skipReason) {
            span.setTag(TEST_SKIP_REASON, skipReason);
          }
          if (errorMessage) {
            span.setTag(ERROR_MESSAGE, errorMessage);
          }
          span.finish();
          if (!isStep) {
            finishAllTraceSpans(span);
          }
        });
        this.addSub("ci:cucumber:error", (err) => {
          if (err) {
            const span = storage.getStore().span;
            span.setTag("error", err);
          }
        });
      }
      startTestSpan(testName, testSuite) {
        return super.startTestSpan(
          testName,
          testSuite,
          this.testSuiteSpan
        );
      }
    };
    module2.exports = CucumberPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-playwright/src/index.js
var require_src3 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-playwright/src/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var CiPlugin = require_ci_plugin();
    var {
      TEST_STATUS,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestSuiteCommonTags
    } = require_test();
    var { RESOURCE_NAME } = require_tags();
    var { COMPONENT } = require_constants();
    var PlaywrightPlugin = class extends CiPlugin {
      static get name() {
        return "playwright";
      }
      constructor(...args) {
        super(...args);
        this._testSuites = /* @__PURE__ */ new Map();
        this.addSub("ci:playwright:session:finish", ({ status, onDone }) => {
          this.testModuleSpan.setTag(TEST_STATUS, status);
          this.testSessionSpan.setTag(TEST_STATUS, status);
          this.testModuleSpan.finish();
          this.testSessionSpan.finish();
          finishAllTraceSpans(this.testSessionSpan);
          this.tracer._exporter.flush(onDone);
        });
        this.addSub("ci:playwright:test-suite:start", (testSuiteAbsolutePath) => {
          const store = storage.getStore();
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.rootDir);
          const testSuiteMetadata = getTestSuiteCommonTags(
            this.command,
            this.frameworkVersion,
            testSuite
          );
          const testSuiteSpan = this.tracer.startSpan("playwright.test_suite", {
            childOf: this.testModuleSpan,
            tags: {
              [COMPONENT]: this.constructor.name,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata
            }
          });
          this.enter(testSuiteSpan, store);
          this._testSuites.set(testSuite, testSuiteSpan);
        });
        this.addSub("ci:playwright:test-suite:finish", (status) => {
          const store = storage.getStore();
          const span = store && store.span;
          if (!span)
            return;
          span.setTag(TEST_STATUS, status);
          span.finish();
        });
        this.addSub("ci:playwright:test:start", ({ testName, testSuiteAbsolutePath }) => {
          const store = storage.getStore();
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.rootDir);
          const span = this.startTestSpan(testName, testSuite);
          this.enter(span, store);
        });
        this.addSub("ci:playwright:test:finish", ({ testStatus, steps, error }) => {
          const store = storage.getStore();
          const span = store && store.span;
          if (!span)
            return;
          span.setTag(TEST_STATUS, testStatus);
          if (error) {
            span.setTag("error", error);
          }
          steps.forEach((step) => {
            const stepStartTime = step.startTime.getTime();
            const stepSpan = this.tracer.startSpan("playwright.step", {
              childOf: span,
              startTime: stepStartTime,
              tags: {
                [COMPONENT]: this.constructor.name,
                "playwright.step": step.title,
                [RESOURCE_NAME]: step.title
              }
            });
            if (step.error) {
              stepSpan.setTag("error", step.error);
            }
            stepSpan.finish(stepStartTime + step.duration);
          });
          span.finish();
          finishAllTraceSpans(span);
        });
      }
      startTestSpan(testName, testSuite) {
        const testSuiteSpan = this._testSuites.get(testSuite);
        return super.startTestSpan(testName, testSuite, testSuiteSpan);
      }
    };
    module2.exports = PlaywrightPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/tracing.js
var require_tracing = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/tracing.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var analyticsSampler = require_analytics_sampler();
    var { COMPONENT } = require_constants();
    var TracingPlugin = class extends Plugin {
      constructor(...args) {
        super(...args);
        this.component = this.constructor.component || this.constructor.name;
        this.operation = this.constructor.operation;
        this.addTraceSub("start", (message) => {
          this.start(message);
        });
        this.addTraceSub("error", (err) => {
          this.error(err);
        });
        this.addTraceSub("finish", (message) => {
          this.finish(message);
        });
      }
      get activeSpan() {
        const store = storage.getStore();
        return store && store.span;
      }
      configure(config) {
        return super.configure({
          ...config,
          hooks: {
            [this.operation]: () => {
            },
            ...config.hooks
          }
        });
      }
      start() {
      }
      finish() {
        this.activeSpan.finish();
      }
      error(error) {
        this.addError(error);
      }
      addTraceSub(eventName, handler2) {
        this.addSub(`apm:${this.component}:${this.operation}:${eventName}`, handler2);
      }
      addError(error) {
        const span = this.activeSpan;
        if (!span._spanContext._tags["error"]) {
          span.setTag("error", error || 1);
        }
      }
      startSpan(name, { childOf, kind, meta, metrics, service, resource, type } = {}) {
        const store = storage.getStore();
        if (store && childOf === void 0) {
          childOf = store.span;
        }
        const span = this.tracer.startSpan(name, {
          childOf,
          tags: {
            [COMPONENT]: this.component,
            "service.name": service || this.tracer._service,
            "resource.name": resource,
            "span.kind": kind,
            "span.type": type,
            ...meta,
            ...metrics
          }
        });
        analyticsSampler.sample(span, this.config.measured);
        storage.enterWith({ ...store, span });
        return span;
      }
    };
    __name(TracingPlugin, "TracingPlugin");
    module2.exports = TracingPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/outgoing.js
var require_outgoing = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/outgoing.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var OutgoingPlugin = class extends TracingPlugin {
      constructor(...args) {
        super(...args);
        this.addTraceSub("connect", (message) => {
          this.connect(message);
        });
      }
      connect(url) {
        this.addHost(url.hostname, url.port);
      }
      addHost(hostname, port) {
        const span = this.activeSpan;
        if (!span)
          return;
        span.addTags({
          "out.host": hostname,
          "out.port": port
        });
      }
    };
    __name(OutgoingPlugin, "OutgoingPlugin");
    module2.exports = OutgoingPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/client.js
var require_client = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/client.js"(exports2, module2) {
    "use strict";
    var OutgoingPlugin = require_outgoing();
    var ClientPlugin = class extends OutgoingPlugin {
      static get operation() {
        return "request";
      }
    };
    __name(ClientPlugin, "ClientPlugin");
    module2.exports = ClientPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/storage.js
var require_storage2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/storage.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client();
    var StoragePlugin = class extends ClientPlugin {
      constructor(...args) {
        super(...args);
        this.system = this.constructor.system || this.component;
      }
      startSpan(name, options) {
        if (!options.service && this.system) {
          options.service = `${this.tracer._service}-${this.system}`;
        }
        return super.startSpan(name, options);
      }
    };
    __name(StoragePlugin, "StoragePlugin");
    module2.exports = StoragePlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/database.js
var require_database = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/database.js"(exports2, module2) {
    "use strict";
    var StoragePlugin = require_storage2();
    var DatabasePlugin = class extends StoragePlugin {
      static get operation() {
        return "query";
      }
      constructor(...args) {
        super(...args);
        this.serviceTags = {
          dddbs: "",
          encodedDddbs: "",
          dde: "",
          encodedDde: "",
          ddps: "",
          encodedDdps: "",
          ddpv: "",
          encodedDdpv: ""
        };
      }
      encodingServiceTags(serviceTag, encodeATag, spanConfig) {
        if (serviceTag !== spanConfig) {
          this.serviceTags[serviceTag] = spanConfig;
          this.serviceTags[encodeATag] = encodeURIComponent(spanConfig);
        }
      }
      createDBMPropagationCommentService(serviceName) {
        this.encodingServiceTags("dddbs", "encodedDddbs", serviceName);
        this.encodingServiceTags("dde", "encodedDde", this.tracer._env);
        this.encodingServiceTags("ddps", "encodedDdps", this.tracer._service);
        this.encodingServiceTags("ddpv", "encodedDdpv", this.tracer._version);
        const { encodedDddbs, encodedDde, encodedDdps, encodedDdpv } = this.serviceTags;
        return `dddbs='${encodedDddbs}',dde='${encodedDde}',ddps='${encodedDdps}',ddpv='${encodedDdpv}'`;
      }
      injectDbmQuery(query, serviceName) {
        if (this.config.dbmPropagationMode === "disabled") {
          return query;
        }
        const servicePropagation = this.createDBMPropagationCommentService(serviceName);
        if (this.config.dbmPropagationMode === "service") {
          return `/*${servicePropagation}*/ ${query}`;
        } else if (this.config.dbmPropagationMode === "full") {
          this.activeSpan.setTag("_dd.dbm_trace_injected", "true");
          const traceparent = this.activeSpan._spanContext.toTraceparent();
          return `/*${servicePropagation},traceparent='${traceparent}'*/ ${query}`;
        }
      }
    };
    __name(DatabasePlugin, "DatabasePlugin");
    module2.exports = DatabasePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js
var require_src4 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var ElasticsearchPlugin = class extends DatabasePlugin {
      static get name() {
        return "elasticsearch";
      }
      start({ params }) {
        const body = getBody(params.body || params.bulkBody);
        this.startSpan(`${this.system}.query`, {
          service: this.config.service,
          resource: `${params.method} ${quantizePath(params.path)}`,
          type: "elasticsearch",
          kind: "client",
          meta: {
            "db.type": this.system,
            [`${this.system}.url`]: params.path,
            [`${this.system}.method`]: params.method,
            [`${this.system}.body`]: body,
            [`${this.system}.params`]: JSON.stringify(params.querystring || params.query)
          }
        });
      }
      finish({ params }) {
        const span = this.activeSpan;
        this.config.hooks.query(span, params);
        super.finish({ params });
      }
    };
    function getBody(body) {
      return body && JSON.stringify(body);
    }
    __name(getBody, "getBody");
    function quantizePath(path) {
      return path && path.replace(/[0-9]+/g, "?");
    }
    __name(quantizePath, "quantizePath");
    module2.exports = ElasticsearchPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/producer.js
var require_producer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/producer.js"(exports2, module2) {
    "use strict";
    var OutgoingPlugin = require_outgoing();
    var ProducerPlugin = class extends OutgoingPlugin {
      static get operation() {
        return "publish";
      }
    };
    __name(ProducerPlugin, "ProducerPlugin");
    module2.exports = ProducerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/producer.js
var require_producer2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/producer.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer();
    var GoogleCloudPubsubProducerPlugin = class extends ProducerPlugin {
      static get name() {
        return "google-cloud-pubsub";
      }
      static get operation() {
        return "request";
      }
      start({ cfg, projectId, messages }) {
        if (cfg.method !== "publish")
          return;
        const topic = cfg.reqOpts.topic;
        const span = this.startSpan("pubsub.request", {
          service: this.config.service || `${this.tracer._service}-pubsub`,
          resource: `${cfg.method} ${topic}`,
          kind: "producer",
          meta: {
            "gcloud.project_id": projectId,
            "pubsub.method": cfg.method,
            "pubsub.topic": topic
          }
        });
        for (const msg of messages) {
          if (!msg.attributes) {
            msg.attributes = {};
          }
          this.tracer.inject(span, "text_map", msg.attributes);
        }
      }
    };
    module2.exports = GoogleCloudPubsubProducerPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/incoming.js
var require_incoming = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/incoming.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var IncomingPlugin = class extends TracingPlugin {
    };
    __name(IncomingPlugin, "IncomingPlugin");
    module2.exports = IncomingPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/consumer.js
var require_consumer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/consumer.js"(exports2, module2) {
    "use strict";
    var IncomingPlugin = require_incoming();
    var ConsumerPlugin = class extends IncomingPlugin {
      static get operation() {
        return "receive";
      }
    };
    __name(ConsumerPlugin, "ConsumerPlugin");
    module2.exports = ConsumerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/consumer.js
var require_consumer2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/consumer.js"(exports2, module2) {
    "use strict";
    var ConsumerPlugin = require_consumer();
    var GoogleCloudPubsubConsumerPlugin = class extends ConsumerPlugin {
      static get name() {
        return "google-cloud-pubsub";
      }
      static get operation() {
        return "receive";
      }
      start({ message }) {
        const subscription = message._subscriber._subscription;
        const topic = subscription.metadata && subscription.metadata.topic;
        const childOf = this.tracer.extract("text_map", message.attributes) || null;
        this.startSpan("pubsub.receive", {
          childOf,
          service: this.config.service,
          resource: topic,
          kind: "consumer",
          type: "worker",
          meta: {
            "gcloud.project_id": subscription.pubsub.projectId,
            "pubsub.topic": topic
          },
          metrics: {
            "pubsub.ack": 0
          }
        });
      }
      finish(message) {
        const span = this.activeSpan;
        if (message.message._handled) {
          span.setTag("pubsub.ack", 1);
        }
        span.finish();
      }
    };
    module2.exports = GoogleCloudPubsubConsumerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/client.js
var require_client2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/client.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client();
    var GoogleCloudPubsubClientPlugin = class extends ClientPlugin {
      static get name() {
        return "google-cloud-pubsub";
      }
      static get operation() {
        return "request";
      }
      start({ cfg, projectId }) {
        if (cfg.method === "publish")
          return;
        this.startSpan("pubsub.request", {
          service: this.config.service || `${this.tracer._service}-pubsub`,
          resource: [cfg.method, cfg.reqOpts.name].filter((x) => x).join(" "),
          kind: "client",
          meta: {
            "pubsub.method": cfg.method,
            "gcloud.project_id": projectId
          }
        });
      }
    };
    module2.exports = GoogleCloudPubsubClientPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/composite.js
var require_composite = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/composite.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var CompositePlugin = class extends Plugin {
      constructor(...args) {
        super(...args);
        for (const [name, PluginClass] of Object.entries(this.constructor.plugins)) {
          this[name] = new PluginClass(...args);
        }
      }
      configure(config) {
        for (const name in this.constructor.plugins) {
          const pluginConfig = config[name] === false ? false : {
            ...config,
            ...config[name]
          };
          this[name].configure(pluginConfig);
        }
      }
    };
    __name(CompositePlugin, "CompositePlugin");
    module2.exports = CompositePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js
var require_src5 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-google-cloud-pubsub/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer2();
    var ConsumerPlugin = require_consumer2();
    var ClientPlugin = require_client2();
    var CompositePlugin = require_composite();
    var GoogleCloudPubsubPlugin = class extends CompositePlugin {
      static get name() {
        return "google-cloud-pubsub";
      }
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
          client: ClientPlugin
        };
      }
    };
    module2.exports = GoogleCloudPubsubPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/server.js
var require_server = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/server.js"(exports2, module2) {
    "use strict";
    var IncomingPlugin = require_incoming();
    var ServerPlugin = class extends IncomingPlugin {
      static get operation() {
        return "request";
      }
    };
    __name(ServerPlugin, "ServerPlugin");
    module2.exports = ServerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js
var require_util3 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js"(exports2, module2) {
    "use strict";
    var pick = require_lodash();
    var log = require_log();
    module2.exports = {
      getMethodMetadata(path, kind) {
        const tags = {
          path,
          kind,
          name: "",
          service: "",
          package: ""
        };
        if (typeof path !== "string")
          return tags;
        const methodParts = path.split("/");
        if (methodParts.length > 2) {
          const serviceParts = methodParts[1].split(".");
          const name = methodParts[2];
          const service = serviceParts.pop();
          const pkg = serviceParts.join(".");
          tags.name = name;
          tags.service = service;
          tags.package = pkg;
        } else {
          tags.name = methodParts[methodParts.length - 1];
        }
        return tags;
      },
      addMetadataTags(span, metadata, filter, type) {
        if (!metadata || typeof metadata.getMap !== "function")
          return;
        const values = filter(metadata.getMap());
        for (const key in values) {
          span.setTag(`grpc.${type}.metadata.${key}`, values[key]);
        }
      },
      getFilter(config, filter) {
        if (typeof config[filter] === "function") {
          return config[filter];
        }
        if (config[filter] instanceof Array) {
          return (element) => pick(element, config[filter]);
        }
        if (config.hasOwnProperty(filter)) {
          log.error(`Expected '${filter}' to be an array or function.`);
        }
        return () => ({});
      }
    };
  }
});

// node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js
var require_server2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-grpc/src/server.js"(exports2, module2) {
    "use strict";
    var ServerPlugin = require_server();
    var { TEXT_MAP } = require_formats();
    var { addMetadataTags, getFilter, getMethodMetadata } = require_util3();
    var GrpcServerPlugin = class extends ServerPlugin {
      static get name() {
        return "grpc";
      }
      static get operation() {
        return "server:request";
      }
      constructor(...args) {
        super(...args);
        this.addTraceSub("update", ({ code }) => {
          const span = this.activeSpan;
          if (!span)
            return;
          this.addCode(span, code);
        });
      }
      start({ name, metadata, type }) {
        const metadataFilter = this.config.metadataFilter;
        const childOf = extract(this.tracer, metadata);
        const method = getMethodMetadata(name, type);
        const span = this.startSpan("grpc.server", {
          childOf,
          service: this.config.service,
          resource: name,
          kind: "server",
          type: "web",
          meta: {
            "component": "grpc",
            "grpc.method.kind": method.kind,
            "grpc.method.path": method.path,
            "grpc.method.name": method.name,
            "grpc.method.service": method.service,
            "grpc.method.package": method.package
          },
          metrics: {
            "grpc.status.code": 0
          }
        });
        addMetadataTags(span, metadata, metadataFilter, "request");
      }
      error(error) {
        const span = this.activeSpan;
        if (!span)
          return;
        this.addCode(span, error.code);
        this.addError(error);
      }
      finish({ code, trailer } = {}) {
        const span = this.activeSpan;
        if (!span)
          return;
        const metadataFilter = this.config.metadataFilter;
        this.addCode(span, code);
        if (trailer && metadataFilter) {
          addMetadataTags(span, trailer, metadataFilter, "response");
        }
        span.finish();
      }
      configure(config) {
        const metadataFilter = getFilter(config, "metadata");
        return super.configure({ ...config, metadataFilter });
      }
      addCode(span, code) {
        if (code !== void 0) {
          span.setTag("grpc.status.code", code);
        }
      }
    };
    function extract(tracer2, metadata) {
      if (!metadata || typeof metadata.getMap !== "function")
        return null;
      return tracer2.extract(TEXT_MAP, metadata.getMap());
    }
    __name(extract, "extract");
    module2.exports = GrpcServerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js
var require_client3 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-grpc/src/client.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client();
    var { TEXT_MAP } = require_formats();
    var { addMetadataTags, getFilter, getMethodMetadata } = require_util3();
    var GrpcClientPlugin = class extends ClientPlugin {
      static get name() {
        return "grpc";
      }
      static get operation() {
        return "client:request";
      }
      start({ metadata, path, type }) {
        const metadataFilter = this.config.metadataFilter;
        const method = getMethodMetadata(path, type);
        const span = this.startSpan("grpc.client", {
          service: this.config.service,
          resource: path,
          kind: "client",
          type: "http",
          meta: {
            "component": "grpc",
            "grpc.method.kind": method.kind,
            "grpc.method.path": method.path,
            "grpc.method.name": method.name,
            "grpc.method.service": method.service,
            "grpc.method.package": method.package
          },
          metrics: {
            "grpc.status.code": 0
          }
        });
        if (metadata) {
          addMetadataTags(span, metadata, metadataFilter, "request");
          inject(this.tracer, span, metadata);
        }
      }
      error(error) {
        const span = this.activeSpan;
        if (!span)
          return;
        this.addCode(span, error.code);
        this.addError(error);
      }
      finish({ code, metadata }) {
        const span = this.activeSpan;
        if (!span)
          return;
        const metadataFilter = this.config.metadataFilter;
        this.addCode(span, code);
        if (metadata && metadataFilter) {
          addMetadataTags(span, metadata, metadataFilter, "response");
        }
        span.finish();
      }
      configure(config) {
        const metadataFilter = getFilter(config, "metadata");
        return super.configure({ ...config, metadataFilter });
      }
      addCode(span, code) {
        if (code !== void 0) {
          span.setTag("grpc.status.code", code);
        }
      }
    };
    function inject(tracer2, span, metadata) {
      if (typeof metadata.set !== "function")
        return;
      const carrier = {};
      tracer2.inject(span, TEXT_MAP, carrier);
      for (const key in carrier) {
        metadata.set(key, carrier[key]);
      }
    }
    __name(inject, "inject");
    module2.exports = GrpcClientPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-grpc/src/index.js
var require_src6 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-grpc/src/index.js"(exports2, module2) {
    "use strict";
    var GrpcServerPlugin = require_server2();
    var GrpcClientPlugin = require_client3();
    var CompositePlugin = require_composite();
    var GrpcPlugin = class extends CompositePlugin {
      static get name() {
        return "grpc";
      }
      static get plugins() {
        return {
          server: GrpcServerPlugin,
          client: GrpcClientPlugin
        };
      }
    };
    module2.exports = GrpcPlugin;
  }
});

// node_modules/lodash.uniq/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.uniq/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    __name(arrayIncludes, "arrayIncludes");
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    __name(arrayIncludesWith, "arrayIncludesWith");
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    __name(baseFindIndex, "baseFindIndex");
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    __name(baseIndexOf, "baseIndexOf");
    function baseIsNaN(value) {
      return value !== value;
    }
    __name(baseIsNaN, "baseIsNaN");
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    __name(cacheHas, "cacheHas");
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    __name(getValue, "getValue");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var Set2 = getNative(root, "Set");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash, "Hash");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    __name(hashClear, "hashClear");
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    __name(hashDelete, "hashDelete");
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    __name(hashGet, "hashGet");
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    __name(hashHas, "hashHas");
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    __name(hashSet, "hashSet");
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache, "ListCache");
    function listCacheClear() {
      this.__data__ = [];
    }
    __name(listCacheClear, "listCacheClear");
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    __name(listCacheDelete, "listCacheDelete");
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet, "listCacheGet");
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    __name(listCacheHas, "listCacheHas");
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet, "listCacheSet");
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache, "MapCache");
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    __name(mapCacheClear, "mapCacheClear");
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    __name(mapCacheDelete, "mapCacheDelete");
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    __name(mapCacheGet, "mapCacheGet");
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    __name(mapCacheHas, "mapCacheHas");
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    __name(mapCacheSet, "mapCacheSet");
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    __name(SetCache, "SetCache");
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    __name(setCacheAdd, "setCacheAdd");
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    __name(setCacheHas, "setCacheHas");
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf, "assocIndexOf");
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    __name(baseIsNative, "baseIsNative");
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    __name(baseUniq, "baseUniq");
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData, "getMapData");
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    __name(getNative, "getNative");
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable, "isKeyable");
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    __name(isMasked, "isMasked");
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource, "toSource");
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    __name(uniq, "uniq");
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq, "eq");
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction, "isFunction");
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject, "isObject");
    function noop() {
    }
    __name(noop, "noop");
    module2.exports = uniq;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js
var require_urlfilter = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/urlfilter.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var urlFilter = {
      getFilter(config) {
        if (typeof config.filter === "function") {
          return config.filter;
        } else if (config.hasOwnProperty("filter")) {
          log.error("Expected `filter` to be a function. Overriding filter property to default.");
        }
        const allowlist = config.allowlist || config.whitelist || /.*/;
        const blocklist = config.blocklist || config.blacklist || [];
        return (uri) => {
          const allowed = applyFilter(allowlist, uri);
          const blocked = applyFilter(blocklist, uri);
          return allowed && !blocked;
        };
        function applyFilter(filter, uri) {
          if (typeof filter === "function") {
            return filter(uri);
          } else if (filter instanceof RegExp) {
            return filter.test(uri);
          } else if (filter instanceof Array) {
            return filter.some((filter2) => applyFilter(filter2, uri));
          }
          return filter === uri;
        }
        __name(applyFilter, "applyFilter");
      }
    };
    module2.exports = urlFilter;
  }
});

// node_modules/dd-trace/node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/dd-trace/node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string, parts) {
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          const ref = string.split(":");
          const results = [];
          for (let i = 0; i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      __name(expandIPv6, "expandIPv6");
      function matchCIDR(first, second, partSize, cidrBits) {
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      __name(matchCIDR, "matchCIDR");
      function parseIntAuto(string) {
        if (hexRegex.test(string)) {
          return parseInt(string, 16);
        }
        if (string[0] === "0" && !isNaN(parseInt(string[1], 10))) {
          if (octalRegex.test(string)) {
            return parseInt(string, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string} as octal`);
        }
        return parseInt(string, 10);
      }
      __name(parseIntAuto, "parseIntAuto");
      function padPart(part, length) {
        while (part.length < length) {
          part = `0${part}`;
        }
        return part;
      }
      __name(padPart, "padPart");
      const ipaddr = {};
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        __name(IPv4, "IPv4");
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        try {
          const cidr = this.parseCIDR(string);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.isIPv4 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function(string) {
        try {
          new this(this.parser(string));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.parse = function(string) {
        const parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr.IPv4.parseCIDR = function(string) {
        let match;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.parser = function(string) {
        let match, part, value;
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        __name(IPv6, "IPv6");
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes = [];
          const ref = this.parts;
          for (let i = 0; i < ref.length; i++) {
            part = ref[i];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        return IPv6;
      }();
      ipaddr.IPv6.broadcastAddressFromCIDR = function(string) {
        try {
          const cidr = this.parseCIDR(string);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv6.isValid = function(string) {
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv6.networkAddressFromCIDR = function(string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.parse = function(string) {
        const addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv6.parseCIDR = function(string) {
        let maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.IPv6.parser = function(string) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string)) {
          return expandIPv6(string, 8);
        }
        if (match = string.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.fromByteArray = function(bytes) {
        const length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string) {
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (e) {
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.process = function(string) {
        const addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = ipaddr;
      } else {
        root.ipaddr = ipaddr;
      }
    })(exports2);
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/ip_blocklist.js
var require_ip_blocklist = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/ip_blocklist.js"(exports2, module2) {
    "use strict";
    var semver = require_semver();
    if (semver.satisfies(process.version, ">=14.18.0")) {
      const net = __require("net");
      module2.exports = net.BlockList;
    } else {
      const ipaddr = require_ipaddr();
      module2.exports = /* @__PURE__ */ __name(class BlockList {
        constructor() {
          this.v4Ranges = [];
          this.v6Ranges = [];
        }
        addSubnet(net, prefix, type) {
          this[type === "ipv4" ? "v4Ranges" : "v6Ranges"].push(ipaddr.parseCIDR(`${net}/${prefix}`));
        }
        check(address, type) {
          try {
            let ip = ipaddr.parse(address);
            type = ip.kind();
            if (type === "ipv6") {
              for (const range of this.v6Ranges) {
                if (ip.match(range))
                  return true;
              }
              if (ip.isIPv4MappedAddress()) {
                ip = ip.toIPv4Address();
                type = ip.kind();
              }
            }
            if (type === "ipv4") {
              for (const range of this.v4Ranges) {
                if (ip.match(range))
                  return true;
              }
            }
            return false;
          } catch {
            return false;
          }
        }
      }, "BlockList");
    }
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/ip_extractor.js
var require_ip_extractor = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/ip_extractor.js"(exports2, module2) {
    "use strict";
    var BlockList = require_ip_blocklist();
    var net = __require("net");
    var log = require_log();
    var ipHeaderList = [
      "x-forwarded-for",
      "x-real-ip",
      "client-ip",
      "x-forwarded",
      "x-cluster-client-ip",
      "forwarded-for",
      "forwarded",
      "via",
      "true-client-ip"
    ];
    var privateCIDRs = [
      "127.0.0.0/8",
      "10.0.0.0/8",
      "172.16.0.0/12",
      "192.168.0.0/16",
      "169.254.0.0/16",
      "::1/128",
      "fec0::/10",
      "fe80::/10",
      "fc00::/7",
      "fd00::/8"
    ];
    var privateIPMatcher = new BlockList();
    for (const cidr of privateCIDRs) {
      const [address, prefix] = cidr.split("/");
      privateIPMatcher.addSubnet(address, parseInt(prefix), net.isIPv6(address) ? "ipv6" : "ipv4");
    }
    function extractIp(config, req) {
      const headers = req.headers;
      if (config.clientIpHeader) {
        if (!headers)
          return;
        const header = headers[config.clientIpHeader];
        if (!header)
          return;
        return findFirstIp(header);
      }
      const foundHeaders = [];
      if (headers) {
        for (let i = 0; i < ipHeaderList.length; i++) {
          if (headers[ipHeaderList[i]]) {
            foundHeaders.push(ipHeaderList[i]);
          }
        }
      }
      if (foundHeaders.length === 1) {
        const header = headers[foundHeaders[0]];
        const firstIp = findFirstIp(header);
        if (firstIp)
          return firstIp;
      } else if (foundHeaders.length > 1) {
        log.error(`Cannot find client IP: multiple IP headers detected ${foundHeaders}`);
        return;
      }
      return req.socket && req.socket.remoteAddress;
    }
    __name(extractIp, "extractIp");
    function findFirstIp(str) {
      let firstPrivateIp;
      const splitted = str.split(",");
      for (let i = 0; i < splitted.length; i++) {
        const chunk = splitted[i].trim();
        const type = net.isIP(chunk);
        if (!type)
          continue;
        if (!privateIPMatcher.check(chunk, type === 6 ? "ipv6" : "ipv4")) {
          return chunk;
        }
        if (!firstPrivateIp)
          firstPrivateIp = chunk;
      }
      return firstPrivateIp;
    }
    __name(findFirstIp, "findFirstIp");
    module2.exports = {
      extractIp
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js
var require_web = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js"(exports2, module2) {
    "use strict";
    var uniq = require_lodash2();
    var analyticsSampler = require_analytics_sampler();
    var FORMAT_HTTP_HEADERS = "http_headers";
    var log = require_log();
    var tags = require_tags();
    var types = require_types();
    var kinds = require_kinds();
    var urlFilter = require_urlfilter();
    var { extractIp } = require_ip_extractor();
    var { ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK } = require_constants();
    var WEB = types.WEB;
    var SERVER = kinds.SERVER;
    var RESOURCE_NAME = tags.RESOURCE_NAME;
    var SERVICE_NAME = tags.SERVICE_NAME;
    var SPAN_TYPE = tags.SPAN_TYPE;
    var SPAN_KIND = tags.SPAN_KIND;
    var ERROR = tags.ERROR;
    var HTTP_METHOD = tags.HTTP_METHOD;
    var HTTP_URL = tags.HTTP_URL;
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE;
    var HTTP_ROUTE = tags.HTTP_ROUTE;
    var HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS;
    var HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS;
    var HTTP_USERAGENT = tags.HTTP_USERAGENT;
    var HTTP_CLIENT_IP = tags.HTTP_CLIENT_IP;
    var MANUAL_DROP = tags.MANUAL_DROP;
    var HTTP2_HEADER_AUTHORITY = ":authority";
    var HTTP2_HEADER_SCHEME = ":scheme";
    var HTTP2_HEADER_PATH = ":path";
    var contexts = /* @__PURE__ */ new WeakMap();
    var ends = /* @__PURE__ */ new WeakMap();
    var web = {
      normalizeConfig(config) {
        const headers = getHeadersToRecord(config);
        const validateStatus = getStatusValidator(config);
        const hooks = getHooks(config);
        const filter = urlFilter.getFilter(config);
        const middleware = getMiddlewareSetting(config);
        const queryStringObfuscation = getQsObfuscator(config);
        return {
          ...config,
          headers,
          validateStatus,
          hooks,
          filter,
          middleware,
          queryStringObfuscation
        };
      },
      setFramework(req, name, config) {
        const context = this.patch(req);
        const span = context.span;
        if (!span)
          return;
        span.context()._name = `${name}.request`;
        span.context()._tags["component"] = name;
        web.setConfig(req, config);
      },
      setConfig(req, config) {
        const context = contexts.get(req);
        const span = context.span;
        context.config = config;
        if (!config.filter(req.url)) {
          span.setTag(MANUAL_DROP, true);
          span.context()._trace.isRecording = false;
        }
        if (config.service) {
          span.setTag(SERVICE_NAME, config.service);
        }
        analyticsSampler.sample(span, config.measured, true);
      },
      startSpan(tracer2, config, req, res, name) {
        const context = this.patch(req);
        let span;
        if (context.span) {
          context.span.context()._name = name;
          span = context.span;
        } else {
          span = web.startChildSpan(tracer2, name, req.headers);
        }
        context.tracer = tracer2;
        context.span = span;
        context.res = res;
        this.setConfig(req, config);
        return span;
      },
      wrap(req) {
        const context = contexts.get(req);
        if (!context.instrumented) {
          this.wrapEnd(context);
          context.instrumented = true;
        }
      },
      instrument(tracer2, config, req, res, name, callback) {
        const span = this.startSpan(tracer2, config, req, res, name);
        this.wrap(req);
        return callback && tracer2.scope().activate(span, () => callback(span));
      },
      reactivate(req, fn) {
        return reactivate(req, fn);
      },
      enterRoute(req, path) {
        if (typeof path === "string") {
          contexts.get(req).paths.push(path);
        }
      },
      setRoute(req, path) {
        const context = contexts.get(req);
        if (!context)
          return;
        context.paths = [path];
      },
      exitRoute(req) {
        contexts.get(req).paths.pop();
      },
      wrapMiddleware(req, middleware, name, fn) {
        if (!this.active(req))
          return fn();
        const context = contexts.get(req);
        const tracer2 = context.tracer;
        const childOf = this.active(req);
        const config = context.config;
        if (config.middleware === false)
          return this.bindAndWrapMiddlewareErrors(fn, req, tracer2, childOf);
        const span = tracer2.startSpan(name, { childOf });
        analyticsSampler.sample(span, config.measured);
        span.addTags({
          [RESOURCE_NAME]: middleware._name || middleware.name || "<anonymous>"
        });
        context.middleware.push(span);
        return tracer2.scope().activate(span, fn);
      },
      bindAndWrapMiddlewareErrors(fn, req, tracer2, activeSpan) {
        try {
          return tracer2.scope().bind(fn, activeSpan).apply(this, arguments);
        } catch (e) {
          web.addError(req, e);
          throw e;
        }
      },
      finish(req, error) {
        if (!this.active(req))
          return;
        const context = contexts.get(req);
        const span = context.middleware.pop();
        if (span) {
          if (error) {
            span.addTags({
              [ERROR_TYPE]: error.name,
              [ERROR_MESSAGE]: error.message,
              [ERROR_STACK]: error.stack
            });
          }
          span.finish();
        }
      },
      beforeEnd(req, callback) {
        contexts.get(req).beforeEnd.push(callback);
      },
      patch(req) {
        let context = contexts.get(req);
        if (context)
          return context;
        context = req.stream && contexts.get(req.stream);
        if (context) {
          contexts.set(req, context);
          return context;
        }
        context = {
          req,
          span: null,
          paths: [],
          middleware: [],
          beforeEnd: [],
          config: {}
        };
        contexts.set(req, context);
        return context;
      },
      root(req) {
        const context = contexts.get(req);
        return context ? context.span : null;
      },
      active(req) {
        const context = contexts.get(req);
        if (!context)
          return null;
        if (context.middleware.length === 0)
          return context.span || null;
        return context.middleware.slice(-1)[0];
      },
      startChildSpan(tracer2, name, headers) {
        const childOf = tracer2.extract(FORMAT_HTTP_HEADERS, headers);
        const span = tracer2.startSpan(name, { childOf });
        return span;
      },
      addStatusError(req, statusCode) {
        const context = contexts.get(req);
        const span = context.span;
        const error = context.error;
        const hasExistingError = span.context()._tags["error"] || span.context()._tags[ERROR_MESSAGE];
        if (!hasExistingError && !context.config.validateStatus(statusCode)) {
          span.setTag(ERROR, error || true);
        }
      },
      addError(req, error) {
        if (error instanceof Error) {
          const context = contexts.get(req);
          if (context) {
            context.error = error;
          }
        }
      },
      finishMiddleware(context) {
        if (context.finished)
          return;
        let span;
        while (span = context.middleware.pop()) {
          span.finish();
        }
      },
      finishSpan(context) {
        const { req, res } = context;
        if (context.finished && !req.stream)
          return;
        addRequestTags(context);
        addResponseTags(context);
        context.config.hooks.request(context.span, req, res);
        addResourceTag(context);
        context.span.finish();
        context.finished = true;
      },
      finishAll(context) {
        for (const beforeEnd of context.beforeEnd) {
          beforeEnd();
        }
        web.finishMiddleware(context);
        web.finishSpan(context);
      },
      obfuscateQs(config, url) {
        const { queryStringObfuscation } = config;
        if (queryStringObfuscation === false)
          return url;
        const i = url.indexOf("?");
        if (i === -1)
          return url;
        const path = url.slice(0, i);
        if (queryStringObfuscation === true)
          return path;
        let qs = url.slice(i + 1);
        qs = qs.replace(queryStringObfuscation, "<redacted>");
        return `${path}?${qs}`;
      },
      wrapWriteHead(context) {
        const { req, res } = context;
        const writeHead = res.writeHead;
        return function(statusCode, statusMessage, headers) {
          headers = typeof statusMessage === "string" ? headers : statusMessage;
          headers = Object.assign(res.getHeaders(), headers);
          if (req.method.toLowerCase() === "options" && isOriginAllowed(req, headers)) {
            addAllowHeaders(req, res, headers);
          }
          return writeHead.apply(this, arguments);
        };
      },
      getContext(req) {
        return contexts.get(req);
      },
      wrapRes(context, req, res, end) {
        return function() {
          web.finishAll(context);
          return end.apply(res, arguments);
        };
      },
      wrapEnd(context) {
        const scope = context.tracer.scope();
        const req = context.req;
        const res = context.res;
        const end = res.end;
        res.writeHead = web.wrapWriteHead(context);
        ends.set(res, this.wrapRes(context, req, res, end));
        Object.defineProperty(res, "end", {
          configurable: true,
          get() {
            return ends.get(this);
          },
          set(value) {
            ends.set(this, scope.bind(value, context.span));
          }
        });
      }
    };
    function addAllowHeaders(req, res, headers) {
      const allowHeaders = splitHeader(headers["access-control-allow-headers"]);
      const requestHeaders = splitHeader(req.headers["access-control-request-headers"]);
      const contextHeaders = [
        "x-datadog-origin",
        "x-datadog-parent-id",
        "x-datadog-sampled",
        "x-datadog-sampling-priority",
        "x-datadog-trace-id",
        "x-datadog-tags"
      ];
      for (const header of contextHeaders) {
        if (~requestHeaders.indexOf(header)) {
          allowHeaders.push(header);
        }
      }
      if (allowHeaders.length > 0) {
        res.setHeader("access-control-allow-headers", uniq(allowHeaders).join(","));
      }
    }
    __name(addAllowHeaders, "addAllowHeaders");
    function isOriginAllowed(req, headers) {
      const origin = req.headers["origin"];
      const allowOrigin = headers["access-control-allow-origin"];
      return origin && (allowOrigin === "*" || allowOrigin === origin);
    }
    __name(isOriginAllowed, "isOriginAllowed");
    function splitHeader(str) {
      return typeof str === "string" ? str.split(/\s*,\s*/) : [];
    }
    __name(splitHeader, "splitHeader");
    function reactivate(req, fn) {
      const context = contexts.get(req);
      return context ? context.tracer.scope().activate(context.span, fn) : fn();
    }
    __name(reactivate, "reactivate");
    function addRequestTags(context) {
      const { req, span, config } = context;
      const url = extractURL(req);
      span.addTags({
        [HTTP_URL]: web.obfuscateQs(config, url),
        [HTTP_METHOD]: req.method,
        [SPAN_KIND]: SERVER,
        [SPAN_TYPE]: WEB,
        [HTTP_USERAGENT]: req.headers["user-agent"]
      });
      if (config.clientIpEnabled && !span.context()._tags.hasOwnProperty(HTTP_CLIENT_IP)) {
        const clientIp = extractIp(config, req);
        if (clientIp) {
          span.setTag(HTTP_CLIENT_IP, clientIp);
        }
      }
      addHeaders(context);
    }
    __name(addRequestTags, "addRequestTags");
    function addResponseTags(context) {
      const { req, res, paths, span } = context;
      if (paths.length > 0) {
        span.setTag(HTTP_ROUTE, paths.join(""));
      }
      span.addTags({
        [HTTP_STATUS_CODE]: res.statusCode
      });
      web.addStatusError(req, res.statusCode);
    }
    __name(addResponseTags, "addResponseTags");
    function addResourceTag(context) {
      const { req, span } = context;
      const tags2 = span.context()._tags;
      if (tags2["resource.name"])
        return;
      const resource = [req.method, tags2[HTTP_ROUTE]].filter((val) => val).join(" ");
      span.setTag(RESOURCE_NAME, resource);
    }
    __name(addResourceTag, "addResourceTag");
    function addHeaders(context) {
      const { req, res, config, span } = context;
      config.headers.forEach((key) => {
        const reqHeader = req.headers[key];
        const resHeader = res.getHeader(key);
        if (reqHeader) {
          span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader);
        }
        if (resHeader) {
          span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader);
        }
      });
    }
    __name(addHeaders, "addHeaders");
    function extractURL(req) {
      const headers = req.headers;
      if (req.stream) {
        return `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`;
      } else {
        const protocol = getProtocol(req);
        return `${protocol}://${req.headers["host"]}${req.originalUrl || req.url}`;
      }
    }
    __name(extractURL, "extractURL");
    function getProtocol(req) {
      if (req.socket && req.socket.encrypted)
        return "https";
      if (req.connection && req.connection.encrypted)
        return "https";
      return "http";
    }
    __name(getProtocol, "getProtocol");
    function getHeadersToRecord(config) {
      if (Array.isArray(config.headers)) {
        try {
          return config.headers.map((key) => key.toLowerCase());
        } catch (err) {
          log.error(err);
        }
      } else if (config.hasOwnProperty("headers")) {
        log.error("Expected `headers` to be an array of strings.");
      }
      return [];
    }
    __name(getHeadersToRecord, "getHeadersToRecord");
    function getStatusValidator(config) {
      if (typeof config.validateStatus === "function") {
        return config.validateStatus;
      } else if (config.hasOwnProperty("validateStatus")) {
        log.error("Expected `validateStatus` to be a function.");
      }
      return (code) => code < 500;
    }
    __name(getStatusValidator, "getStatusValidator");
    function getHooks(config) {
      const noop = /* @__PURE__ */ __name(() => {
      }, "noop");
      const request = config.hooks && config.hooks.request || noop;
      return { request };
    }
    __name(getHooks, "getHooks");
    function getMiddlewareSetting(config) {
      if (config && typeof config.middleware === "boolean") {
        return config.middleware;
      } else if (config && config.hasOwnProperty("middleware")) {
        log.error("Expected `middleware` to be a boolean.");
      }
      return true;
    }
    __name(getMiddlewareSetting, "getMiddlewareSetting");
    function getQsObfuscator(config) {
      const obfuscator = config.queryStringObfuscation;
      if (typeof obfuscator === "boolean") {
        return obfuscator;
      }
      if (typeof obfuscator === "string") {
        if (obfuscator === "")
          return false;
        if (obfuscator === ".*")
          return true;
        try {
          return new RegExp(obfuscator, "gi");
        } catch (err) {
          log.error(err);
        }
      }
      if (config.hasOwnProperty("queryStringObfuscation")) {
        log.error("Expected `queryStringObfuscation` to be a regex string or boolean.");
      }
      return true;
    }
    __name(getQsObfuscator, "getQsObfuscator");
    module2.exports = web;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-web/src/index.js
var require_src7 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-web/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var web = require_web();
    var WebPlugin = class extends Plugin {
      static get name() {
        return "web";
      }
      configure(config) {
        return super.configure(web.normalizeConfig(config));
      }
      setFramework(req, name, config) {
        web.setFramework(req, name, config);
      }
    };
    module2.exports = WebPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-router/src/index.js
var require_src8 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-router/src/index.js"(exports2, module2) {
    "use strict";
    var web = require_web();
    var WebPlugin = require_src7();
    var analyticsSampler = require_analytics_sampler();
    var { storage } = require_datadog_core();
    var { COMPONENT } = require_constants();
    var RouterPlugin = class extends WebPlugin {
      static get name() {
        return "router";
      }
      constructor(...args) {
        super(...args);
        this._storeStack = [];
        this._contexts = /* @__PURE__ */ new WeakMap();
        this.addSub(`apm:${this.constructor.name}:middleware:enter`, ({ req, name, route }) => {
          const childOf = this._getActive(req) || this._getStoreSpan();
          if (!childOf)
            return;
          const span = this._getMiddlewareSpan(name, childOf);
          const context = this._createContext(req, route, childOf);
          if (childOf !== span) {
            context.middleware.push(span);
          }
          const store = storage.getStore();
          this._storeStack.push(store);
          this.enter(span, store);
          web.patch(req);
          web.setRoute(req, context.route);
        });
        this.addSub(`apm:${this.constructor.name}:middleware:next`, ({ req }) => {
          const context = this._contexts.get(req);
          if (!context)
            return;
          context.stack.pop();
        });
        this.addSub(`apm:${this.constructor.name}:middleware:finish`, ({ req }) => {
          const context = this._contexts.get(req);
          if (!context || context.middleware.length === 0)
            return;
          context.middleware.pop().finish();
        });
        this.addSub(`apm:${this.constructor.name}:middleware:exit`, ({ req }) => {
          const savedStore = this._storeStack.pop();
          const span = savedStore && savedStore.span;
          this.enter(span, savedStore);
        });
        this.addSub(`apm:${this.constructor.name}:middleware:error`, ({ req, error }) => {
          web.addError(req, error);
          if (!this.config.middleware)
            return;
          const span = this._getActive(req);
          if (!span)
            return;
          span.setTag("error", error);
        });
        this.addSub(`apm:http:server:request:finish`, ({ req }) => {
          const context = this._contexts.get(req);
          if (!context)
            return;
          let span;
          while (span = context.middleware.pop()) {
            span.finish();
          }
        });
      }
      _getActive(req) {
        const context = this._contexts.get(req);
        if (!context)
          return;
        if (context.middleware.length === 0)
          return context.span;
        return context.middleware[context.middleware.length - 1];
      }
      _getStoreSpan() {
        const store = storage.getStore();
        return store && store.span;
      }
      _getMiddlewareSpan(name, childOf) {
        if (this.config.middleware === false) {
          return childOf;
        }
        const span = this.tracer.startSpan(`${this.constructor.name}.middleware`, {
          childOf,
          tags: {
            [COMPONENT]: this.constructor.name,
            "resource.name": name || "<anonymous>"
          }
        });
        analyticsSampler.sample(span, this.config.measured);
        return span;
      }
      _createContext(req, route, span) {
        let context = this._contexts.get(req);
        if (!route || route === "/" || route === "*") {
          route = "";
        }
        if (context) {
          context.stack.push(route);
          route = context.stack.join("");
          if (route.length > context.route.length) {
            context.route = route;
          }
        } else {
          context = {
            span,
            stack: [route],
            route,
            middleware: []
          };
          this._contexts.set(req, context);
        }
        return context;
      }
    };
    module2.exports = RouterPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-hapi/src/index.js
var require_src9 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-hapi/src/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var RouterPlugin = require_src8();
    var web = require_web();
    var HapiPlugin = class extends RouterPlugin {
      static get name() {
        return "hapi";
      }
      constructor(...args) {
        super(...args);
        this._requestSpans = /* @__PURE__ */ new WeakMap();
        this.addSub("apm:hapi:request:handle", ({ req }) => {
          const store = storage.getStore();
          const span = store && store.span;
          this.setFramework(req, "hapi", this.config);
          this._requestSpans.set(req, span);
        });
        this.addSub("apm:hapi:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
        this.addSub("apm:hapi:request:error", (error) => {
          if (!error || !error.isBoom || !this.config.validateStatus(error.output.statusCode)) {
            this.addError(error);
          }
        });
        this.addSub("apm:hapi:extension:enter", ({ req }) => {
          this.enter(this._requestSpans.get(req));
        });
      }
    };
    module2.exports = HapiPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-jest/src/index.js
var require_src10 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-jest/src/index.js"(exports2, module2) {
    var CiPlugin = require_ci_plugin();
    var { storage } = require_datadog_core();
    var {
      TEST_STATUS,
      JEST_TEST_RUNNER,
      finishAllTraceSpans,
      getTestEnvironmentMetadata,
      getTestSuiteCommonTags,
      addIntelligentTestRunnerSpanTags,
      TEST_PARAMETERS,
      getCodeOwnersFileEntries,
      TEST_COMMAND,
      TEST_FRAMEWORK_VERSION
    } = require_test();
    var { COMPONENT } = require_constants();
    var CHILD_MESSAGE_END = 2;
    var JestPlugin = class extends CiPlugin {
      static get name() {
        return "jest";
      }
      constructor(...args) {
        super(...args);
        const handler2 = /* @__PURE__ */ __name(([message]) => {
          if (message === CHILD_MESSAGE_END) {
            this.tracer._exporter.flush(() => {
              process.removeListener("message", handler2);
            });
          }
        }, "handler");
        process.on("message", handler2);
        this.testEnvironmentMetadata = getTestEnvironmentMetadata("jest", this.config);
        this.codeOwnersEntries = getCodeOwnersFileEntries();
        this.addSub("ci:jest:session:finish", ({
          status,
          isSuitesSkipped,
          isSuitesSkippingEnabled,
          isCodeCoverageEnabled,
          testCodeCoverageLinesTotal
        }) => {
          this.testSessionSpan.setTag(TEST_STATUS, status);
          this.testModuleSpan.setTag(TEST_STATUS, status);
          addIntelligentTestRunnerSpanTags(
            this.testSessionSpan,
            this.testModuleSpan,
            { isSuitesSkipped, isSuitesSkippingEnabled, isCodeCoverageEnabled, testCodeCoverageLinesTotal }
          );
          this.testModuleSpan.finish();
          this.testSessionSpan.finish();
          finishAllTraceSpans(this.testSessionSpan);
          this.tracer._exporter.flush();
        });
        this.addSub("ci:jest:session:configuration", (configs) => {
          configs.forEach((config) => {
            config._ddTestSessionId = this.testSessionSpan.context().toTraceId();
            config._ddTestModuleId = this.testModuleSpan.context().toSpanId();
            config._ddTestCommand = this.testSessionSpan.context()._tags[TEST_COMMAND];
          });
        });
        this.addSub("ci:jest:test-suite:start", ({ testSuite, testEnvironmentOptions, frameworkVersion }) => {
          const {
            _ddTestSessionId: testSessionId,
            _ddTestCommand: testCommand,
            _ddTestModuleId: testModuleId
          } = testEnvironmentOptions;
          const testSessionSpanContext = this.tracer.extract("text_map", {
            "x-datadog-trace-id": testSessionId,
            "x-datadog-parent-id": testModuleId
          });
          const testSuiteMetadata = getTestSuiteCommonTags(testCommand, frameworkVersion, testSuite);
          this.testSuiteSpan = this.tracer.startSpan("jest.test_suite", {
            childOf: testSessionSpanContext,
            tags: {
              [COMPONENT]: this.constructor.name,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata
            }
          });
        });
        this.addSub("ci:jest:test-suite:finish", ({ status, errorMessage }) => {
          this.testSuiteSpan.setTag(TEST_STATUS, status);
          if (errorMessage) {
            this.testSuiteSpan.setTag("error", new Error(errorMessage));
          }
          this.testSuiteSpan.finish();
          finishAllTraceSpans(this.testSuiteSpan);
        });
        this.addSub("ci:jest:test-suite:code-coverage", (coverageFiles) => {
          this.tracer._exporter.exportCoverage({ span: this.testSuiteSpan, coverageFiles });
        });
        this.addSub("ci:jest:test:start", (test) => {
          const store = storage.getStore();
          const span = this.startTestSpan(test);
          this.enter(span, store);
        });
        this.addSub("ci:jest:test:finish", (status) => {
          const span = storage.getStore().span;
          span.setTag(TEST_STATUS, status);
          span.finish();
          finishAllTraceSpans(span);
        });
        this.addSub("ci:jest:test:err", (error) => {
          if (error) {
            const store = storage.getStore();
            if (store && store.span) {
              const span = store.span;
              span.setTag(TEST_STATUS, "fail");
              span.setTag("error", error);
            }
          }
        });
        this.addSub("ci:jest:test:skip", (test) => {
          const span = this.startTestSpan(test);
          span.setTag(TEST_STATUS, "skip");
          span.finish();
        });
      }
      startTestSpan(test) {
        const { suite, name, runner, testParameters, frameworkVersion } = test;
        const extraTags = {
          [JEST_TEST_RUNNER]: runner,
          [TEST_PARAMETERS]: testParameters,
          [TEST_FRAMEWORK_VERSION]: frameworkVersion
        };
        return super.startTestSpan(name, suite, this.testSuiteSpan, extraTags);
      }
    };
    module2.exports = JestPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js
var require_src11 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-koa/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src8();
    var web = require_web();
    var KoaPlugin = class extends RouterPlugin {
      static get name() {
        return "koa";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:koa:request:handle", ({ req }) => {
          this.setFramework(req, "koa", this.config);
        });
        this.addSub("apm:koa:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
      }
    };
    module2.exports = KoaPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/cache.js
var require_cache = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/cache.js"(exports2, module2) {
    "use strict";
    var StoragePlugin = require_storage2();
    var CachePlugin = class extends StoragePlugin {
      static get operation() {
        return "command";
      }
    };
    __name(CachePlugin, "CachePlugin");
    module2.exports = CachePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js
var require_src12 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-redis/src/index.js"(exports2, module2) {
    "use strict";
    var CachePlugin = require_cache();
    var urlFilter = require_urlfilter();
    var RedisPlugin = class extends CachePlugin {
      static get name() {
        return "redis";
      }
      static get system() {
        return "redis";
      }
      start({ db, command, args, connectionOptions = {}, connectionName }) {
        if (!this.config.filter(command))
          return this.skip();
        this.startSpan("redis.command", {
          service: getService(this.config, connectionName),
          resource: command,
          type: "redis",
          kind: "client",
          meta: {
            "db.type": "redis",
            "db.name": db || "0",
            "redis.raw_command": formatCommand(command, args),
            "out.host": connectionOptions.host,
            "out.port": connectionOptions.port
          }
        });
      }
      configure(config) {
        super.configure(normalizeConfig(config));
      }
    };
    function getService(config, connectionName) {
      if (config.splitByInstance && connectionName) {
        return config.service ? `${config.service}-${connectionName}` : connectionName;
      }
      return config.service;
    }
    __name(getService, "getService");
    function formatCommand(command, args) {
      command = command.toUpperCase();
      if (!args || command === "AUTH")
        return command;
      for (let i = 0, l = args.length; i < l; i++) {
        if (typeof args[i] === "function")
          continue;
        command = `${command} ${formatArg(args[i])}`;
        if (command.length > 1e3)
          return trim(command, 1e3);
      }
      return command;
    }
    __name(formatCommand, "formatCommand");
    function formatArg(arg) {
      switch (typeof arg) {
        case "string":
        case "number":
          return trim(String(arg), 100);
        default:
          return "?";
      }
    }
    __name(formatArg, "formatArg");
    function trim(str, maxlen) {
      if (str.length > maxlen) {
        str = str.substr(0, maxlen - 3) + "...";
      }
      return str;
    }
    __name(trim, "trim");
    function normalizeConfig(config) {
      const filter = urlFilter.getFilter(config);
      return Object.assign({}, config, {
        filter
      });
    }
    __name(normalizeConfig, "normalizeConfig");
    module2.exports = RedisPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-opensearch/src/index.js
var require_src13 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-opensearch/src/index.js"(exports2, module2) {
    "use strict";
    var ElasticsearchPlugin = require_src4();
    var OpenSearchPlugin = class extends ElasticsearchPlugin {
      static get name() {
        return "opensearch";
      }
    };
    module2.exports = OpenSearchPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-amqp10/src/util.js
var require_util4 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-amqp10/src/util.js"(exports2, module2) {
    "use strict";
    function getAddress(link) {
      if (!link || !link.session || !link.session.connection)
        return {};
      return link.session.connection.address || {};
    }
    __name(getAddress, "getAddress");
    function getShortName(link) {
      if (!link || !link.name)
        return null;
      return link.name.split("_").slice(0, -1).join("_");
    }
    __name(getShortName, "getShortName");
    module2.exports = { getAddress, getShortName };
  }
});

// node_modules/dd-trace/packages/datadog-plugin-amqp10/src/producer.js
var require_producer3 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-amqp10/src/producer.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer();
    var { getAddress, getShortName } = require_util4();
    var Amqp10ProducerPlugin = class extends ProducerPlugin {
      static get name() {
        return "amqp10";
      }
      static get operation() {
        return "send";
      }
      static get system() {
        return "amqp";
      }
      start({ link }) {
        const address = getAddress(link);
        const target = getShortName(link);
        this.startSpan("amqp.send", {
          service: this.config.service || `${this.tracer._service}-amqp`,
          resource: ["send", target].filter((v) => v).join(" "),
          kind: "producer",
          meta: {
            "amqp.link.target.address": target,
            "amqp.link.role": "sender",
            "out.host": address.host,
            "out.port": address.port,
            "amqp.link.name": link.name,
            "amqp.link.handle": link.handle,
            "amqp.connection.host": address.host,
            "amqp.connection.port": address.port,
            "amqp.connection.user": address.user
          }
        });
      }
    };
    module2.exports = Amqp10ProducerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-amqp10/src/consumer.js
var require_consumer3 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-amqp10/src/consumer.js"(exports2, module2) {
    "use strict";
    var ConsumerPlugin = require_consumer();
    var { getAddress, getShortName } = require_util4();
    var Amqp10ConsumerPlugin = class extends ConsumerPlugin {
      static get name() {
        return "amqp10";
      }
      static get system() {
        return "amqp";
      }
      start({ link }) {
        const source = getShortName(link);
        const address = getAddress(link);
        this.startSpan("amqp.receive", {
          service: this.config.service || `${this.tracer._service}-amqp`,
          resource: ["receive", source].filter((v) => v).join(" "),
          type: "worker",
          kind: "consumer",
          meta: {
            "amqp.link.source.address": source,
            "amqp.link.role": "receiver",
            "amqp.link.name": link.name,
            "amqp.link.handle": link.handle,
            "amqp.connection.host": address.host,
            "amqp.connection.port": address.port,
            "amqp.connection.user": address.user
          }
        });
      }
    };
    module2.exports = Amqp10ConsumerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js
var require_src14 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-amqp10/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer3();
    var ConsumerPlugin = require_consumer3();
    var CompositePlugin = require_composite();
    var Amqp10Plugin = class extends CompositePlugin {
      static get name() {
        return "amqp10";
      }
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin
        };
      }
    };
    module2.exports = Amqp10Plugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-amqplib/src/util.js
var require_util5 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-amqplib/src/util.js"(exports2, module2) {
    "use strict";
    function getResourceName(method, fields = {}) {
      return [
        method,
        fields.exchange,
        fields.routingKey,
        fields.queue,
        fields.source,
        fields.destination
      ].filter((val) => val).join(" ");
    }
    __name(getResourceName, "getResourceName");
    module2.exports = { getResourceName };
  }
});

// node_modules/dd-trace/packages/datadog-plugin-amqplib/src/producer.js
var require_producer4 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-amqplib/src/producer.js"(exports2, module2) {
    "use strict";
    var { TEXT_MAP } = require_formats();
    var ProducerPlugin = require_producer();
    var { getResourceName } = require_util5();
    var AmqplibProducerPlugin = class extends ProducerPlugin {
      static get name() {
        return "amqplib";
      }
      static get operation() {
        return "command";
      }
      start({ channel = {}, method, fields }) {
        if (method !== "basic.publish")
          return;
        const stream = channel.connection && channel.connection.stream || {};
        const span = this.startSpan("amqp.command", {
          service: this.config.service || `${this.tracer._service}-amqp`,
          resource: getResourceName(method, fields),
          kind: "producer",
          meta: {
            "out.host": stream._host,
            "out.port": stream.remotePort,
            "amqp.queue": fields.queue,
            "amqp.exchange": fields.exchange,
            "amqp.routingKey": fields.routingKey,
            "amqp.consumerTag": fields.consumerTag,
            "amqp.source": fields.source,
            "amqp.destination": fields.destination
          }
        });
        fields.headers = fields.headers || {};
        this.tracer.inject(span, TEXT_MAP, fields.headers);
      }
    };
    module2.exports = AmqplibProducerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-amqplib/src/consumer.js
var require_consumer4 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-amqplib/src/consumer.js"(exports2, module2) {
    "use strict";
    var { TEXT_MAP } = require_formats();
    var ConsumerPlugin = require_consumer();
    var { getResourceName } = require_util5();
    var AmqplibConsumerPlugin = class extends ConsumerPlugin {
      static get name() {
        return "amqplib";
      }
      static get operation() {
        return "command";
      }
      start({ method, fields, message }) {
        if (method !== "basic.deliver" && method !== "basic.get")
          return;
        const childOf = extract(this.tracer, message);
        this.startSpan("amqp.command", {
          childOf,
          service: this.config.service || `${this.tracer._service}-amqp`,
          resource: getResourceName(method, fields),
          kind: "consumer",
          type: "worker",
          meta: {
            "amqp.queue": fields.queue,
            "amqp.exchange": fields.exchange,
            "amqp.routingKey": fields.routingKey,
            "amqp.consumerTag": fields.consumerTag,
            "amqp.source": fields.source,
            "amqp.destination": fields.destination
          }
        });
      }
    };
    function extract(tracer2, message) {
      return message ? tracer2.extract(TEXT_MAP, message.properties.headers) : null;
    }
    __name(extract, "extract");
    module2.exports = AmqplibConsumerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-amqplib/src/client.js
var require_client4 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-amqplib/src/client.js"(exports2, module2) {
    "use strict";
    var { TEXT_MAP } = require_formats();
    var ClientPlugin = require_client();
    var { getResourceName } = require_util5();
    var AmqplibClientPlugin = class extends ClientPlugin {
      static get name() {
        return "amqplib";
      }
      static get operation() {
        return "command";
      }
      start({ channel = {}, method, fields }) {
        if (method === "basic.deliver" || method === "basic.get")
          return;
        if (method === "basic.publish")
          return;
        const stream = channel.connection && channel.connection.stream || {};
        const span = this.startSpan("amqp.command", {
          service: this.config.service || `${this.tracer._service}-amqp`,
          resource: getResourceName(method, fields),
          kind: "client",
          meta: {
            "out.host": stream._host,
            "out.port": stream.remotePort,
            "amqp.queue": fields.queue,
            "amqp.exchange": fields.exchange,
            "amqp.routingKey": fields.routingKey,
            "amqp.consumerTag": fields.consumerTag,
            "amqp.source": fields.source,
            "amqp.destination": fields.destination
          }
        });
        fields.headers = fields.headers || {};
        this.tracer.inject(span, TEXT_MAP, fields.headers);
      }
    };
    module2.exports = AmqplibClientPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js
var require_src15 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-amqplib/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer4();
    var ConsumerPlugin = require_consumer4();
    var ClientPlugin = require_client4();
    var CompositePlugin = require_composite();
    var AmqplibPlugin = class extends CompositePlugin {
      static get name() {
        return "amqplib";
      }
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
          client: ClientPlugin
        };
      }
    };
    module2.exports = AmqplibPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js
var require_log_plugin = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/log_plugin.js"(exports2, module2) {
    "use strict";
    var { LOG } = require_formats();
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var hasOwn = /* @__PURE__ */ __name((obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), "hasOwn");
    function messageProxy(message, holder) {
      return new Proxy(message, {
        get(target, p, receiver) {
          if (p === Symbol.toStringTag) {
            return Object.prototype.toString.call(target).slice(8, -1);
          }
          if (shouldOverride(target, p)) {
            return holder.dd;
          }
          return Reflect.get(target, p, receiver);
        },
        ownKeys(target) {
          const ownKeys = Reflect.ownKeys(target);
          return hasOwn(target, "dd") || !Reflect.isExtensible(target) ? ownKeys : ["dd", ...ownKeys];
        },
        getOwnPropertyDescriptor(target, p) {
          return Reflect.getOwnPropertyDescriptor(shouldOverride(target, p) ? holder : target, p);
        }
      });
    }
    __name(messageProxy, "messageProxy");
    function shouldOverride(target, p) {
      return p === "dd" && !Reflect.has(target, p) && Reflect.isExtensible(target);
    }
    __name(shouldOverride, "shouldOverride");
    module2.exports = /* @__PURE__ */ __name(class LogPlugin extends Plugin {
      constructor(...args) {
        super(...args);
        this.addSub(`apm:${this.constructor.name}:log`, (arg) => {
          const store = storage.getStore();
          const span = store && store.span;
          const holder = {};
          this.tracer.inject(span, LOG, holder);
          arg.message = messageProxy(arg.message, holder);
        });
      }
      configure(config) {
        return super.configure({
          ...config,
          enabled: config.enabled && config.logInjection
        });
      }
    }, "LogPlugin");
  }
});

// node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js
var require_src16 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-bunyan/src/index.js"(exports2, module2) {
    "use strict";
    var LogPlugin = require_log_plugin();
    var BunyanPlugin = class extends LogPlugin {
      static get name() {
        return "bunyan";
      }
    };
    module2.exports = BunyanPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js
var require_src17 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-cassandra-driver/src/index.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var CassandraDriverPlugin = class extends DatabasePlugin {
      static get name() {
        return "cassandra-driver";
      }
      static get system() {
        return "cassandra";
      }
      start({ keyspace, query, connectionOptions = {} }) {
        if (Array.isArray(query)) {
          query = combine(query);
        }
        this.startSpan("cassandra.query", {
          service: this.config.service,
          resource: trim(query, 5e3),
          type: "cassandra",
          kind: "client",
          meta: {
            "db.type": "cassandra",
            "cassandra.query": query,
            "cassandra.keyspace": keyspace,
            "out.host": connectionOptions.host,
            "out.port": connectionOptions.port
          }
        });
      }
    };
    function combine(queries) {
      return queries.map((query) => (query.query || query).replace(/;?$/, ";")).join(" ");
    }
    __name(combine, "combine");
    function trim(str, size) {
      if (!str || str.length <= size)
        return str;
      return `${str.substr(0, size - 3)}...`;
    }
    __name(trim, "trim");
    module2.exports = CassandraDriverPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-connect/src/index.js
var require_src18 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-connect/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src8();
    var ConnectPlugin = class extends RouterPlugin {
      static get name() {
        return "connect";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:connect:request:handle", ({ req }) => {
          this.setFramework(req, "connect", this.config);
        });
      }
    };
    module2.exports = ConnectPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js
var require_src19 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-couchbase/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var analyticsSampler = require_analytics_sampler();
    var CouchBasePlugin = class extends Plugin {
      static get name() {
        return "couchbase";
      }
      addSubs(func, start, finish = defaultFinish) {
        this.addSub(`apm:couchbase:${func}:start`, start);
        this.addSub(`apm:couchbase:${func}:error`, this.addError);
        this.addSub(`apm:couchbase:${func}:finish`, finish);
      }
      startSpan(operation, customTags, store, { bucket, collection }) {
        const tags = {
          "db.type": "couchbase",
          "component": "couchbase",
          "service.name": this.config.service || `${this.tracer._service}-couchbase`,
          "resource.name": `couchbase.${operation}`,
          "span.kind": "client"
        };
        for (const tag in customTags) {
          tags[tag] = customTags[tag];
        }
        const span = this.tracer.startSpan(`couchbase.${operation}`, {
          childOf: store ? store.span : null,
          tags
        });
        if (bucket)
          span.setTag(`couchbase.bucket.name`, bucket.name);
        if (collection)
          span.setTag(`couchbase.collection.name`, collection.name);
        analyticsSampler.sample(span, this.config.measured);
        return span;
      }
      constructor(...args) {
        super(...args);
        this.addSubs("query", ({ resource, bucket }) => {
          const store = storage.getStore();
          const span = this.startSpan(
            "query",
            { "span.type": "sql", "resource.name": resource },
            store,
            { bucket }
          );
          this.enter(span, store);
        });
        this._addCommandSubs("upsert");
        this._addCommandSubs("insert");
        this._addCommandSubs("replace");
        this._addCommandSubs("append");
        this._addCommandSubs("prepend");
      }
      _addCommandSubs(name) {
        this.addSubs(name, ({ bucket, collection }) => {
          const store = storage.getStore();
          const span = this.startSpan(name, {}, store, { bucket, collection });
          this.enter(span, store);
        });
      }
    };
    function defaultFinish() {
      storage.getStore().span.finish();
    }
    __name(defaultFinish, "defaultFinish");
    module2.exports = CouchBasePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-cypress/src/index.js
var require_src20 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-cypress/src/index.js"(exports2, module2) {
    var Plugin = require_plugin();
    var CypressPlugin = class extends Plugin {
      static get name() {
        return "cypress";
      }
    };
    module2.exports = CypressPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-dns/src/lookup.js
var require_lookup = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-dns/src/lookup.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client();
    var DNSLookupPlugin = class extends ClientPlugin {
      static get name() {
        return "dns";
      }
      static get operation() {
        return "lookup";
      }
      start([hostname]) {
        this.startSpan("dns.lookup", {
          service: this.config.service,
          resource: hostname,
          kind: "client",
          meta: {
            "dns.hostname": hostname,
            "dns.address": "",
            "dns.addresses": ""
          }
        });
      }
      finish(result) {
        const span = this.activeSpan;
        if (Array.isArray(result)) {
          const addresses = Array.isArray(result) ? result.map((address) => address.address).sort() : [result];
          span.setTag("dns.address", addresses[0]);
          span.setTag("dns.addresses", addresses.join(","));
        } else {
          span.setTag("dns.address", result);
        }
        span.finish();
      }
    };
    module2.exports = DNSLookupPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-dns/src/lookup_service.js
var require_lookup_service = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-dns/src/lookup_service.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client();
    var DNSLookupServicePlugin = class extends ClientPlugin {
      static get name() {
        return "dns";
      }
      static get operation() {
        return "lookup_service";
      }
      start([address, port]) {
        this.startSpan("dns.lookup_service", {
          service: this.config.service,
          resource: `${address}:${port}`,
          kind: "client",
          meta: {
            "dns.address": address
          },
          metrics: {
            "dns.port": port
          }
        });
      }
    };
    module2.exports = DNSLookupServicePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-dns/src/resolve.js
var require_resolve = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-dns/src/resolve.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client();
    var DNSResolvePlugin = class extends ClientPlugin {
      static get name() {
        return "dns";
      }
      static get operation() {
        return "resolve";
      }
      start([hostname, maybeType]) {
        const rrtype = typeof maybeType === "string" ? maybeType : "A";
        this.startSpan("dns.resolve", {
          service: this.config.service,
          resource: `${rrtype} ${hostname}`,
          kind: "client",
          meta: {
            "dns.hostname": hostname,
            "dns.rrtype": rrtype
          }
        });
      }
    };
    module2.exports = DNSResolvePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-dns/src/reverse.js
var require_reverse = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-dns/src/reverse.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client();
    var DNSReversePlugin = class extends ClientPlugin {
      static get name() {
        return "dns";
      }
      static get operation() {
        return "reverse";
      }
      start([ip]) {
        this.startSpan("dns.reverse", {
          service: this.config.service,
          resource: ip,
          kind: "client",
          meta: {
            "dns.ip": ip
          }
        });
      }
    };
    module2.exports = DNSReversePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js
var require_src21 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite();
    var DNSLookupPlugin = require_lookup();
    var DNSLookupServicePlugin = require_lookup_service();
    var DNSResolvePlugin = require_resolve();
    var DNSReversePlugin = require_reverse();
    var DNSPlugin = class extends CompositePlugin {
      static get name() {
        return "dns";
      }
      static get plugins() {
        return {
          lookup: DNSLookupPlugin,
          lookup_service: DNSLookupServicePlugin,
          resolve: DNSResolvePlugin,
          reverse: DNSReversePlugin
        };
      }
    };
    module2.exports = DNSPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-express/src/index.js
var require_src22 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-express/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src8();
    var ExpressPlugin = class extends RouterPlugin {
      static get name() {
        return "express";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:express:request:handle", ({ req }) => {
          this.setFramework(req, "express", this.config);
        });
      }
    };
    module2.exports = ExpressPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js
var require_src23 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-fastify/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src8();
    var FastifyPlugin = class extends RouterPlugin {
      static get name() {
        return "fastify";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:fastify:request:handle", ({ req }) => {
          this.setFramework(req, "fastify", this.config);
        });
      }
    };
    module2.exports = FastifyPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-find-my-way/src/index.js
var require_src24 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-find-my-way/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var web = require_web();
    var FindMyWayPlugin = class extends Plugin {
      static get name() {
        return "find-my-way";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:find-my-way:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
      }
    };
    module2.exports = FindMyWayPlugin;
  }
});

// node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS({
  "node_modules/graphql/jsutils/devAssert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.devAssert = devAssert;
    function devAssert(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message);
      }
    }
    __name(devAssert, "devAssert");
  }
});

// node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS({
  "node_modules/graphql/jsutils/inspect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.inspect = inspect;
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH = 2;
    function inspect(value) {
      return formatValue(value, []);
    }
    __name(inspect, "inspect");
    function formatValue(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    __name(formatValue, "formatValue");
    function formatObjectValue(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    __name(formatObjectValue, "formatObjectValue");
    function isJSONable(value) {
      return typeof value.toJSON === "function";
    }
    __name(isJSONable, "isJSONable");
    function formatObject(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      const properties = entries.map(
        ([key, value]) => key + ": " + formatValue(value, seenValues)
      );
      return "{ " + properties.join(", ") + " }";
    }
    __name(formatObject, "formatObject");
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      const len = Math.min(MAX_ARRAY_LENGTH, array.length);
      const remaining = array.length - len;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    __name(formatArray, "formatArray");
    function getObjectTag(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
    __name(getObjectTag, "getObjectTag");
  }
});

// node_modules/graphql/language/ast.js
var require_ast = __commonJS({
  "node_modules/graphql/language/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Token = exports2.QueryDocumentKeys = exports2.OperationTypeNode = exports2.Location = void 0;
    exports2.isNode = isNode;
    var Location = class {
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    __name(Location, "Location");
    exports2.Location = Location;
    var Token = class {
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    __name(Token, "Token");
    exports2.Token = Token;
    var QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    exports2.QueryDocumentKeys = QueryDocumentKeys;
    var kindValues = new Set(Object.keys(QueryDocumentKeys));
    function isNode(maybeNode) {
      const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
      return typeof maybeKind === "string" && kindValues.has(maybeKind);
    }
    __name(isNode, "isNode");
    var OperationTypeNode;
    exports2.OperationTypeNode = OperationTypeNode;
    (function(OperationTypeNode2) {
      OperationTypeNode2["QUERY"] = "query";
      OperationTypeNode2["MUTATION"] = "mutation";
      OperationTypeNode2["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode || (exports2.OperationTypeNode = OperationTypeNode = {}));
  }
});

// node_modules/graphql/language/kinds.js
var require_kinds2 = __commonJS({
  "node_modules/graphql/language/kinds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Kind = void 0;
    var Kind;
    exports2.Kind = Kind;
    (function(Kind2) {
      Kind2["NAME"] = "Name";
      Kind2["DOCUMENT"] = "Document";
      Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind2["SELECTION_SET"] = "SelectionSet";
      Kind2["FIELD"] = "Field";
      Kind2["ARGUMENT"] = "Argument";
      Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind2["INLINE_FRAGMENT"] = "InlineFragment";
      Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind2["VARIABLE"] = "Variable";
      Kind2["INT"] = "IntValue";
      Kind2["FLOAT"] = "FloatValue";
      Kind2["STRING"] = "StringValue";
      Kind2["BOOLEAN"] = "BooleanValue";
      Kind2["NULL"] = "NullValue";
      Kind2["ENUM"] = "EnumValue";
      Kind2["LIST"] = "ListValue";
      Kind2["OBJECT"] = "ObjectValue";
      Kind2["OBJECT_FIELD"] = "ObjectField";
      Kind2["DIRECTIVE"] = "Directive";
      Kind2["NAMED_TYPE"] = "NamedType";
      Kind2["LIST_TYPE"] = "ListType";
      Kind2["NON_NULL_TYPE"] = "NonNullType";
      Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind2["FIELD_DEFINITION"] = "FieldDefinition";
      Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind || (exports2.Kind = Kind = {}));
  }
});

// node_modules/graphql/language/visitor.js
var require_visitor = __commonJS({
  "node_modules/graphql/language/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BREAK = void 0;
    exports2.getEnterLeaveForKind = getEnterLeaveForKind;
    exports2.getVisitFn = getVisitFn;
    exports2.visit = visit;
    exports2.visitInParallel = visitInParallel;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _ast = require_ast();
    var _kinds = require_kinds2();
    var BREAK = Object.freeze({});
    exports2.BREAK = BREAK;
    function visit(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
      const enterLeaveMap = /* @__PURE__ */ new Map();
      for (const kind of Object.values(_kinds.Kind)) {
        enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
      }
      let stack = void 0;
      let inArray = Array.isArray(root);
      let keys = [root];
      let index = -1;
      let edits = [];
      let node = root;
      let key = void 0;
      let parent = void 0;
      const path = [];
      const ancestors = [];
      do {
        index++;
        const isLeaving = index === keys.length;
        const isEdited = isLeaving && edits.length !== 0;
        if (isLeaving) {
          key = ancestors.length === 0 ? void 0 : path[path.length - 1];
          node = parent;
          parent = ancestors.pop();
          if (isEdited) {
            if (inArray) {
              node = node.slice();
              let editOffset = 0;
              for (const [editKey, editValue] of edits) {
                const arrayKey = editKey - editOffset;
                if (editValue === null) {
                  node.splice(arrayKey, 1);
                  editOffset++;
                } else {
                  node[arrayKey] = editValue;
                }
              }
            } else {
              node = Object.defineProperties(
                {},
                Object.getOwnPropertyDescriptors(node)
              );
              for (const [editKey, editValue] of edits) {
                node[editKey] = editValue;
              }
            }
          }
          index = stack.index;
          keys = stack.keys;
          edits = stack.edits;
          inArray = stack.inArray;
          stack = stack.prev;
        } else if (parent) {
          key = inArray ? index : keys[index];
          node = parent[key];
          if (node === null || node === void 0) {
            continue;
          }
          path.push(key);
        }
        let result;
        if (!Array.isArray(node)) {
          var _enterLeaveMap$get, _enterLeaveMap$get2;
          (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
            false,
            `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
          );
          const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
          result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
          if (result === BREAK) {
            break;
          }
          if (result === false) {
            if (!isLeaving) {
              path.pop();
              continue;
            }
          } else if (result !== void 0) {
            edits.push([key, result]);
            if (!isLeaving) {
              if ((0, _ast.isNode)(result)) {
                node = result;
              } else {
                path.pop();
                continue;
              }
            }
          }
        }
        if (result === void 0 && isEdited) {
          edits.push([key, node]);
        }
        if (isLeaving) {
          path.pop();
        } else {
          var _node$kind;
          stack = {
            inArray,
            index,
            keys,
            edits,
            prev: stack
          };
          inArray = Array.isArray(node);
          keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
          index = -1;
          edits = [];
          if (parent) {
            ancestors.push(parent);
          }
          parent = node;
        }
      } while (stack !== void 0);
      if (edits.length !== 0) {
        return edits[edits.length - 1][1];
      }
      return root;
    }
    __name(visit, "visit");
    function visitInParallel(visitors) {
      const skipping = new Array(visitors.length).fill(null);
      const mergedVisitor = /* @__PURE__ */ Object.create(null);
      for (const kind of Object.values(_kinds.Kind)) {
        let hasVisitor = false;
        const enterList = new Array(visitors.length).fill(void 0);
        const leaveList = new Array(visitors.length).fill(void 0);
        for (let i = 0; i < visitors.length; ++i) {
          const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
          hasVisitor || (hasVisitor = enter != null || leave != null);
          enterList[i] = enter;
          leaveList[i] = leave;
        }
        if (!hasVisitor) {
          continue;
        }
        const mergedEnterLeave = {
          enter(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _enterList$i;
                const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                if (result === false) {
                  skipping[i] = node;
                } else if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0) {
                  return result;
                }
              }
            }
          },
          leave(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _leaveList$i;
                const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0 && result !== false) {
                  return result;
                }
              } else if (skipping[i] === node) {
                skipping[i] = null;
              }
            }
          }
        };
        mergedVisitor[kind] = mergedEnterLeave;
      }
      return mergedVisitor;
    }
    __name(visitInParallel, "visitInParallel");
    function getEnterLeaveForKind(visitor, kind) {
      const kindVisitor = visitor[kind];
      if (typeof kindVisitor === "object") {
        return kindVisitor;
      } else if (typeof kindVisitor === "function") {
        return {
          enter: kindVisitor,
          leave: void 0
        };
      }
      return {
        enter: visitor.enter,
        leave: visitor.leave
      };
    }
    __name(getEnterLeaveForKind, "getEnterLeaveForKind");
    function getVisitFn(visitor, kind, isLeaving) {
      const { enter, leave } = getEnterLeaveForKind(visitor, kind);
      return isLeaving ? leave : enter;
    }
    __name(getVisitFn, "getVisitFn");
  }
});

// node_modules/graphql/language/characterClasses.js
var require_characterClasses = __commonJS({
  "node_modules/graphql/language/characterClasses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isDigit = isDigit;
    exports2.isLetter = isLetter;
    exports2.isNameContinue = isNameContinue;
    exports2.isNameStart = isNameStart;
    exports2.isWhiteSpace = isWhiteSpace;
    function isWhiteSpace(code) {
      return code === 9 || code === 32;
    }
    __name(isWhiteSpace, "isWhiteSpace");
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    __name(isDigit, "isDigit");
    function isLetter(code) {
      return code >= 97 && code <= 122 || code >= 65 && code <= 90;
    }
    __name(isLetter, "isLetter");
    function isNameStart(code) {
      return isLetter(code) || code === 95;
    }
    __name(isNameStart, "isNameStart");
    function isNameContinue(code) {
      return isLetter(code) || isDigit(code) || code === 95;
    }
    __name(isNameContinue, "isNameContinue");
  }
});

// node_modules/graphql/language/blockString.js
var require_blockString = __commonJS({
  "node_modules/graphql/language/blockString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dedentBlockStringLines = dedentBlockStringLines;
    exports2.isPrintableAsBlockString = isPrintableAsBlockString;
    exports2.printBlockString = printBlockString;
    var _characterClasses = require_characterClasses();
    function dedentBlockStringLines(lines) {
      var _firstNonEmptyLine2;
      let commonIndent = Number.MAX_SAFE_INTEGER;
      let firstNonEmptyLine = null;
      let lastNonEmptyLine = -1;
      for (let i = 0; i < lines.length; ++i) {
        var _firstNonEmptyLine;
        const line = lines[i];
        const indent = leadingWhitespace(line);
        if (indent === line.length) {
          continue;
        }
        firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
        lastNonEmptyLine = i;
        if (i !== 0 && indent < commonIndent) {
          commonIndent = indent;
        }
      }
      return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
        (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
        lastNonEmptyLine + 1
      );
    }
    __name(dedentBlockStringLines, "dedentBlockStringLines");
    function leadingWhitespace(str) {
      let i = 0;
      while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
        ++i;
      }
      return i;
    }
    __name(leadingWhitespace, "leadingWhitespace");
    function isPrintableAsBlockString(value) {
      if (value === "") {
        return true;
      }
      let isEmptyLine = true;
      let hasIndent = false;
      let hasCommonIndent = true;
      let seenNonEmptyLine = false;
      for (let i = 0; i < value.length; ++i) {
        switch (value.codePointAt(i)) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 11:
          case 12:
          case 14:
          case 15:
            return false;
          case 13:
            return false;
          case 10:
            if (isEmptyLine && !seenNonEmptyLine) {
              return false;
            }
            seenNonEmptyLine = true;
            isEmptyLine = true;
            hasIndent = false;
            break;
          case 9:
          case 32:
            hasIndent || (hasIndent = isEmptyLine);
            break;
          default:
            hasCommonIndent && (hasCommonIndent = hasIndent);
            isEmptyLine = false;
        }
      }
      if (isEmptyLine) {
        return false;
      }
      if (hasCommonIndent && seenNonEmptyLine) {
        return false;
      }
      return true;
    }
    __name(isPrintableAsBlockString, "isPrintableAsBlockString");
    function printBlockString(value, options) {
      const escapedValue = value.replace(/"""/g, '\\"""');
      const lines = escapedValue.split(/\r\n|[\n\r]/g);
      const isSingleLine = lines.length === 1;
      const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
        (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
      );
      const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
      const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
      const hasTrailingSlash = value.endsWith("\\");
      const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
      const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
      let result = "";
      const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
      if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
        result += "\n";
      }
      result += escapedValue;
      if (printAsMultipleLines || forceTrailingNewline) {
        result += "\n";
      }
      return '"""' + result + '"""';
    }
    __name(printBlockString, "printBlockString");
  }
});

// node_modules/graphql/language/printString.js
var require_printString = __commonJS({
  "node_modules/graphql/language/printString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printString = printString;
    function printString(str) {
      return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
    }
    __name(printString, "printString");
    var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    function escapedReplacer(str) {
      return escapeSequences[str.charCodeAt(0)];
    }
    __name(escapedReplacer, "escapedReplacer");
    var escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});

// node_modules/graphql/language/printer.js
var require_printer = __commonJS({
  "node_modules/graphql/language/printer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.print = print;
    var _blockString = require_blockString();
    var _printString = require_printString();
    var _visitor = require_visitor();
    function print(ast) {
      return (0, _visitor.visit)(ast, printDocASTReducer);
    }
    __name(print, "print");
    var MAX_LINE_LENGTH = 80;
    var printDocASTReducer = {
      Name: {
        leave: (node) => node.value
      },
      Variable: {
        leave: (node) => "$" + node.name
      },
      Document: {
        leave: (node) => join(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join(
            [
              node.operation,
              join([node.name, varDefs]),
              join(node.directives, " ")
            ],
            " "
          );
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
      },
      SelectionSet: {
        leave: ({ selections }) => block(selections)
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: ({ name, value }) => name + ": " + value
      },
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join(
          [
            "...",
            wrap("on ", typeCondition),
            join(directives, " "),
            selectionSet
          ],
          " "
        )
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
      },
      IntValue: {
        leave: ({ value }) => value
      },
      FloatValue: {
        leave: ({ value }) => value
      },
      StringValue: {
        leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
      },
      BooleanValue: {
        leave: ({ value }) => value ? "true" : "false"
      },
      NullValue: {
        leave: () => "null"
      },
      EnumValue: {
        leave: ({ value }) => value
      },
      ListValue: {
        leave: ({ values }) => "[" + join(values, ", ") + "]"
      },
      ObjectValue: {
        leave: ({ fields }) => "{" + join(fields, ", ") + "}"
      },
      ObjectField: {
        leave: ({ name, value }) => name + ": " + value
      },
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
      },
      NamedType: {
        leave: ({ name }) => name
      },
      ListType: {
        leave: ({ type }) => "[" + type + "]"
      },
      NonNullType: {
        leave: ({ type }) => type + "!"
      },
      SchemaDefinition: {
        leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      FieldDefinition: {
        leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
          [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
          " "
        )
      },
      InterfaceTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeDefinition: {
        leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
          ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
          " "
        )
      },
      EnumTypeDefinition: {
        leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join(
          ["extend schema", join(directives, " "), block(operationTypes)],
          " "
        )
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join(
          [
            "extend union",
            name,
            join(directives, " "),
            wrap("= ", join(types, " | "))
          ],
          " "
        )
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
      }
    };
    function join(maybeArray, separator = "") {
      var _maybeArray$filter$jo;
      return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
    }
    __name(join, "join");
    function block(array) {
      return wrap("{\n", indent(join(array, "\n")), "\n}");
    }
    __name(block, "block");
    function wrap(start, maybeString, end = "") {
      return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
    }
    __name(wrap, "wrap");
    function indent(str) {
      return wrap("  ", str.replace(/\n/g, "\n  "));
    }
    __name(indent, "indent");
    function hasMultilineItems(maybeArray) {
      var _maybeArray$some;
      return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
    }
    __name(hasMultilineItems, "hasMultilineItems");
  }
});

// node_modules/graphql/utilities/getIntrospectionQuery.js
var require_getIntrospectionQuery = __commonJS({
  "node_modules/graphql/utilities/getIntrospectionQuery.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getIntrospectionQuery = getIntrospectionQuery;
    function getIntrospectionQuery(options) {
      const optionsWithDefault = {
        descriptions: true,
        specifiedByUrl: false,
        directiveIsRepeatable: false,
        schemaDescription: false,
        inputValueDeprecation: false,
        ...options
      };
      const descriptions = optionsWithDefault.descriptions ? "description" : "";
      const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
      const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
      const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
      function inputDeprecation(str) {
        return optionsWithDefault.inputValueDeprecation ? str : "";
      }
      __name(inputDeprecation, "inputDeprecation");
      return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
    }
    __name(getIntrospectionQuery, "getIntrospectionQuery");
  }
});

// node_modules/graphql/utilities/getOperationAST.js
var require_getOperationAST = __commonJS({
  "node_modules/graphql/utilities/getOperationAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOperationAST = getOperationAST;
    var _kinds = require_kinds2();
    function getOperationAST(documentAST, operationName) {
      let operation = null;
      for (const definition of documentAST.definitions) {
        if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
          var _definition$name;
          if (operationName == null) {
            if (operation) {
              return null;
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
            return definition;
          }
        }
      }
      return operation;
    }
    __name(getOperationAST, "getOperationAST");
  }
});

// node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/graphql/jsutils/isObjectLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isObjectLike = isObjectLike;
    function isObjectLike(value) {
      return typeof value == "object" && value !== null;
    }
    __name(isObjectLike, "isObjectLike");
  }
});

// node_modules/graphql/jsutils/invariant.js
var require_invariant = __commonJS({
  "node_modules/graphql/jsutils/invariant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.invariant = invariant;
    function invariant(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(
          message != null ? message : "Unexpected invariant triggered."
        );
      }
    }
    __name(invariant, "invariant");
  }
});

// node_modules/graphql/language/location.js
var require_location = __commonJS({
  "node_modules/graphql/language/location.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getLocation = getLocation;
    var _invariant = require_invariant();
    var LineRegExp = /\r\n|[\n\r]/g;
    function getLocation(source, position) {
      let lastLineStart = 0;
      let line = 1;
      for (const match of source.body.matchAll(LineRegExp)) {
        typeof match.index === "number" || (0, _invariant.invariant)(false);
        if (match.index >= position) {
          break;
        }
        lastLineStart = match.index + match[0].length;
        line += 1;
      }
      return {
        line,
        column: position + 1 - lastLineStart
      };
    }
    __name(getLocation, "getLocation");
  }
});

// node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS({
  "node_modules/graphql/language/printLocation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printLocation = printLocation;
    exports2.printSourceLocation = printSourceLocation;
    var _location = require_location();
    function printLocation(location) {
      return printSourceLocation(
        location.source,
        (0, _location.getLocation)(location.source, location.start)
      );
    }
    __name(printLocation, "printLocation");
    function printSourceLocation(source, sourceLocation) {
      const firstLineColumnOffset = source.locationOffset.column - 1;
      const body = "".padStart(firstLineColumnOffset) + source.body;
      const lineIndex = sourceLocation.line - 1;
      const lineOffset = source.locationOffset.line - 1;
      const lineNum = sourceLocation.line + lineOffset;
      const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
      const columnNum = sourceLocation.column + columnOffset;
      const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
      const lines = body.split(/\r\n|[\n\r]/g);
      const locationLine = lines[lineIndex];
      if (locationLine.length > 120) {
        const subLineIndex = Math.floor(columnNum / 80);
        const subLineColumnNum = columnNum % 80;
        const subLines = [];
        for (let i = 0; i < locationLine.length; i += 80) {
          subLines.push(locationLine.slice(i, i + 80));
        }
        return locationStr + printPrefixedLines([
          [`${lineNum} |`, subLines[0]],
          ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
          ["|", "^".padStart(subLineColumnNum)],
          ["|", subLines[subLineIndex + 1]]
        ]);
      }
      return locationStr + printPrefixedLines([
        [`${lineNum - 1} |`, lines[lineIndex - 1]],
        [`${lineNum} |`, locationLine],
        ["|", "^".padStart(columnNum)],
        [`${lineNum + 1} |`, lines[lineIndex + 1]]
      ]);
    }
    __name(printSourceLocation, "printSourceLocation");
    function printPrefixedLines(lines) {
      const existingLines = lines.filter(([_, line]) => line !== void 0);
      const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
      return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
    }
    __name(printPrefixedLines, "printPrefixedLines");
  }
});

// node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS({
  "node_modules/graphql/error/GraphQLError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLError = void 0;
    exports2.formatError = formatError;
    exports2.printError = printError;
    var _isObjectLike = require_isObjectLike();
    var _location = require_location();
    var _printLocation = require_printLocation();
    function toNormalizedOptions(args) {
      const firstArg = args[0];
      if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
        return {
          nodes: firstArg,
          source: args[1],
          positions: args[2],
          path: args[3],
          originalError: args[4],
          extensions: args[5]
        };
      }
      return firstArg;
    }
    __name(toNormalizedOptions, "toNormalizedOptions");
    var GraphQLError = class extends Error {
      constructor(message, ...rawArgs) {
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : void 0;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        this.nodes = undefinedIfEmpty(
          Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
        );
        const nodeLocations = undefinedIfEmpty(
          (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
        );
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
        this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map(
          (loc) => (0, _location.getLocation)(loc.source, loc.start)
        );
        const originalExtensions = (0, _isObjectLike.isObjectLike)(
          originalError === null || originalError === void 0 ? void 0 : originalError.extensions
        ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
        Object.defineProperties(this, {
          message: {
            writable: true,
            enumerable: true
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(this, "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, GraphQLError);
        } else {
          Object.defineProperty(this, "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let output = this.message;
        if (this.nodes) {
          for (const node of this.nodes) {
            if (node.loc) {
              output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const location of this.locations) {
            output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
          }
        }
        return output;
      }
      toJSON() {
        const formattedError = {
          message: this.message
        };
        if (this.locations != null) {
          formattedError.locations = this.locations;
        }
        if (this.path != null) {
          formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          formattedError.extensions = this.extensions;
        }
        return formattedError;
      }
    };
    __name(GraphQLError, "GraphQLError");
    exports2.GraphQLError = GraphQLError;
    function undefinedIfEmpty(array) {
      return array === void 0 || array.length === 0 ? void 0 : array;
    }
    __name(undefinedIfEmpty, "undefinedIfEmpty");
    function printError(error) {
      return error.toString();
    }
    __name(printError, "printError");
    function formatError(error) {
      return error.toJSON();
    }
    __name(formatError, "formatError");
  }
});

// node_modules/graphql/utilities/getOperationRootType.js
var require_getOperationRootType = __commonJS({
  "node_modules/graphql/utilities/getOperationRootType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOperationRootType = getOperationRootType;
    var _GraphQLError = require_GraphQLError();
    function getOperationRootType(schema, operation) {
      if (operation.operation === "query") {
        const queryType = schema.getQueryType();
        if (!queryType) {
          throw new _GraphQLError.GraphQLError(
            "Schema does not define the required query root type.",
            {
              nodes: operation
            }
          );
        }
        return queryType;
      }
      if (operation.operation === "mutation") {
        const mutationType = schema.getMutationType();
        if (!mutationType) {
          throw new _GraphQLError.GraphQLError(
            "Schema is not configured for mutations.",
            {
              nodes: operation
            }
          );
        }
        return mutationType;
      }
      if (operation.operation === "subscription") {
        const subscriptionType = schema.getSubscriptionType();
        if (!subscriptionType) {
          throw new _GraphQLError.GraphQLError(
            "Schema is not configured for subscriptions.",
            {
              nodes: operation
            }
          );
        }
        return subscriptionType;
      }
      throw new _GraphQLError.GraphQLError(
        "Can only have query, mutation and subscription operations.",
        {
          nodes: operation
        }
      );
    }
    __name(getOperationRootType, "getOperationRootType");
  }
});

// node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS({
  "node_modules/graphql/error/syntaxError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.syntaxError = syntaxError;
    var _GraphQLError = require_GraphQLError();
    function syntaxError(source, position, description) {
      return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
        source,
        positions: [position]
      });
    }
    __name(syntaxError, "syntaxError");
  }
});

// node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS({
  "node_modules/graphql/language/directiveLocation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation;
    exports2.DirectiveLocation = DirectiveLocation;
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation || (exports2.DirectiveLocation = DirectiveLocation = {}));
  }
});

// node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS({
  "node_modules/graphql/language/tokenKind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenKind = void 0;
    var TokenKind;
    exports2.TokenKind = TokenKind;
    (function(TokenKind2) {
      TokenKind2["SOF"] = "<SOF>";
      TokenKind2["EOF"] = "<EOF>";
      TokenKind2["BANG"] = "!";
      TokenKind2["DOLLAR"] = "$";
      TokenKind2["AMP"] = "&";
      TokenKind2["PAREN_L"] = "(";
      TokenKind2["PAREN_R"] = ")";
      TokenKind2["SPREAD"] = "...";
      TokenKind2["COLON"] = ":";
      TokenKind2["EQUALS"] = "=";
      TokenKind2["AT"] = "@";
      TokenKind2["BRACKET_L"] = "[";
      TokenKind2["BRACKET_R"] = "]";
      TokenKind2["BRACE_L"] = "{";
      TokenKind2["PIPE"] = "|";
      TokenKind2["BRACE_R"] = "}";
      TokenKind2["NAME"] = "Name";
      TokenKind2["INT"] = "Int";
      TokenKind2["FLOAT"] = "Float";
      TokenKind2["STRING"] = "String";
      TokenKind2["BLOCK_STRING"] = "BlockString";
      TokenKind2["COMMENT"] = "Comment";
    })(TokenKind || (exports2.TokenKind = TokenKind = {}));
  }
});

// node_modules/graphql/language/lexer.js
var require_lexer = __commonJS({
  "node_modules/graphql/language/lexer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Lexer = void 0;
    exports2.isPunctuatorTokenKind = isPunctuatorTokenKind;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _blockString = require_blockString();
    var _characterClasses = require_characterClasses();
    var _tokenKind = require_tokenKind();
    var Lexer = class {
      constructor(source) {
        const startOfFileToken = new _ast.Token(
          _tokenKind.TokenKind.SOF,
          0,
          0,
          0,
          0
        );
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
      }
      lookahead() {
        let token = this.token;
        if (token.kind !== _tokenKind.TokenKind.EOF) {
          do {
            if (token.next) {
              token = token.next;
            } else {
              const nextToken = readNextToken(this, token.end);
              token.next = nextToken;
              nextToken.prev = token;
              token = nextToken;
            }
          } while (token.kind === _tokenKind.TokenKind.COMMENT);
        }
        return token;
      }
    };
    __name(Lexer, "Lexer");
    exports2.Lexer = Lexer;
    function isPunctuatorTokenKind(kind) {
      return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
    }
    __name(isPunctuatorTokenKind, "isPunctuatorTokenKind");
    function isUnicodeScalarValue(code) {
      return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
    }
    __name(isUnicodeScalarValue, "isUnicodeScalarValue");
    function isSupplementaryCodePoint(body, location) {
      return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
    }
    __name(isSupplementaryCodePoint, "isSupplementaryCodePoint");
    function isLeadingSurrogate(code) {
      return code >= 55296 && code <= 56319;
    }
    __name(isLeadingSurrogate, "isLeadingSurrogate");
    function isTrailingSurrogate(code) {
      return code >= 56320 && code <= 57343;
    }
    __name(isTrailingSurrogate, "isTrailingSurrogate");
    function printCodePointAt(lexer, location) {
      const code = lexer.source.body.codePointAt(location);
      if (code === void 0) {
        return _tokenKind.TokenKind.EOF;
      } else if (code >= 32 && code <= 126) {
        const char = String.fromCodePoint(code);
        return char === '"' ? `'"'` : `"${char}"`;
      }
      return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
    }
    __name(printCodePointAt, "printCodePointAt");
    function createToken(lexer, kind, start, end, value) {
      const line = lexer.line;
      const col = 1 + start - lexer.lineStart;
      return new _ast.Token(kind, start, end, line, col, value);
    }
    __name(createToken, "createToken");
    function readNextToken(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        switch (code) {
          case 65279:
          case 9:
          case 32:
          case 44:
            ++position;
            continue;
          case 10:
            ++position;
            ++lexer.line;
            lexer.lineStart = position;
            continue;
          case 13:
            if (body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            ++lexer.line;
            lexer.lineStart = position;
            continue;
          case 35:
            return readComment(lexer, position);
          case 33:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BANG,
              position,
              position + 1
            );
          case 36:
            return createToken(
              lexer,
              _tokenKind.TokenKind.DOLLAR,
              position,
              position + 1
            );
          case 38:
            return createToken(
              lexer,
              _tokenKind.TokenKind.AMP,
              position,
              position + 1
            );
          case 40:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PAREN_L,
              position,
              position + 1
            );
          case 41:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PAREN_R,
              position,
              position + 1
            );
          case 46:
            if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
              return createToken(
                lexer,
                _tokenKind.TokenKind.SPREAD,
                position,
                position + 3
              );
            }
            break;
          case 58:
            return createToken(
              lexer,
              _tokenKind.TokenKind.COLON,
              position,
              position + 1
            );
          case 61:
            return createToken(
              lexer,
              _tokenKind.TokenKind.EQUALS,
              position,
              position + 1
            );
          case 64:
            return createToken(
              lexer,
              _tokenKind.TokenKind.AT,
              position,
              position + 1
            );
          case 91:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACKET_L,
              position,
              position + 1
            );
          case 93:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACKET_R,
              position,
              position + 1
            );
          case 123:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACE_L,
              position,
              position + 1
            );
          case 124:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PIPE,
              position,
              position + 1
            );
          case 125:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACE_R,
              position,
              position + 1
            );
          case 34:
            if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
              return readBlockString(lexer, position);
            }
            return readString(lexer, position);
        }
        if ((0, _characterClasses.isDigit)(code) || code === 45) {
          return readNumber(lexer, position, code);
        }
        if ((0, _characterClasses.isNameStart)(code)) {
          return readName(lexer, position);
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
        );
      }
      return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
    }
    __name(readNextToken, "readNextToken");
    function readComment(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 10 || code === 13) {
          break;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          break;
        }
      }
      return createToken(
        lexer,
        _tokenKind.TokenKind.COMMENT,
        start,
        position,
        body.slice(start + 1, position)
      );
    }
    __name(readComment, "readComment");
    function readNumber(lexer, start, firstCode) {
      const body = lexer.source.body;
      let position = start;
      let code = firstCode;
      let isFloat = false;
      if (code === 45) {
        code = body.charCodeAt(++position);
      }
      if (code === 48) {
        code = body.charCodeAt(++position);
        if ((0, _characterClasses.isDigit)(code)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid number, unexpected digit after 0: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      } else {
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46) {
        isFloat = true;
        code = body.charCodeAt(++position);
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 69 || code === 101) {
        isFloat = true;
        code = body.charCodeAt(++position);
        if (code === 43 || code === 45) {
          code = body.charCodeAt(++position);
        }
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid number, expected digit but got: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
      return createToken(
        lexer,
        isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,
        start,
        position,
        body.slice(start, position)
      );
    }
    __name(readNumber, "readNumber");
    function readDigits(lexer, start, firstCode) {
      if (!(0, _characterClasses.isDigit)(firstCode)) {
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          start,
          `Invalid number, expected digit but got: ${printCodePointAt(
            lexer,
            start
          )}.`
        );
      }
      const body = lexer.source.body;
      let position = start + 1;
      while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
        ++position;
      }
      return position;
    }
    __name(readDigits, "readDigits");
    function readString(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      let chunkStart = position;
      let value = "";
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 34) {
          value += body.slice(chunkStart, position);
          return createToken(
            lexer,
            _tokenKind.TokenKind.STRING,
            start,
            position + 1,
            value
          );
        }
        if (code === 92) {
          value += body.slice(chunkStart, position);
          const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
          value += escape2.value;
          position += escape2.size;
          chunkStart = position;
          continue;
        }
        if (code === 10 || code === 13) {
          break;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid character within String: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        "Unterminated string."
      );
    }
    __name(readString, "readString");
    function readEscapedUnicodeVariableWidth(lexer, position) {
      const body = lexer.source.body;
      let point = 0;
      let size = 3;
      while (size < 12) {
        const code = body.charCodeAt(position + size++);
        if (code === 125) {
          if (size < 5 || !isUnicodeScalarValue(point)) {
            break;
          }
          return {
            value: String.fromCodePoint(point),
            size
          };
        }
        point = point << 4 | readHexDigit(code);
        if (point < 0) {
          break;
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid Unicode escape sequence: "${body.slice(
          position,
          position + size
        )}".`
      );
    }
    __name(readEscapedUnicodeVariableWidth, "readEscapedUnicodeVariableWidth");
    function readEscapedUnicodeFixedWidth(lexer, position) {
      const body = lexer.source.body;
      const code = read16BitHexCode(body, position + 2);
      if (isUnicodeScalarValue(code)) {
        return {
          value: String.fromCodePoint(code),
          size: 6
        };
      }
      if (isLeadingSurrogate(code)) {
        if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
          const trailingCode = read16BitHexCode(body, position + 8);
          if (isTrailingSurrogate(trailingCode)) {
            return {
              value: String.fromCodePoint(code, trailingCode),
              size: 12
            };
          }
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
      );
    }
    __name(readEscapedUnicodeFixedWidth, "readEscapedUnicodeFixedWidth");
    function read16BitHexCode(body, position) {
      return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
    }
    __name(read16BitHexCode, "read16BitHexCode");
    function readHexDigit(code) {
      return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
    }
    __name(readHexDigit, "readHexDigit");
    function readEscapedCharacter(lexer, position) {
      const body = lexer.source.body;
      const code = body.charCodeAt(position + 1);
      switch (code) {
        case 34:
          return {
            value: '"',
            size: 2
          };
        case 92:
          return {
            value: "\\",
            size: 2
          };
        case 47:
          return {
            value: "/",
            size: 2
          };
        case 98:
          return {
            value: "\b",
            size: 2
          };
        case 102:
          return {
            value: "\f",
            size: 2
          };
        case 110:
          return {
            value: "\n",
            size: 2
          };
        case 114:
          return {
            value: "\r",
            size: 2
          };
        case 116:
          return {
            value: "	",
            size: 2
          };
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid character escape sequence: "${body.slice(
          position,
          position + 2
        )}".`
      );
    }
    __name(readEscapedCharacter, "readEscapedCharacter");
    function readBlockString(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let lineStart = lexer.lineStart;
      let position = start + 3;
      let chunkStart = position;
      let currentLine = "";
      const blockLines = [];
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          currentLine += body.slice(chunkStart, position);
          blockLines.push(currentLine);
          const token = createToken(
            lexer,
            _tokenKind.TokenKind.BLOCK_STRING,
            start,
            position + 3,
            (0, _blockString.dedentBlockStringLines)(blockLines).join("\n")
          );
          lexer.line += blockLines.length - 1;
          lexer.lineStart = lineStart;
          return token;
        }
        if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
          currentLine += body.slice(chunkStart, position);
          chunkStart = position + 1;
          position += 4;
          continue;
        }
        if (code === 10 || code === 13) {
          currentLine += body.slice(chunkStart, position);
          blockLines.push(currentLine);
          if (code === 13 && body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          currentLine = "";
          chunkStart = position;
          lineStart = position;
          continue;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid character within String: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        "Unterminated string."
      );
    }
    __name(readBlockString, "readBlockString");
    function readName(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if ((0, _characterClasses.isNameContinue)(code)) {
          ++position;
        } else {
          break;
        }
      }
      return createToken(
        lexer,
        _tokenKind.TokenKind.NAME,
        start,
        position,
        body.slice(start, position)
      );
    }
    __name(readName, "readName");
  }
});

// node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS({
  "node_modules/graphql/jsutils/instanceOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.instanceOf = void 0;
    var _inspect = require_inspect();
    var instanceOf = process.env.NODE_ENV === "production" ? /* @__PURE__ */ __name(function instanceOf2(value, constructor) {
      return value instanceof constructor;
    }, "instanceOf") : /* @__PURE__ */ __name(function instanceOf2(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
        if (className === valueClassName) {
          const stringifiedValue = (0, _inspect.inspect)(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    }, "instanceOf");
    exports2.instanceOf = instanceOf;
  }
});

// node_modules/graphql/language/source.js
var require_source = __commonJS({
  "node_modules/graphql/language/source.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Source = void 0;
    exports2.isSource = isSource;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var Source = class {
      constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
      }) {
        typeof body === "string" || (0, _devAssert.devAssert)(
          false,
          `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`
        );
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || (0, _devAssert.devAssert)(
          false,
          "line in locationOffset is 1-indexed and must be positive."
        );
        this.locationOffset.column > 0 || (0, _devAssert.devAssert)(
          false,
          "column in locationOffset is 1-indexed and must be positive."
        );
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    };
    __name(Source, "Source");
    exports2.Source = Source;
    function isSource(source) {
      return (0, _instanceOf.instanceOf)(source, Source);
    }
    __name(isSource, "isSource");
  }
});

// node_modules/graphql/language/parser.js
var require_parser = __commonJS({
  "node_modules/graphql/language/parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Parser = void 0;
    exports2.parse = parse;
    exports2.parseConstValue = parseConstValue;
    exports2.parseType = parseType;
    exports2.parseValue = parseValue;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _directiveLocation = require_directiveLocation();
    var _kinds = require_kinds2();
    var _lexer = require_lexer();
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    function parse(source, options) {
      const parser = new Parser(source, options);
      return parser.parseDocument();
    }
    __name(parse, "parse");
    function parseValue(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const value = parser.parseValueLiteral(false);
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    __name(parseValue, "parseValue");
    function parseConstValue(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const value = parser.parseConstValueLiteral();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    __name(parseConstValue, "parseConstValue");
    function parseType(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const type = parser.parseTypeReference();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return type;
    }
    __name(parseType, "parseType");
    var Parser = class {
      constructor(source, options = {}) {
        const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        this._lexer = new _lexer.Lexer(sourceObj);
        this._options = options;
        this._tokenCounter = 0;
      }
      parseName() {
        const token = this.expectToken(_tokenKind.TokenKind.NAME);
        return this.node(token, {
          kind: _kinds.Kind.NAME,
          value: token.value
        });
      }
      parseDocument() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.DOCUMENT,
          definitions: this.many(
            _tokenKind.TokenKind.SOF,
            this.parseDefinition,
            _tokenKind.TokenKind.EOF
          )
        });
      }
      parseDefinition() {
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (hasDescription) {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              this._lexer.token.start,
              "Unexpected description, descriptions are supported only on type definitions."
            );
          }
          switch (keywordToken.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation: _ast.OperationTypeNode.QUERY,
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet()
          });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          name = this.parseName();
        }
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      parseOperationType() {
        const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return _ast.OperationTypeNode.QUERY;
          case "mutation":
            return _ast.OperationTypeNode.MUTATION;
          case "subscription":
            return _ast.OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
      }
      parseVariableDefinitions() {
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          this.parseVariableDefinition,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
          directives: this.parseConstDirectives()
        });
      }
      parseVariable() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.DOLLAR);
        return this.node(start, {
          kind: _kinds.Kind.VARIABLE,
          name: this.parseName()
        });
      }
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.SELECTION_SET,
          selections: this.many(
            _tokenKind.TokenKind.BRACE_L,
            this.parseSelection,
            _tokenKind.TokenKind.BRACE_R
          )
        });
      }
      parseSelection() {
        return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return this.node(start, {
          kind: _kinds.Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
        });
      }
      parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          item,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
          kind: _kinds.Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      parseFragment() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false)
          });
        }
        return this.node(start, {
          kind: _kinds.Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      parseFragmentDefinition() {
        const start = this._lexer.token;
        this.expectKeyword("fragment");
        if (this._options.allowLegacyFragmentVariables === true) {
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        return this.node(start, {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch (token.kind) {
          case _tokenKind.TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case _tokenKind.TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case _tokenKind.TokenKind.INT:
            this.advanceLexer();
            return this.node(token, {
              kind: _kinds.Kind.INT,
              value: token.value
            });
          case _tokenKind.TokenKind.FLOAT:
            this.advanceLexer();
            return this.node(token, {
              kind: _kinds.Kind.FLOAT,
              value: token.value
            });
          case _tokenKind.TokenKind.STRING:
          case _tokenKind.TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case _tokenKind.TokenKind.NAME:
            this.advanceLexer();
            switch (token.value) {
              case "true":
                return this.node(token, {
                  kind: _kinds.Kind.BOOLEAN,
                  value: true
                });
              case "false":
                return this.node(token, {
                  kind: _kinds.Kind.BOOLEAN,
                  value: false
                });
              case "null":
                return this.node(token, {
                  kind: _kinds.Kind.NULL
                });
              default:
                return this.node(token, {
                  kind: _kinds.Kind.ENUM,
                  value: token.value
                });
            }
          case _tokenKind.TokenKind.DOLLAR:
            if (isConst) {
              this.expectToken(_tokenKind.TokenKind.DOLLAR);
              if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                const varName = this._lexer.token.value;
                throw (0, _syntaxError.syntaxError)(
                  this._lexer.source,
                  token.start,
                  `Unexpected variable "$${varName}" in constant value.`
                );
              } else {
                throw this.unexpected(token);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const token = this._lexer.token;
        this.advanceLexer();
        return this.node(token, {
          kind: _kinds.Kind.STRING,
          value: token.value,
          block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
        });
      }
      parseList(isConst) {
        const item = /* @__PURE__ */ __name(() => this.parseValueLiteral(isConst), "item");
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.LIST,
          values: this.any(
            _tokenKind.TokenKind.BRACKET_L,
            item,
            _tokenKind.TokenKind.BRACKET_R
          )
        });
      }
      parseObject(isConst) {
        const item = /* @__PURE__ */ __name(() => this.parseObjectField(isConst), "item");
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.OBJECT,
          fields: this.any(
            _tokenKind.TokenKind.BRACE_L,
            item,
            _tokenKind.TokenKind.BRACE_R
          )
        });
      }
      parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseDirectives(isConst) {
        const directives = [];
        while (this.peek(_tokenKind.TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.AT);
        return this.node(start, {
          kind: _kinds.Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst)
        });
      }
      parseTypeReference() {
        const start = this._lexer.token;
        let type;
        if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
          const innerType = this.parseTypeReference();
          this.expectToken(_tokenKind.TokenKind.BRACKET_R);
          type = this.node(start, {
            kind: _kinds.Kind.LIST_TYPE,
            type: innerType
          });
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
          return this.node(start, {
            kind: _kinds.Kind.NON_NULL_TYPE,
            type
          });
        }
        return type;
      }
      parseNamedType() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.NAMED_TYPE,
          name: this.parseName()
        });
      }
      peekDescription() {
        return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
      }
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(
          _tokenKind.TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
        return this.node(start, {
          kind: _kinds.Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes
        });
      }
      parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseNamedType();
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type
        });
      }
      parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives
        });
      }
      parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
      }
      parseFieldsDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseFieldDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type,
          directives
        });
      }
      parseArgumentDefs() {
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          this.parseInputValueDef,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
          defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type,
          defaultValue,
          directives
        });
      }
      parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        return this.node(start, {
          kind: _kinds.Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types
        });
      }
      parseUnionMemberTypes() {
        return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
      }
      parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
          kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values
        });
      }
      parseEnumValuesDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseEnumValueDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives
        });
      }
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            this._lexer.token.start,
            `${getTokenDesc(
              this._lexer.token
            )} is reserved and cannot be used for an enum value.`
          );
        }
        return this.parseName();
      }
      parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields
        });
      }
      parseInputFieldsDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseInputValueDef,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes
        });
      }
      parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives
        });
      }
      parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types
        });
      }
      parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values
        });
      }
      parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields
        });
      }
      parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(_tokenKind.TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
          kind: _kinds.Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations
        });
      }
      parseDirectiveLocations() {
        return this.delimitedMany(
          _tokenKind.TokenKind.PIPE,
          this.parseDirectiveLocation
        );
      }
      parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(
          _directiveLocation.DirectiveLocation,
          name.value
        )) {
          return name;
        }
        throw this.unexpected(start);
      }
      node(startToken, node) {
        if (this._options.noLocation !== true) {
          node.loc = new _ast.Location(
            startToken,
            this._lexer.lastToken,
            this._lexer.source
          );
        }
        return node;
      }
      peek(kind) {
        return this._lexer.token.kind === kind;
      }
      expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return token;
        }
        throw (0, _syntaxError.syntaxError)(
          this._lexer.source,
          token.start,
          `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
        );
      }
      expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this.advanceLexer();
        } else {
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token.start,
            `Expected "${value}", found ${getTokenDesc(token)}.`
          );
        }
      }
      expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return (0, _syntaxError.syntaxError)(
          this._lexer.source,
          token.start,
          `Unexpected ${getTokenDesc(token)}.`
        );
      }
      any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      }
      optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      }
      many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      }
      advanceLexer() {
        const { maxTokens } = this._options;
        const token = this._lexer.advance();
        if (maxTokens !== void 0 && token.kind !== _tokenKind.TokenKind.EOF) {
          ++this._tokenCounter;
          if (this._tokenCounter > maxTokens) {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              token.start,
              `Document contains more that ${maxTokens} tokens. Parsing aborted.`
            );
          }
        }
      }
    };
    __name(Parser, "Parser");
    exports2.Parser = Parser;
    function getTokenDesc(token) {
      const value = token.value;
      return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
    }
    __name(getTokenDesc, "getTokenDesc");
    function getTokenKindDesc(kind) {
      return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
    }
    __name(getTokenKindDesc, "getTokenKindDesc");
  }
});

// node_modules/graphql/jsutils/isIterableObject.js
var require_isIterableObject = __commonJS({
  "node_modules/graphql/jsutils/isIterableObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIterableObject = isIterableObject;
    function isIterableObject(maybeIterable) {
      return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
    }
    __name(isIterableObject, "isIterableObject");
  }
});

// node_modules/graphql/jsutils/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/graphql/jsutils/isPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isPromise = isPromise;
    function isPromise(value) {
      return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
    }
    __name(isPromise, "isPromise");
  }
});

// node_modules/graphql/jsutils/memoize3.js
var require_memoize3 = __commonJS({
  "node_modules/graphql/jsutils/memoize3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.memoize3 = memoize3;
    function memoize3(fn) {
      let cache0;
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3) {
        if (cache0 === void 0) {
          cache0 = /* @__PURE__ */ new WeakMap();
        }
        let cache1 = cache0.get(a1);
        if (cache1 === void 0) {
          cache1 = /* @__PURE__ */ new WeakMap();
          cache0.set(a1, cache1);
        }
        let cache2 = cache1.get(a2);
        if (cache2 === void 0) {
          cache2 = /* @__PURE__ */ new WeakMap();
          cache1.set(a2, cache2);
        }
        let fnResult = cache2.get(a3);
        if (fnResult === void 0) {
          fnResult = fn(a1, a2, a3);
          cache2.set(a3, fnResult);
        }
        return fnResult;
      }, "memoized");
    }
    __name(memoize3, "memoize3");
  }
});

// node_modules/graphql/jsutils/Path.js
var require_Path = __commonJS({
  "node_modules/graphql/jsutils/Path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addPath = addPath;
    exports2.pathToArray = pathToArray;
    function addPath(prev, key, typename) {
      return {
        prev,
        key,
        typename
      };
    }
    __name(addPath, "addPath");
    function pathToArray(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    __name(pathToArray, "pathToArray");
  }
});

// node_modules/graphql/jsutils/promiseForObject.js
var require_promiseForObject = __commonJS({
  "node_modules/graphql/jsutils/promiseForObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.promiseForObject = promiseForObject;
    function promiseForObject(object) {
      return Promise.all(Object.values(object)).then((resolvedValues) => {
        const resolvedObject = /* @__PURE__ */ Object.create(null);
        for (const [i, key] of Object.keys(object).entries()) {
          resolvedObject[key] = resolvedValues[i];
        }
        return resolvedObject;
      });
    }
    __name(promiseForObject, "promiseForObject");
  }
});

// node_modules/graphql/jsutils/promiseReduce.js
var require_promiseReduce = __commonJS({
  "node_modules/graphql/jsutils/promiseReduce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.promiseReduce = promiseReduce;
    var _isPromise = require_isPromise();
    function promiseReduce(values, callbackFn, initialValue) {
      let accumulator = initialValue;
      for (const value of values) {
        accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
      }
      return accumulator;
    }
    __name(promiseReduce, "promiseReduce");
  }
});

// node_modules/graphql/jsutils/toError.js
var require_toError = __commonJS({
  "node_modules/graphql/jsutils/toError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toError = toError;
    var _inspect = require_inspect();
    function toError(thrownValue) {
      return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
    }
    __name(toError, "toError");
    var NonErrorThrown = class extends Error {
      constructor(thrownValue) {
        super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
        this.name = "NonErrorThrown";
        this.thrownValue = thrownValue;
      }
    };
    __name(NonErrorThrown, "NonErrorThrown");
  }
});

// node_modules/graphql/error/locatedError.js
var require_locatedError = __commonJS({
  "node_modules/graphql/error/locatedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.locatedError = locatedError;
    var _toError = require_toError();
    var _GraphQLError = require_GraphQLError();
    function locatedError(rawOriginalError, nodes, path) {
      var _nodes;
      const originalError = (0, _toError.toError)(rawOriginalError);
      if (isLocatedGraphQLError(originalError)) {
        return originalError;
      }
      return new _GraphQLError.GraphQLError(originalError.message, {
        nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
        source: originalError.source,
        positions: originalError.positions,
        path,
        originalError
      });
    }
    __name(locatedError, "locatedError");
    function isLocatedGraphQLError(error) {
      return Array.isArray(error.path);
    }
    __name(isLocatedGraphQLError, "isLocatedGraphQLError");
  }
});

// node_modules/graphql/jsutils/didYouMean.js
var require_didYouMean = __commonJS({
  "node_modules/graphql/jsutils/didYouMean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.didYouMean = didYouMean;
    var MAX_SUGGESTIONS = 5;
    function didYouMean(firstArg, secondArg) {
      const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
      let message = " Did you mean ";
      if (subMessage) {
        message += subMessage + " ";
      }
      const suggestions = suggestionsArg.map((x) => `"${x}"`);
      switch (suggestions.length) {
        case 0:
          return "";
        case 1:
          return message + suggestions[0] + "?";
        case 2:
          return message + suggestions[0] + " or " + suggestions[1] + "?";
      }
      const selected = suggestions.slice(0, MAX_SUGGESTIONS);
      const lastItem = selected.pop();
      return message + selected.join(", ") + ", or " + lastItem + "?";
    }
    __name(didYouMean, "didYouMean");
  }
});

// node_modules/graphql/jsutils/identityFunc.js
var require_identityFunc = __commonJS({
  "node_modules/graphql/jsutils/identityFunc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.identityFunc = identityFunc;
    function identityFunc(x) {
      return x;
    }
    __name(identityFunc, "identityFunc");
  }
});

// node_modules/graphql/jsutils/keyMap.js
var require_keyMap = __commonJS({
  "node_modules/graphql/jsutils/keyMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keyMap = keyMap;
    function keyMap(list, keyFn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const item of list) {
        result[keyFn(item)] = item;
      }
      return result;
    }
    __name(keyMap, "keyMap");
  }
});

// node_modules/graphql/jsutils/keyValMap.js
var require_keyValMap = __commonJS({
  "node_modules/graphql/jsutils/keyValMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keyValMap = keyValMap;
    function keyValMap(list, keyFn, valFn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const item of list) {
        result[keyFn(item)] = valFn(item);
      }
      return result;
    }
    __name(keyValMap, "keyValMap");
  }
});

// node_modules/graphql/jsutils/mapValue.js
var require_mapValue = __commonJS({
  "node_modules/graphql/jsutils/mapValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mapValue = mapValue;
    function mapValue(map, fn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(map)) {
        result[key] = fn(map[key], key);
      }
      return result;
    }
    __name(mapValue, "mapValue");
  }
});

// node_modules/graphql/jsutils/naturalCompare.js
var require_naturalCompare = __commonJS({
  "node_modules/graphql/jsutils/naturalCompare.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.naturalCompare = naturalCompare;
    function naturalCompare(aStr, bStr) {
      let aIndex = 0;
      let bIndex = 0;
      while (aIndex < aStr.length && bIndex < bStr.length) {
        let aChar = aStr.charCodeAt(aIndex);
        let bChar = bStr.charCodeAt(bIndex);
        if (isDigit(aChar) && isDigit(bChar)) {
          let aNum = 0;
          do {
            ++aIndex;
            aNum = aNum * 10 + aChar - DIGIT_0;
            aChar = aStr.charCodeAt(aIndex);
          } while (isDigit(aChar) && aNum > 0);
          let bNum = 0;
          do {
            ++bIndex;
            bNum = bNum * 10 + bChar - DIGIT_0;
            bChar = bStr.charCodeAt(bIndex);
          } while (isDigit(bChar) && bNum > 0);
          if (aNum < bNum) {
            return -1;
          }
          if (aNum > bNum) {
            return 1;
          }
        } else {
          if (aChar < bChar) {
            return -1;
          }
          if (aChar > bChar) {
            return 1;
          }
          ++aIndex;
          ++bIndex;
        }
      }
      return aStr.length - bStr.length;
    }
    __name(naturalCompare, "naturalCompare");
    var DIGIT_0 = 48;
    var DIGIT_9 = 57;
    function isDigit(code) {
      return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
    }
    __name(isDigit, "isDigit");
  }
});

// node_modules/graphql/jsutils/suggestionList.js
var require_suggestionList = __commonJS({
  "node_modules/graphql/jsutils/suggestionList.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.suggestionList = suggestionList;
    var _naturalCompare = require_naturalCompare();
    function suggestionList(input, options) {
      const optionsByDistance = /* @__PURE__ */ Object.create(null);
      const lexicalDistance = new LexicalDistance(input);
      const threshold = Math.floor(input.length * 0.4) + 1;
      for (const option of options) {
        const distance = lexicalDistance.measure(option, threshold);
        if (distance !== void 0) {
          optionsByDistance[option] = distance;
        }
      }
      return Object.keys(optionsByDistance).sort((a, b) => {
        const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
        return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
      });
    }
    __name(suggestionList, "suggestionList");
    var LexicalDistance = class {
      constructor(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0)
        ];
      }
      measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        const optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        let a = stringToArray(optionLowerCase);
        let b = this._inputArray;
        if (a.length < b.length) {
          const tmp = a;
          a = b;
          b = tmp;
        }
        const aLength = a.length;
        const bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        const rows = this._rows;
        for (let j = 0; j <= bLength; j++) {
          rows[0][j] = j;
        }
        for (let i = 1; i <= aLength; i++) {
          const upRow = rows[(i - 1) % 3];
          const currentRow = rows[i % 3];
          let smallestCell = currentRow[0] = i;
          for (let j = 1; j <= bLength; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            let currentCell = Math.min(
              upRow[j] + 1,
              currentRow[j - 1] + 1,
              upRow[j - 1] + cost
            );
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[j] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        const distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      }
    };
    __name(LexicalDistance, "LexicalDistance");
    function stringToArray(str) {
      const strLength = str.length;
      const array = new Array(strLength);
      for (let i = 0; i < strLength; ++i) {
        array[i] = str.charCodeAt(i);
      }
      return array;
    }
    __name(stringToArray, "stringToArray");
  }
});

// node_modules/graphql/jsutils/toObjMap.js
var require_toObjMap = __commonJS({
  "node_modules/graphql/jsutils/toObjMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toObjMap = toObjMap;
    function toObjMap(obj) {
      if (obj == null) {
        return /* @__PURE__ */ Object.create(null);
      }
      if (Object.getPrototypeOf(obj) === null) {
        return obj;
      }
      const map = /* @__PURE__ */ Object.create(null);
      for (const [key, value] of Object.entries(obj)) {
        map[key] = value;
      }
      return map;
    }
    __name(toObjMap, "toObjMap");
  }
});

// node_modules/graphql/utilities/valueFromASTUntyped.js
var require_valueFromASTUntyped = __commonJS({
  "node_modules/graphql/utilities/valueFromASTUntyped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.valueFromASTUntyped = valueFromASTUntyped;
    var _keyValMap = require_keyValMap();
    var _kinds = require_kinds2();
    function valueFromASTUntyped(valueNode, variables) {
      switch (valueNode.kind) {
        case _kinds.Kind.NULL:
          return null;
        case _kinds.Kind.INT:
          return parseInt(valueNode.value, 10);
        case _kinds.Kind.FLOAT:
          return parseFloat(valueNode.value);
        case _kinds.Kind.STRING:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.BOOLEAN:
          return valueNode.value;
        case _kinds.Kind.LIST:
          return valueNode.values.map(
            (node) => valueFromASTUntyped(node, variables)
          );
        case _kinds.Kind.OBJECT:
          return (0, _keyValMap.keyValMap)(
            valueNode.fields,
            (field) => field.name.value,
            (field) => valueFromASTUntyped(field.value, variables)
          );
        case _kinds.Kind.VARIABLE:
          return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
      }
    }
    __name(valueFromASTUntyped, "valueFromASTUntyped");
  }
});

// node_modules/graphql/type/assertName.js
var require_assertName = __commonJS({
  "node_modules/graphql/type/assertName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertEnumValueName = assertEnumValueName;
    exports2.assertName = assertName;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _characterClasses = require_characterClasses();
    function assertName(name) {
      name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
      typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
      if (name.length === 0) {
        throw new _GraphQLError.GraphQLError(
          "Expected name to be a non-empty string."
        );
      }
      for (let i = 1; i < name.length; ++i) {
        if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
          throw new _GraphQLError.GraphQLError(
            `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
          );
        }
      }
      if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
        throw new _GraphQLError.GraphQLError(
          `Names must start with [_a-zA-Z] but "${name}" does not.`
        );
      }
      return name;
    }
    __name(assertName, "assertName");
    function assertEnumValueName(name) {
      if (name === "true" || name === "false" || name === "null") {
        throw new _GraphQLError.GraphQLError(
          `Enum values cannot be named: ${name}`
        );
      }
      return assertName(name);
    }
    __name(assertEnumValueName, "assertEnumValueName");
  }
});

// node_modules/graphql/type/definition.js
var require_definition = __commonJS({
  "node_modules/graphql/type/definition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLUnionType = exports2.GraphQLScalarType = exports2.GraphQLObjectType = exports2.GraphQLNonNull = exports2.GraphQLList = exports2.GraphQLInterfaceType = exports2.GraphQLInputObjectType = exports2.GraphQLEnumType = void 0;
    exports2.argsToArgsConfig = argsToArgsConfig;
    exports2.assertAbstractType = assertAbstractType;
    exports2.assertCompositeType = assertCompositeType;
    exports2.assertEnumType = assertEnumType;
    exports2.assertInputObjectType = assertInputObjectType;
    exports2.assertInputType = assertInputType;
    exports2.assertInterfaceType = assertInterfaceType;
    exports2.assertLeafType = assertLeafType;
    exports2.assertListType = assertListType;
    exports2.assertNamedType = assertNamedType;
    exports2.assertNonNullType = assertNonNullType;
    exports2.assertNullableType = assertNullableType;
    exports2.assertObjectType = assertObjectType;
    exports2.assertOutputType = assertOutputType;
    exports2.assertScalarType = assertScalarType;
    exports2.assertType = assertType;
    exports2.assertUnionType = assertUnionType;
    exports2.assertWrappingType = assertWrappingType;
    exports2.defineArguments = defineArguments;
    exports2.getNamedType = getNamedType;
    exports2.getNullableType = getNullableType;
    exports2.isAbstractType = isAbstractType;
    exports2.isCompositeType = isCompositeType;
    exports2.isEnumType = isEnumType;
    exports2.isInputObjectType = isInputObjectType;
    exports2.isInputType = isInputType;
    exports2.isInterfaceType = isInterfaceType;
    exports2.isLeafType = isLeafType;
    exports2.isListType = isListType;
    exports2.isNamedType = isNamedType;
    exports2.isNonNullType = isNonNullType;
    exports2.isNullableType = isNullableType;
    exports2.isObjectType = isObjectType;
    exports2.isOutputType = isOutputType;
    exports2.isRequiredArgument = isRequiredArgument;
    exports2.isRequiredInputField = isRequiredInputField;
    exports2.isScalarType = isScalarType;
    exports2.isType = isType;
    exports2.isUnionType = isUnionType;
    exports2.isWrappingType = isWrappingType;
    exports2.resolveObjMapThunk = resolveObjMapThunk;
    exports2.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
    var _devAssert = require_devAssert();
    var _didYouMean = require_didYouMean();
    var _identityFunc = require_identityFunc();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _keyMap = require_keyMap();
    var _keyValMap = require_keyValMap();
    var _mapValue = require_mapValue();
    var _suggestionList = require_suggestionList();
    var _toObjMap = require_toObjMap();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _printer = require_printer();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _assertName = require_assertName();
    function isType(type) {
      return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
    }
    __name(isType, "isType");
    function assertType(type) {
      if (!isType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`
        );
      }
      return type;
    }
    __name(assertType, "assertType");
    function isScalarType(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLScalarType);
    }
    __name(isScalarType, "isScalarType");
    function assertScalarType(type) {
      if (!isScalarType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`
        );
      }
      return type;
    }
    __name(assertScalarType, "assertScalarType");
    function isObjectType(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLObjectType);
    }
    __name(isObjectType, "isObjectType");
    function assertObjectType(type) {
      if (!isObjectType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`
        );
      }
      return type;
    }
    __name(assertObjectType, "assertObjectType");
    function isInterfaceType(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType);
    }
    __name(isInterfaceType, "isInterfaceType");
    function assertInterfaceType(type) {
      if (!isInterfaceType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`
        );
      }
      return type;
    }
    __name(assertInterfaceType, "assertInterfaceType");
    function isUnionType(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLUnionType);
    }
    __name(isUnionType, "isUnionType");
    function assertUnionType(type) {
      if (!isUnionType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`
        );
      }
      return type;
    }
    __name(assertUnionType, "assertUnionType");
    function isEnumType(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLEnumType);
    }
    __name(isEnumType, "isEnumType");
    function assertEnumType(type) {
      if (!isEnumType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`
        );
      }
      return type;
    }
    __name(assertEnumType, "assertEnumType");
    function isInputObjectType(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType);
    }
    __name(isInputObjectType, "isInputObjectType");
    function assertInputObjectType(type) {
      if (!isInputObjectType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(
            type
          )} to be a GraphQL Input Object type.`
        );
      }
      return type;
    }
    __name(assertInputObjectType, "assertInputObjectType");
    function isListType(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLList);
    }
    __name(isListType, "isListType");
    function assertListType(type) {
      if (!isListType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`
        );
      }
      return type;
    }
    __name(assertListType, "assertListType");
    function isNonNullType(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLNonNull);
    }
    __name(isNonNullType, "isNonNullType");
    function assertNonNullType(type) {
      if (!isNonNullType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`
        );
      }
      return type;
    }
    __name(assertNonNullType, "assertNonNullType");
    function isInputType(type) {
      return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
    }
    __name(isInputType, "isInputType");
    function assertInputType(type) {
      if (!isInputType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`
        );
      }
      return type;
    }
    __name(assertInputType, "assertInputType");
    function isOutputType(type) {
      return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
    }
    __name(isOutputType, "isOutputType");
    function assertOutputType(type) {
      if (!isOutputType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`
        );
      }
      return type;
    }
    __name(assertOutputType, "assertOutputType");
    function isLeafType(type) {
      return isScalarType(type) || isEnumType(type);
    }
    __name(isLeafType, "isLeafType");
    function assertLeafType(type) {
      if (!isLeafType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`
        );
      }
      return type;
    }
    __name(assertLeafType, "assertLeafType");
    function isCompositeType(type) {
      return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
    }
    __name(isCompositeType, "isCompositeType");
    function assertCompositeType(type) {
      if (!isCompositeType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`
        );
      }
      return type;
    }
    __name(assertCompositeType, "assertCompositeType");
    function isAbstractType(type) {
      return isInterfaceType(type) || isUnionType(type);
    }
    __name(isAbstractType, "isAbstractType");
    function assertAbstractType(type) {
      if (!isAbstractType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`
        );
      }
      return type;
    }
    __name(assertAbstractType, "assertAbstractType");
    var GraphQLList = class {
      constructor(ofType) {
        isType(ofType) || (0, _devAssert.devAssert)(
          false,
          `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLList";
      }
      toString() {
        return "[" + String(this.ofType) + "]";
      }
      toJSON() {
        return this.toString();
      }
    };
    __name(GraphQLList, "GraphQLList");
    exports2.GraphQLList = GraphQLList;
    var GraphQLNonNull = class {
      constructor(ofType) {
        isNullableType(ofType) || (0, _devAssert.devAssert)(
          false,
          `Expected ${(0, _inspect.inspect)(
            ofType
          )} to be a GraphQL nullable type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
      }
      toString() {
        return String(this.ofType) + "!";
      }
      toJSON() {
        return this.toString();
      }
    };
    __name(GraphQLNonNull, "GraphQLNonNull");
    exports2.GraphQLNonNull = GraphQLNonNull;
    function isWrappingType(type) {
      return isListType(type) || isNonNullType(type);
    }
    __name(isWrappingType, "isWrappingType");
    function assertWrappingType(type) {
      if (!isWrappingType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`
        );
      }
      return type;
    }
    __name(assertWrappingType, "assertWrappingType");
    function isNullableType(type) {
      return isType(type) && !isNonNullType(type);
    }
    __name(isNullableType, "isNullableType");
    function assertNullableType(type) {
      if (!isNullableType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`
        );
      }
      return type;
    }
    __name(assertNullableType, "assertNullableType");
    function getNullableType(type) {
      if (type) {
        return isNonNullType(type) ? type.ofType : type;
      }
    }
    __name(getNullableType, "getNullableType");
    function isNamedType(type) {
      return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
    }
    __name(isNamedType, "isNamedType");
    function assertNamedType(type) {
      if (!isNamedType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`
        );
      }
      return type;
    }
    __name(assertNamedType, "assertNamedType");
    function getNamedType(type) {
      if (type) {
        let unwrappedType = type;
        while (isWrappingType(unwrappedType)) {
          unwrappedType = unwrappedType.ofType;
        }
        return unwrappedType;
      }
    }
    __name(getNamedType, "getNamedType");
    function resolveReadonlyArrayThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    __name(resolveReadonlyArrayThunk, "resolveReadonlyArrayThunk");
    function resolveObjMapThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    __name(resolveObjMapThunk, "resolveObjMapThunk");
    var GraphQLScalarType = class {
      constructor(config) {
        var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
        const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.specifiedByURL = config.specifiedByURL;
        this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
        this.parseValue = parseValue;
        this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue(
          (0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables)
        );
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        config.specifiedByURL == null || typeof config.specifiedByURL === "string" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, _inspect.inspect)(config.specifiedByURL)}.`
        );
        config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
        );
        if (config.parseLiteral) {
          typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
          );
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          specifiedByURL: this.specifiedByURL,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    __name(GraphQLScalarType, "GraphQLScalarType");
    exports2.GraphQLScalarType = GraphQLScalarType;
    var GraphQLObjectType = class {
      constructor(config) {
        var _config$extensionASTN2;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.isTypeOf = config.isTypeOf;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
        this._fields = () => defineFieldMap(config);
        this._interfaces = () => defineInterfaces(config);
        config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "isTypeOf" as a function, but got: ${(0, _inspect.inspect)(config.isTypeOf)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    __name(GraphQLObjectType, "GraphQLObjectType");
    exports2.GraphQLObjectType = GraphQLObjectType;
    function defineInterfaces(config) {
      var _config$interfaces;
      const interfaces = resolveReadonlyArrayThunk(
        (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
      );
      Array.isArray(interfaces) || (0, _devAssert.devAssert)(
        false,
        `${config.name} interfaces must be an Array or a function which returns an Array.`
      );
      return interfaces;
    }
    __name(defineInterfaces, "defineInterfaces");
    function defineFieldMap(config) {
      const fieldMap = resolveObjMapThunk(config.fields);
      isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
        false,
        `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
      );
      return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
        var _fieldConfig$args;
        isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(
          false,
          `${config.name}.${fieldName} field config must be an object.`
        );
        fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(
          false,
          `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`
        );
        const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
        isPlainObj(argsConfig) || (0, _devAssert.devAssert)(
          false,
          `${config.name}.${fieldName} args must be an object with argument names as keys.`
        );
        return {
          name: (0, _assertName.assertName)(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          args: defineArguments(argsConfig),
          resolve: fieldConfig.resolve,
          subscribe: fieldConfig.subscribe,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    __name(defineFieldMap, "defineFieldMap");
    function defineArguments(config) {
      return Object.entries(config).map(([argName, argConfig]) => ({
        name: (0, _assertName.assertName)(argName),
        description: argConfig.description,
        type: argConfig.type,
        defaultValue: argConfig.defaultValue,
        deprecationReason: argConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
        astNode: argConfig.astNode
      }));
    }
    __name(defineArguments, "defineArguments");
    function isPlainObj(obj) {
      return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
    }
    __name(isPlainObj, "isPlainObj");
    function fieldsToFieldsConfig(fields) {
      return (0, _mapValue.mapValue)(fields, (field) => ({
        description: field.description,
        type: field.type,
        args: argsToArgsConfig(field.args),
        resolve: field.resolve,
        subscribe: field.subscribe,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode
      }));
    }
    __name(fieldsToFieldsConfig, "fieldsToFieldsConfig");
    function argsToArgsConfig(args) {
      return (0, _keyValMap.keyValMap)(
        args,
        (arg) => arg.name,
        (arg) => ({
          description: arg.description,
          type: arg.type,
          defaultValue: arg.defaultValue,
          deprecationReason: arg.deprecationReason,
          extensions: arg.extensions,
          astNode: arg.astNode
        })
      );
    }
    __name(argsToArgsConfig, "argsToArgsConfig");
    function isRequiredArgument(arg) {
      return isNonNullType(arg.type) && arg.defaultValue === void 0;
    }
    __name(isRequiredArgument, "isRequiredArgument");
    var GraphQLInterfaceType = class {
      constructor(config) {
        var _config$extensionASTN3;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
        this._fields = defineFieldMap.bind(void 0, config);
        this._interfaces = defineInterfaces.bind(void 0, config);
        config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    __name(GraphQLInterfaceType, "GraphQLInterfaceType");
    exports2.GraphQLInterfaceType = GraphQLInterfaceType;
    var GraphQLUnionType = class {
      constructor(config) {
        var _config$extensionASTN4;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
        this._types = defineTypes.bind(void 0, config);
        config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
      }
      getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    __name(GraphQLUnionType, "GraphQLUnionType");
    exports2.GraphQLUnionType = GraphQLUnionType;
    function defineTypes(config) {
      const types = resolveReadonlyArrayThunk(config.types);
      Array.isArray(types) || (0, _devAssert.devAssert)(
        false,
        `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
      );
      return types;
    }
    __name(defineTypes, "defineTypes");
    var GraphQLEnumType = class {
      constructor(config) {
        var _config$extensionASTN5;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
        this._values = defineEnumValues(this.name, config.values);
        this._valueLookup = new Map(
          this._values.map((enumValue) => [enumValue.value, enumValue])
        );
        this._nameLookup = (0, _keyMap.keyMap)(this._values, (value) => value.name);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
      }
      getValues() {
        return this._values;
      }
      getValue(name) {
        return this._nameLookup[name];
      }
      serialize(outputValue) {
        const enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(
              outputValue
            )}`
          );
        }
        return enumValue.name;
      }
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          const valueStr = (0, _inspect.inspect)(inputValue);
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
          );
        }
        const enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new _GraphQLError.GraphQLError(
            `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
          );
        }
        return enumValue.value;
      }
      parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== _kinds.Kind.ENUM) {
          const valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        const enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          const valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError(
            `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        return enumValue.value;
      }
      toConfig() {
        const values = (0, _keyValMap.keyValMap)(
          this.getValues(),
          (value) => value.name,
          (value) => ({
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          })
        );
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    __name(GraphQLEnumType, "GraphQLEnumType");
    exports2.GraphQLEnumType = GraphQLEnumType;
    function didYouMeanEnumValue(enumType, unknownValueStr) {
      const allNames = enumType.getValues().map((value) => value.name);
      const suggestedValues = (0, _suggestionList.suggestionList)(
        unknownValueStr,
        allNames
      );
      return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
    }
    __name(didYouMeanEnumValue, "didYouMeanEnumValue");
    function defineEnumValues(typeName, valueMap) {
      isPlainObj(valueMap) || (0, _devAssert.devAssert)(
        false,
        `${typeName} values must be an object with value names as keys.`
      );
      return Object.entries(valueMap).map(([valueName, valueConfig]) => {
        isPlainObj(valueConfig) || (0, _devAssert.devAssert)(
          false,
          `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${(0, _inspect.inspect)(
            valueConfig
          )}.`
        );
        return {
          name: (0, _assertName.assertEnumValueName)(valueName),
          description: valueConfig.description,
          value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
          deprecationReason: valueConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
          astNode: valueConfig.astNode
        };
      });
    }
    __name(defineEnumValues, "defineEnumValues");
    var GraphQLInputObjectType = class {
      constructor(config) {
        var _config$extensionASTN6;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
        this._fields = defineInputFieldMap.bind(void 0, config);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      toConfig() {
        const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
          description: field.description,
          type: field.type,
          defaultValue: field.defaultValue,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    __name(GraphQLInputObjectType, "GraphQLInputObjectType");
    exports2.GraphQLInputObjectType = GraphQLInputObjectType;
    function defineInputFieldMap(config) {
      const fieldMap = resolveObjMapThunk(config.fields);
      isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
        false,
        `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
      );
      return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
        !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(
          false,
          `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
        );
        return {
          name: (0, _assertName.assertName)(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          defaultValue: fieldConfig.defaultValue,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    __name(defineInputFieldMap, "defineInputFieldMap");
    function isRequiredInputField(field) {
      return isNonNullType(field.type) && field.defaultValue === void 0;
    }
    __name(isRequiredInputField, "isRequiredInputField");
  }
});

// node_modules/graphql/type/scalars.js
var require_scalars = __commonJS({
  "node_modules/graphql/type/scalars.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLString = exports2.GraphQLInt = exports2.GraphQLID = exports2.GraphQLFloat = exports2.GraphQLBoolean = exports2.GRAPHQL_MIN_INT = exports2.GRAPHQL_MAX_INT = void 0;
    exports2.isSpecifiedScalarType = isSpecifiedScalarType;
    exports2.specifiedScalarTypes = void 0;
    var _inspect = require_inspect();
    var _isObjectLike = require_isObjectLike();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _printer = require_printer();
    var _definition = require_definition();
    var GRAPHQL_MAX_INT = 2147483647;
    exports2.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
    var GRAPHQL_MIN_INT = -2147483648;
    exports2.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
    var GraphQLInt = new _definition.GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isInteger(num)) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        }
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            "Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue)
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${inputValue}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        const num = parseInt(valueNode.value, 10);
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
            {
              nodes: valueNode
            }
          );
        }
        return num;
      }
    });
    exports2.GraphQLInt = GraphQLInt;
    var GraphQLFloat = new _definition.GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isFinite(num)) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _printer.print)(
              valueNode
            )}`,
            valueNode
          );
        }
        return parseFloat(valueNode.value);
      }
    });
    exports2.GraphQLFloat = GraphQLFloat;
    var GraphQLString = new _definition.GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (typeof coercedValue === "boolean") {
          return coercedValue ? "true" : "false";
        }
        if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
          return coercedValue.toString();
        }
        throw new _GraphQLError.GraphQLError(
          `String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          throw new _GraphQLError.GraphQLError(
            `String cannot represent a non string value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING) {
          throw new _GraphQLError.GraphQLError(
            `String cannot represent a non string value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLString = GraphQLString;
    var GraphQLBoolean = new _definition.GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue;
        }
        if (Number.isFinite(coercedValue)) {
          return coercedValue !== 0;
        }
        throw new _GraphQLError.GraphQLError(
          `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
            coercedValue
          )}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "boolean") {
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLBoolean = GraphQLBoolean;
    var GraphQLID = new _definition.GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (Number.isInteger(coercedValue)) {
          return String(coercedValue);
        }
        throw new _GraphQLError.GraphQLError(
          `ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue === "string") {
          return inputValue;
        }
        if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
          return inputValue.toString();
        }
        throw new _GraphQLError.GraphQLError(
          `ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`
        );
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            "ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode),
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLID = GraphQLID;
    var specifiedScalarTypes = Object.freeze([
      GraphQLString,
      GraphQLInt,
      GraphQLFloat,
      GraphQLBoolean,
      GraphQLID
    ]);
    exports2.specifiedScalarTypes = specifiedScalarTypes;
    function isSpecifiedScalarType(type) {
      return specifiedScalarTypes.some(({ name }) => type.name === name);
    }
    __name(isSpecifiedScalarType, "isSpecifiedScalarType");
    function serializeObject(outputValue) {
      if ((0, _isObjectLike.isObjectLike)(outputValue)) {
        if (typeof outputValue.valueOf === "function") {
          const valueOfResult = outputValue.valueOf();
          if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
            return valueOfResult;
          }
        }
        if (typeof outputValue.toJSON === "function") {
          return outputValue.toJSON();
        }
      }
      return outputValue;
    }
    __name(serializeObject, "serializeObject");
  }
});

// node_modules/graphql/utilities/astFromValue.js
var require_astFromValue = __commonJS({
  "node_modules/graphql/utilities/astFromValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.astFromValue = astFromValue;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _kinds = require_kinds2();
    var _definition = require_definition();
    var _scalars = require_scalars();
    function astFromValue(value, type) {
      if ((0, _definition.isNonNullType)(type)) {
        const astValue = astFromValue(value, type.ofType);
        if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
          return null;
        }
        return astValue;
      }
      if (value === null) {
        return {
          kind: _kinds.Kind.NULL
        };
      }
      if (value === void 0) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if ((0, _isIterableObject.isIterableObject)(value)) {
          const valuesNodes = [];
          for (const item of value) {
            const itemNode = astFromValue(item, itemType);
            if (itemNode != null) {
              valuesNodes.push(itemNode);
            }
          }
          return {
            kind: _kinds.Kind.LIST,
            values: valuesNodes
          };
        }
        return astFromValue(value, itemType);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.isObjectLike)(value)) {
          return null;
        }
        const fieldNodes = [];
        for (const field of Object.values(type.getFields())) {
          const fieldValue = astFromValue(value[field.name], field.type);
          if (fieldValue) {
            fieldNodes.push({
              kind: _kinds.Kind.OBJECT_FIELD,
              name: {
                kind: _kinds.Kind.NAME,
                value: field.name
              },
              value: fieldValue
            });
          }
        }
        return {
          kind: _kinds.Kind.OBJECT,
          fields: fieldNodes
        };
      }
      if ((0, _definition.isLeafType)(type)) {
        const serialized = type.serialize(value);
        if (serialized == null) {
          return null;
        }
        if (typeof serialized === "boolean") {
          return {
            kind: _kinds.Kind.BOOLEAN,
            value: serialized
          };
        }
        if (typeof serialized === "number" && Number.isFinite(serialized)) {
          const stringNum = String(serialized);
          return integerStringRegExp.test(stringNum) ? {
            kind: _kinds.Kind.INT,
            value: stringNum
          } : {
            kind: _kinds.Kind.FLOAT,
            value: stringNum
          };
        }
        if (typeof serialized === "string") {
          if ((0, _definition.isEnumType)(type)) {
            return {
              kind: _kinds.Kind.ENUM,
              value: serialized
            };
          }
          if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
            return {
              kind: _kinds.Kind.INT,
              value: serialized
            };
          }
          return {
            kind: _kinds.Kind.STRING,
            value: serialized
          };
        }
        throw new TypeError(
          `Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`
        );
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type)
      );
    }
    __name(astFromValue, "astFromValue");
    var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/graphql/type/introspection.js
var require_introspection = __commonJS({
  "node_modules/graphql/type/introspection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.introspectionTypes = exports2.__TypeKind = exports2.__Type = exports2.__Schema = exports2.__InputValue = exports2.__Field = exports2.__EnumValue = exports2.__DirectiveLocation = exports2.__Directive = exports2.TypeNameMetaFieldDef = exports2.TypeMetaFieldDef = exports2.TypeKind = exports2.SchemaMetaFieldDef = void 0;
    exports2.isIntrospectionType = isIntrospectionType;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _directiveLocation = require_directiveLocation();
    var _printer = require_printer();
    var _astFromValue = require_astFromValue();
    var _definition = require_definition();
    var _scalars = require_scalars();
    var __Schema = new _definition.GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: () => ({
        description: {
          type: _scalars.GraphQLString,
          resolve: (schema) => schema.description
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))
          ),
          resolve(schema) {
            return Object.values(schema.getTypeMap());
          }
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new _definition.GraphQLNonNull(__Type),
          resolve: (schema) => schema.getQueryType()
        },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getMutationType()
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getSubscriptionType()
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__Directive)
            )
          ),
          resolve: (schema) => schema.getDirectives()
        }
      })
    });
    exports2.__Schema = __Schema;
    var __Directive = new _definition.GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (directive) => directive.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (directive) => directive.description
        },
        isRepeatable: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (directive) => directive.isRepeatable
        },
        locations: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__DirectiveLocation)
            )
          ),
          resolve: (directive) => directive.locations
        },
        args: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue)
            )
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        }
      })
    });
    exports2.__Directive = __Directive;
    var __DirectiveLocation = new _definition.GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: _directiveLocation.DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: _directiveLocation.DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: _directiveLocation.DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: _directiveLocation.DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: _directiveLocation.DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: _directiveLocation.DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: _directiveLocation.DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: _directiveLocation.DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: _directiveLocation.DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    exports2.__DirectiveLocation = __DirectiveLocation;
    var __Type = new _definition.GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: () => ({
        kind: {
          type: new _definition.GraphQLNonNull(__TypeKind),
          resolve(type) {
            if ((0, _definition.isScalarType)(type)) {
              return TypeKind.SCALAR;
            }
            if ((0, _definition.isObjectType)(type)) {
              return TypeKind.OBJECT;
            }
            if ((0, _definition.isInterfaceType)(type)) {
              return TypeKind.INTERFACE;
            }
            if ((0, _definition.isUnionType)(type)) {
              return TypeKind.UNION;
            }
            if ((0, _definition.isEnumType)(type)) {
              return TypeKind.ENUM;
            }
            if ((0, _definition.isInputObjectType)(type)) {
              return TypeKind.INPUT_OBJECT;
            }
            if ((0, _definition.isListType)(type)) {
              return TypeKind.LIST;
            }
            if ((0, _definition.isNonNullType)(type)) {
              return TypeKind.NON_NULL;
            }
            (0, _invariant.invariant)(
              false,
              `Unexpected type: "${(0, _inspect.inspect)(type)}".`
            );
          }
        },
        name: {
          type: _scalars.GraphQLString,
          resolve: (type) => "name" in type ? type.name : void 0
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (type) => "description" in type ? type.description : void 0
        },
        specifiedByURL: {
          type: _scalars.GraphQLString,
          resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
        },
        fields: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__Field)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
              const fields = Object.values(type.getFields());
              return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
            }
          }
        },
        interfaces: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve(type) {
            if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
              return type.getInterfaces();
            }
          }
        },
        possibleTypes: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve(type, _args, _context, { schema }) {
            if ((0, _definition.isAbstractType)(type)) {
              return schema.getPossibleTypes(type);
            }
          }
        },
        enumValues: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__EnumValue)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if ((0, _definition.isEnumType)(type)) {
              const values = type.getValues();
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        inputFields: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__InputValue)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if ((0, _definition.isInputObjectType)(type)) {
              const values = Object.values(type.getFields());
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        ofType: {
          type: __Type,
          resolve: (type) => "ofType" in type ? type.ofType : void 0
        }
      })
    });
    exports2.__Type = __Type;
    var __Field = new _definition.GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (field) => field.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (field) => field.description
        },
        args: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue)
            )
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: (field) => field.type
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: (field) => field.deprecationReason
        }
      })
    });
    exports2.__Field = __Field;
    var __InputValue = new _definition.GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (inputValue) => inputValue.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (inputValue) => inputValue.description
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: (inputValue) => inputValue.type
        },
        defaultValue: {
          type: _scalars.GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve(inputValue) {
            const { type, defaultValue } = inputValue;
            const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
            return valueAST ? (0, _printer.print)(valueAST) : null;
          }
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: (obj) => obj.deprecationReason
        }
      })
    });
    exports2.__InputValue = __InputValue;
    var __EnumValue = new _definition.GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (enumValue) => enumValue.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (enumValue) => enumValue.description
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (enumValue) => enumValue.deprecationReason != null
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: (enumValue) => enumValue.deprecationReason
        }
      })
    });
    exports2.__EnumValue = __EnumValue;
    var TypeKind;
    exports2.TypeKind = TypeKind;
    (function(TypeKind2) {
      TypeKind2["SCALAR"] = "SCALAR";
      TypeKind2["OBJECT"] = "OBJECT";
      TypeKind2["INTERFACE"] = "INTERFACE";
      TypeKind2["UNION"] = "UNION";
      TypeKind2["ENUM"] = "ENUM";
      TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
      TypeKind2["LIST"] = "LIST";
      TypeKind2["NON_NULL"] = "NON_NULL";
    })(TypeKind || (exports2.TypeKind = TypeKind = {}));
    var __TypeKind = new _definition.GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    exports2.__TypeKind = __TypeKind;
    var SchemaMetaFieldDef = {
      name: "__schema",
      type: new _definition.GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: (_source, _args, _context, { schema }) => schema,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.SchemaMetaFieldDef = SchemaMetaFieldDef;
    var TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [
        {
          name: "name",
          description: void 0,
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          defaultValue: void 0,
          deprecationReason: void 0,
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: void 0
        }
      ],
      resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.TypeMetaFieldDef = TypeMetaFieldDef;
    var TypeNameMetaFieldDef = {
      name: "__typename",
      type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: (_source, _args, _context, { parentType }) => parentType.name,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
    var introspectionTypes = Object.freeze([
      __Schema,
      __Directive,
      __DirectiveLocation,
      __Type,
      __Field,
      __InputValue,
      __EnumValue,
      __TypeKind
    ]);
    exports2.introspectionTypes = introspectionTypes;
    function isIntrospectionType(type) {
      return introspectionTypes.some(({ name }) => type.name === name);
    }
    __name(isIntrospectionType, "isIntrospectionType");
  }
});

// node_modules/graphql/utilities/typeComparators.js
var require_typeComparators = __commonJS({
  "node_modules/graphql/utilities/typeComparators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.doTypesOverlap = doTypesOverlap;
    exports2.isEqualType = isEqualType;
    exports2.isTypeSubTypeOf = isTypeSubTypeOf;
    var _definition = require_definition();
    function isEqualType(typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      return false;
    }
    __name(isEqualType, "isEqualType");
    function isTypeSubTypeOf(schema, maybeSubType, superType) {
      if (maybeSubType === superType) {
        return true;
      }
      if ((0, _definition.isNonNullType)(superType)) {
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isNonNullType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
      }
      if ((0, _definition.isListType)(superType)) {
        if ((0, _definition.isListType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isListType)(maybeSubType)) {
        return false;
      }
      return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
    }
    __name(isTypeSubTypeOf, "isTypeSubTypeOf");
    function doTypesOverlap(schema, typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isAbstractType)(typeA)) {
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
        }
        return schema.isSubType(typeA, typeB);
      }
      if ((0, _definition.isAbstractType)(typeB)) {
        return schema.isSubType(typeB, typeA);
      }
      return false;
    }
    __name(doTypesOverlap, "doTypesOverlap");
  }
});

// node_modules/graphql/type/directives.js
var require_directives = __commonJS({
  "node_modules/graphql/type/directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLSpecifiedByDirective = exports2.GraphQLSkipDirective = exports2.GraphQLIncludeDirective = exports2.GraphQLDirective = exports2.GraphQLDeprecatedDirective = exports2.DEFAULT_DEPRECATION_REASON = void 0;
    exports2.assertDirective = assertDirective;
    exports2.isDirective = isDirective;
    exports2.isSpecifiedDirective = isSpecifiedDirective;
    exports2.specifiedDirectives = void 0;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _toObjMap = require_toObjMap();
    var _directiveLocation = require_directiveLocation();
    var _assertName = require_assertName();
    var _definition = require_definition();
    var _scalars = require_scalars();
    function isDirective(directive) {
      return (0, _instanceOf.instanceOf)(directive, GraphQLDirective);
    }
    __name(isDirective, "isDirective");
    function assertDirective(directive) {
      if (!isDirective(directive)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`
        );
      }
      return directive;
    }
    __name(assertDirective, "assertDirective");
    var GraphQLDirective = class {
      constructor(config) {
        var _config$isRepeatable, _config$args;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.locations = config.locations;
        this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        Array.isArray(config.locations) || (0, _devAssert.devAssert)(
          false,
          `@${config.name} locations must be an Array.`
        );
        const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
        (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(
          false,
          `@${config.name} args must be an object with argument names as keys.`
        );
        this.args = (0, _definition.defineArguments)(args);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLDirective";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: (0, _definition.argsToArgsConfig)(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      }
      toString() {
        return "@" + this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    __name(GraphQLDirective, "GraphQLDirective");
    exports2.GraphQLDirective = GraphQLDirective;
    var GraphQLIncludeDirective = new GraphQLDirective({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    exports2.GraphQLIncludeDirective = GraphQLIncludeDirective;
    var GraphQLSkipDirective = new GraphQLDirective({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    exports2.GraphQLSkipDirective = GraphQLSkipDirective;
    var DEFAULT_DEPRECATION_REASON = "No longer supported";
    exports2.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
    var GraphQLDeprecatedDirective = new GraphQLDirective({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
        _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ENUM_VALUE
      ],
      args: {
        reason: {
          type: _scalars.GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    exports2.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
    var GraphQLSpecifiedByDirective = new GraphQLDirective({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behavior of this scalar.",
      locations: [_directiveLocation.DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          description: "The URL that specifies the behavior of this scalar."
        }
      }
    });
    exports2.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
    var specifiedDirectives = Object.freeze([
      GraphQLIncludeDirective,
      GraphQLSkipDirective,
      GraphQLDeprecatedDirective,
      GraphQLSpecifiedByDirective
    ]);
    exports2.specifiedDirectives = specifiedDirectives;
    function isSpecifiedDirective(directive) {
      return specifiedDirectives.some(({ name }) => name === directive.name);
    }
    __name(isSpecifiedDirective, "isSpecifiedDirective");
  }
});

// node_modules/graphql/type/schema.js
var require_schema = __commonJS({
  "node_modules/graphql/type/schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLSchema = void 0;
    exports2.assertSchema = assertSchema;
    exports2.isSchema = isSchema;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _toObjMap = require_toObjMap();
    var _ast = require_ast();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    function isSchema(schema) {
      return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);
    }
    __name(isSchema, "isSchema");
    function assertSchema(schema) {
      if (!isSchema(schema)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`
        );
      }
      return schema;
    }
    __name(assertSchema, "assertSchema");
    var GraphQLSchema = class {
      constructor(config) {
        var _config$extensionASTN, _config$directives;
        this.__validationErrors = config.assumeValid === true ? [] : void 0;
        (0, _isObjectLike.isObjectLike)(config) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
        !config.types || Array.isArray(config.types) || (0, _devAssert.devAssert)(
          false,
          `"types" must be Array if provided but got: ${(0, _inspect.inspect)(
            config.types
          )}.`
        );
        !config.directives || Array.isArray(config.directives) || (0, _devAssert.devAssert)(
          false,
          `"directives" must be Array if provided but got: ${(0, _inspect.inspect)(config.directives)}.`
        );
        this.description = config.description;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        this._queryType = config.query;
        this._mutationType = config.mutation;
        this._subscriptionType = config.subscription;
        this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
        const allReferencedTypes = new Set(config.types);
        if (config.types != null) {
          for (const type of config.types) {
            allReferencedTypes.delete(type);
            collectReferencedTypes(type, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (const directive of this._directives) {
          if ((0, _directives.isDirective)(directive)) {
            for (const arg of directive.args) {
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
        this._typeMap = /* @__PURE__ */ Object.create(null);
        this._subTypeMap = /* @__PURE__ */ Object.create(null);
        this._implementationsMap = /* @__PURE__ */ Object.create(null);
        for (const namedType of allReferencedTypes) {
          if (namedType == null) {
            continue;
          }
          const typeName = namedType.name;
          typeName || (0, _devAssert.devAssert)(
            false,
            "One of the provided types for building the Schema is missing a name."
          );
          if (this._typeMap[typeName] !== void 0) {
            throw new Error(
              `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
            );
          }
          this._typeMap[typeName] = namedType;
          if ((0, _definition.isInterfaceType)(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if ((0, _definition.isInterfaceType)(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if ((0, _definition.isObjectType)(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if ((0, _definition.isInterfaceType)(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLSchema";
      }
      getQueryType() {
        return this._queryType;
      }
      getMutationType() {
        return this._mutationType;
      }
      getSubscriptionType() {
        return this._subscriptionType;
      }
      getRootType(operation) {
        switch (operation) {
          case _ast.OperationTypeNode.QUERY:
            return this.getQueryType();
          case _ast.OperationTypeNode.MUTATION:
            return this.getMutationType();
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return this.getSubscriptionType();
        }
      }
      getTypeMap() {
        return this._typeMap;
      }
      getType(name) {
        return this.getTypeMap()[name];
      }
      getPossibleTypes(abstractType) {
        return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      }
      getImplementations(interfaceType) {
        const implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      }
      isSubType(abstractType, maybeSubType) {
        let map = this._subTypeMap[abstractType.name];
        if (map === void 0) {
          map = /* @__PURE__ */ Object.create(null);
          if ((0, _definition.isUnionType)(abstractType)) {
            for (const type of abstractType.getTypes()) {
              map[type.name] = true;
            }
          } else {
            const implementations = this.getImplementations(abstractType);
            for (const type of implementations.objects) {
              map[type.name] = true;
            }
            for (const type of implementations.interfaces) {
              map[type.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== void 0;
      }
      getDirectives() {
        return this._directives;
      }
      getDirective(name) {
        return this.getDirectives().find((directive) => directive.name === name);
      }
      toConfig() {
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: Object.values(this.getTypeMap()),
          directives: this.getDirectives(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          assumeValid: this.__validationErrors !== void 0
        };
      }
    };
    __name(GraphQLSchema, "GraphQLSchema");
    exports2.GraphQLSchema = GraphQLSchema;
    function collectReferencedTypes(type, typeSet) {
      const namedType = (0, _definition.getNamedType)(type);
      if (!typeSet.has(namedType)) {
        typeSet.add(namedType);
        if ((0, _definition.isUnionType)(namedType)) {
          for (const memberType of namedType.getTypes()) {
            collectReferencedTypes(memberType, typeSet);
          }
        } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
          for (const interfaceType of namedType.getInterfaces()) {
            collectReferencedTypes(interfaceType, typeSet);
          }
          for (const field of Object.values(namedType.getFields())) {
            collectReferencedTypes(field.type, typeSet);
            for (const arg of field.args) {
              collectReferencedTypes(arg.type, typeSet);
            }
          }
        } else if ((0, _definition.isInputObjectType)(namedType)) {
          for (const field of Object.values(namedType.getFields())) {
            collectReferencedTypes(field.type, typeSet);
          }
        }
      }
      return typeSet;
    }
    __name(collectReferencedTypes, "collectReferencedTypes");
  }
});

// node_modules/graphql/type/validate.js
var require_validate = __commonJS({
  "node_modules/graphql/type/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidSchema = assertValidSchema;
    exports2.validateSchema = validateSchema;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _ast = require_ast();
    var _typeComparators = require_typeComparators();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _schema = require_schema();
    function validateSchema(schema) {
      (0, _schema.assertSchema)(schema);
      if (schema.__validationErrors) {
        return schema.__validationErrors;
      }
      const context = new SchemaValidationContext(schema);
      validateRootTypes(context);
      validateDirectives(context);
      validateTypes(context);
      const errors = context.getErrors();
      schema.__validationErrors = errors;
      return errors;
    }
    __name(validateSchema, "validateSchema");
    function assertValidSchema(schema) {
      const errors = validateSchema(schema);
      if (errors.length !== 0) {
        throw new Error(errors.map((error) => error.message).join("\n\n"));
      }
    }
    __name(assertValidSchema, "assertValidSchema");
    var SchemaValidationContext = class {
      constructor(schema) {
        this._errors = [];
        this.schema = schema;
      }
      reportError(message, nodes) {
        const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this._errors.push(
          new _GraphQLError.GraphQLError(message, {
            nodes: _nodes
          })
        );
      }
      getErrors() {
        return this._errors;
      }
    };
    __name(SchemaValidationContext, "SchemaValidationContext");
    function validateRootTypes(context) {
      const schema = context.schema;
      const queryType = schema.getQueryType();
      if (!queryType) {
        context.reportError("Query root type must be provided.", schema.astNode);
      } else if (!(0, _definition.isObjectType)(queryType)) {
        var _getOperationTypeNode;
        context.reportError(
          `Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`,
          (_getOperationTypeNode = getOperationTypeNode(
            schema,
            _ast.OperationTypeNode.QUERY
          )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
        );
      }
      const mutationType = schema.getMutationType();
      if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
        var _getOperationTypeNode2;
        context.reportError(
          `Mutation root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(mutationType)}.`,
          (_getOperationTypeNode2 = getOperationTypeNode(
            schema,
            _ast.OperationTypeNode.MUTATION
          )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
        );
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
        var _getOperationTypeNode3;
        context.reportError(
          `Subscription root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(subscriptionType)}.`,
          (_getOperationTypeNode3 = getOperationTypeNode(
            schema,
            _ast.OperationTypeNode.SUBSCRIPTION
          )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
        );
      }
    }
    __name(validateRootTypes, "validateRootTypes");
    function getOperationTypeNode(schema, operation) {
      var _flatMap$find;
      return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
        (schemaNode) => {
          var _schemaNode$operation;
          return (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : [];
        }
      ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
    }
    __name(getOperationTypeNode, "getOperationTypeNode");
    function validateDirectives(context) {
      for (const directive of context.schema.getDirectives()) {
        if (!(0, _directives.isDirective)(directive)) {
          context.reportError(
            `Expected directive but got: ${(0, _inspect.inspect)(directive)}.`,
            directive === null || directive === void 0 ? void 0 : directive.astNode
          );
          continue;
        }
        validateName(context, directive);
        for (const arg of directive.args) {
          validateName(context, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            context.reportError(
              `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
              arg.astNode
            );
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode;
            context.reportError(
              `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
              ]
            );
          }
        }
      }
    }
    __name(validateDirectives, "validateDirectives");
    function validateName(context, node) {
      if (node.name.startsWith("__")) {
        context.reportError(
          `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
          node.astNode
        );
      }
    }
    __name(validateName, "validateName");
    function validateTypes(context) {
      const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
      const typeMap = context.schema.getTypeMap();
      for (const type of Object.values(typeMap)) {
        if (!(0, _definition.isNamedType)(type)) {
          context.reportError(
            `Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`,
            type.astNode
          );
          continue;
        }
        if (!(0, _introspection.isIntrospectionType)(type)) {
          validateName(context, type);
        }
        if ((0, _definition.isObjectType)(type)) {
          validateFields(context, type);
          validateInterfaces(context, type);
        } else if ((0, _definition.isInterfaceType)(type)) {
          validateFields(context, type);
          validateInterfaces(context, type);
        } else if ((0, _definition.isUnionType)(type)) {
          validateUnionMembers(context, type);
        } else if ((0, _definition.isEnumType)(type)) {
          validateEnumValues(context, type);
        } else if ((0, _definition.isInputObjectType)(type)) {
          validateInputFields(context, type);
          validateInputObjectCircularRefs(type);
        }
      }
    }
    __name(validateTypes, "validateTypes");
    function validateFields(context, type) {
      const fields = Object.values(type.getFields());
      if (fields.length === 0) {
        context.reportError(`Type ${type.name} must define one or more fields.`, [
          type.astNode,
          ...type.extensionASTNodes
        ]);
      }
      for (const field of fields) {
        validateName(context, field);
        if (!(0, _definition.isOutputType)(field.type)) {
          var _field$astNode;
          context.reportError(
            `The type of ${type.name}.${field.name} must be Output Type but got: ${(0, _inspect.inspect)(field.type)}.`,
            (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
          );
        }
        for (const arg of field.args) {
          const argName = arg.name;
          validateName(context, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            var _arg$astNode2;
            context.reportError(
              `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
              (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
            );
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode3;
            context.reportError(
              `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
              ]
            );
          }
        }
      }
    }
    __name(validateFields, "validateFields");
    function validateInterfaces(context, type) {
      const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
      for (const iface of type.getInterfaces()) {
        if (!(0, _definition.isInterfaceType)(iface)) {
          context.reportError(
            `Type ${(0, _inspect.inspect)(
              type
            )} must only implement Interface types, it cannot implement ${(0, _inspect.inspect)(iface)}.`,
            getAllImplementsInterfaceNodes(type, iface)
          );
          continue;
        }
        if (type === iface) {
          context.reportError(
            `Type ${type.name} cannot implement itself because it would create a circular reference.`,
            getAllImplementsInterfaceNodes(type, iface)
          );
          continue;
        }
        if (ifaceTypeNames[iface.name]) {
          context.reportError(
            `Type ${type.name} can only implement ${iface.name} once.`,
            getAllImplementsInterfaceNodes(type, iface)
          );
          continue;
        }
        ifaceTypeNames[iface.name] = true;
        validateTypeImplementsAncestors(context, type, iface);
        validateTypeImplementsInterface(context, type, iface);
      }
    }
    __name(validateInterfaces, "validateInterfaces");
    function validateTypeImplementsInterface(context, type, iface) {
      const typeFieldMap = type.getFields();
      for (const ifaceField of Object.values(iface.getFields())) {
        const fieldName = ifaceField.name;
        const typeField = typeFieldMap[fieldName];
        if (!typeField) {
          context.reportError(
            `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
            [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
          );
          continue;
        }
        if (!(0, _typeComparators.isTypeSubTypeOf)(
          context.schema,
          typeField.type,
          ifaceField.type
        )) {
          var _ifaceField$astNode, _typeField$astNode;
          context.reportError(
            `Interface field ${iface.name}.${fieldName} expects type ${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} is type ${(0, _inspect.inspect)(typeField.type)}.`,
            [
              (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
              (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
            ]
          );
        }
        for (const ifaceArg of ifaceField.args) {
          const argName = ifaceArg.name;
          const typeArg = typeField.args.find((arg) => arg.name === argName);
          if (!typeArg) {
            context.reportError(
              `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
              [ifaceArg.astNode, typeField.astNode]
            );
            continue;
          }
          if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
            var _ifaceArg$astNode, _typeArg$astNode;
            context.reportError(
              `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${(0, _inspect.inspect)(typeArg.type)}.`,
              [
                (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
              ]
            );
          }
        }
        for (const typeArg of typeField.args) {
          const argName = typeArg.name;
          const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
          if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
            context.reportError(
              `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
              [typeArg.astNode, ifaceField.astNode]
            );
          }
        }
      }
    }
    __name(validateTypeImplementsInterface, "validateTypeImplementsInterface");
    function validateTypeImplementsAncestors(context, type, iface) {
      const ifaceInterfaces = type.getInterfaces();
      for (const transitive of iface.getInterfaces()) {
        if (!ifaceInterfaces.includes(transitive)) {
          context.reportError(
            transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
            [
              ...getAllImplementsInterfaceNodes(iface, transitive),
              ...getAllImplementsInterfaceNodes(type, iface)
            ]
          );
        }
      }
    }
    __name(validateTypeImplementsAncestors, "validateTypeImplementsAncestors");
    function validateUnionMembers(context, union) {
      const memberTypes = union.getTypes();
      if (memberTypes.length === 0) {
        context.reportError(
          `Union type ${union.name} must define one or more member types.`,
          [union.astNode, ...union.extensionASTNodes]
        );
      }
      const includedTypeNames = /* @__PURE__ */ Object.create(null);
      for (const memberType of memberTypes) {
        if (includedTypeNames[memberType.name]) {
          context.reportError(
            `Union type ${union.name} can only include type ${memberType.name} once.`,
            getUnionMemberTypeNodes(union, memberType.name)
          );
          continue;
        }
        includedTypeNames[memberType.name] = true;
        if (!(0, _definition.isObjectType)(memberType)) {
          context.reportError(
            `Union type ${union.name} can only include Object types, it cannot include ${(0, _inspect.inspect)(memberType)}.`,
            getUnionMemberTypeNodes(union, String(memberType))
          );
        }
      }
    }
    __name(validateUnionMembers, "validateUnionMembers");
    function validateEnumValues(context, enumType) {
      const enumValues = enumType.getValues();
      if (enumValues.length === 0) {
        context.reportError(
          `Enum type ${enumType.name} must define one or more values.`,
          [enumType.astNode, ...enumType.extensionASTNodes]
        );
      }
      for (const enumValue of enumValues) {
        validateName(context, enumValue);
      }
    }
    __name(validateEnumValues, "validateEnumValues");
    function validateInputFields(context, inputObj) {
      const fields = Object.values(inputObj.getFields());
      if (fields.length === 0) {
        context.reportError(
          `Input Object type ${inputObj.name} must define one or more fields.`,
          [inputObj.astNode, ...inputObj.extensionASTNodes]
        );
      }
      for (const field of fields) {
        validateName(context, field);
        if (!(0, _definition.isInputType)(field.type)) {
          var _field$astNode2;
          context.reportError(
            `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${(0, _inspect.inspect)(field.type)}.`,
            (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
          );
        }
        if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
          var _field$astNode3;
          context.reportError(
            `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
            [
              getDeprecatedDirectiveNode(field.astNode),
              (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
            ]
          );
        }
      }
    }
    __name(validateInputFields, "validateInputFields");
    function createInputObjectCircularRefsValidator(context) {
      const visitedTypes = /* @__PURE__ */ Object.create(null);
      const fieldPath = [];
      const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
      return detectCycleRecursive;
      function detectCycleRecursive(inputObj) {
        if (visitedTypes[inputObj.name]) {
          return;
        }
        visitedTypes[inputObj.name] = true;
        fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
        const fields = Object.values(inputObj.getFields());
        for (const field of fields) {
          if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
            const fieldType = field.type.ofType;
            const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
            fieldPath.push(field);
            if (cycleIndex === void 0) {
              detectCycleRecursive(fieldType);
            } else {
              const cyclePath = fieldPath.slice(cycleIndex);
              const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
              context.reportError(
                `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
                cyclePath.map((fieldObj) => fieldObj.astNode)
              );
            }
            fieldPath.pop();
          }
        }
        fieldPathIndexByTypeName[inputObj.name] = void 0;
      }
      __name(detectCycleRecursive, "detectCycleRecursive");
    }
    __name(createInputObjectCircularRefsValidator, "createInputObjectCircularRefsValidator");
    function getAllImplementsInterfaceNodes(type, iface) {
      const { astNode, extensionASTNodes } = type;
      const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
      return nodes.flatMap((typeNode) => {
        var _typeNode$interfaces;
        return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : [];
      }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
    }
    __name(getAllImplementsInterfaceNodes, "getAllImplementsInterfaceNodes");
    function getUnionMemberTypeNodes(union, typeName) {
      const { astNode, extensionASTNodes } = union;
      const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
      return nodes.flatMap((unionNode) => {
        var _unionNode$types;
        return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : [];
      }).filter((typeNode) => typeNode.name.value === typeName);
    }
    __name(getUnionMemberTypeNodes, "getUnionMemberTypeNodes");
    function getDeprecatedDirectiveNode(definitionNode) {
      var _definitionNode$direc;
      return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
        (node) => node.name.value === _directives.GraphQLDeprecatedDirective.name
      );
    }
    __name(getDeprecatedDirectiveNode, "getDeprecatedDirectiveNode");
  }
});

// node_modules/graphql/utilities/typeFromAST.js
var require_typeFromAST = __commonJS({
  "node_modules/graphql/utilities/typeFromAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.typeFromAST = typeFromAST;
    var _kinds = require_kinds2();
    var _definition = require_definition();
    function typeFromAST(schema, typeNode) {
      switch (typeNode.kind) {
        case _kinds.Kind.LIST_TYPE: {
          const innerType = typeFromAST(schema, typeNode.type);
          return innerType && new _definition.GraphQLList(innerType);
        }
        case _kinds.Kind.NON_NULL_TYPE: {
          const innerType = typeFromAST(schema, typeNode.type);
          return innerType && new _definition.GraphQLNonNull(innerType);
        }
        case _kinds.Kind.NAMED_TYPE:
          return schema.getType(typeNode.name.value);
      }
    }
    __name(typeFromAST, "typeFromAST");
  }
});

// node_modules/graphql/jsutils/printPathArray.js
var require_printPathArray = __commonJS({
  "node_modules/graphql/jsutils/printPathArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printPathArray = printPathArray;
    function printPathArray(path) {
      return path.map(
        (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
      ).join("");
    }
    __name(printPathArray, "printPathArray");
  }
});

// node_modules/graphql/utilities/coerceInputValue.js
var require_coerceInputValue = __commonJS({
  "node_modules/graphql/utilities/coerceInputValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.coerceInputValue = coerceInputValue;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _Path = require_Path();
    var _printPathArray = require_printPathArray();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function coerceInputValue(inputValue, type, onError = defaultOnError) {
      return coerceInputValueImpl(inputValue, type, onError, void 0);
    }
    __name(coerceInputValue, "coerceInputValue");
    function defaultOnError(path, invalidValue, error) {
      let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
      if (path.length > 0) {
        errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
      }
      error.message = errorPrefix + ": " + error.message;
      throw error;
    }
    __name(defaultOnError, "defaultOnError");
    function coerceInputValueImpl(inputValue, type, onError, path) {
      if ((0, _definition.isNonNullType)(type)) {
        if (inputValue != null) {
          return coerceInputValueImpl(inputValue, type.ofType, onError, path);
        }
        onError(
          (0, _Path.pathToArray)(path),
          inputValue,
          new _GraphQLError.GraphQLError(
            `Expected non-nullable type "${(0, _inspect.inspect)(
              type
            )}" not to be null.`
          )
        );
        return;
      }
      if (inputValue == null) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if ((0, _isIterableObject.isIterableObject)(inputValue)) {
          return Array.from(inputValue, (itemValue, index) => {
            const itemPath = (0, _Path.addPath)(path, index, void 0);
            return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
          });
        }
        return [coerceInputValueImpl(inputValue, itemType, onError, path)];
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.isObjectLike)(inputValue)) {
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(
              `Expected type "${type.name}" to be an object.`
            )
          );
          return;
        }
        const coercedValue = {};
        const fieldDefs = type.getFields();
        for (const field of Object.values(fieldDefs)) {
          const fieldValue = inputValue[field.name];
          if (fieldValue === void 0) {
            if (field.defaultValue !== void 0) {
              coercedValue[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              const typeStr = (0, _inspect.inspect)(field.type);
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Field "${field.name}" of required type "${typeStr}" was not provided.`
                )
              );
            }
            continue;
          }
          coercedValue[field.name] = coerceInputValueImpl(
            fieldValue,
            field.type,
            onError,
            (0, _Path.addPath)(path, field.name, type.name)
          );
        }
        for (const fieldName of Object.keys(inputValue)) {
          if (!fieldDefs[fieldName]) {
            const suggestions = (0, _suggestionList.suggestionList)(
              fieldName,
              Object.keys(type.getFields())
            );
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Field "${fieldName}" is not defined by type "${type.name}".` + (0, _didYouMean.didYouMean)(suggestions)
              )
            );
          }
        }
        return coercedValue;
      }
      if ((0, _definition.isLeafType)(type)) {
        let parseResult;
        try {
          parseResult = type.parseValue(inputValue);
        } catch (error) {
          if (error instanceof _GraphQLError.GraphQLError) {
            onError((0, _Path.pathToArray)(path), inputValue, error);
          } else {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Expected type "${type.name}". ` + error.message,
                {
                  originalError: error
                }
              )
            );
          }
          return;
        }
        if (parseResult === void 0) {
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(`Expected type "${type.name}".`)
          );
        }
        return parseResult;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type)
      );
    }
    __name(coerceInputValueImpl, "coerceInputValueImpl");
  }
});

// node_modules/graphql/utilities/valueFromAST.js
var require_valueFromAST = __commonJS({
  "node_modules/graphql/utilities/valueFromAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.valueFromAST = valueFromAST;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _kinds = require_kinds2();
    var _definition = require_definition();
    function valueFromAST(valueNode, type, variables) {
      if (!valueNode) {
        return;
      }
      if (valueNode.kind === _kinds.Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variables == null || variables[variableName] === void 0) {
          return;
        }
        const variableValue = variables[variableName];
        if (variableValue === null && (0, _definition.isNonNullType)(type)) {
          return;
        }
        return variableValue;
      }
      if ((0, _definition.isNonNullType)(type)) {
        if (valueNode.kind === _kinds.Kind.NULL) {
          return;
        }
        return valueFromAST(valueNode, type.ofType, variables);
      }
      if (valueNode.kind === _kinds.Kind.NULL) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if (valueNode.kind === _kinds.Kind.LIST) {
          const coercedValues = [];
          for (const itemNode of valueNode.values) {
            if (isMissingVariable(itemNode, variables)) {
              if ((0, _definition.isNonNullType)(itemType)) {
                return;
              }
              coercedValues.push(null);
            } else {
              const itemValue = valueFromAST(itemNode, itemType, variables);
              if (itemValue === void 0) {
                return;
              }
              coercedValues.push(itemValue);
            }
          }
          return coercedValues;
        }
        const coercedValue = valueFromAST(valueNode, itemType, variables);
        if (coercedValue === void 0) {
          return;
        }
        return [coercedValue];
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (valueNode.kind !== _kinds.Kind.OBJECT) {
          return;
        }
        const coercedObj = /* @__PURE__ */ Object.create(null);
        const fieldNodes = (0, _keyMap.keyMap)(
          valueNode.fields,
          (field) => field.name.value
        );
        for (const field of Object.values(type.getFields())) {
          const fieldNode = fieldNodes[field.name];
          if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
            if (field.defaultValue !== void 0) {
              coercedObj[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              return;
            }
            continue;
          }
          const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
          if (fieldValue === void 0) {
            return;
          }
          coercedObj[field.name] = fieldValue;
        }
        return coercedObj;
      }
      if ((0, _definition.isLeafType)(type)) {
        let result;
        try {
          result = type.parseLiteral(valueNode, variables);
        } catch (_error) {
          return;
        }
        if (result === void 0) {
          return;
        }
        return result;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type)
      );
    }
    __name(valueFromAST, "valueFromAST");
    function isMissingVariable(valueNode, variables) {
      return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
    }
    __name(isMissingVariable, "isMissingVariable");
  }
});

// node_modules/graphql/execution/values.js
var require_values = __commonJS({
  "node_modules/graphql/execution/values.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getArgumentValues = getArgumentValues;
    exports2.getDirectiveValues = getDirectiveValues;
    exports2.getVariableValues = getVariableValues;
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _printPathArray = require_printPathArray();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _printer = require_printer();
    var _definition = require_definition();
    var _coerceInputValue = require_coerceInputValue();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    function getVariableValues(schema, varDefNodes, inputs, options) {
      const errors = [];
      const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
      try {
        const coerced = coerceVariableValues(
          schema,
          varDefNodes,
          inputs,
          (error) => {
            if (maxErrors != null && errors.length >= maxErrors) {
              throw new _GraphQLError.GraphQLError(
                "Too many errors processing variables, error limit reached. Execution aborted."
              );
            }
            errors.push(error);
          }
        );
        if (errors.length === 0) {
          return {
            coerced
          };
        }
      } catch (error) {
        errors.push(error);
      }
      return {
        errors
      };
    }
    __name(getVariableValues, "getVariableValues");
    function coerceVariableValues(schema, varDefNodes, inputs, onError) {
      const coercedValues = {};
      for (const varDefNode of varDefNodes) {
        const varName = varDefNode.variable.name.value;
        const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
        if (!(0, _definition.isInputType)(varType)) {
          const varTypeStr = (0, _printer.print)(varDefNode.type);
          onError(
            new _GraphQLError.GraphQLError(
              `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
              {
                nodes: varDefNode.type
              }
            )
          );
          continue;
        }
        if (!hasOwnProperty2(inputs, varName)) {
          if (varDefNode.defaultValue) {
            coercedValues[varName] = (0, _valueFromAST.valueFromAST)(
              varDefNode.defaultValue,
              varType
            );
          } else if ((0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(
              new _GraphQLError.GraphQLError(
                `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
                {
                  nodes: varDefNode
                }
              )
            );
          }
          continue;
        }
        const value = inputs[varName];
        if (value === null && (0, _definition.isNonNullType)(varType)) {
          const varTypeStr = (0, _inspect.inspect)(varType);
          onError(
            new _GraphQLError.GraphQLError(
              `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
              {
                nodes: varDefNode
              }
            )
          );
          continue;
        }
        coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(
          value,
          varType,
          (path, invalidValue, error) => {
            let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
            if (path.length > 0) {
              prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(
                path
              )}"`;
            }
            onError(
              new _GraphQLError.GraphQLError(prefix + "; " + error.message, {
                nodes: varDefNode,
                originalError: error.originalError
              })
            );
          }
        );
      }
      return coercedValues;
    }
    __name(coerceVariableValues, "coerceVariableValues");
    function getArgumentValues(def, node, variableValues) {
      var _node$arguments;
      const coercedValues = {};
      const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
      const argNodeMap = (0, _keyMap.keyMap)(
        argumentNodes,
        (arg) => arg.name.value
      );
      for (const argDef of def.args) {
        const name = argDef.name;
        const argType = argDef.type;
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (argDef.defaultValue !== void 0) {
            coercedValues[name] = argDef.defaultValue;
          } else if ((0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(
              `Argument "${name}" of required type "${(0, _inspect.inspect)(
                argType
              )}" was not provided.`,
              {
                nodes: node
              }
            );
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === _kinds.Kind.NULL;
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || !hasOwnProperty2(variableValues, variableName)) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError(
                `Argument "${name}" of required type "${(0, _inspect.inspect)(
                  argType
                )}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
                {
                  nodes: valueNode
                }
              );
            }
            continue;
          }
          isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, _definition.isNonNullType)(argType)) {
          throw new _GraphQLError.GraphQLError(
            `Argument "${name}" of non-null type "${(0, _inspect.inspect)(
              argType
            )}" must not be null.`,
            {
              nodes: valueNode
            }
          );
        }
        const coercedValue = (0, _valueFromAST.valueFromAST)(
          valueNode,
          argType,
          variableValues
        );
        if (coercedValue === void 0) {
          throw new _GraphQLError.GraphQLError(
            `Argument "${name}" has invalid value ${(0, _printer.print)(
              valueNode
            )}.`,
            {
              nodes: valueNode
            }
          );
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    __name(getArgumentValues, "getArgumentValues");
    function getDirectiveValues(directiveDef, node, variableValues) {
      var _node$directives;
      const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
        (directive) => directive.name.value === directiveDef.name
      );
      if (directiveNode) {
        return getArgumentValues(directiveDef, directiveNode, variableValues);
      }
    }
    __name(getDirectiveValues, "getDirectiveValues");
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    __name(hasOwnProperty2, "hasOwnProperty");
  }
});

// node_modules/graphql/execution/collectFields.js
var require_collectFields = __commonJS({
  "node_modules/graphql/execution/collectFields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.collectFields = collectFields;
    exports2.collectSubfields = collectSubfields;
    var _kinds = require_kinds2();
    var _definition = require_definition();
    var _directives = require_directives();
    var _typeFromAST = require_typeFromAST();
    var _values = require_values();
    function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
      const fields = /* @__PURE__ */ new Map();
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        runtimeType,
        selectionSet,
        fields,
        /* @__PURE__ */ new Set()
      );
      return fields;
    }
    __name(collectFields, "collectFields");
    function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const node of fieldNodes) {
        if (node.selectionSet) {
          collectFieldsImpl(
            schema,
            fragments,
            variableValues,
            returnType,
            node.selectionSet,
            subFieldNodes,
            visitedFragmentNames
          );
        }
      }
      return subFieldNodes;
    }
    __name(collectSubfields, "collectSubfields");
    function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
              continue;
            }
            collectFieldsImpl(
              schema,
              fragments,
              variableValues,
              runtimeType,
              selection.selectionSet,
              fields,
              visitedFragmentNames
            );
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
              continue;
            }
            collectFieldsImpl(
              schema,
              fragments,
              variableValues,
              runtimeType,
              fragment.selectionSet,
              fields,
              visitedFragmentNames
            );
            break;
          }
        }
      }
    }
    __name(collectFieldsImpl, "collectFieldsImpl");
    function shouldIncludeNode(variableValues, node) {
      const skip = (0, _values.getDirectiveValues)(
        _directives.GraphQLSkipDirective,
        node,
        variableValues
      );
      if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
      }
      const include = (0, _values.getDirectiveValues)(
        _directives.GraphQLIncludeDirective,
        node,
        variableValues
      );
      if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
      }
      return true;
    }
    __name(shouldIncludeNode, "shouldIncludeNode");
    function doesFragmentConditionMatch(schema, fragment, type) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, _typeFromAST.typeFromAST)(
        schema,
        typeConditionNode
      );
      if (conditionalType === type) {
        return true;
      }
      if ((0, _definition.isAbstractType)(conditionalType)) {
        return schema.isSubType(conditionalType, type);
      }
      return false;
    }
    __name(doesFragmentConditionMatch, "doesFragmentConditionMatch");
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    __name(getFieldEntryKey, "getFieldEntryKey");
  }
});

// node_modules/graphql/execution/execute.js
var require_execute = __commonJS({
  "node_modules/graphql/execution/execute.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidExecutionArguments = assertValidExecutionArguments;
    exports2.buildExecutionContext = buildExecutionContext;
    exports2.buildResolveInfo = buildResolveInfo;
    exports2.defaultTypeResolver = exports2.defaultFieldResolver = void 0;
    exports2.execute = execute;
    exports2.executeSync = executeSync;
    exports2.getFieldDef = getFieldDef;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _isPromise = require_isPromise();
    var _memoize = require_memoize3();
    var _Path = require_Path();
    var _promiseForObject = require_promiseForObject();
    var _promiseReduce = require_promiseReduce();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _ast = require_ast();
    var _kinds = require_kinds2();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _validate = require_validate();
    var _collectFields = require_collectFields();
    var _values = require_values();
    var collectSubfields = (0, _memoize.memoize3)(
      (exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        returnType,
        fieldNodes
      )
    );
    function execute(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const { schema, document, variableValues, rootValue } = args;
      assertValidExecutionArguments(schema, document, variableValues);
      const exeContext = buildExecutionContext(args);
      if (!("schema" in exeContext)) {
        return {
          errors: exeContext
        };
      }
      try {
        const { operation } = exeContext;
        const result = executeOperation(exeContext, operation, rootValue);
        if ((0, _isPromise.isPromise)(result)) {
          return result.then(
            (data) => buildResponse(data, exeContext.errors),
            (error) => {
              exeContext.errors.push(error);
              return buildResponse(null, exeContext.errors);
            }
          );
        }
        return buildResponse(result, exeContext.errors);
      } catch (error) {
        exeContext.errors.push(error);
        return buildResponse(null, exeContext.errors);
      }
    }
    __name(execute, "execute");
    function executeSync(args) {
      const result = execute(args);
      if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    __name(executeSync, "executeSync");
    function buildResponse(data, errors) {
      return errors.length === 0 ? {
        data
      } : {
        errors,
        data
      };
    }
    __name(buildResponse, "buildResponse");
    function assertValidExecutionArguments(schema, document, rawVariableValues) {
      document || (0, _devAssert.devAssert)(false, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(
        false,
        "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
      );
    }
    __name(assertValidExecutionArguments, "assertValidExecutionArguments");
    function buildExecutionContext(args) {
      var _definition$name, _operation$variableDe;
      const {
        schema,
        document,
        rootValue,
        contextValue,
        variableValues: rawVariableValues,
        operationName,
        fieldResolver,
        typeResolver,
        subscribeFieldResolver
      } = args;
      let operation;
      const fragments = /* @__PURE__ */ Object.create(null);
      for (const definition of document.definitions) {
        switch (definition.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            if (operationName == null) {
              if (operation !== void 0) {
                return [
                  new _GraphQLError.GraphQLError(
                    "Must provide operation name if query contains multiple operations."
                  )
                ];
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              operation = definition;
            }
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            fragments[definition.name.value] = definition;
            break;
          default:
        }
      }
      if (!operation) {
        if (operationName != null) {
          return [
            new _GraphQLError.GraphQLError(
              `Unknown operation named "${operationName}".`
            )
          ];
        }
        return [new _GraphQLError.GraphQLError("Must provide an operation.")];
      }
      const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
      const coercedVariableValues = (0, _values.getVariableValues)(
        schema,
        variableDefinitions,
        rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
        {
          maxErrors: 50
        }
      );
      if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
      }
      return {
        schema,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
        typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
        subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
        errors: []
      };
    }
    __name(buildExecutionContext, "buildExecutionContext");
    function executeOperation(exeContext, operation, rootValue) {
      const rootType = exeContext.schema.getRootType(operation.operation);
      if (rootType == null) {
        throw new _GraphQLError.GraphQLError(
          `Schema is not configured to execute ${operation.operation} operation.`,
          {
            nodes: operation
          }
        );
      }
      const rootFields = (0, _collectFields.collectFields)(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        rootType,
        operation.selectionSet
      );
      const path = void 0;
      switch (operation.operation) {
        case _ast.OperationTypeNode.QUERY:
          return executeFields(exeContext, rootType, rootValue, path, rootFields);
        case _ast.OperationTypeNode.MUTATION:
          return executeFieldsSerially(
            exeContext,
            rootType,
            rootValue,
            path,
            rootFields
          );
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return executeFields(exeContext, rootType, rootValue, path, rootFields);
      }
    }
    __name(executeOperation, "executeOperation");
    function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
      return (0, _promiseReduce.promiseReduce)(
        fields.entries(),
        (results, [responseName, fieldNodes]) => {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField(
            exeContext,
            parentType,
            sourceValue,
            fieldNodes,
            fieldPath
          );
          if (result === void 0) {
            return results;
          }
          if ((0, _isPromise.isPromise)(result)) {
            return result.then((resolvedResult) => {
              results[responseName] = resolvedResult;
              return results;
            });
          }
          results[responseName] = result;
          return results;
        },
        /* @__PURE__ */ Object.create(null)
      );
    }
    __name(executeFieldsSerially, "executeFieldsSerially");
    function executeFields(exeContext, parentType, sourceValue, path, fields) {
      const results = /* @__PURE__ */ Object.create(null);
      let containsPromise = false;
      for (const [responseName, fieldNodes] of fields.entries()) {
        const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        const result = executeField(
          exeContext,
          parentType,
          sourceValue,
          fieldNodes,
          fieldPath
        );
        if (result !== void 0) {
          results[responseName] = result;
          if ((0, _isPromise.isPromise)(result)) {
            containsPromise = true;
          }
        }
      }
      if (!containsPromise) {
        return results;
      }
      return (0, _promiseForObject.promiseForObject)(results);
    }
    __name(executeFields, "executeFields");
    function executeField(exeContext, parentType, source, fieldNodes, path) {
      var _fieldDef$resolve;
      const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
      if (!fieldDef) {
        return;
      }
      const returnType = fieldDef.type;
      const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
      const info = buildResolveInfo(
        exeContext,
        fieldDef,
        fieldNodes,
        parentType,
        path
      );
      try {
        const args = (0, _values.getArgumentValues)(
          fieldDef,
          fieldNodes[0],
          exeContext.variableValues
        );
        const contextValue = exeContext.contextValue;
        const result = resolveFn(source, args, contextValue, info);
        let completed;
        if ((0, _isPromise.isPromise)(result)) {
          completed = result.then(
            (resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved)
          );
        } else {
          completed = completeValue(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          );
        }
        if ((0, _isPromise.isPromise)(completed)) {
          return completed.then(void 0, (rawError) => {
            const error = (0, _locatedError.locatedError)(
              rawError,
              fieldNodes,
              (0, _Path.pathToArray)(path)
            );
            return handleFieldError(error, returnType, exeContext);
          });
        }
        return completed;
      } catch (rawError) {
        const error = (0, _locatedError.locatedError)(
          rawError,
          fieldNodes,
          (0, _Path.pathToArray)(path)
        );
        return handleFieldError(error, returnType, exeContext);
      }
    }
    __name(executeField, "executeField");
    function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
      return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues
      };
    }
    __name(buildResolveInfo, "buildResolveInfo");
    function handleFieldError(error, returnType, exeContext) {
      if ((0, _definition.isNonNullType)(returnType)) {
        throw error;
      }
      exeContext.errors.push(error);
      return null;
    }
    __name(handleFieldError, "handleFieldError");
    function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
      if (result instanceof Error) {
        throw result;
      }
      if ((0, _definition.isNonNullType)(returnType)) {
        const completed = completeValue(
          exeContext,
          returnType.ofType,
          fieldNodes,
          info,
          path,
          result
        );
        if (completed === null) {
          throw new Error(
            `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`
          );
        }
        return completed;
      }
      if (result == null) {
        return null;
      }
      if ((0, _definition.isListType)(returnType)) {
        return completeListValue(
          exeContext,
          returnType,
          fieldNodes,
          info,
          path,
          result
        );
      }
      if ((0, _definition.isLeafType)(returnType)) {
        return completeLeafValue(returnType, result);
      }
      if ((0, _definition.isAbstractType)(returnType)) {
        return completeAbstractValue(
          exeContext,
          returnType,
          fieldNodes,
          info,
          path,
          result
        );
      }
      if ((0, _definition.isObjectType)(returnType)) {
        return completeObjectValue(
          exeContext,
          returnType,
          fieldNodes,
          info,
          path,
          result
        );
      }
      (0, _invariant.invariant)(
        false,
        "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType)
      );
    }
    __name(completeValue, "completeValue");
    function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
      if (!(0, _isIterableObject.isIterableObject)(result)) {
        throw new _GraphQLError.GraphQLError(
          `Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`
        );
      }
      const itemType = returnType.ofType;
      let containsPromise = false;
      const completedResults = Array.from(result, (item, index) => {
        const itemPath = (0, _Path.addPath)(path, index, void 0);
        try {
          let completedItem;
          if ((0, _isPromise.isPromise)(item)) {
            completedItem = item.then(
              (resolved) => completeValue(
                exeContext,
                itemType,
                fieldNodes,
                info,
                itemPath,
                resolved
              )
            );
          } else {
            completedItem = completeValue(
              exeContext,
              itemType,
              fieldNodes,
              info,
              itemPath,
              item
            );
          }
          if ((0, _isPromise.isPromise)(completedItem)) {
            containsPromise = true;
            return completedItem.then(void 0, (rawError) => {
              const error = (0, _locatedError.locatedError)(
                rawError,
                fieldNodes,
                (0, _Path.pathToArray)(itemPath)
              );
              return handleFieldError(error, itemType, exeContext);
            });
          }
          return completedItem;
        } catch (rawError) {
          const error = (0, _locatedError.locatedError)(
            rawError,
            fieldNodes,
            (0, _Path.pathToArray)(itemPath)
          );
          return handleFieldError(error, itemType, exeContext);
        }
      });
      return containsPromise ? Promise.all(completedResults) : completedResults;
    }
    __name(completeListValue, "completeListValue");
    function completeLeafValue(returnType, result) {
      const serializedResult = returnType.serialize(result);
      if (serializedResult == null) {
        throw new Error(
          `Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to return non-nullable value, returned: ${(0, _inspect.inspect)(
            serializedResult
          )}`
        );
      }
      return serializedResult;
    }
    __name(completeLeafValue, "completeLeafValue");
    function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
      var _returnType$resolveTy;
      const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
      const contextValue = exeContext.contextValue;
      const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
      if ((0, _isPromise.isPromise)(runtimeType)) {
        return runtimeType.then(
          (resolvedRuntimeType) => completeObjectValue(
            exeContext,
            ensureValidRuntimeType(
              resolvedRuntimeType,
              exeContext,
              returnType,
              fieldNodes,
              info,
              result
            ),
            fieldNodes,
            info,
            path,
            result
          )
        );
      }
      return completeObjectValue(
        exeContext,
        ensureValidRuntimeType(
          runtimeType,
          exeContext,
          returnType,
          fieldNodes,
          info,
          result
        ),
        fieldNodes,
        info,
        path,
        result
      );
    }
    __name(completeAbstractValue, "completeAbstractValue");
    function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
      if (runtimeTypeName == null) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
          fieldNodes
        );
      }
      if ((0, _definition.isObjectType)(runtimeTypeName)) {
        throw new _GraphQLError.GraphQLError(
          "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
        );
      }
      if (typeof runtimeTypeName !== "string") {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`
        );
      }
      const runtimeType = exeContext.schema.getType(runtimeTypeName);
      if (runtimeType == null) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
          {
            nodes: fieldNodes
          }
        );
      }
      if (!(0, _definition.isObjectType)(runtimeType)) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
          {
            nodes: fieldNodes
          }
        );
      }
      if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw new _GraphQLError.GraphQLError(
          `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
          {
            nodes: fieldNodes
          }
        );
      }
      return runtimeType;
    }
    __name(ensureValidRuntimeType, "ensureValidRuntimeType");
    function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
      const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
      if (returnType.isTypeOf) {
        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
        if ((0, _isPromise.isPromise)(isTypeOf)) {
          return isTypeOf.then((resolvedIsTypeOf) => {
            if (!resolvedIsTypeOf) {
              throw invalidReturnTypeError(returnType, result, fieldNodes);
            }
            return executeFields(
              exeContext,
              returnType,
              result,
              path,
              subFieldNodes
            );
          });
        }
        if (!isTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
      }
      return executeFields(exeContext, returnType, result, path, subFieldNodes);
    }
    __name(completeObjectValue, "completeObjectValue");
    function invalidReturnTypeError(returnType, result, fieldNodes) {
      return new _GraphQLError.GraphQLError(
        `Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`,
        {
          nodes: fieldNodes
        }
      );
    }
    __name(invalidReturnTypeError, "invalidReturnTypeError");
    var defaultTypeResolver = /* @__PURE__ */ __name(function(value, contextValue, info, abstractType) {
      if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      const possibleTypes = info.schema.getPossibleTypes(abstractType);
      const promisedIsTypeOfResults = [];
      for (let i = 0; i < possibleTypes.length; i++) {
        const type = possibleTypes[i];
        if (type.isTypeOf) {
          const isTypeOfResult = type.isTypeOf(value, contextValue, info);
          if ((0, _isPromise.isPromise)(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
          for (let i = 0; i < isTypeOfResults.length; i++) {
            if (isTypeOfResults[i]) {
              return possibleTypes[i].name;
            }
          }
        });
      }
    }, "defaultTypeResolver");
    exports2.defaultTypeResolver = defaultTypeResolver;
    var defaultFieldResolver = /* @__PURE__ */ __name(function(source, args, contextValue, info) {
      if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
        const property = source[info.fieldName];
        if (typeof property === "function") {
          return source[info.fieldName](args, contextValue, info);
        }
        return property;
      }
    }, "defaultFieldResolver");
    exports2.defaultFieldResolver = defaultFieldResolver;
    function getFieldDef(schema, parentType, fieldNode) {
      const fieldName = fieldNode.name.value;
      if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
        return _introspection.TypeNameMetaFieldDef;
      }
      return parentType.getFields()[fieldName];
    }
    __name(getFieldDef, "getFieldDef");
  }
});

// node_modules/graphql/utilities/introspectionFromSchema.js
var require_introspectionFromSchema = __commonJS({
  "node_modules/graphql/utilities/introspectionFromSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.introspectionFromSchema = introspectionFromSchema;
    var _invariant = require_invariant();
    var _parser = require_parser();
    var _execute = require_execute();
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    function introspectionFromSchema(schema, options) {
      const optionsWithDefaults = {
        specifiedByUrl: true,
        directiveIsRepeatable: true,
        schemaDescription: true,
        inputValueDeprecation: true,
        ...options
      };
      const document = (0, _parser.parse)(
        (0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults)
      );
      const result = (0, _execute.executeSync)({
        schema,
        document
      });
      !result.errors && result.data || (0, _invariant.invariant)(false);
      return result.data;
    }
    __name(introspectionFromSchema, "introspectionFromSchema");
  }
});

// node_modules/graphql/utilities/buildClientSchema.js
var require_buildClientSchema = __commonJS({
  "node_modules/graphql/utilities/buildClientSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildClientSchema = buildClientSchema;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _isObjectLike = require_isObjectLike();
    var _keyValMap = require_keyValMap();
    var _parser = require_parser();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _schema = require_schema();
    var _valueFromAST = require_valueFromAST();
    function buildClientSchema(introspection, options) {
      (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(
        false,
        `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`
      );
      const schemaIntrospection = introspection.__schema;
      const typeMap = (0, _keyValMap.keyValMap)(
        schemaIntrospection.types,
        (typeIntrospection) => typeIntrospection.name,
        (typeIntrospection) => buildType(typeIntrospection)
      );
      for (const stdType of [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
      ]) {
        if (typeMap[stdType.name]) {
          typeMap[stdType.name] = stdType;
        }
      }
      const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
      const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
      const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
      const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
      return new _schema.GraphQLSchema({
        description: schemaIntrospection.description,
        query: queryType,
        mutation: mutationType,
        subscription: subscriptionType,
        types: Object.values(typeMap),
        directives,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
      });
      function getType(typeRef) {
        if (typeRef.kind === _introspection.TypeKind.LIST) {
          const itemRef = typeRef.ofType;
          if (!itemRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          return new _definition.GraphQLList(getType(itemRef));
        }
        if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
          const nullableRef = typeRef.ofType;
          if (!nullableRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          const nullableType = getType(nullableRef);
          return new _definition.GraphQLNonNull(
            (0, _definition.assertNullableType)(nullableType)
          );
        }
        return getNamedType(typeRef);
      }
      __name(getType, "getType");
      function getNamedType(typeRef) {
        const typeName = typeRef.name;
        if (!typeName) {
          throw new Error(
            `Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`
          );
        }
        const type = typeMap[typeName];
        if (!type) {
          throw new Error(
            `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
          );
        }
        return type;
      }
      __name(getNamedType, "getNamedType");
      function getObjectType(typeRef) {
        return (0, _definition.assertObjectType)(getNamedType(typeRef));
      }
      __name(getObjectType, "getObjectType");
      function getInterfaceType(typeRef) {
        return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
      }
      __name(getInterfaceType, "getInterfaceType");
      function buildType(type) {
        if (type != null && type.name != null && type.kind != null) {
          switch (type.kind) {
            case _introspection.TypeKind.SCALAR:
              return buildScalarDef(type);
            case _introspection.TypeKind.OBJECT:
              return buildObjectDef(type);
            case _introspection.TypeKind.INTERFACE:
              return buildInterfaceDef(type);
            case _introspection.TypeKind.UNION:
              return buildUnionDef(type);
            case _introspection.TypeKind.ENUM:
              return buildEnumDef(type);
            case _introspection.TypeKind.INPUT_OBJECT:
              return buildInputObjectDef(type);
          }
        }
        const typeStr = (0, _inspect.inspect)(type);
        throw new Error(
          `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
        );
      }
      __name(buildType, "buildType");
      function buildScalarDef(scalarIntrospection) {
        return new _definition.GraphQLScalarType({
          name: scalarIntrospection.name,
          description: scalarIntrospection.description,
          specifiedByURL: scalarIntrospection.specifiedByURL
        });
      }
      __name(buildScalarDef, "buildScalarDef");
      function buildImplementationsList(implementingIntrospection) {
        if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
          return [];
        }
        if (!implementingIntrospection.interfaces) {
          const implementingIntrospectionStr = (0, _inspect.inspect)(
            implementingIntrospection
          );
          throw new Error(
            `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
          );
        }
        return implementingIntrospection.interfaces.map(getInterfaceType);
      }
      __name(buildImplementationsList, "buildImplementationsList");
      function buildObjectDef(objectIntrospection) {
        return new _definition.GraphQLObjectType({
          name: objectIntrospection.name,
          description: objectIntrospection.description,
          interfaces: () => buildImplementationsList(objectIntrospection),
          fields: () => buildFieldDefMap(objectIntrospection)
        });
      }
      __name(buildObjectDef, "buildObjectDef");
      function buildInterfaceDef(interfaceIntrospection) {
        return new _definition.GraphQLInterfaceType({
          name: interfaceIntrospection.name,
          description: interfaceIntrospection.description,
          interfaces: () => buildImplementationsList(interfaceIntrospection),
          fields: () => buildFieldDefMap(interfaceIntrospection)
        });
      }
      __name(buildInterfaceDef, "buildInterfaceDef");
      function buildUnionDef(unionIntrospection) {
        if (!unionIntrospection.possibleTypes) {
          const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
          throw new Error(
            `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLUnionType({
          name: unionIntrospection.name,
          description: unionIntrospection.description,
          types: () => unionIntrospection.possibleTypes.map(getObjectType)
        });
      }
      __name(buildUnionDef, "buildUnionDef");
      function buildEnumDef(enumIntrospection) {
        if (!enumIntrospection.enumValues) {
          const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
          throw new Error(
            `Introspection result missing enumValues: ${enumIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLEnumType({
          name: enumIntrospection.name,
          description: enumIntrospection.description,
          values: (0, _keyValMap.keyValMap)(
            enumIntrospection.enumValues,
            (valueIntrospection) => valueIntrospection.name,
            (valueIntrospection) => ({
              description: valueIntrospection.description,
              deprecationReason: valueIntrospection.deprecationReason
            })
          )
        });
      }
      __name(buildEnumDef, "buildEnumDef");
      function buildInputObjectDef(inputObjectIntrospection) {
        if (!inputObjectIntrospection.inputFields) {
          const inputObjectIntrospectionStr = (0, _inspect.inspect)(
            inputObjectIntrospection
          );
          throw new Error(
            `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLInputObjectType({
          name: inputObjectIntrospection.name,
          description: inputObjectIntrospection.description,
          fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
        });
      }
      __name(buildInputObjectDef, "buildInputObjectDef");
      function buildFieldDefMap(typeIntrospection) {
        if (!typeIntrospection.fields) {
          throw new Error(
            `Introspection result missing fields: ${(0, _inspect.inspect)(
              typeIntrospection
            )}.`
          );
        }
        return (0, _keyValMap.keyValMap)(
          typeIntrospection.fields,
          (fieldIntrospection) => fieldIntrospection.name,
          buildField
        );
      }
      __name(buildFieldDefMap, "buildFieldDefMap");
      function buildField(fieldIntrospection) {
        const type = getType(fieldIntrospection.type);
        if (!(0, _definition.isOutputType)(type)) {
          const typeStr = (0, _inspect.inspect)(type);
          throw new Error(
            `Introspection must provide output type for fields, but received: ${typeStr}.`
          );
        }
        if (!fieldIntrospection.args) {
          const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
          throw new Error(
            `Introspection result missing field args: ${fieldIntrospectionStr}.`
          );
        }
        return {
          description: fieldIntrospection.description,
          deprecationReason: fieldIntrospection.deprecationReason,
          type,
          args: buildInputValueDefMap(fieldIntrospection.args)
        };
      }
      __name(buildField, "buildField");
      function buildInputValueDefMap(inputValueIntrospections) {
        return (0, _keyValMap.keyValMap)(
          inputValueIntrospections,
          (inputValue) => inputValue.name,
          buildInputValue
        );
      }
      __name(buildInputValueDefMap, "buildInputValueDefMap");
      function buildInputValue(inputValueIntrospection) {
        const type = getType(inputValueIntrospection.type);
        if (!(0, _definition.isInputType)(type)) {
          const typeStr = (0, _inspect.inspect)(type);
          throw new Error(
            `Introspection must provide input type for arguments, but received: ${typeStr}.`
          );
        }
        const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)(
          (0, _parser.parseValue)(inputValueIntrospection.defaultValue),
          type
        ) : void 0;
        return {
          description: inputValueIntrospection.description,
          type,
          defaultValue,
          deprecationReason: inputValueIntrospection.deprecationReason
        };
      }
      __name(buildInputValue, "buildInputValue");
      function buildDirective(directiveIntrospection) {
        if (!directiveIntrospection.args) {
          const directiveIntrospectionStr = (0, _inspect.inspect)(
            directiveIntrospection
          );
          throw new Error(
            `Introspection result missing directive args: ${directiveIntrospectionStr}.`
          );
        }
        if (!directiveIntrospection.locations) {
          const directiveIntrospectionStr = (0, _inspect.inspect)(
            directiveIntrospection
          );
          throw new Error(
            `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
          );
        }
        return new _directives.GraphQLDirective({
          name: directiveIntrospection.name,
          description: directiveIntrospection.description,
          isRepeatable: directiveIntrospection.isRepeatable,
          locations: directiveIntrospection.locations.slice(),
          args: buildInputValueDefMap(directiveIntrospection.args)
        });
      }
      __name(buildDirective, "buildDirective");
    }
    __name(buildClientSchema, "buildClientSchema");
  }
});

// node_modules/graphql/utilities/TypeInfo.js
var require_TypeInfo = __commonJS({
  "node_modules/graphql/utilities/TypeInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TypeInfo = void 0;
    exports2.visitWithTypeInfo = visitWithTypeInfo;
    var _ast = require_ast();
    var _kinds = require_kinds2();
    var _visitor = require_visitor();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _typeFromAST = require_typeFromAST();
    var TypeInfo = class {
      constructor(schema, initialType, getFieldDefFn) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if ((0, _definition.isInputType)(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if ((0, _definition.isCompositeType)(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if ((0, _definition.isOutputType)(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "TypeInfo";
      }
      getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      }
      getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      }
      getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      }
      getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      }
      getFieldDef() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      }
      getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      }
      getDirective() {
        return this._directive;
      }
      getArgument() {
        return this._argument;
      }
      getEnumValue() {
        return this._enumValue;
      }
      enter(node) {
        const schema = this._schema;
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET: {
            const namedType = (0, _definition.getNamedType)(this.getType());
            this._parentTypeStack.push(
              (0, _definition.isCompositeType)(namedType) ? namedType : void 0
            );
            break;
          }
          case _kinds.Kind.FIELD: {
            const parentType = this.getParentType();
            let fieldDef;
            let fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push(
              (0, _definition.isOutputType)(fieldType) ? fieldType : void 0
            );
            break;
          }
          case _kinds.Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case _kinds.Kind.OPERATION_DEFINITION: {
            const rootType = schema.getRootType(node.operation);
            this._typeStack.push(
              (0, _definition.isObjectType)(rootType) ? rootType : void 0
            );
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION: {
            const typeConditionAST = node.typeCondition;
            const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
            this._typeStack.push(
              (0, _definition.isOutputType)(outputType) ? outputType : void 0
            );
            break;
          }
          case _kinds.Kind.VARIABLE_DEFINITION: {
            const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(inputType) ? inputType : void 0
            );
            break;
          }
          case _kinds.Kind.ARGUMENT: {
            var _this$getDirective;
            let argDef;
            let argType;
            const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = fieldOrDirective.args.find(
                (arg) => arg.name === node.name.value
              );
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(argType) ? argType : void 0
            );
            break;
          }
          case _kinds.Kind.LIST: {
            const listType = (0, _definition.getNullableType)(this.getInputType());
            const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(itemType) ? itemType : void 0
            );
            break;
          }
          case _kinds.Kind.OBJECT_FIELD: {
            const objectType = (0, _definition.getNamedType)(this.getInputType());
            let inputFieldType;
            let inputField;
            if ((0, _definition.isInputObjectType)(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(
              inputField ? inputField.defaultValue : void 0
            );
            this._inputTypeStack.push(
              (0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0
            );
            break;
          }
          case _kinds.Kind.ENUM: {
            const enumType = (0, _definition.getNamedType)(this.getInputType());
            let enumValue;
            if ((0, _definition.isEnumType)(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
          default:
        }
      }
      leave(node) {
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case _kinds.Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case _kinds.Kind.DIRECTIVE:
            this._directive = null;
            break;
          case _kinds.Kind.OPERATION_DEFINITION:
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case _kinds.Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.LIST:
          case _kinds.Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ENUM:
            this._enumValue = null;
            break;
          default:
        }
      }
    };
    __name(TypeInfo, "TypeInfo");
    exports2.TypeInfo = TypeInfo;
    function getFieldDef(schema, parentType, fieldNode) {
      const name = fieldNode.name.value;
      if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      }
      if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      }
      if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
        return _introspection.TypeNameMetaFieldDef;
      }
      if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
        return parentType.getFields()[name];
      }
    }
    __name(getFieldDef, "getFieldDef");
    function visitWithTypeInfo(typeInfo, visitor) {
      return {
        enter(...args) {
          const node = args[0];
          typeInfo.enter(node);
          const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
          if (fn) {
            const result = fn.apply(visitor, args);
            if (result !== void 0) {
              typeInfo.leave(node);
              if ((0, _ast.isNode)(result)) {
                typeInfo.enter(result);
              }
            }
            return result;
          }
        },
        leave(...args) {
          const node = args[0];
          const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
          let result;
          if (fn) {
            result = fn.apply(visitor, args);
          }
          typeInfo.leave(node);
          return result;
        }
      };
    }
    __name(visitWithTypeInfo, "visitWithTypeInfo");
  }
});

// node_modules/graphql/language/predicates.js
var require_predicates = __commonJS({
  "node_modules/graphql/language/predicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isConstValueNode = isConstValueNode;
    exports2.isDefinitionNode = isDefinitionNode;
    exports2.isExecutableDefinitionNode = isExecutableDefinitionNode;
    exports2.isSelectionNode = isSelectionNode;
    exports2.isTypeDefinitionNode = isTypeDefinitionNode;
    exports2.isTypeExtensionNode = isTypeExtensionNode;
    exports2.isTypeNode = isTypeNode;
    exports2.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
    exports2.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
    exports2.isValueNode = isValueNode;
    var _kinds = require_kinds2();
    function isDefinitionNode(node) {
      return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
    }
    __name(isDefinitionNode, "isDefinitionNode");
    function isExecutableDefinitionNode(node) {
      return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
    }
    __name(isExecutableDefinitionNode, "isExecutableDefinitionNode");
    function isSelectionNode(node) {
      return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
    }
    __name(isSelectionNode, "isSelectionNode");
    function isValueNode(node) {
      return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
    }
    __name(isValueNode, "isValueNode");
    function isConstValueNode(node) {
      return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
    }
    __name(isConstValueNode, "isConstValueNode");
    function isTypeNode(node) {
      return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
    }
    __name(isTypeNode, "isTypeNode");
    function isTypeSystemDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
    }
    __name(isTypeSystemDefinitionNode, "isTypeSystemDefinitionNode");
    function isTypeDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
    }
    __name(isTypeDefinitionNode, "isTypeDefinitionNode");
    function isTypeSystemExtensionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
    }
    __name(isTypeSystemExtensionNode, "isTypeSystemExtensionNode");
    function isTypeExtensionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
    __name(isTypeExtensionNode, "isTypeExtensionNode");
  }
});

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
var require_ExecutableDefinitionsRule = __commonJS({
  "node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _predicates = require_predicates();
    function ExecutableDefinitionsRule(context) {
      return {
        Document(node) {
          for (const definition of node.definitions) {
            if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
              const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `The ${defName} definition is not executable.`,
                  {
                    nodes: definition
                  }
                )
              );
            }
          }
          return false;
        }
      };
    }
    __name(ExecutableDefinitionsRule, "ExecutableDefinitionsRule");
  }
});

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
var require_FieldsOnCorrectTypeRule = __commonJS({
  "node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
    var _didYouMean = require_didYouMean();
    var _naturalCompare = require_naturalCompare();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function FieldsOnCorrectTypeRule(context) {
      return {
        Field(node) {
          const type = context.getParentType();
          if (type) {
            const fieldDef = context.getFieldDef();
            if (!fieldDef) {
              const schema = context.getSchema();
              const fieldName = node.name.value;
              let suggestion = (0, _didYouMean.didYouMean)(
                "to use an inline fragment on",
                getSuggestedTypeNames(schema, type, fieldName)
              );
              if (suggestion === "") {
                suggestion = (0, _didYouMean.didYouMean)(
                  getSuggestedFieldNames(type, fieldName)
                );
              }
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        }
      };
    }
    __name(FieldsOnCorrectTypeRule, "FieldsOnCorrectTypeRule");
    function getSuggestedTypeNames(schema, type, fieldName) {
      if (!(0, _definition.isAbstractType)(type)) {
        return [];
      }
      const suggestedTypes = /* @__PURE__ */ new Set();
      const usageCount = /* @__PURE__ */ Object.create(null);
      for (const possibleType of schema.getPossibleTypes(type)) {
        if (!possibleType.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleType);
        usageCount[possibleType.name] = 1;
        for (const possibleInterface of possibleType.getInterfaces()) {
          var _usageCount$possibleI;
          if (!possibleInterface.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleInterface);
          usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
        }
      }
      return [...suggestedTypes].sort((typeA, typeB) => {
        const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
        if (usageCountDiff !== 0) {
          return usageCountDiff;
        }
        if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
          return -1;
        }
        if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
          return 1;
        }
        return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
      }).map((x) => x.name);
    }
    __name(getSuggestedTypeNames, "getSuggestedTypeNames");
    function getSuggestedFieldNames(type, fieldName) {
      if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
        const possibleFieldNames = Object.keys(type.getFields());
        return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
      }
      return [];
    }
    __name(getSuggestedFieldNames, "getSuggestedFieldNames");
  }
});

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
var require_FragmentsOnCompositeTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function FragmentsOnCompositeTypesRule(context) {
      return {
        InlineFragment(node) {
          const typeCondition = node.typeCondition;
          if (typeCondition) {
            const type = (0, _typeFromAST.typeFromAST)(
              context.getSchema(),
              typeCondition
            );
            if (type && !(0, _definition.isCompositeType)(type)) {
              const typeStr = (0, _printer.print)(typeCondition);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment cannot condition on non composite type "${typeStr}".`,
                  {
                    nodes: typeCondition
                  }
                )
              );
            }
          }
        },
        FragmentDefinition(node) {
          const type = (0, _typeFromAST.typeFromAST)(
            context.getSchema(),
            node.typeCondition
          );
          if (type && !(0, _definition.isCompositeType)(type)) {
            const typeStr = (0, _printer.print)(node.typeCondition);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
                {
                  nodes: node.typeCondition
                }
              )
            );
          }
        }
      };
    }
    __name(FragmentsOnCompositeTypesRule, "FragmentsOnCompositeTypesRule");
  }
});

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
var require_KnownArgumentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
    exports2.KnownArgumentNamesRule = KnownArgumentNamesRule;
    var _didYouMean = require_didYouMean();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _directives = require_directives();
    function KnownArgumentNamesRule(context) {
      return {
        ...KnownArgumentNamesOnDirectivesRule(context),
        Argument(argNode) {
          const argDef = context.getArgument();
          const fieldDef = context.getFieldDef();
          const parentType = context.getParentType();
          if (!argDef && fieldDef && parentType) {
            const argName = argNode.name.value;
            const knownArgsNames = fieldDef.args.map((arg) => arg.name);
            const suggestions = (0, _suggestionList.suggestionList)(
              argName,
              knownArgsNames
            );
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      };
    }
    __name(KnownArgumentNamesRule, "KnownArgumentNamesRule");
    function KnownArgumentNamesOnDirectivesRule(context) {
      const directiveArgs = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
        }
      }
      return {
        Directive(directiveNode) {
          const directiveName = directiveNode.name.value;
          const knownArgs = directiveArgs[directiveName];
          if (directiveNode.arguments && knownArgs) {
            for (const argNode of directiveNode.arguments) {
              const argName = argNode.name.value;
              if (!knownArgs.includes(argName)) {
                const suggestions = (0, _suggestionList.suggestionList)(
                  argName,
                  knownArgs
                );
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions),
                    {
                      nodes: argNode
                    }
                  )
                );
              }
            }
          }
          return false;
        }
      };
    }
    __name(KnownArgumentNamesOnDirectivesRule, "KnownArgumentNamesOnDirectivesRule");
  }
});

// node_modules/graphql/validation/rules/KnownDirectivesRule.js
var require_KnownDirectivesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownDirectivesRule = KnownDirectivesRule;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    var _ast = require_ast();
    var _directiveLocation = require_directiveLocation();
    var _kinds = require_kinds2();
    var _directives = require_directives();
    function KnownDirectivesRule(context) {
      const locationsMap = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        locationsMap[directive.name] = directive.locations;
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          locationsMap[def.name.value] = def.locations.map((name) => name.value);
        }
      }
      return {
        Directive(node, _key, _parent, _path, ancestors) {
          const name = node.name.value;
          const locations = locationsMap[name];
          if (!locations) {
            context.reportError(
              new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
                nodes: node
              })
            );
            return;
          }
          const candidateLocation = getDirectiveLocationForASTPath(ancestors);
          if (candidateLocation && !locations.includes(candidateLocation)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Directive "@${name}" may not be used on ${candidateLocation}.`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(KnownDirectivesRule, "KnownDirectivesRule");
    function getDirectiveLocationForASTPath(ancestors) {
      const appliedTo = ancestors[ancestors.length - 1];
      "kind" in appliedTo || (0, _invariant.invariant)(false);
      switch (appliedTo.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          return getDirectiveLocationForOperation(appliedTo.operation);
        case _kinds.Kind.FIELD:
          return _directiveLocation.DirectiveLocation.FIELD;
        case _kinds.Kind.FRAGMENT_SPREAD:
          return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
        case _kinds.Kind.INLINE_FRAGMENT:
          return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
        case _kinds.Kind.VARIABLE_DEFINITION:
          return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
        case _kinds.Kind.SCHEMA_DEFINITION:
        case _kinds.Kind.SCHEMA_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCHEMA;
        case _kinds.Kind.SCALAR_TYPE_DEFINITION:
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCALAR;
        case _kinds.Kind.OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.OBJECT;
        case _kinds.Kind.FIELD_DEFINITION:
          return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INTERFACE;
        case _kinds.Kind.UNION_TYPE_DEFINITION:
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.UNION;
        case _kinds.Kind.ENUM_TYPE_DEFINITION:
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.ENUM;
        case _kinds.Kind.ENUM_VALUE_DEFINITION:
          return _directiveLocation.DirectiveLocation.ENUM_VALUE;
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
        case _kinds.Kind.INPUT_VALUE_DEFINITION: {
          const parentNode = ancestors[ancestors.length - 3];
          "kind" in parentNode || (0, _invariant.invariant)(false);
          return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
        }
        default:
          (0, _invariant.invariant)(
            false,
            "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind)
          );
      }
    }
    __name(getDirectiveLocationForASTPath, "getDirectiveLocationForASTPath");
    function getDirectiveLocationForOperation(operation) {
      switch (operation) {
        case _ast.OperationTypeNode.QUERY:
          return _directiveLocation.DirectiveLocation.QUERY;
        case _ast.OperationTypeNode.MUTATION:
          return _directiveLocation.DirectiveLocation.MUTATION;
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
      }
    }
    __name(getDirectiveLocationForOperation, "getDirectiveLocationForOperation");
  }
});

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
var require_KnownFragmentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownFragmentNamesRule = KnownFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function KnownFragmentNamesRule(context) {
      return {
        FragmentSpread(node) {
          const fragmentName = node.name.value;
          const fragment = context.getFragment(fragmentName);
          if (!fragment) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown fragment "${fragmentName}".`,
                {
                  nodes: node.name
                }
              )
            );
          }
        }
      };
    }
    __name(KnownFragmentNamesRule, "KnownFragmentNamesRule");
  }
});

// node_modules/graphql/validation/rules/KnownTypeNamesRule.js
var require_KnownTypeNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownTypeNamesRule = KnownTypeNamesRule;
    var _didYouMean = require_didYouMean();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _predicates = require_predicates();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    function KnownTypeNamesRule(context) {
      const schema = context.getSchema();
      const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const definedTypes = /* @__PURE__ */ Object.create(null);
      for (const def of context.getDocument().definitions) {
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = true;
        }
      }
      const typeNames = [
        ...Object.keys(existingTypesMap),
        ...Object.keys(definedTypes)
      ];
      return {
        NamedType(node, _1, parent, _2, ancestors) {
          const typeName = node.name.value;
          if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
            var _ancestors$;
            const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
            const isSDL = definitionNode != null && isSDLNode(definitionNode);
            if (isSDL && standardTypeNames.includes(typeName)) {
              return;
            }
            const suggestedTypes = (0, _suggestionList.suggestionList)(
              typeName,
              isSDL ? standardTypeNames.concat(typeNames) : typeNames
            );
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes),
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(KnownTypeNamesRule, "KnownTypeNamesRule");
    var standardTypeNames = [
      ..._scalars.specifiedScalarTypes,
      ..._introspection.introspectionTypes
    ].map((type) => type.name);
    function isSDLNode(value) {
      return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
    }
    __name(isSDLNode, "isSDLNode");
  }
});

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
var require_LoneAnonymousOperationRule = __commonJS({
  "node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    function LoneAnonymousOperationRule(context) {
      let operationCount = 0;
      return {
        Document(node) {
          operationCount = node.definitions.filter(
            (definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION
          ).length;
        },
        OperationDefinition(node) {
          if (!node.name && operationCount > 1) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                "This anonymous operation must be the only defined operation.",
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(LoneAnonymousOperationRule, "LoneAnonymousOperationRule");
  }
});

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
var require_LoneSchemaDefinitionRule = __commonJS({
  "node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
    var _GraphQLError = require_GraphQLError();
    function LoneSchemaDefinitionRule(context) {
      var _ref, _ref2, _oldSchema$astNode;
      const oldSchema = context.getSchema();
      const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
      let schemaDefinitionsCount = 0;
      return {
        SchemaDefinition(node) {
          if (alreadyDefined) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                "Cannot define a new schema within a schema extension.",
                {
                  nodes: node
                }
              )
            );
            return;
          }
          if (schemaDefinitionsCount > 0) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                "Must provide only one schema definition.",
                {
                  nodes: node
                }
              )
            );
          }
          ++schemaDefinitionsCount;
        }
      };
    }
    __name(LoneSchemaDefinitionRule, "LoneSchemaDefinitionRule");
  }
});

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
var require_NoFragmentCyclesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoFragmentCyclesRule = NoFragmentCyclesRule;
    var _GraphQLError = require_GraphQLError();
    function NoFragmentCyclesRule(context) {
      const visitedFrags = /* @__PURE__ */ Object.create(null);
      const spreadPath = [];
      const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: () => false,
        FragmentDefinition(node) {
          detectCycleRecursive(node);
          return false;
        }
      };
      function detectCycleRecursive(fragment) {
        if (visitedFrags[fragment.name.value]) {
          return;
        }
        const fragmentName = fragment.name.value;
        visitedFrags[fragmentName] = true;
        const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
        if (spreadNodes.length === 0) {
          return;
        }
        spreadPathIndexByName[fragmentName] = spreadPath.length;
        for (const spreadNode of spreadNodes) {
          const spreadName = spreadNode.name.value;
          const cycleIndex = spreadPathIndexByName[spreadName];
          spreadPath.push(spreadNode);
          if (cycleIndex === void 0) {
            const spreadFragment = context.getFragment(spreadName);
            if (spreadFragment) {
              detectCycleRecursive(spreadFragment);
            }
          } else {
            const cyclePath = spreadPath.slice(cycleIndex);
            const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
                {
                  nodes: cyclePath
                }
              )
            );
          }
          spreadPath.pop();
        }
        spreadPathIndexByName[fragmentName] = void 0;
      }
      __name(detectCycleRecursive, "detectCycleRecursive");
    }
    __name(NoFragmentCyclesRule, "NoFragmentCyclesRule");
  }
});

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
var require_NoUndefinedVariablesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUndefinedVariablesRule(context) {
      let variableNameDefined = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            variableNameDefined = /* @__PURE__ */ Object.create(null);
          },
          leave(operation) {
            const usages = context.getRecursiveVariableUsages(operation);
            for (const { node } of usages) {
              const varName = node.name.value;
              if (variableNameDefined[varName] !== true) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                    {
                      nodes: [node, operation]
                    }
                  )
                );
              }
            }
          }
        },
        VariableDefinition(node) {
          variableNameDefined[node.variable.name.value] = true;
        }
      };
    }
    __name(NoUndefinedVariablesRule, "NoUndefinedVariablesRule");
  }
});

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
var require_NoUnusedFragmentsRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedFragmentsRule(context) {
      const operationDefs = [];
      const fragmentDefs = [];
      return {
        OperationDefinition(node) {
          operationDefs.push(node);
          return false;
        },
        FragmentDefinition(node) {
          fragmentDefs.push(node);
          return false;
        },
        Document: {
          leave() {
            const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
            for (const operation of operationDefs) {
              for (const fragment of context.getRecursivelyReferencedFragments(
                operation
              )) {
                fragmentNameUsed[fragment.name.value] = true;
              }
            }
            for (const fragmentDef of fragmentDefs) {
              const fragName = fragmentDef.name.value;
              if (fragmentNameUsed[fragName] !== true) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Fragment "${fragName}" is never used.`,
                    {
                      nodes: fragmentDef
                    }
                  )
                );
              }
            }
          }
        }
      };
    }
    __name(NoUnusedFragmentsRule, "NoUnusedFragmentsRule");
  }
});

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
var require_NoUnusedVariablesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUnusedVariablesRule = NoUnusedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedVariablesRule(context) {
      let variableDefs = [];
      return {
        OperationDefinition: {
          enter() {
            variableDefs = [];
          },
          leave(operation) {
            const variableNameUsed = /* @__PURE__ */ Object.create(null);
            const usages = context.getRecursiveVariableUsages(operation);
            for (const { node } of usages) {
              variableNameUsed[node.name.value] = true;
            }
            for (const variableDef of variableDefs) {
              const variableName = variableDef.variable.name.value;
              if (variableNameUsed[variableName] !== true) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                    {
                      nodes: variableDef
                    }
                  )
                );
              }
            }
          }
        },
        VariableDefinition(def) {
          variableDefs.push(def);
        }
      };
    }
    __name(NoUnusedVariablesRule, "NoUnusedVariablesRule");
  }
});

// node_modules/graphql/utilities/sortValueNode.js
var require_sortValueNode = __commonJS({
  "node_modules/graphql/utilities/sortValueNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.sortValueNode = sortValueNode;
    var _naturalCompare = require_naturalCompare();
    var _kinds = require_kinds2();
    function sortValueNode(valueNode) {
      switch (valueNode.kind) {
        case _kinds.Kind.OBJECT:
          return { ...valueNode, fields: sortFields(valueNode.fields) };
        case _kinds.Kind.LIST:
          return { ...valueNode, values: valueNode.values.map(sortValueNode) };
        case _kinds.Kind.INT:
        case _kinds.Kind.FLOAT:
        case _kinds.Kind.STRING:
        case _kinds.Kind.BOOLEAN:
        case _kinds.Kind.NULL:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.VARIABLE:
          return valueNode;
      }
    }
    __name(sortValueNode, "sortValueNode");
    function sortFields(fields) {
      return fields.map((fieldNode) => ({
        ...fieldNode,
        value: sortValueNode(fieldNode.value)
      })).sort(
        (fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value)
      );
    }
    __name(sortFields, "sortFields");
  }
});

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
var require_OverlappingFieldsCanBeMergedRule = __commonJS({
  "node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _printer = require_printer();
    var _definition = require_definition();
    var _sortValueNode = require_sortValueNode();
    var _typeFromAST = require_typeFromAST();
    function reasonMessage(reason) {
      if (Array.isArray(reason)) {
        return reason.map(
          ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
        ).join(" and ");
      }
      return reason;
    }
    __name(reasonMessage, "reasonMessage");
    function OverlappingFieldsCanBeMergedRule(context) {
      const comparedFragmentPairs = new PairSet();
      const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
      return {
        SelectionSet(selectionSet) {
          const conflicts = findConflictsWithinSelectionSet(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            context.getParentType(),
            selectionSet
          );
          for (const [[responseName, reason], fields1, fields2] of conflicts) {
            const reasonMsg = reasonMessage(reason);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
                {
                  nodes: fields1.concat(fields2)
                }
              )
            );
          }
        }
      };
    }
    __name(OverlappingFieldsCanBeMergedRule, "OverlappingFieldsCanBeMergedRule");
    function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
      const conflicts = [];
      const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        parentType,
        selectionSet
      );
      collectConflictsWithin(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        fieldMap
      );
      if (fragmentNames.length !== 0) {
        for (let i = 0; i < fragmentNames.length; i++) {
          collectConflictsBetweenFieldsAndFragment(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            fieldMap,
            fragmentNames[i]
          );
          for (let j = i + 1; j < fragmentNames.length; j++) {
            collectConflictsBetweenFragments(
              context,
              conflicts,
              cachedFieldsAndFragmentNames,
              comparedFragmentPairs,
              false,
              fragmentNames[i],
              fragmentNames[j]
            );
          }
        }
      }
      return conflicts;
    }
    __name(findConflictsWithinSelectionSet, "findConflictsWithinSelectionSet");
    function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return;
      }
      const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        fragment
      );
      if (fieldMap === fieldMap2) {
        return;
      }
      collectConflictsBetween(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap,
        fieldMap2
      );
      for (const referencedFragmentName of referencedFragmentNames) {
        if (comparedFragmentPairs.has(
          referencedFragmentName,
          fragmentName,
          areMutuallyExclusive
        )) {
          continue;
        }
        comparedFragmentPairs.add(
          referencedFragmentName,
          fragmentName,
          areMutuallyExclusive
        );
        collectConflictsBetweenFieldsAndFragment(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap,
          referencedFragmentName
        );
      }
    }
    __name(collectConflictsBetweenFieldsAndFragment, "collectConflictsBetweenFieldsAndFragment");
    function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
      if (fragmentName1 === fragmentName2) {
        return;
      }
      if (comparedFragmentPairs.has(
        fragmentName1,
        fragmentName2,
        areMutuallyExclusive
      )) {
        return;
      }
      comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
      const fragment1 = context.getFragment(fragmentName1);
      const fragment2 = context.getFragment(fragmentName2);
      if (!fragment1 || !fragment2) {
        return;
      }
      const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        fragment1
      );
      const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        fragment2
      );
      collectConflictsBetween(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap1,
        fieldMap2
      );
      for (const referencedFragmentName2 of referencedFragmentNames2) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fragmentName1,
          referencedFragmentName2
        );
      }
      for (const referencedFragmentName1 of referencedFragmentNames1) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          referencedFragmentName1,
          fragmentName2
        );
      }
    }
    __name(collectConflictsBetweenFragments, "collectConflictsBetweenFragments");
    function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
      const conflicts = [];
      const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        parentType1,
        selectionSet1
      );
      const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        parentType2,
        selectionSet2
      );
      collectConflictsBetween(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap1,
        fieldMap2
      );
      for (const fragmentName2 of fragmentNames2) {
        collectConflictsBetweenFieldsAndFragment(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap1,
          fragmentName2
        );
      }
      for (const fragmentName1 of fragmentNames1) {
        collectConflictsBetweenFieldsAndFragment(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap2,
          fragmentName1
        );
      }
      for (const fragmentName1 of fragmentNames1) {
        for (const fragmentName2 of fragmentNames2) {
          collectConflictsBetweenFragments(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fragmentName1,
            fragmentName2
          );
        }
      }
      return conflicts;
    }
    __name(findConflictsBetweenSubSelectionSets, "findConflictsBetweenSubSelectionSets");
    function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
      for (const [responseName, fields] of Object.entries(fieldMap)) {
        if (fields.length > 1) {
          for (let i = 0; i < fields.length; i++) {
            for (let j = i + 1; j < fields.length; j++) {
              const conflict = findConflict(
                context,
                cachedFieldsAndFragmentNames,
                comparedFragmentPairs,
                false,
                responseName,
                fields[i],
                fields[j]
              );
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    __name(collectConflictsWithin, "collectConflictsWithin");
    function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
      for (const [responseName, fields1] of Object.entries(fieldMap1)) {
        const fields2 = fieldMap2[responseName];
        if (fields2) {
          for (const field1 of fields1) {
            for (const field2 of fields2) {
              const conflict = findConflict(
                context,
                cachedFieldsAndFragmentNames,
                comparedFragmentPairs,
                parentFieldsAreMutuallyExclusive,
                responseName,
                field1,
                field2
              );
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    __name(collectConflictsBetween, "collectConflictsBetween");
    function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
      const [parentType1, node1, def1] = field1;
      const [parentType2, node2, def2] = field2;
      const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
      if (!areMutuallyExclusive) {
        const name1 = node1.name.value;
        const name2 = node2.name.value;
        if (name1 !== name2) {
          return [
            [responseName, `"${name1}" and "${name2}" are different fields`],
            [node1],
            [node2]
          ];
        }
        if (stringifyArguments(node1) !== stringifyArguments(node2)) {
          return [
            [responseName, "they have differing arguments"],
            [node1],
            [node2]
          ];
        }
      }
      const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
      const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
      if (type1 && type2 && doTypesConflict(type1, type2)) {
        return [
          [
            responseName,
            `they return conflicting types "${(0, _inspect.inspect)(
              type1
            )}" and "${(0, _inspect.inspect)(type2)}"`
          ],
          [node1],
          [node2]
        ];
      }
      const selectionSet1 = node1.selectionSet;
      const selectionSet2 = node2.selectionSet;
      if (selectionSet1 && selectionSet2) {
        const conflicts = findConflictsBetweenSubSelectionSets(
          context,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          (0, _definition.getNamedType)(type1),
          selectionSet1,
          (0, _definition.getNamedType)(type2),
          selectionSet2
        );
        return subfieldConflicts(conflicts, responseName, node1, node2);
      }
    }
    __name(findConflict, "findConflict");
    function stringifyArguments(fieldNode) {
      var _fieldNode$arguments;
      const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
      const inputObjectWithArgs = {
        kind: _kinds.Kind.OBJECT,
        fields: args.map((argNode) => ({
          kind: _kinds.Kind.OBJECT_FIELD,
          name: argNode.name,
          value: argNode.value
        }))
      };
      return (0, _printer.print)(
        (0, _sortValueNode.sortValueNode)(inputObjectWithArgs)
      );
    }
    __name(stringifyArguments, "stringifyArguments");
    function doTypesConflict(type1, type2) {
      if ((0, _definition.isListType)(type1)) {
        return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isListType)(type2)) {
        return true;
      }
      if ((0, _definition.isNonNullType)(type1)) {
        return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isNonNullType)(type2)) {
        return true;
      }
      if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
        return type1 !== type2;
      }
      return false;
    }
    __name(doTypesConflict, "doTypesConflict");
    function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
      const cached = cachedFieldsAndFragmentNames.get(selectionSet);
      if (cached) {
        return cached;
      }
      const nodeAndDefs = /* @__PURE__ */ Object.create(null);
      const fragmentNames = /* @__PURE__ */ Object.create(null);
      _collectFieldsAndFragmentNames(
        context,
        parentType,
        selectionSet,
        nodeAndDefs,
        fragmentNames
      );
      const result = [nodeAndDefs, Object.keys(fragmentNames)];
      cachedFieldsAndFragmentNames.set(selectionSet, result);
      return result;
    }
    __name(getFieldsAndFragmentNames, "getFieldsAndFragmentNames");
    function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
      const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
      if (cached) {
        return cached;
      }
      const fragmentType = (0, _typeFromAST.typeFromAST)(
        context.getSchema(),
        fragment.typeCondition
      );
      return getFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        fragmentType,
        fragment.selectionSet
      );
    }
    __name(getReferencedFieldsAndFragmentNames, "getReferencedFieldsAndFragmentNames");
    function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            const fieldName = selection.name.value;
            let fieldDef;
            if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
              fieldDef = parentType.getFields()[fieldName];
            }
            const responseName = selection.alias ? selection.alias.value : fieldName;
            if (!nodeAndDefs[responseName]) {
              nodeAndDefs[responseName] = [];
            }
            nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD:
            fragmentNames[selection.name.value] = true;
            break;
          case _kinds.Kind.INLINE_FRAGMENT: {
            const typeCondition = selection.typeCondition;
            const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
            _collectFieldsAndFragmentNames(
              context,
              inlineFragmentType,
              selection.selectionSet,
              nodeAndDefs,
              fragmentNames
            );
            break;
          }
        }
      }
    }
    __name(_collectFieldsAndFragmentNames, "_collectFieldsAndFragmentNames");
    function subfieldConflicts(conflicts, responseName, node1, node2) {
      if (conflicts.length > 0) {
        return [
          [responseName, conflicts.map(([reason]) => reason)],
          [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
          [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
        ];
      }
    }
    __name(subfieldConflicts, "subfieldConflicts");
    var PairSet = class {
      constructor() {
        this._data = /* @__PURE__ */ new Map();
      }
      has(a, b, areMutuallyExclusive) {
        var _this$_data$get;
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
        if (result === void 0) {
          return false;
        }
        return areMutuallyExclusive ? true : areMutuallyExclusive === result;
      }
      add(a, b, areMutuallyExclusive) {
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const map = this._data.get(key1);
        if (map === void 0) {
          this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
        } else {
          map.set(key2, areMutuallyExclusive);
        }
      }
    };
    __name(PairSet, "PairSet");
  }
});

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
var require_PossibleFragmentSpreadsRule = __commonJS({
  "node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _typeComparators = require_typeComparators();
    var _typeFromAST = require_typeFromAST();
    function PossibleFragmentSpreadsRule(context) {
      return {
        InlineFragment(node) {
          const fragType = context.getType();
          const parentType = context.getParentType();
          if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(
            context.getSchema(),
            fragType,
            parentType
          )) {
            const parentTypeStr = (0, _inspect.inspect)(parentType);
            const fragTypeStr = (0, _inspect.inspect)(fragType);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        FragmentSpread(node) {
          const fragName = node.name.value;
          const fragType = getFragmentType(context, fragName);
          const parentType = context.getParentType();
          if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(
            context.getSchema(),
            fragType,
            parentType
          )) {
            const parentTypeStr = (0, _inspect.inspect)(parentType);
            const fragTypeStr = (0, _inspect.inspect)(fragType);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(PossibleFragmentSpreadsRule, "PossibleFragmentSpreadsRule");
    function getFragmentType(context, name) {
      const frag = context.getFragment(name);
      if (frag) {
        const type = (0, _typeFromAST.typeFromAST)(
          context.getSchema(),
          frag.typeCondition
        );
        if ((0, _definition.isCompositeType)(type)) {
          return type;
        }
      }
    }
    __name(getFragmentType, "getFragmentType");
  }
});

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
var require_PossibleTypeExtensionsRule = __commonJS({
  "node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _predicates = require_predicates();
    var _definition = require_definition();
    function PossibleTypeExtensionsRule(context) {
      const schema = context.getSchema();
      const definedTypes = /* @__PURE__ */ Object.create(null);
      for (const def of context.getDocument().definitions) {
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = def;
        }
      }
      return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension
      };
      function checkExtension(node) {
        const typeName = node.name.value;
        const defNode = definedTypes[typeName];
        const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
        let expectedKind;
        if (defNode) {
          expectedKind = defKindToExtKind[defNode.kind];
        } else if (existingType) {
          expectedKind = typeToExtKind(existingType);
        }
        if (expectedKind) {
          if (expectedKind !== node.kind) {
            const kindStr = extensionKindToTypeName(node.kind);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot extend non-${kindStr} type "${typeName}".`,
                {
                  nodes: defNode ? [defNode, node] : node
                }
              )
            );
          }
        } else {
          const allTypeNames = Object.keys({
            ...definedTypes,
            ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
          });
          const suggestedTypes = (0, _suggestionList.suggestionList)(
            typeName,
            allTypeNames
          );
          context.reportError(
            new _GraphQLError.GraphQLError(
              `Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes),
              {
                nodes: node.name
              }
            )
          );
        }
      }
      __name(checkExtension, "checkExtension");
    }
    __name(PossibleTypeExtensionsRule, "PossibleTypeExtensionsRule");
    var defKindToExtKind = {
      [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
      [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
      [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
      [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
      [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
      [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
    };
    function typeToExtKind(type) {
      if ((0, _definition.isScalarType)(type)) {
        return _kinds.Kind.SCALAR_TYPE_EXTENSION;
      }
      if ((0, _definition.isObjectType)(type)) {
        return _kinds.Kind.OBJECT_TYPE_EXTENSION;
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
      }
      if ((0, _definition.isUnionType)(type)) {
        return _kinds.Kind.UNION_TYPE_EXTENSION;
      }
      if ((0, _definition.isEnumType)(type)) {
        return _kinds.Kind.ENUM_TYPE_EXTENSION;
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type)
      );
    }
    __name(typeToExtKind, "typeToExtKind");
    function extensionKindToTypeName(kind) {
      switch (kind) {
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return "scalar";
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return "object";
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return "interface";
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return "union";
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return "enum";
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return "input object";
        default:
          (0, _invariant.invariant)(
            false,
            "Unexpected kind: " + (0, _inspect.inspect)(kind)
          );
      }
    }
    __name(extensionKindToTypeName, "extensionKindToTypeName");
  }
});

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
var require_ProvidedRequiredArgumentsRule = __commonJS({
  "node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
    exports2.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _printer = require_printer();
    var _definition = require_definition();
    var _directives = require_directives();
    function ProvidedRequiredArgumentsRule(context) {
      return {
        ...ProvidedRequiredArgumentsOnDirectivesRule(context),
        Field: {
          leave(fieldNode) {
            var _fieldNode$arguments;
            const fieldDef = context.getFieldDef();
            if (!fieldDef) {
              return false;
            }
            const providedArgs = new Set(
              (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
            );
            for (const argDef of fieldDef.args) {
              if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                const argTypeStr = (0, _inspect.inspect)(argDef.type);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                    {
                      nodes: fieldNode
                    }
                  )
                );
              }
            }
          }
        }
      };
    }
    __name(ProvidedRequiredArgumentsRule, "ProvidedRequiredArgumentsRule");
    function ProvidedRequiredArgumentsOnDirectivesRule(context) {
      var _schema$getDirectives;
      const requiredArgsMap = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(
          directive.args.filter(_definition.isRequiredArgument),
          (arg) => arg.name
        );
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(
            argNodes.filter(isRequiredArgumentNode),
            (arg) => arg.name.value
          );
        }
      }
      return {
        Directive: {
          leave(directiveNode) {
            const directiveName = directiveNode.name.value;
            const requiredArgs = requiredArgsMap[directiveName];
            if (requiredArgs) {
              var _directiveNode$argume;
              const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
              const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
              for (const [argName, argDef] of Object.entries(requiredArgs)) {
                if (!argNodeMap.has(argName)) {
                  const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                      {
                        nodes: directiveNode
                      }
                    )
                  );
                }
              }
            }
          }
        }
      };
    }
    __name(ProvidedRequiredArgumentsOnDirectivesRule, "ProvidedRequiredArgumentsOnDirectivesRule");
    function isRequiredArgumentNode(arg) {
      return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
    }
    __name(isRequiredArgumentNode, "isRequiredArgumentNode");
  }
});

// node_modules/graphql/validation/rules/ScalarLeafsRule.js
var require_ScalarLeafsRule = __commonJS({
  "node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ScalarLeafsRule = ScalarLeafsRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function ScalarLeafsRule(context) {
      return {
        Field(node) {
          const type = context.getType();
          const selectionSet = node.selectionSet;
          if (type) {
            if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
              if (selectionSet) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                    {
                      nodes: selectionSet
                    }
                  )
                );
              }
            } else if (!selectionSet) {
              const fieldName = node.name.value;
              const typeStr = (0, _inspect.inspect)(type);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        }
      };
    }
    __name(ScalarLeafsRule, "ScalarLeafsRule");
  }
});

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
var require_SingleFieldSubscriptionsRule = __commonJS({
  "node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _collectFields = require_collectFields();
    function SingleFieldSubscriptionsRule(context) {
      return {
        OperationDefinition(node) {
          if (node.operation === "subscription") {
            const schema = context.getSchema();
            const subscriptionType = schema.getSubscriptionType();
            if (subscriptionType) {
              const operationName = node.name ? node.name.value : null;
              const variableValues = /* @__PURE__ */ Object.create(null);
              const document = context.getDocument();
              const fragments = /* @__PURE__ */ Object.create(null);
              for (const definition of document.definitions) {
                if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                  fragments[definition.name.value] = definition;
                }
              }
              const fields = (0, _collectFields.collectFields)(
                schema,
                fragments,
                variableValues,
                subscriptionType,
                node.selectionSet
              );
              if (fields.size > 1) {
                const fieldSelectionLists = [...fields.values()];
                const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                const extraFieldSelections = extraFieldSelectionLists.flat();
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                    {
                      nodes: extraFieldSelections
                    }
                  )
                );
              }
              for (const fieldNodes of fields.values()) {
                const field = fieldNodes[0];
                const fieldName = field.name.value;
                if (fieldName.startsWith("__")) {
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                      {
                        nodes: fieldNodes
                      }
                    )
                  );
                }
              }
            }
          }
        }
      };
    }
    __name(SingleFieldSubscriptionsRule, "SingleFieldSubscriptionsRule");
  }
});

// node_modules/graphql/jsutils/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/graphql/jsutils/groupBy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.groupBy = groupBy;
    function groupBy(list, keyFn) {
      const result = /* @__PURE__ */ new Map();
      for (const item of list) {
        const key = keyFn(item);
        const group = result.get(key);
        if (group === void 0) {
          result.set(key, [item]);
        } else {
          group.push(item);
        }
      }
      return result;
    }
    __name(groupBy, "groupBy");
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
var require_UniqueArgumentDefinitionNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentDefinitionNamesRule(context) {
      return {
        DirectiveDefinition(directiveNode) {
          var _directiveNode$argume;
          const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
        },
        InterfaceTypeDefinition: checkArgUniquenessPerField,
        InterfaceTypeExtension: checkArgUniquenessPerField,
        ObjectTypeDefinition: checkArgUniquenessPerField,
        ObjectTypeExtension: checkArgUniquenessPerField
      };
      function checkArgUniquenessPerField(typeNode) {
        var _typeNode$fields;
        const typeName = typeNode.name.value;
        const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
        for (const fieldDef of fieldNodes) {
          var _fieldDef$arguments;
          const fieldName = fieldDef.name.value;
          const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
          checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
        }
        return false;
      }
      __name(checkArgUniquenessPerField, "checkArgUniquenessPerField");
      function checkArgUniqueness(parentName, argumentNodes) {
        const seenArgs = (0, _groupBy.groupBy)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const [argName, argNodes] of seenArgs) {
          if (argNodes.length > 1) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Argument "${parentName}(${argName}:)" can only be defined once.`,
                {
                  nodes: argNodes.map((node) => node.name)
                }
              )
            );
          }
        }
        return false;
      }
      __name(checkArgUniqueness, "checkArgUniqueness");
    }
    __name(UniqueArgumentDefinitionNamesRule, "UniqueArgumentDefinitionNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
var require_UniqueArgumentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentNamesRule(context) {
      return {
        Field: checkArgUniqueness,
        Directive: checkArgUniqueness
      };
      function checkArgUniqueness(parentNode) {
        var _parentNode$arguments;
        const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
        const seenArgs = (0, _groupBy.groupBy)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const [argName, argNodes] of seenArgs) {
          if (argNodes.length > 1) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one argument named "${argName}".`,
                {
                  nodes: argNodes.map((node) => node.name)
                }
              )
            );
          }
        }
      }
      __name(checkArgUniqueness, "checkArgUniqueness");
    }
    __name(UniqueArgumentNamesRule, "UniqueArgumentNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
var require_UniqueDirectiveNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueDirectiveNamesRule(context) {
      const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      return {
        DirectiveDefinition(node) {
          const directiveName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
                {
                  nodes: node.name
                }
              )
            );
            return;
          }
          if (knownDirectiveNames[directiveName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one directive named "@${directiveName}".`,
                {
                  nodes: [knownDirectiveNames[directiveName], node.name]
                }
              )
            );
          } else {
            knownDirectiveNames[directiveName] = node.name;
          }
          return false;
        }
      };
    }
    __name(UniqueDirectiveNamesRule, "UniqueDirectiveNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
var require_UniqueDirectivesPerLocationRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _predicates = require_predicates();
    var _directives = require_directives();
    function UniqueDirectivesPerLocationRule(context) {
      const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          uniqueDirectiveMap[def.name.value] = !def.repeatable;
        }
      }
      const schemaDirectives = /* @__PURE__ */ Object.create(null);
      const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
      return {
        enter(node) {
          if (!("directives" in node) || !node.directives) {
            return;
          }
          let seenDirectives;
          if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            seenDirectives = schemaDirectives;
          } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
            const typeName = node.name.value;
            seenDirectives = typeDirectivesMap[typeName];
            if (seenDirectives === void 0) {
              typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
            }
          } else {
            seenDirectives = /* @__PURE__ */ Object.create(null);
          }
          for (const directive of node.directives) {
            const directiveName = directive.name.value;
            if (uniqueDirectiveMap[directiveName]) {
              if (seenDirectives[directiveName]) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `The directive "@${directiveName}" can only be used once at this location.`,
                    {
                      nodes: [seenDirectives[directiveName], directive]
                    }
                  )
                );
              } else {
                seenDirectives[directiveName] = directive;
              }
            }
          }
        }
      };
    }
    __name(UniqueDirectivesPerLocationRule, "UniqueDirectivesPerLocationRule");
  }
});

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
var require_UniqueEnumValueNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueEnumValueNamesRule(context) {
      const schema = context.getSchema();
      const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const knownValueNames = /* @__PURE__ */ Object.create(null);
      return {
        EnumTypeDefinition: checkValueUniqueness,
        EnumTypeExtension: checkValueUniqueness
      };
      function checkValueUniqueness(node) {
        var _node$values;
        const typeName = node.name.value;
        if (!knownValueNames[typeName]) {
          knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
        const valueNames = knownValueNames[typeName];
        for (const valueDef of valueNodes) {
          const valueName = valueDef.name.value;
          const existingType = existingTypeMap[typeName];
          if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
                {
                  nodes: valueDef.name
                }
              )
            );
          } else if (valueNames[valueName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Enum value "${typeName}.${valueName}" can only be defined once.`,
                {
                  nodes: [valueNames[valueName], valueDef.name]
                }
              )
            );
          } else {
            valueNames[valueName] = valueDef.name;
          }
        }
        return false;
      }
      __name(checkValueUniqueness, "checkValueUniqueness");
    }
    __name(UniqueEnumValueNamesRule, "UniqueEnumValueNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
var require_UniqueFieldDefinitionNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueFieldDefinitionNamesRule(context) {
      const schema = context.getSchema();
      const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const knownFieldNames = /* @__PURE__ */ Object.create(null);
      return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness
      };
      function checkFieldUniqueness(node) {
        var _node$fields;
        const typeName = node.name.value;
        if (!knownFieldNames[typeName]) {
          knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
        const fieldNames = knownFieldNames[typeName];
        for (const fieldDef of fieldNodes) {
          const fieldName = fieldDef.name.value;
          if (hasField(existingTypeMap[typeName], fieldName)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
                {
                  nodes: fieldDef.name
                }
              )
            );
          } else if (fieldNames[fieldName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${typeName}.${fieldName}" can only be defined once.`,
                {
                  nodes: [fieldNames[fieldName], fieldDef.name]
                }
              )
            );
          } else {
            fieldNames[fieldName] = fieldDef.name;
          }
        }
        return false;
      }
      __name(checkFieldUniqueness, "checkFieldUniqueness");
    }
    __name(UniqueFieldDefinitionNamesRule, "UniqueFieldDefinitionNamesRule");
    function hasField(type, fieldName) {
      if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
        return type.getFields()[fieldName] != null;
      }
      return false;
    }
    __name(hasField, "hasField");
  }
});

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
var require_UniqueFragmentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueFragmentNamesRule(context) {
      const knownFragmentNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: () => false,
        FragmentDefinition(node) {
          const fragmentName = node.name.value;
          if (knownFragmentNames[fragmentName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one fragment named "${fragmentName}".`,
                {
                  nodes: [knownFragmentNames[fragmentName], node.name]
                }
              )
            );
          } else {
            knownFragmentNames[fragmentName] = node.name;
          }
          return false;
        }
      };
    }
    __name(UniqueFragmentNamesRule, "UniqueFragmentNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
var require_UniqueInputFieldNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    function UniqueInputFieldNamesRule(context) {
      const knownNameStack = [];
      let knownNames = /* @__PURE__ */ Object.create(null);
      return {
        ObjectValue: {
          enter() {
            knownNameStack.push(knownNames);
            knownNames = /* @__PURE__ */ Object.create(null);
          },
          leave() {
            const prevKnownNames = knownNameStack.pop();
            prevKnownNames || (0, _invariant.invariant)(false);
            knownNames = prevKnownNames;
          }
        },
        ObjectField(node) {
          const fieldName = node.name.value;
          if (knownNames[fieldName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one input field named "${fieldName}".`,
                {
                  nodes: [knownNames[fieldName], node.name]
                }
              )
            );
          } else {
            knownNames[fieldName] = node.name;
          }
        }
      };
    }
    __name(UniqueInputFieldNamesRule, "UniqueInputFieldNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
var require_UniqueOperationNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueOperationNamesRule = UniqueOperationNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationNamesRule(context) {
      const knownOperationNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition(node) {
          const operationName = node.name;
          if (operationName) {
            if (knownOperationNames[operationName.value]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one operation named "${operationName.value}".`,
                  {
                    nodes: [
                      knownOperationNames[operationName.value],
                      operationName
                    ]
                  }
                )
              );
            } else {
              knownOperationNames[operationName.value] = operationName;
            }
          }
          return false;
        },
        FragmentDefinition: () => false
      };
    }
    __name(UniqueOperationNamesRule, "UniqueOperationNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
var require_UniqueOperationTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueOperationTypesRule = UniqueOperationTypesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationTypesRule(context) {
      const schema = context.getSchema();
      const definedOperationTypes = /* @__PURE__ */ Object.create(null);
      const existingOperationTypes = schema ? {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType()
      } : {};
      return {
        SchemaDefinition: checkOperationTypes,
        SchemaExtension: checkOperationTypes
      };
      function checkOperationTypes(node) {
        var _node$operationTypes;
        const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
        for (const operationType of operationTypesNodes) {
          const operation = operationType.operation;
          const alreadyDefinedOperationType = definedOperationTypes[operation];
          if (existingOperationTypes[operation]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Type for ${operation} already defined in the schema. It cannot be redefined.`,
                {
                  nodes: operationType
                }
              )
            );
          } else if (alreadyDefinedOperationType) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one ${operation} type in schema.`,
                {
                  nodes: [alreadyDefinedOperationType, operationType]
                }
              )
            );
          } else {
            definedOperationTypes[operation] = operationType;
          }
        }
        return false;
      }
      __name(checkOperationTypes, "checkOperationTypes");
    }
    __name(UniqueOperationTypesRule, "UniqueOperationTypesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
var require_UniqueTypeNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueTypeNamesRule = UniqueTypeNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueTypeNamesRule(context) {
      const knownTypeNames = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName
      };
      function checkTypeName(node) {
        const typeName = node.name.value;
        if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
          context.reportError(
            new _GraphQLError.GraphQLError(
              `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
              {
                nodes: node.name
              }
            )
          );
          return;
        }
        if (knownTypeNames[typeName]) {
          context.reportError(
            new _GraphQLError.GraphQLError(
              `There can be only one type named "${typeName}".`,
              {
                nodes: [knownTypeNames[typeName], node.name]
              }
            )
          );
        } else {
          knownTypeNames[typeName] = node.name;
        }
        return false;
      }
      __name(checkTypeName, "checkTypeName");
    }
    __name(UniqueTypeNamesRule, "UniqueTypeNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
var require_UniqueVariableNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueVariableNamesRule = UniqueVariableNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueVariableNamesRule(context) {
      return {
        OperationDefinition(operationNode) {
          var _operationNode$variab;
          const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
          const seenVariableDefinitions = (0, _groupBy.groupBy)(
            variableDefinitions,
            (node) => node.variable.name.value
          );
          for (const [variableName, variableNodes] of seenVariableDefinitions) {
            if (variableNodes.length > 1) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one variable named "$${variableName}".`,
                  {
                    nodes: variableNodes.map((node) => node.variable.name)
                  }
                )
              );
            }
          }
        }
      };
    }
    __name(UniqueVariableNamesRule, "UniqueVariableNamesRule");
  }
});

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
var require_ValuesOfCorrectTypeRule = __commonJS({
  "node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    function ValuesOfCorrectTypeRule(context) {
      return {
        ListValue(node) {
          const type = (0, _definition.getNullableType)(
            context.getParentInputType()
          );
          if (!(0, _definition.isListType)(type)) {
            isValidValueNode(context, node);
            return false;
          }
        },
        ObjectValue(node) {
          const type = (0, _definition.getNamedType)(context.getInputType());
          if (!(0, _definition.isInputObjectType)(type)) {
            isValidValueNode(context, node);
            return false;
          }
          const fieldNodeMap = (0, _keyMap.keyMap)(
            node.fields,
            (field) => field.name.value
          );
          for (const fieldDef of Object.values(type.getFields())) {
            const fieldNode = fieldNodeMap[fieldDef.name];
            if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
              const typeStr = (0, _inspect.inspect)(fieldDef.type);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        },
        ObjectField(node) {
          const parentType = (0, _definition.getNamedType)(
            context.getParentInputType()
          );
          const fieldType = context.getInputType();
          if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
            const suggestions = (0, _suggestionList.suggestionList)(
              node.name.value,
              Object.keys(parentType.getFields())
            );
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                {
                  nodes: node
                }
              )
            );
          }
        },
        NullValue(node) {
          const type = context.getInputType();
          if ((0, _definition.isNonNullType)(type)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Expected value of type "${(0, _inspect.inspect)(
                  type
                )}", found ${(0, _printer.print)(node)}.`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        EnumValue: (node) => isValidValueNode(context, node),
        IntValue: (node) => isValidValueNode(context, node),
        FloatValue: (node) => isValidValueNode(context, node),
        StringValue: (node) => isValidValueNode(context, node),
        BooleanValue: (node) => isValidValueNode(context, node)
      };
    }
    __name(ValuesOfCorrectTypeRule, "ValuesOfCorrectTypeRule");
    function isValidValueNode(context, node) {
      const locationType = context.getInputType();
      if (!locationType) {
        return;
      }
      const type = (0, _definition.getNamedType)(locationType);
      if (!(0, _definition.isLeafType)(type)) {
        const typeStr = (0, _inspect.inspect)(locationType);
        context.reportError(
          new _GraphQLError.GraphQLError(
            `Expected value of type "${typeStr}", found ${(0, _printer.print)(
              node
            )}.`,
            {
              nodes: node
            }
          )
        );
        return;
      }
      try {
        const parseResult = type.parseLiteral(
          node,
          void 0
        );
        if (parseResult === void 0) {
          const typeStr = (0, _inspect.inspect)(locationType);
          context.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}.`,
              {
                nodes: node
              }
            )
          );
        }
      } catch (error) {
        const typeStr = (0, _inspect.inspect)(locationType);
        if (error instanceof _GraphQLError.GraphQLError) {
          context.reportError(error);
        } else {
          context.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}; ` + error.message,
              {
                nodes: node,
                originalError: error
              }
            )
          );
        }
      }
    }
    __name(isValidValueNode, "isValidValueNode");
  }
});

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
var require_VariablesAreInputTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function VariablesAreInputTypesRule(context) {
      return {
        VariableDefinition(node) {
          const type = (0, _typeFromAST.typeFromAST)(
            context.getSchema(),
            node.type
          );
          if (type !== void 0 && !(0, _definition.isInputType)(type)) {
            const variableName = node.variable.name.value;
            const typeName = (0, _printer.print)(node.type);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
                {
                  nodes: node.type
                }
              )
            );
          }
        }
      };
    }
    __name(VariablesAreInputTypesRule, "VariablesAreInputTypesRule");
  }
});

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
var require_VariablesInAllowedPositionRule = __commonJS({
  "node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds2();
    var _definition = require_definition();
    var _typeComparators = require_typeComparators();
    var _typeFromAST = require_typeFromAST();
    function VariablesInAllowedPositionRule(context) {
      let varDefMap = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            varDefMap = /* @__PURE__ */ Object.create(null);
          },
          leave(operation) {
            const usages = context.getRecursiveVariableUsages(operation);
            for (const { node, type, defaultValue } of usages) {
              const varName = node.name.value;
              const varDef = varDefMap[varName];
              if (varDef && type) {
                const schema = context.getSchema();
                const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                if (varType && !allowedVariableUsage(
                  schema,
                  varType,
                  varDef.defaultValue,
                  type,
                  defaultValue
                )) {
                  const varTypeStr = (0, _inspect.inspect)(varType);
                  const typeStr = (0, _inspect.inspect)(type);
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                      {
                        nodes: [varDef, node]
                      }
                    )
                  );
                }
              }
            }
          }
        },
        VariableDefinition(node) {
          varDefMap[node.variable.name.value] = node;
        }
      };
    }
    __name(VariablesInAllowedPositionRule, "VariablesInAllowedPositionRule");
    function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
      if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
        const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
        const hasLocationDefaultValue = locationDefaultValue !== void 0;
        if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
          return false;
        }
        const nullableLocationType = locationType.ofType;
        return (0, _typeComparators.isTypeSubTypeOf)(
          schema,
          varType,
          nullableLocationType
        );
      }
      return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
    }
    __name(allowedVariableUsage, "allowedVariableUsage");
  }
});

// node_modules/graphql/validation/specifiedRules.js
var require_specifiedRules = __commonJS({
  "node_modules/graphql/validation/specifiedRules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.specifiedSDLRules = exports2.specifiedRules = void 0;
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var specifiedRules = Object.freeze([
      _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
      _UniqueOperationNamesRule.UniqueOperationNamesRule,
      _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
      _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
      _KnownTypeNamesRule.KnownTypeNamesRule,
      _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
      _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
      _ScalarLeafsRule.ScalarLeafsRule,
      _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
      _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
      _KnownFragmentNamesRule.KnownFragmentNamesRule,
      _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
      _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
      _NoFragmentCyclesRule.NoFragmentCyclesRule,
      _UniqueVariableNamesRule.UniqueVariableNamesRule,
      _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
      _NoUnusedVariablesRule.NoUnusedVariablesRule,
      _KnownDirectivesRule.KnownDirectivesRule,
      _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
      _KnownArgumentNamesRule.KnownArgumentNamesRule,
      _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
      _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
      _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
      _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
      _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
      _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule
    ]);
    exports2.specifiedRules = specifiedRules;
    var specifiedSDLRules = Object.freeze([
      _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
      _UniqueOperationTypesRule.UniqueOperationTypesRule,
      _UniqueTypeNamesRule.UniqueTypeNamesRule,
      _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
      _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
      _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
      _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
      _KnownTypeNamesRule.KnownTypeNamesRule,
      _KnownDirectivesRule.KnownDirectivesRule,
      _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
      _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
      _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
      _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
      _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
      _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
    ]);
    exports2.specifiedSDLRules = specifiedSDLRules;
  }
});

// node_modules/graphql/validation/ValidationContext.js
var require_ValidationContext = __commonJS({
  "node_modules/graphql/validation/ValidationContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValidationContext = exports2.SDLValidationContext = exports2.ASTValidationContext = void 0;
    var _kinds = require_kinds2();
    var _visitor = require_visitor();
    var _TypeInfo = require_TypeInfo();
    var ASTValidationContext = class {
      constructor(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = /* @__PURE__ */ new Map();
        this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
        this._onError = onError;
      }
      get [Symbol.toStringTag]() {
        return "ASTValidationContext";
      }
      reportError(error) {
        this._onError(error);
      }
      getDocument() {
        return this._ast;
      }
      getFragment(name) {
        let fragments;
        if (this._fragments) {
          fragments = this._fragments;
        } else {
          fragments = /* @__PURE__ */ Object.create(null);
          for (const defNode of this.getDocument().definitions) {
            if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
              fragments[defNode.name.value] = defNode;
            }
          }
          this._fragments = fragments;
        }
        return fragments[name];
      }
      getFragmentSpreads(node) {
        let spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          const setsToVisit = [node];
          let set;
          while (set = setsToVisit.pop()) {
            for (const selection of set.selections) {
              if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      }
      getRecursivelyReferencedFragments(operation) {
        let fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          const collectedNames = /* @__PURE__ */ Object.create(null);
          const nodesToVisit = [operation.selectionSet];
          let node;
          while (node = nodesToVisit.pop()) {
            for (const spread of this.getFragmentSpreads(node)) {
              const fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                const fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      }
    };
    __name(ASTValidationContext, "ASTValidationContext");
    exports2.ASTValidationContext = ASTValidationContext;
    var SDLValidationContext = class extends ASTValidationContext {
      constructor(ast, schema, onError) {
        super(ast, onError);
        this._schema = schema;
      }
      get [Symbol.toStringTag]() {
        return "SDLValidationContext";
      }
      getSchema() {
        return this._schema;
      }
    };
    __name(SDLValidationContext, "SDLValidationContext");
    exports2.SDLValidationContext = SDLValidationContext;
    var ValidationContext = class extends ASTValidationContext {
      constructor(schema, ast, typeInfo, onError) {
        super(ast, onError);
        this._schema = schema;
        this._typeInfo = typeInfo;
        this._variableUsages = /* @__PURE__ */ new Map();
        this._recursiveVariableUsages = /* @__PURE__ */ new Map();
      }
      get [Symbol.toStringTag]() {
        return "ValidationContext";
      }
      getSchema() {
        return this._schema;
      }
      getVariableUsages(node) {
        let usages = this._variableUsages.get(node);
        if (!usages) {
          const newUsages = [];
          const typeInfo = new _TypeInfo.TypeInfo(this._schema);
          (0, _visitor.visit)(
            node,
            (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
              VariableDefinition: () => false,
              Variable(variable) {
                newUsages.push({
                  node: variable,
                  type: typeInfo.getInputType(),
                  defaultValue: typeInfo.getDefaultValue()
                });
              }
            })
          );
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      }
      getRecursiveVariableUsages(operation) {
        let usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (const frag of this.getRecursivelyReferencedFragments(operation)) {
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      }
      getType() {
        return this._typeInfo.getType();
      }
      getParentType() {
        return this._typeInfo.getParentType();
      }
      getInputType() {
        return this._typeInfo.getInputType();
      }
      getParentInputType() {
        return this._typeInfo.getParentInputType();
      }
      getFieldDef() {
        return this._typeInfo.getFieldDef();
      }
      getDirective() {
        return this._typeInfo.getDirective();
      }
      getArgument() {
        return this._typeInfo.getArgument();
      }
      getEnumValue() {
        return this._typeInfo.getEnumValue();
      }
    };
    __name(ValidationContext, "ValidationContext");
    exports2.ValidationContext = ValidationContext;
  }
});

// node_modules/graphql/validation/validate.js
var require_validate2 = __commonJS({
  "node_modules/graphql/validation/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidSDL = assertValidSDL;
    exports2.assertValidSDLExtension = assertValidSDLExtension;
    exports2.validate = validate;
    exports2.validateSDL = validateSDL;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _visitor = require_visitor();
    var _validate = require_validate();
    var _TypeInfo = require_TypeInfo();
    var _specifiedRules = require_specifiedRules();
    var _ValidationContext = require_ValidationContext();
    function validate(schema, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema)) {
      var _options$maxErrors;
      const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
      documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      const abortObj = Object.freeze({});
      const errors = [];
      const context = new _ValidationContext.ValidationContext(
        schema,
        documentAST,
        typeInfo,
        (error) => {
          if (errors.length >= maxErrors) {
            errors.push(
              new _GraphQLError.GraphQLError(
                "Too many validation errors, error limit reached. Validation aborted."
              )
            );
            throw abortObj;
          }
          errors.push(error);
        }
      );
      const visitor = (0, _visitor.visitInParallel)(
        rules.map((rule) => rule(context))
      );
      try {
        (0, _visitor.visit)(
          documentAST,
          (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor)
        );
      } catch (e) {
        if (e !== abortObj) {
          throw e;
        }
      }
      return errors;
    }
    __name(validate, "validate");
    function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
      const errors = [];
      const context = new _ValidationContext.SDLValidationContext(
        documentAST,
        schemaToExtend,
        (error) => {
          errors.push(error);
        }
      );
      const visitors = rules.map((rule) => rule(context));
      (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
      return errors;
    }
    __name(validateSDL, "validateSDL");
    function assertValidSDL(documentAST) {
      const errors = validateSDL(documentAST);
      if (errors.length !== 0) {
        throw new Error(errors.map((error) => error.message).join("\n\n"));
      }
    }
    __name(assertValidSDL, "assertValidSDL");
    function assertValidSDLExtension(documentAST, schema) {
      const errors = validateSDL(documentAST, schema);
      if (errors.length !== 0) {
        throw new Error(errors.map((error) => error.message).join("\n\n"));
      }
    }
    __name(assertValidSDLExtension, "assertValidSDLExtension");
  }
});

// node_modules/graphql/utilities/extendSchema.js
var require_extendSchema = __commonJS({
  "node_modules/graphql/utilities/extendSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.extendSchema = extendSchema;
    exports2.extendSchemaImpl = extendSchemaImpl;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _mapValue = require_mapValue();
    var _kinds = require_kinds2();
    var _predicates = require_predicates();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _schema = require_schema();
    var _validate = require_validate2();
    var _values = require_values();
    var _valueFromAST = require_valueFromAST();
    function extendSchema(schema, documentAST, options) {
      (0, _schema.assertSchema)(schema);
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
      if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDLExtension)(documentAST, schema);
      }
      const schemaConfig = schema.toConfig();
      const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
      return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
    }
    __name(extendSchema, "extendSchema");
    function extendSchemaImpl(schemaConfig, documentAST, options) {
      var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
      const typeDefs = [];
      const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
      const directiveDefs = [];
      let schemaDef;
      const schemaExtensions = [];
      for (const def of documentAST.definitions) {
        if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
          schemaDef = def;
        } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
          schemaExtensions.push(def);
        } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
          typeDefs.push(def);
        } else if ((0, _predicates.isTypeExtensionNode)(def)) {
          const extendedTypeName = def.name.value;
          const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
          typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
        } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          directiveDefs.push(def);
        }
      }
      if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
        return schemaConfig;
      }
      const typeMap = /* @__PURE__ */ Object.create(null);
      for (const existingType of schemaConfig.types) {
        typeMap[existingType.name] = extendNamedType(existingType);
      }
      for (const typeNode of typeDefs) {
        var _stdTypeMap$name;
        const name = typeNode.name.value;
        typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
      }
      const operationTypes = {
        query: schemaConfig.query && replaceNamedType(schemaConfig.query),
        mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
        subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
        ...schemaDef && getOperationTypes([schemaDef]),
        ...getOperationTypes(schemaExtensions)
      };
      return {
        description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
        ...operationTypes,
        types: Object.values(typeMap),
        directives: [
          ...schemaConfig.directives.map(replaceDirective),
          ...directiveDefs.map(buildDirective)
        ],
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
        extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
        assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
      };
      function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
          return new _definition.GraphQLList(replaceType(type.ofType));
        }
        if ((0, _definition.isNonNullType)(type)) {
          return new _definition.GraphQLNonNull(replaceType(type.ofType));
        }
        return replaceNamedType(type);
      }
      __name(replaceType, "replaceType");
      function replaceNamedType(type) {
        return typeMap[type.name];
      }
      __name(replaceNamedType, "replaceNamedType");
      function replaceDirective(directive) {
        const config = directive.toConfig();
        return new _directives.GraphQLDirective({
          ...config,
          args: (0, _mapValue.mapValue)(config.args, extendArg)
        });
      }
      __name(replaceDirective, "replaceDirective");
      function extendNamedType(type) {
        if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
          return type;
        }
        if ((0, _definition.isScalarType)(type)) {
          return extendScalarType(type);
        }
        if ((0, _definition.isObjectType)(type)) {
          return extendObjectType(type);
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return extendInterfaceType(type);
        }
        if ((0, _definition.isUnionType)(type)) {
          return extendUnionType(type);
        }
        if ((0, _definition.isEnumType)(type)) {
          return extendEnumType(type);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return extendInputObjectType(type);
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
      __name(extendNamedType, "extendNamedType");
      function extendInputObjectType(type) {
        var _typeExtensionsMap$co;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
        return new _definition.GraphQLInputObjectType({
          ...config,
          fields: () => ({
            ...(0, _mapValue.mapValue)(config.fields, (field) => ({
              ...field,
              type: replaceType(field.type)
            })),
            ...buildInputFieldMap(extensions)
          }),
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendInputObjectType, "extendInputObjectType");
      function extendEnumType(type) {
        var _typeExtensionsMap$ty;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
        return new _definition.GraphQLEnumType({
          ...config,
          values: { ...config.values, ...buildEnumValueMap(extensions) },
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendEnumType, "extendEnumType");
      function extendScalarType(type) {
        var _typeExtensionsMap$co2;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
        let specifiedByURL = config.specifiedByURL;
        for (const extensionNode of extensions) {
          var _getSpecifiedByURL;
          specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
        }
        return new _definition.GraphQLScalarType({
          ...config,
          specifiedByURL,
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendScalarType, "extendScalarType");
      function extendObjectType(type) {
        var _typeExtensionsMap$co3;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
        return new _definition.GraphQLObjectType({
          ...config,
          interfaces: () => [
            ...type.getInterfaces().map(replaceNamedType),
            ...buildInterfaces(extensions)
          ],
          fields: () => ({
            ...(0, _mapValue.mapValue)(config.fields, extendField),
            ...buildFieldMap(extensions)
          }),
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendObjectType, "extendObjectType");
      function extendInterfaceType(type) {
        var _typeExtensionsMap$co4;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
        return new _definition.GraphQLInterfaceType({
          ...config,
          interfaces: () => [
            ...type.getInterfaces().map(replaceNamedType),
            ...buildInterfaces(extensions)
          ],
          fields: () => ({
            ...(0, _mapValue.mapValue)(config.fields, extendField),
            ...buildFieldMap(extensions)
          }),
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendInterfaceType, "extendInterfaceType");
      function extendUnionType(type) {
        var _typeExtensionsMap$co5;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
        return new _definition.GraphQLUnionType({
          ...config,
          types: () => [
            ...type.getTypes().map(replaceNamedType),
            ...buildUnionTypes(extensions)
          ],
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendUnionType, "extendUnionType");
      function extendField(field) {
        return {
          ...field,
          type: replaceType(field.type),
          args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
        };
      }
      __name(extendField, "extendField");
      function extendArg(arg) {
        return { ...arg, type: replaceType(arg.type) };
      }
      __name(extendArg, "extendArg");
      function getOperationTypes(nodes) {
        const opTypes = {};
        for (const node of nodes) {
          var _node$operationTypes;
          const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
          for (const operationType of operationTypesNodes) {
            opTypes[operationType.operation] = getNamedType(operationType.type);
          }
        }
        return opTypes;
      }
      __name(getOperationTypes, "getOperationTypes");
      function getNamedType(node) {
        var _stdTypeMap$name2;
        const name = node.name.value;
        const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
        if (type === void 0) {
          throw new Error(`Unknown type: "${name}".`);
        }
        return type;
      }
      __name(getNamedType, "getNamedType");
      function getWrappedType(node) {
        if (node.kind === _kinds.Kind.LIST_TYPE) {
          return new _definition.GraphQLList(getWrappedType(node.type));
        }
        if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
          return new _definition.GraphQLNonNull(getWrappedType(node.type));
        }
        return getNamedType(node);
      }
      __name(getWrappedType, "getWrappedType");
      function buildDirective(node) {
        var _node$description;
        return new _directives.GraphQLDirective({
          name: node.name.value,
          description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
          locations: node.locations.map(({ value }) => value),
          isRepeatable: node.repeatable,
          args: buildArgumentMap(node.arguments),
          astNode: node
        });
      }
      __name(buildDirective, "buildDirective");
      function buildFieldMap(nodes) {
        const fieldConfigMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$fields;
          const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
          for (const field of nodeFields) {
            var _field$description;
            fieldConfigMap[field.name.value] = {
              type: getWrappedType(field.type),
              description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
              args: buildArgumentMap(field.arguments),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return fieldConfigMap;
      }
      __name(buildFieldMap, "buildFieldMap");
      function buildArgumentMap(args) {
        const argsNodes = args !== null && args !== void 0 ? args : [];
        const argConfigMap = /* @__PURE__ */ Object.create(null);
        for (const arg of argsNodes) {
          var _arg$description;
          const type = getWrappedType(arg.type);
          argConfigMap[arg.name.value] = {
            type,
            description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
            defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
            deprecationReason: getDeprecationReason(arg),
            astNode: arg
          };
        }
        return argConfigMap;
      }
      __name(buildArgumentMap, "buildArgumentMap");
      function buildInputFieldMap(nodes) {
        const inputFieldMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$fields2;
          const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
          for (const field of fieldsNodes) {
            var _field$description2;
            const type = getWrappedType(field.type);
            inputFieldMap[field.name.value] = {
              type,
              description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
              defaultValue: (0, _valueFromAST.valueFromAST)(
                field.defaultValue,
                type
              ),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return inputFieldMap;
      }
      __name(buildInputFieldMap, "buildInputFieldMap");
      function buildEnumValueMap(nodes) {
        const enumValueMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$values;
          const valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
          for (const value of valuesNodes) {
            var _value$description;
            enumValueMap[value.name.value] = {
              description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
              deprecationReason: getDeprecationReason(value),
              astNode: value
            };
          }
        }
        return enumValueMap;
      }
      __name(buildEnumValueMap, "buildEnumValueMap");
      function buildInterfaces(nodes) {
        return nodes.flatMap(
          (node) => {
            var _node$interfaces$map, _node$interfaces;
            return (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : [];
          }
        );
      }
      __name(buildInterfaces, "buildInterfaces");
      function buildUnionTypes(nodes) {
        return nodes.flatMap(
          (node) => {
            var _node$types$map, _node$types;
            return (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : [];
          }
        );
      }
      __name(buildUnionTypes, "buildUnionTypes");
      function buildType(astNode) {
        var _typeExtensionsMap$na;
        const name = astNode.name.value;
        const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
        switch (astNode.kind) {
          case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
            var _astNode$description;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLObjectType({
              name,
              description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
              interfaces: () => buildInterfaces(allNodes),
              fields: () => buildFieldMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
            var _astNode$description2;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLInterfaceType({
              name,
              description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
              interfaces: () => buildInterfaces(allNodes),
              fields: () => buildFieldMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.ENUM_TYPE_DEFINITION: {
            var _astNode$description3;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLEnumType({
              name,
              description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
              values: buildEnumValueMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.UNION_TYPE_DEFINITION: {
            var _astNode$description4;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLUnionType({
              name,
              description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
              types: () => buildUnionTypes(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
            var _astNode$description5;
            return new _definition.GraphQLScalarType({
              name,
              description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
              specifiedByURL: getSpecifiedByURL(astNode),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
            var _astNode$description6;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLInputObjectType({
              name,
              description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
              fields: () => buildInputFieldMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
        }
      }
      __name(buildType, "buildType");
    }
    __name(extendSchemaImpl, "extendSchemaImpl");
    var stdTypeMap = (0, _keyMap.keyMap)(
      [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes],
      (type) => type.name
    );
    function getDeprecationReason(node) {
      const deprecated = (0, _values.getDirectiveValues)(
        _directives.GraphQLDeprecatedDirective,
        node
      );
      return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
    }
    __name(getDeprecationReason, "getDeprecationReason");
    function getSpecifiedByURL(node) {
      const specifiedBy = (0, _values.getDirectiveValues)(
        _directives.GraphQLSpecifiedByDirective,
        node
      );
      return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
    }
    __name(getSpecifiedByURL, "getSpecifiedByURL");
  }
});

// node_modules/graphql/utilities/buildASTSchema.js
var require_buildASTSchema = __commonJS({
  "node_modules/graphql/utilities/buildASTSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildASTSchema = buildASTSchema;
    exports2.buildSchema = buildSchema;
    var _devAssert = require_devAssert();
    var _kinds = require_kinds2();
    var _parser = require_parser();
    var _directives = require_directives();
    var _schema = require_schema();
    var _validate = require_validate2();
    var _extendSchema = require_extendSchema();
    function buildASTSchema(documentAST, options) {
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
      if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDL)(documentAST);
      }
      const emptySchemaConfig = {
        description: void 0,
        types: [],
        directives: [],
        extensions: /* @__PURE__ */ Object.create(null),
        extensionASTNodes: [],
        assumeValid: false
      };
      const config = (0, _extendSchema.extendSchemaImpl)(
        emptySchemaConfig,
        documentAST,
        options
      );
      if (config.astNode == null) {
        for (const type of config.types) {
          switch (type.name) {
            case "Query":
              config.query = type;
              break;
            case "Mutation":
              config.mutation = type;
              break;
            case "Subscription":
              config.subscription = type;
              break;
          }
        }
      }
      const directives = [
        ...config.directives,
        ..._directives.specifiedDirectives.filter(
          (stdDirective) => config.directives.every(
            (directive) => directive.name !== stdDirective.name
          )
        )
      ];
      return new _schema.GraphQLSchema({ ...config, directives });
    }
    __name(buildASTSchema, "buildASTSchema");
    function buildSchema(source, options) {
      const document = (0, _parser.parse)(source, {
        noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
        allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
      });
      return buildASTSchema(document, {
        assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
      });
    }
    __name(buildSchema, "buildSchema");
  }
});

// node_modules/graphql/utilities/lexicographicSortSchema.js
var require_lexicographicSortSchema = __commonJS({
  "node_modules/graphql/utilities/lexicographicSortSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.lexicographicSortSchema = lexicographicSortSchema;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyValMap = require_keyValMap();
    var _naturalCompare = require_naturalCompare();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _schema = require_schema();
    function lexicographicSortSchema(schema) {
      const schemaConfig = schema.toConfig();
      const typeMap = (0, _keyValMap.keyValMap)(
        sortByName(schemaConfig.types),
        (type) => type.name,
        sortNamedType
      );
      return new _schema.GraphQLSchema({
        ...schemaConfig,
        types: Object.values(typeMap),
        directives: sortByName(schemaConfig.directives).map(sortDirective),
        query: replaceMaybeType(schemaConfig.query),
        mutation: replaceMaybeType(schemaConfig.mutation),
        subscription: replaceMaybeType(schemaConfig.subscription)
      });
      function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
          return new _definition.GraphQLList(replaceType(type.ofType));
        } else if ((0, _definition.isNonNullType)(type)) {
          return new _definition.GraphQLNonNull(replaceType(type.ofType));
        }
        return replaceNamedType(type);
      }
      __name(replaceType, "replaceType");
      function replaceNamedType(type) {
        return typeMap[type.name];
      }
      __name(replaceNamedType, "replaceNamedType");
      function replaceMaybeType(maybeType) {
        return maybeType && replaceNamedType(maybeType);
      }
      __name(replaceMaybeType, "replaceMaybeType");
      function sortDirective(directive) {
        const config = directive.toConfig();
        return new _directives.GraphQLDirective({
          ...config,
          locations: sortBy(config.locations, (x) => x),
          args: sortArgs(config.args)
        });
      }
      __name(sortDirective, "sortDirective");
      function sortArgs(args) {
        return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
      }
      __name(sortArgs, "sortArgs");
      function sortFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field) => ({
          ...field,
          type: replaceType(field.type),
          args: field.args && sortArgs(field.args)
        }));
      }
      __name(sortFields, "sortFields");
      function sortInputFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field) => ({
          ...field,
          type: replaceType(field.type)
        }));
      }
      __name(sortInputFields, "sortInputFields");
      function sortTypes(array) {
        return sortByName(array).map(replaceNamedType);
      }
      __name(sortTypes, "sortTypes");
      function sortNamedType(type) {
        if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
          return type;
        }
        if ((0, _definition.isObjectType)(type)) {
          const config = type.toConfig();
          return new _definition.GraphQLObjectType({
            ...config,
            interfaces: () => sortTypes(config.interfaces),
            fields: () => sortFields(config.fields)
          });
        }
        if ((0, _definition.isInterfaceType)(type)) {
          const config = type.toConfig();
          return new _definition.GraphQLInterfaceType({
            ...config,
            interfaces: () => sortTypes(config.interfaces),
            fields: () => sortFields(config.fields)
          });
        }
        if ((0, _definition.isUnionType)(type)) {
          const config = type.toConfig();
          return new _definition.GraphQLUnionType({
            ...config,
            types: () => sortTypes(config.types)
          });
        }
        if ((0, _definition.isEnumType)(type)) {
          const config = type.toConfig();
          return new _definition.GraphQLEnumType({
            ...config,
            values: sortObjMap(config.values, (value) => value)
          });
        }
        if ((0, _definition.isInputObjectType)(type)) {
          const config = type.toConfig();
          return new _definition.GraphQLInputObjectType({
            ...config,
            fields: () => sortInputFields(config.fields)
          });
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
      __name(sortNamedType, "sortNamedType");
    }
    __name(lexicographicSortSchema, "lexicographicSortSchema");
    function sortObjMap(map, sortValueFn) {
      const sortedMap = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)) {
        sortedMap[key] = sortValueFn(map[key]);
      }
      return sortedMap;
    }
    __name(sortObjMap, "sortObjMap");
    function sortByName(array) {
      return sortBy(array, (obj) => obj.name);
    }
    __name(sortByName, "sortByName");
    function sortBy(array, mapToKey) {
      return array.slice().sort((obj1, obj2) => {
        const key1 = mapToKey(obj1);
        const key2 = mapToKey(obj2);
        return (0, _naturalCompare.naturalCompare)(key1, key2);
      });
    }
    __name(sortBy, "sortBy");
  }
});

// node_modules/graphql/utilities/printSchema.js
var require_printSchema = __commonJS({
  "node_modules/graphql/utilities/printSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printIntrospectionSchema = printIntrospectionSchema;
    exports2.printSchema = printSchema;
    exports2.printType = printType;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _blockString = require_blockString();
    var _kinds = require_kinds2();
    var _printer = require_printer();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _astFromValue = require_astFromValue();
    function printSchema(schema) {
      return printFilteredSchema(
        schema,
        (n) => !(0, _directives.isSpecifiedDirective)(n),
        isDefinedType
      );
    }
    __name(printSchema, "printSchema");
    function printIntrospectionSchema(schema) {
      return printFilteredSchema(
        schema,
        _directives.isSpecifiedDirective,
        _introspection.isIntrospectionType
      );
    }
    __name(printIntrospectionSchema, "printIntrospectionSchema");
    function isDefinedType(type) {
      return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
    }
    __name(isDefinedType, "isDefinedType");
    function printFilteredSchema(schema, directiveFilter, typeFilter) {
      const directives = schema.getDirectives().filter(directiveFilter);
      const types = Object.values(schema.getTypeMap()).filter(typeFilter);
      return [
        printSchemaDefinition(schema),
        ...directives.map((directive) => printDirective(directive)),
        ...types.map((type) => printType(type))
      ].filter(Boolean).join("\n\n");
    }
    __name(printFilteredSchema, "printFilteredSchema");
    function printSchemaDefinition(schema) {
      if (schema.description == null && isSchemaOfCommonNames(schema)) {
        return;
      }
      const operationTypes = [];
      const queryType = schema.getQueryType();
      if (queryType) {
        operationTypes.push(`  query: ${queryType.name}`);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        operationTypes.push(`  mutation: ${mutationType.name}`);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        operationTypes.push(`  subscription: ${subscriptionType.name}`);
      }
      return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
    }
    __name(printSchemaDefinition, "printSchemaDefinition");
    function isSchemaOfCommonNames(schema) {
      const queryType = schema.getQueryType();
      if (queryType && queryType.name !== "Query") {
        return false;
      }
      const mutationType = schema.getMutationType();
      if (mutationType && mutationType.name !== "Mutation") {
        return false;
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && subscriptionType.name !== "Subscription") {
        return false;
      }
      return true;
    }
    __name(isSchemaOfCommonNames, "isSchemaOfCommonNames");
    function printType(type) {
      if ((0, _definition.isScalarType)(type)) {
        return printScalar(type);
      }
      if ((0, _definition.isObjectType)(type)) {
        return printObject(type);
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return printInterface(type);
      }
      if ((0, _definition.isUnionType)(type)) {
        return printUnion(type);
      }
      if ((0, _definition.isEnumType)(type)) {
        return printEnum(type);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return printInputObject(type);
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type)
      );
    }
    __name(printType, "printType");
    function printScalar(type) {
      return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
    }
    __name(printScalar, "printScalar");
    function printImplementedInterfaces(type) {
      const interfaces = type.getInterfaces();
      return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
    }
    __name(printImplementedInterfaces, "printImplementedInterfaces");
    function printObject(type) {
      return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
    }
    __name(printObject, "printObject");
    function printInterface(type) {
      return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
    }
    __name(printInterface, "printInterface");
    function printUnion(type) {
      const types = type.getTypes();
      const possibleTypes = types.length ? " = " + types.join(" | ") : "";
      return printDescription(type) + "union " + type.name + possibleTypes;
    }
    __name(printUnion, "printUnion");
    function printEnum(type) {
      const values = type.getValues().map(
        (value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason)
      );
      return printDescription(type) + `enum ${type.name}` + printBlock(values);
    }
    __name(printEnum, "printEnum");
    function printInputObject(type) {
      const fields = Object.values(type.getFields()).map(
        (f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f)
      );
      return printDescription(type) + `input ${type.name}` + printBlock(fields);
    }
    __name(printInputObject, "printInputObject");
    function printFields(type) {
      const fields = Object.values(type.getFields()).map(
        (f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason)
      );
      return printBlock(fields);
    }
    __name(printFields, "printFields");
    function printBlock(items) {
      return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
    }
    __name(printBlock, "printBlock");
    function printArgs(args, indentation = "") {
      if (args.length === 0) {
        return "";
      }
      if (args.every((arg) => !arg.description)) {
        return "(" + args.map(printInputValue).join(", ") + ")";
      }
      return "(\n" + args.map(
        (arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)
      ).join("\n") + "\n" + indentation + ")";
    }
    __name(printArgs, "printArgs");
    function printInputValue(arg) {
      const defaultAST = (0, _astFromValue.astFromValue)(
        arg.defaultValue,
        arg.type
      );
      let argDecl = arg.name + ": " + String(arg.type);
      if (defaultAST) {
        argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
      }
      return argDecl + printDeprecated(arg.deprecationReason);
    }
    __name(printInputValue, "printInputValue");
    function printDirective(directive) {
      return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
    }
    __name(printDirective, "printDirective");
    function printDeprecated(reason) {
      if (reason == null) {
        return "";
      }
      if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
        const astValue = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: reason
        });
        return ` @deprecated(reason: ${astValue})`;
      }
      return " @deprecated";
    }
    __name(printDeprecated, "printDeprecated");
    function printSpecifiedByURL(scalar) {
      if (scalar.specifiedByURL == null) {
        return "";
      }
      const astValue = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: scalar.specifiedByURL
      });
      return ` @specifiedBy(url: ${astValue})`;
    }
    __name(printSpecifiedByURL, "printSpecifiedByURL");
    function printDescription(def, indentation = "", firstInBlock = true) {
      const { description } = def;
      if (description == null) {
        return "";
      }
      const blockString = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: description,
        block: (0, _blockString.isPrintableAsBlockString)(description)
      });
      const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
      return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
    }
    __name(printDescription, "printDescription");
  }
});

// node_modules/graphql/utilities/concatAST.js
var require_concatAST = __commonJS({
  "node_modules/graphql/utilities/concatAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.concatAST = concatAST;
    var _kinds = require_kinds2();
    function concatAST(documents) {
      const definitions = [];
      for (const doc of documents) {
        definitions.push(...doc.definitions);
      }
      return {
        kind: _kinds.Kind.DOCUMENT,
        definitions
      };
    }
    __name(concatAST, "concatAST");
  }
});

// node_modules/graphql/utilities/separateOperations.js
var require_separateOperations = __commonJS({
  "node_modules/graphql/utilities/separateOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.separateOperations = separateOperations;
    var _kinds = require_kinds2();
    var _visitor = require_visitor();
    function separateOperations(documentAST) {
      const operations = [];
      const depGraph = /* @__PURE__ */ Object.create(null);
      for (const definitionNode of documentAST.definitions) {
        switch (definitionNode.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            operations.push(definitionNode);
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            depGraph[definitionNode.name.value] = collectDependencies(
              definitionNode.selectionSet
            );
            break;
          default:
        }
      }
      const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
      for (const operation of operations) {
        const dependencies = /* @__PURE__ */ new Set();
        for (const fragmentName of collectDependencies(operation.selectionSet)) {
          collectTransitiveDependencies(dependencies, depGraph, fragmentName);
        }
        const operationName = operation.name ? operation.name.value : "";
        separatedDocumentASTs[operationName] = {
          kind: _kinds.Kind.DOCUMENT,
          definitions: documentAST.definitions.filter(
            (node) => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
          )
        };
      }
      return separatedDocumentASTs;
    }
    __name(separateOperations, "separateOperations");
    function collectTransitiveDependencies(collected, depGraph, fromName) {
      if (!collected.has(fromName)) {
        collected.add(fromName);
        const immediateDeps = depGraph[fromName];
        if (immediateDeps !== void 0) {
          for (const toName of immediateDeps) {
            collectTransitiveDependencies(collected, depGraph, toName);
          }
        }
      }
    }
    __name(collectTransitiveDependencies, "collectTransitiveDependencies");
    function collectDependencies(selectionSet) {
      const dependencies = [];
      (0, _visitor.visit)(selectionSet, {
        FragmentSpread(node) {
          dependencies.push(node.name.value);
        }
      });
      return dependencies;
    }
    __name(collectDependencies, "collectDependencies");
  }
});

// node_modules/graphql/utilities/stripIgnoredCharacters.js
var require_stripIgnoredCharacters = __commonJS({
  "node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.stripIgnoredCharacters = stripIgnoredCharacters;
    var _blockString = require_blockString();
    var _lexer = require_lexer();
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    function stripIgnoredCharacters(source) {
      const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
      const body = sourceObj.body;
      const lexer = new _lexer.Lexer(sourceObj);
      let strippedBody = "";
      let wasLastAddedTokenNonPunctuator = false;
      while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
        const currentToken = lexer.token;
        const tokenKind = currentToken.kind;
        const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(
          currentToken.kind
        );
        if (wasLastAddedTokenNonPunctuator) {
          if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
            strippedBody += " ";
          }
        }
        const tokenBody = body.slice(currentToken.start, currentToken.end);
        if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
          strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
            minimize: true
          });
        } else {
          strippedBody += tokenBody;
        }
        wasLastAddedTokenNonPunctuator = isNonPunctuator;
      }
      return strippedBody;
    }
    __name(stripIgnoredCharacters, "stripIgnoredCharacters");
  }
});

// node_modules/graphql/utilities/assertValidName.js
var require_assertValidName = __commonJS({
  "node_modules/graphql/utilities/assertValidName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidName = assertValidName;
    exports2.isValidNameError = isValidNameError;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _assertName = require_assertName();
    function assertValidName(name) {
      const error = isValidNameError(name);
      if (error) {
        throw error;
      }
      return name;
    }
    __name(assertValidName, "assertValidName");
    function isValidNameError(name) {
      typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
      if (name.startsWith("__")) {
        return new _GraphQLError.GraphQLError(
          `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
        );
      }
      try {
        (0, _assertName.assertName)(name);
      } catch (error) {
        return error;
      }
    }
    __name(isValidNameError, "isValidNameError");
  }
});

// node_modules/graphql/utilities/findBreakingChanges.js
var require_findBreakingChanges = __commonJS({
  "node_modules/graphql/utilities/findBreakingChanges.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DangerousChangeType = exports2.BreakingChangeType = void 0;
    exports2.findBreakingChanges = findBreakingChanges;
    exports2.findDangerousChanges = findDangerousChanges;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _printer = require_printer();
    var _definition = require_definition();
    var _scalars = require_scalars();
    var _astFromValue = require_astFromValue();
    var _sortValueNode = require_sortValueNode();
    var BreakingChangeType;
    exports2.BreakingChangeType = BreakingChangeType;
    (function(BreakingChangeType2) {
      BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
      BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
      BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
      BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
      BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
      BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
      BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
      BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
      BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
      BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
      BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
      BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
      BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
      BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
      BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
      BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
    })(
      BreakingChangeType || (exports2.BreakingChangeType = BreakingChangeType = {})
    );
    var DangerousChangeType;
    exports2.DangerousChangeType = DangerousChangeType;
    (function(DangerousChangeType2) {
      DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
      DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
      DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
      DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
      DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
      DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
    })(
      DangerousChangeType || (exports2.DangerousChangeType = DangerousChangeType = {})
    );
    function findBreakingChanges(oldSchema, newSchema) {
      return findSchemaChanges(oldSchema, newSchema).filter(
        (change) => change.type in BreakingChangeType
      );
    }
    __name(findBreakingChanges, "findBreakingChanges");
    function findDangerousChanges(oldSchema, newSchema) {
      return findSchemaChanges(oldSchema, newSchema).filter(
        (change) => change.type in DangerousChangeType
      );
    }
    __name(findDangerousChanges, "findDangerousChanges");
    function findSchemaChanges(oldSchema, newSchema) {
      return [
        ...findTypeChanges(oldSchema, newSchema),
        ...findDirectiveChanges(oldSchema, newSchema)
      ];
    }
    __name(findSchemaChanges, "findSchemaChanges");
    function findDirectiveChanges(oldSchema, newSchema) {
      const schemaChanges = [];
      const directivesDiff = diff(
        oldSchema.getDirectives(),
        newSchema.getDirectives()
      );
      for (const oldDirective of directivesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REMOVED,
          description: `${oldDirective.name} was removed.`
        });
      }
      for (const [oldDirective, newDirective] of directivesDiff.persisted) {
        const argsDiff = diff(oldDirective.args, newDirective.args);
        for (const newArg of argsDiff.added) {
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
              description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
            });
          }
        }
        for (const oldArg of argsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
            description: `${oldArg.name} was removed from ${oldDirective.name}.`
          });
        }
        if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
            description: `Repeatable flag was removed from ${oldDirective.name}.`
          });
        }
        for (const location of oldDirective.locations) {
          if (!newDirective.locations.includes(location)) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
              description: `${location} was removed from ${oldDirective.name}.`
            });
          }
        }
      }
      return schemaChanges;
    }
    __name(findDirectiveChanges, "findDirectiveChanges");
    function findTypeChanges(oldSchema, newSchema) {
      const schemaChanges = [];
      const typesDiff = diff(
        Object.values(oldSchema.getTypeMap()),
        Object.values(newSchema.getTypeMap())
      );
      for (const oldType of typesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED,
          description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
        });
      }
      for (const [oldType, newType] of typesDiff.persisted) {
        if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
          schemaChanges.push(...findEnumTypeChanges(oldType, newType));
        } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
          schemaChanges.push(...findUnionTypeChanges(oldType, newType));
        } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
          schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
        } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
          schemaChanges.push(
            ...findFieldChanges(oldType, newType),
            ...findImplementedInterfacesChanges(oldType, newType)
          );
        } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
          schemaChanges.push(
            ...findFieldChanges(oldType, newType),
            ...findImplementedInterfacesChanges(oldType, newType)
          );
        } else if (oldType.constructor !== newType.constructor) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_CHANGED_KIND,
            description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findTypeChanges, "findTypeChanges");
    function findInputObjectTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const fieldsDiff = diff(
        Object.values(oldType.getFields()),
        Object.values(newType.getFields())
      );
      for (const newField of fieldsDiff.added) {
        if ((0, _definition.isRequiredInputField)(newField)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
            description: `A required field ${newField.name} on input type ${oldType.name} was added.`
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
            description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
          });
        }
      }
      for (const oldField of fieldsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: `${oldType.name}.${oldField.name} was removed.`
        });
      }
      for (const [oldField, newField] of fieldsDiff.persisted) {
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
          oldField.type,
          newField.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findInputObjectTypeChanges, "findInputObjectTypeChanges");
    function findUnionTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
      for (const newPossibleType of possibleTypesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.TYPE_ADDED_TO_UNION,
          description: `${newPossibleType.name} was added to union type ${oldType.name}.`
        });
      }
      for (const oldPossibleType of possibleTypesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
          description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
        });
      }
      return schemaChanges;
    }
    __name(findUnionTypeChanges, "findUnionTypeChanges");
    function findEnumTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const valuesDiff = diff(oldType.getValues(), newType.getValues());
      for (const newValue of valuesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
          description: `${newValue.name} was added to enum type ${oldType.name}.`
        });
      }
      for (const oldValue of valuesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
          description: `${oldValue.name} was removed from enum type ${oldType.name}.`
        });
      }
      return schemaChanges;
    }
    __name(findEnumTypeChanges, "findEnumTypeChanges");
    function findImplementedInterfacesChanges(oldType, newType) {
      const schemaChanges = [];
      const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
      for (const newInterface of interfacesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
          description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
        });
      }
      for (const oldInterface of interfacesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
          description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
        });
      }
      return schemaChanges;
    }
    __name(findImplementedInterfacesChanges, "findImplementedInterfacesChanges");
    function findFieldChanges(oldType, newType) {
      const schemaChanges = [];
      const fieldsDiff = diff(
        Object.values(oldType.getFields()),
        Object.values(newType.getFields())
      );
      for (const oldField of fieldsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: `${oldType.name}.${oldField.name} was removed.`
        });
      }
      for (const [oldField, newField] of fieldsDiff.persisted) {
        schemaChanges.push(...findArgChanges(oldType, oldField, newField));
        const isSafe = isChangeSafeForObjectOrInterfaceField(
          oldField.type,
          newField.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findFieldChanges, "findFieldChanges");
    function findArgChanges(oldType, oldField, newField) {
      const schemaChanges = [];
      const argsDiff = diff(oldField.args, newField.args);
      for (const oldArg of argsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.ARG_REMOVED,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
        });
      }
      for (const [oldArg, newArg] of argsDiff.persisted) {
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
          oldArg.type,
          newArg.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
          });
        } else if (oldArg.defaultValue !== void 0) {
          if (newArg.defaultValue === void 0) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
            });
          } else {
            const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
            const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
            if (oldValueStr !== newValueStr) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
              });
            }
          }
        }
      }
      for (const newArg of argsDiff.added) {
        if ((0, _definition.isRequiredArgument)(newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_ARG_ADDED,
            description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_ARG_ADDED,
            description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findArgChanges, "findArgChanges");
    function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(
          oldType.ofType,
          newType.ofType
        ) || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
    }
    __name(isChangeSafeForObjectOrInterfaceField, "isChangeSafeForObjectOrInterfaceField");
    function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
          oldType.ofType,
          newType.ofType
        ) || !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
    }
    __name(isChangeSafeForInputObjectFieldOrFieldArg, "isChangeSafeForInputObjectFieldOrFieldArg");
    function typeKindName(type) {
      if ((0, _definition.isScalarType)(type)) {
        return "a Scalar type";
      }
      if ((0, _definition.isObjectType)(type)) {
        return "an Object type";
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return "an Interface type";
      }
      if ((0, _definition.isUnionType)(type)) {
        return "a Union type";
      }
      if ((0, _definition.isEnumType)(type)) {
        return "an Enum type";
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return "an Input type";
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type)
      );
    }
    __name(typeKindName, "typeKindName");
    function stringifyValue(value, type) {
      const ast = (0, _astFromValue.astFromValue)(value, type);
      ast != null || (0, _invariant.invariant)(false);
      return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
    }
    __name(stringifyValue, "stringifyValue");
    function diff(oldArray, newArray) {
      const added = [];
      const removed = [];
      const persisted = [];
      const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
      const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
      for (const oldItem of oldArray) {
        const newItem = newMap[oldItem.name];
        if (newItem === void 0) {
          removed.push(oldItem);
        } else {
          persisted.push([oldItem, newItem]);
        }
      }
      for (const newItem of newArray) {
        if (oldMap[newItem.name] === void 0) {
          added.push(newItem);
        }
      }
      return {
        added,
        persisted,
        removed
      };
    }
    __name(diff, "diff");
  }
});

// node_modules/graphql/utilities/index.js
var require_utilities = __commonJS({
  "node_modules/graphql/utilities/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BreakingChangeType", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.BreakingChangeType;
      }
    });
    Object.defineProperty(exports2, "DangerousChangeType", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.DangerousChangeType;
      }
    });
    Object.defineProperty(exports2, "TypeInfo", {
      enumerable: true,
      get: function() {
        return _TypeInfo.TypeInfo;
      }
    });
    Object.defineProperty(exports2, "assertValidName", {
      enumerable: true,
      get: function() {
        return _assertValidName.assertValidName;
      }
    });
    Object.defineProperty(exports2, "astFromValue", {
      enumerable: true,
      get: function() {
        return _astFromValue.astFromValue;
      }
    });
    Object.defineProperty(exports2, "buildASTSchema", {
      enumerable: true,
      get: function() {
        return _buildASTSchema.buildASTSchema;
      }
    });
    Object.defineProperty(exports2, "buildClientSchema", {
      enumerable: true,
      get: function() {
        return _buildClientSchema.buildClientSchema;
      }
    });
    Object.defineProperty(exports2, "buildSchema", {
      enumerable: true,
      get: function() {
        return _buildASTSchema.buildSchema;
      }
    });
    Object.defineProperty(exports2, "coerceInputValue", {
      enumerable: true,
      get: function() {
        return _coerceInputValue.coerceInputValue;
      }
    });
    Object.defineProperty(exports2, "concatAST", {
      enumerable: true,
      get: function() {
        return _concatAST.concatAST;
      }
    });
    Object.defineProperty(exports2, "doTypesOverlap", {
      enumerable: true,
      get: function() {
        return _typeComparators.doTypesOverlap;
      }
    });
    Object.defineProperty(exports2, "extendSchema", {
      enumerable: true,
      get: function() {
        return _extendSchema.extendSchema;
      }
    });
    Object.defineProperty(exports2, "findBreakingChanges", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.findBreakingChanges;
      }
    });
    Object.defineProperty(exports2, "findDangerousChanges", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.findDangerousChanges;
      }
    });
    Object.defineProperty(exports2, "getIntrospectionQuery", {
      enumerable: true,
      get: function() {
        return _getIntrospectionQuery.getIntrospectionQuery;
      }
    });
    Object.defineProperty(exports2, "getOperationAST", {
      enumerable: true,
      get: function() {
        return _getOperationAST.getOperationAST;
      }
    });
    Object.defineProperty(exports2, "getOperationRootType", {
      enumerable: true,
      get: function() {
        return _getOperationRootType.getOperationRootType;
      }
    });
    Object.defineProperty(exports2, "introspectionFromSchema", {
      enumerable: true,
      get: function() {
        return _introspectionFromSchema.introspectionFromSchema;
      }
    });
    Object.defineProperty(exports2, "isEqualType", {
      enumerable: true,
      get: function() {
        return _typeComparators.isEqualType;
      }
    });
    Object.defineProperty(exports2, "isTypeSubTypeOf", {
      enumerable: true,
      get: function() {
        return _typeComparators.isTypeSubTypeOf;
      }
    });
    Object.defineProperty(exports2, "isValidNameError", {
      enumerable: true,
      get: function() {
        return _assertValidName.isValidNameError;
      }
    });
    Object.defineProperty(exports2, "lexicographicSortSchema", {
      enumerable: true,
      get: function() {
        return _lexicographicSortSchema.lexicographicSortSchema;
      }
    });
    Object.defineProperty(exports2, "printIntrospectionSchema", {
      enumerable: true,
      get: function() {
        return _printSchema.printIntrospectionSchema;
      }
    });
    Object.defineProperty(exports2, "printSchema", {
      enumerable: true,
      get: function() {
        return _printSchema.printSchema;
      }
    });
    Object.defineProperty(exports2, "printType", {
      enumerable: true,
      get: function() {
        return _printSchema.printType;
      }
    });
    Object.defineProperty(exports2, "separateOperations", {
      enumerable: true,
      get: function() {
        return _separateOperations.separateOperations;
      }
    });
    Object.defineProperty(exports2, "stripIgnoredCharacters", {
      enumerable: true,
      get: function() {
        return _stripIgnoredCharacters.stripIgnoredCharacters;
      }
    });
    Object.defineProperty(exports2, "typeFromAST", {
      enumerable: true,
      get: function() {
        return _typeFromAST.typeFromAST;
      }
    });
    Object.defineProperty(exports2, "valueFromAST", {
      enumerable: true,
      get: function() {
        return _valueFromAST.valueFromAST;
      }
    });
    Object.defineProperty(exports2, "valueFromASTUntyped", {
      enumerable: true,
      get: function() {
        return _valueFromASTUntyped.valueFromASTUntyped;
      }
    });
    Object.defineProperty(exports2, "visitWithTypeInfo", {
      enumerable: true,
      get: function() {
        return _TypeInfo.visitWithTypeInfo;
      }
    });
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    var _getOperationAST = require_getOperationAST();
    var _getOperationRootType = require_getOperationRootType();
    var _introspectionFromSchema = require_introspectionFromSchema();
    var _buildClientSchema = require_buildClientSchema();
    var _buildASTSchema = require_buildASTSchema();
    var _extendSchema = require_extendSchema();
    var _lexicographicSortSchema = require_lexicographicSortSchema();
    var _printSchema = require_printSchema();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _astFromValue = require_astFromValue();
    var _TypeInfo = require_TypeInfo();
    var _coerceInputValue = require_coerceInputValue();
    var _concatAST = require_concatAST();
    var _separateOperations = require_separateOperations();
    var _stripIgnoredCharacters = require_stripIgnoredCharacters();
    var _typeComparators = require_typeComparators();
    var _assertValidName = require_assertValidName();
    var _findBreakingChanges = require_findBreakingChanges();
  }
});

// node_modules/lodash.sortby/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.sortby/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    __name(apply, "apply");
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    __name(arraySome, "arraySome");
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    __name(baseProperty, "baseProperty");
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    __name(baseSortBy, "baseSortBy");
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    __name(baseUnary, "baseUnary");
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    __name(getValue, "getValue");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash, "Hash");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    __name(hashClear, "hashClear");
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    __name(hashDelete, "hashDelete");
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    __name(hashGet, "hashGet");
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    __name(hashHas, "hashHas");
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    __name(hashSet, "hashSet");
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache, "ListCache");
    function listCacheClear() {
      this.__data__ = [];
    }
    __name(listCacheClear, "listCacheClear");
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    __name(listCacheDelete, "listCacheDelete");
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet, "listCacheGet");
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    __name(listCacheHas, "listCacheHas");
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet, "listCacheSet");
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache, "MapCache");
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    __name(mapCacheClear, "mapCacheClear");
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    __name(mapCacheDelete, "mapCacheDelete");
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    __name(mapCacheGet, "mapCacheGet");
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    __name(mapCacheHas, "mapCacheHas");
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    __name(mapCacheSet, "mapCacheSet");
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    __name(SetCache, "SetCache");
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    __name(setCacheAdd, "setCacheAdd");
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    __name(setCacheHas, "setCacheHas");
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    __name(Stack, "Stack");
    function stackClear() {
      this.__data__ = new ListCache();
    }
    __name(stackClear, "stackClear");
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    __name(stackDelete, "stackDelete");
    function stackGet(key) {
      return this.__data__.get(key);
    }
    __name(stackGet, "stackGet");
    function stackHas(key) {
      return this.__data__.has(key);
    }
    __name(stackHas, "stackHas");
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    __name(stackSet, "stackSet");
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf, "assocIndexOf");
    var baseEach = createBaseEach(baseForOwn);
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    __name(baseFlatten, "baseFlatten");
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    __name(baseForOwn, "baseForOwn");
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    __name(baseGet, "baseGet");
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    __name(baseGetTag, "baseGetTag");
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    __name(baseHasIn, "baseHasIn");
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    __name(baseIsEqual, "baseIsEqual");
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    __name(baseIsEqualDeep, "baseIsEqualDeep");
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    __name(baseIsMatch, "baseIsMatch");
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    __name(baseIsNative, "baseIsNative");
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    __name(baseIsTypedArray, "baseIsTypedArray");
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    __name(baseIteratee, "baseIteratee");
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    __name(baseMap, "baseMap");
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    __name(baseMatches, "baseMatches");
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    __name(baseMatchesProperty, "baseMatchesProperty");
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    __name(baseOrderBy, "baseOrderBy");
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    __name(basePropertyDeep, "basePropertyDeep");
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    __name(baseRest, "baseRest");
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(baseToString, "baseToString");
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    __name(castPath, "castPath");
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    __name(compareAscending, "compareAscending");
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    __name(compareMultiple, "compareMultiple");
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    __name(createBaseEach, "createBaseEach");
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    __name(createBaseFor, "createBaseFor");
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    __name(equalArrays, "equalArrays");
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    __name(equalByTag, "equalByTag");
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    __name(equalObjects, "equalObjects");
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData, "getMapData");
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    __name(getMatchData, "getMatchData");
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    __name(getNative, "getNative");
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = /* @__PURE__ */ __name(function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      }, "getTag");
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    __name(hasPath, "hasPath");
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    __name(isFlattenable, "isFlattenable");
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex, "isIndex");
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    __name(isIterateeCall, "isIterateeCall");
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    __name(isKey, "isKey");
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable, "isKeyable");
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    __name(isMasked, "isMasked");
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    __name(isStrictComparable, "isStrictComparable");
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    __name(matchesStrictComparable, "matchesStrictComparable");
    var stringToPath = memoize(function(string) {
      string = toString2(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(toKey, "toKey");
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource, "toSource");
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = /* @__PURE__ */ __name(function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      }, "memoized");
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    __name(memoize, "memoize");
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq, "eq");
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    __name(isArguments, "isArguments");
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    __name(isArrayLike, "isArrayLike");
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction, "isFunction");
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol, "isSymbol");
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    __name(toString2, "toString");
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    __name(get, "get");
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    __name(hasIn, "hasIn");
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    function identity(value) {
      return value;
    }
    __name(identity, "identity");
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    __name(property, "property");
    module2.exports = sortBy;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/transforms.js
var require_transforms = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/transforms.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var printer_1 = require_printer();
    var utilities_1 = require_utilities();
    var lodash_sortby_1 = __importDefault(require_lodash3());
    function hideLiterals(ast) {
      return visitor_1.visit(ast, {
        IntValue(node) {
          return Object.assign({}, node, { value: "0" });
        },
        FloatValue(node) {
          return Object.assign({}, node, { value: "0" });
        },
        StringValue(node) {
          return Object.assign({}, node, { value: "", block: false });
        },
        ListValue(node) {
          return Object.assign({}, node, { values: [] });
        },
        ObjectValue(node) {
          return Object.assign({}, node, { fields: [] });
        }
      });
    }
    __name(hideLiterals, "hideLiterals");
    exports2.hideLiterals = hideLiterals;
    function hideStringAndNumericLiterals(ast) {
      return visitor_1.visit(ast, {
        IntValue(node) {
          return Object.assign({}, node, { value: "0" });
        },
        FloatValue(node) {
          return Object.assign({}, node, { value: "0" });
        },
        StringValue(node) {
          return Object.assign({}, node, { value: "", block: false });
        }
      });
    }
    __name(hideStringAndNumericLiterals, "hideStringAndNumericLiterals");
    exports2.hideStringAndNumericLiterals = hideStringAndNumericLiterals;
    function dropUnusedDefinitions(ast, operationName) {
      const separated = utilities_1.separateOperations(ast)[operationName];
      if (!separated) {
        return ast;
      }
      return separated;
    }
    __name(dropUnusedDefinitions, "dropUnusedDefinitions");
    exports2.dropUnusedDefinitions = dropUnusedDefinitions;
    function sorted(items) {
      if (items) {
        return lodash_sortby_1.default.apply(null, arguments);
      }
      return void 0;
    }
    __name(sorted, "sorted");
    function sortAST(ast) {
      return visitor_1.visit(ast, {
        OperationDefinition(node) {
          return Object.assign({}, node, { variableDefinitions: sorted(node.variableDefinitions, "variable.name.value") });
        },
        SelectionSet(node) {
          return Object.assign({}, node, { selections: lodash_sortby_1.default(node.selections, "kind", "name.value") });
        },
        Field(node) {
          return Object.assign({}, node, { arguments: sorted(node.arguments, "name.value") });
        },
        FragmentSpread(node) {
          return Object.assign({}, node, { directives: sorted(node.directives, "name.value") });
        },
        InlineFragment(node) {
          return Object.assign({}, node, { directives: sorted(node.directives, "name.value") });
        },
        FragmentDefinition(node) {
          return Object.assign({}, node, { directives: sorted(node.directives, "name.value"), variableDefinitions: sorted(node.variableDefinitions, "variable.name.value") });
        },
        Directive(node) {
          return Object.assign({}, node, { arguments: sorted(node.arguments, "name.value") });
        }
      });
    }
    __name(sortAST, "sortAST");
    exports2.sortAST = sortAST;
    function removeAliases(ast) {
      return visitor_1.visit(ast, {
        Field(node) {
          return Object.assign({}, node, { alias: void 0 });
        }
      });
    }
    __name(removeAliases, "removeAliases");
    exports2.removeAliases = removeAliases;
    function printWithReducedWhitespace(ast) {
      const sanitizedAST = visitor_1.visit(ast, {
        StringValue(node) {
          return Object.assign({}, node, { value: Buffer.from(node.value, "utf8").toString("hex"), block: false });
        }
      });
      const withWhitespace = printer_1.print(sanitizedAST);
      const minimizedButStillHex = withWhitespace.replace(/\s+/g, " ").replace(/([^_a-zA-Z0-9]) /g, (_, c) => c).replace(/ ([^_a-zA-Z0-9])/g, (_, c) => c);
      return minimizedButStillHex.replace(/"([a-f0-9]+)"/g, (_, hex) => JSON.stringify(Buffer.from(hex, "hex").toString("utf8")));
    }
    __name(printWithReducedWhitespace, "printWithReducedWhitespace");
    exports2.printWithReducedWhitespace = printWithReducedWhitespace;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/signature.js
var require_signature = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/signature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var transforms_1 = require_transforms();
    function defaultEngineReportingSignature(ast, operationName) {
      return transforms_1.printWithReducedWhitespace(transforms_1.sortAST(transforms_1.removeAliases(transforms_1.hideLiterals(transforms_1.dropUnusedDefinitions(ast, operationName)))));
    }
    __name(defaultEngineReportingSignature, "defaultEngineReportingSignature");
    exports2.defaultEngineReportingSignature = defaultEngineReportingSignature;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/index.js
var require_tools = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-graphql/src/tools/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var signature_1 = require_signature();
    exports2.defaultEngineReportingSignature = signature_1.defaultEngineReportingSignature;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/execute.js
var require_execute2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-graphql/src/execute.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var tools;
    var GraphQLExecutePlugin = class extends TracingPlugin {
      static get name() {
        return "graphql";
      }
      static get operation() {
        return "execute";
      }
      start({ operation, args, docSource }) {
        const type = operation && operation.operation;
        const name = operation && operation.name && operation.name.value;
        const document = args.document;
        const source = this.config.source && document && docSource;
        const span = this.startSpan("graphql.execute", {
          service: this.config.service,
          resource: getSignature(document, name, type, this.config.signature),
          kind: "server",
          type: "graphql",
          meta: {
            "graphql.operation.type": type,
            "graphql.operation.name": name,
            "graphql.source": source
          }
        });
        addVariableTags(this.config, span, args.variableValues);
      }
      finish({ res, args }) {
        const span = this.activeSpan;
        this.config.hooks.execute(span, args, res);
        span.finish();
      }
    };
    function addVariableTags(config, span, variableValues) {
      const tags = {};
      if (variableValues && config.variables) {
        const variables = config.variables(variableValues);
        for (const param in variables) {
          tags[`graphql.variables.${param}`] = variables[param];
        }
      }
      span.addTags(tags);
    }
    __name(addVariableTags, "addVariableTags");
    function getSignature(document, operationName, operationType, calculate) {
      if (calculate !== false && tools !== false) {
        try {
          try {
            tools = tools || require_tools();
          } catch (e) {
            tools = false;
            throw e;
          }
          return tools.defaultEngineReportingSignature(document, operationName);
        } catch (e) {
        }
      }
      return [operationType, operationName].filter((val) => val).join(" ");
    }
    __name(getSignature, "getSignature");
    module2.exports = GraphQLExecutePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/parse.js
var require_parse = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-graphql/src/parse.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var GraphQLParsePlugin = class extends TracingPlugin {
      static get name() {
        return "graphql";
      }
      static get operation() {
        return "parser";
      }
      start() {
        this.startSpan("graphql.parse", {
          service: this.config.service,
          type: "graphql",
          meta: {
            "graphql.source": ""
          }
        });
      }
      finish({ source, document, docSource }) {
        const span = this.activeSpan;
        if (this.config.source && document) {
          span.setTag("graphql.source", docSource);
        }
        this.config.hooks.parse(span, source, document);
        span.finish();
      }
    };
    module2.exports = GraphQLParsePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/validate.js
var require_validate3 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-graphql/src/validate.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var GraphQLValidatePlugin = class extends TracingPlugin {
      static get name() {
        return "graphql";
      }
      static get operation() {
        return "validate";
      }
      start({ docSource, document }) {
        const source = this.config.source && document && docSource;
        this.startSpan("graphql.validate", {
          service: this.config.service,
          type: "graphql",
          meta: {
            "graphql.source": source
          }
        });
      }
      finish({ document, errors }) {
        const span = this.activeSpan;
        this.config.hooks.validate(span, document, errors);
        span.finish();
      }
    };
    module2.exports = GraphQLValidatePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/resolve.js
var require_resolve2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-graphql/src/resolve.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var collapsedPathSym = Symbol("collapsedPaths");
    var GraphQLResolvePlugin = class extends TracingPlugin {
      static get name() {
        return "graphql";
      }
      static get operation() {
        return "resolve";
      }
      start({ info, context }) {
        const path = getPath(info, this.config);
        if (!shouldInstrument(this.config, path))
          return;
        const computedPathString = path.join(".");
        if (this.config.collapse) {
          if (!context[collapsedPathSym]) {
            context[collapsedPathSym] = {};
          }
          if (context.fields[computedPathString])
            return;
          if (context[collapsedPathSym][computedPathString])
            return;
          context[collapsedPathSym][computedPathString] = true;
        }
        const document = context.source;
        const fieldNode = info.fieldNodes.find((fieldNode2) => fieldNode2.kind === "Field");
        const loc = this.config.source && document && fieldNode && fieldNode.loc;
        const source = loc && document.substring(loc.start, loc.end);
        const span = this.startSpan("graphql.resolve", {
          service: this.config.service,
          resource: `${info.fieldName}:${info.returnType}`,
          type: "graphql",
          meta: {
            "graphql.field.name": info.fieldName,
            "graphql.field.path": computedPathString,
            "graphql.field.type": info.returnType.name,
            "graphql.source": source
          }
        });
        if (fieldNode && this.config.variables && fieldNode.arguments) {
          const variables = this.config.variables(info.variableValues);
          fieldNode.arguments.filter((arg) => arg.value && arg.value.kind === "Variable").filter((arg) => arg.value.name && variables[arg.value.name.value]).map((arg) => arg.value.name.value).forEach((name) => {
            span.setTag(`graphql.variables.${name}`, variables[name]);
          });
        }
      }
      finish(finishTime) {
        const span = this.activeSpan;
        span.finish(finishTime);
      }
      constructor(...args) {
        super(...args);
        this.addTraceSub("updateField", ({ field, info, err }) => {
          const path = getPath(info, this.config);
          if (!shouldInstrument(this.config, path))
            return;
          const span = this.activeSpan;
          field.finishTime = span._getTime ? span._getTime() : 0;
          field.error = field.error || err;
        });
      }
      configure(config) {
        super.configure(config.depth === 0 ? false : config);
      }
    };
    function shouldInstrument(config, path) {
      const depth = path.filter((item) => typeof item === "string").length;
      return config.depth < 0 || config.depth >= depth;
    }
    __name(shouldInstrument, "shouldInstrument");
    function getPath(info, config) {
      const responsePathAsArray = config.collapse ? withCollapse(pathToArray) : pathToArray;
      return responsePathAsArray(info && info.path);
    }
    __name(getPath, "getPath");
    function pathToArray(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    __name(pathToArray, "pathToArray");
    function withCollapse(responsePathAsArray) {
      return function() {
        return responsePathAsArray.apply(this, arguments).map((segment) => typeof segment === "number" ? "*" : segment);
      };
    }
    __name(withCollapse, "withCollapse");
    module2.exports = GraphQLResolvePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js
var require_src25 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite();
    var log = require_log();
    var GraphQLExecutePlugin = require_execute2();
    var GraphQLParsePlugin = require_parse();
    var GraphQLValidatePlugin = require_validate3();
    var GraphQLResolvePlugin = require_resolve2();
    var GraphQLPlugin = class extends CompositePlugin {
      static get name() {
        return "graphql";
      }
      static get plugins() {
        return {
          execute: GraphQLExecutePlugin,
          parse: GraphQLParsePlugin,
          validate: GraphQLValidatePlugin,
          resolve: GraphQLResolvePlugin
        };
      }
      configure(config) {
        return super.configure(validateConfig(config));
      }
    };
    function validateConfig(config) {
      return Object.assign({}, config, {
        depth: getDepth(config),
        variables: getVariablesFilter(config),
        collapse: config.collapse === void 0 || !!config.collapse,
        hooks: getHooks(config)
      });
    }
    __name(validateConfig, "validateConfig");
    function getDepth(config) {
      if (typeof config.depth === "number") {
        return config.depth;
      } else if (config.hasOwnProperty("depth")) {
        log.error("Expected `depth` to be a integer.");
      }
      return -1;
    }
    __name(getDepth, "getDepth");
    function getVariablesFilter(config) {
      if (typeof config.variables === "function") {
        return config.variables;
      } else if (config.variables instanceof Array) {
        return (variables) => pick(variables, config.variables);
      } else if (config.hasOwnProperty("variables")) {
        log.error("Expected `variables` to be an array or function.");
      }
      return null;
    }
    __name(getVariablesFilter, "getVariablesFilter");
    function getHooks(config) {
      const noop = /* @__PURE__ */ __name(() => {
      }, "noop");
      const execute = config.hooks && config.hooks.execute || noop;
      const parse = config.hooks && config.hooks.parse || noop;
      const validate = config.hooks && config.hooks.validate || noop;
      return { execute, parse, validate };
    }
    __name(getHooks, "getHooks");
    function pick(obj, selectors) {
      return Object.fromEntries(Object.entries(obj).filter(([key]) => selectors.includes(key)));
    }
    __name(pick, "pick");
    module2.exports = GraphQLPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/channels.js
var require_channels2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/channels.js"(exports2, module2) {
    "use strict";
    var dc = __require("diagnostics_channel");
    module2.exports = {
      incomingHttpRequestStart: dc.channel("dd-trace:incomingHttpRequestStart"),
      incomingHttpRequestEnd: dc.channel("dd-trace:incomingHttpRequestEnd")
    };
  }
});

// node_modules/dd-trace/packages/datadog-plugin-http/src/server.js
var require_server3 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-http/src/server.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var web = require_web();
    var { incomingHttpRequestStart, incomingHttpRequestEnd } = require_channels2();
    var { COMPONENT } = require_constants();
    var HttpServerPlugin = class extends Plugin {
      static get name() {
        return "http";
      }
      constructor(...args) {
        super(...args);
        this._parentStore = void 0;
        this.addSub("apm:http:server:request:start", ({ req, res, abortController }) => {
          const store = storage.getStore();
          const span = web.startSpan(this.tracer, this.config, req, res, "web.request");
          span.setTag(COMPONENT, this.constructor.name);
          this._parentStore = store;
          this.enter(span, { ...store, req });
          const context = web.getContext(req);
          if (!context.instrumented) {
            context.res.writeHead = web.wrapWriteHead(context);
            context.instrumented = true;
          }
          if (incomingHttpRequestStart.hasSubscribers) {
            incomingHttpRequestStart.publish({ req, res, abortController });
          }
        });
        this.addSub("apm:http:server:request:error", (error) => {
          web.addError(error);
        });
        this.addSub("apm:http:server:request:exit", ({ req }) => {
          const span = this._parentStore && this._parentStore.span;
          this.enter(span, this._parentStore);
          this._parentStore = void 0;
        });
        this.addSub("apm:http:server:request:finish", ({ req }) => {
          const context = web.getContext(req);
          if (!context || !context.res)
            return;
          if (incomingHttpRequestEnd.hasSubscribers) {
            incomingHttpRequestEnd.publish({ req, res: context.res });
          }
          web.finishAll(context);
        });
      }
      configure(config) {
        return super.configure(web.normalizeConfig(config));
      }
    };
    module2.exports = HttpServerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-http/src/client.js
var require_client5 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-http/src/client.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var tags = require_tags();
    var analyticsSampler = require_analytics_sampler();
    var formats = require_formats();
    var HTTP_HEADERS = formats.HTTP_HEADERS;
    var urlFilter = require_urlfilter();
    var log = require_log();
    var url = __require("url");
    var { COMPONENT, ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK } = require_constants();
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE;
    var HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS;
    var HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS;
    var HttpClientPlugin = class extends Plugin {
      static get name() {
        return "http";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:http:client:request:start", ({ args: args2, http }) => {
          const store = storage.getStore();
          const options = args2.options;
          const agent = options.agent || options._defaultAgent || http.globalAgent;
          const protocol = options.protocol || agent.protocol || "http:";
          const hostname = options.hostname || options.host || "localhost";
          const host = options.port ? `${hostname}:${options.port}` : hostname;
          const path = options.path ? options.path.split(/[?#]/)[0] : "/";
          const uri = `${protocol}//${host}${path}`;
          const allowed = this.config.filter(uri);
          const method = (options.method || "GET").toUpperCase();
          const childOf = store && allowed ? store.span : null;
          const span = this.tracer.startSpan("http.request", {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.name,
              "span.kind": "client",
              "service.name": getServiceName(this.tracer, this.config, options),
              "resource.name": method,
              "span.type": "http",
              "http.method": method,
              "http.url": uri
            }
          });
          if (!allowed) {
            span._spanContext._trace.record = false;
          }
          if (!(hasAmazonSignature(options) || !this.config.propagationFilter(uri))) {
            this.tracer.inject(span, HTTP_HEADERS, options.headers);
          }
          analyticsSampler.sample(span, this.config.measured);
          this.enter(span, store);
        });
        this.addSub("apm:http:client:request:finish", ({ req, res }) => {
          const span = storage.getStore().span;
          if (res) {
            span.setTag(HTTP_STATUS_CODE, res.statusCode);
            if (!this.config.validateStatus(res.statusCode)) {
              span.setTag("error", 1);
            }
            addResponseHeaders(res, span, this.config);
          }
          addRequestHeaders(req, span, this.config);
          this.config.hooks.request(span, req, res);
          span.finish();
        });
        this.addSub("apm:http:client:request:error", errorHandler);
      }
      configure(config) {
        return super.configure(normalizeClientConfig(config));
      }
    };
    function errorHandler(err) {
      const span = storage.getStore().span;
      if (err) {
        span.addTags({
          [ERROR_TYPE]: err.name,
          [ERROR_MESSAGE]: err.message,
          [ERROR_STACK]: err.stack
        });
      } else {
        span.setTag("error", 1);
      }
    }
    __name(errorHandler, "errorHandler");
    function addResponseHeaders(res, span, config) {
      config.headers.forEach((key) => {
        const value = res.headers[key];
        if (value) {
          span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, value);
        }
      });
    }
    __name(addResponseHeaders, "addResponseHeaders");
    function addRequestHeaders(req, span, config) {
      config.headers.forEach((key) => {
        const value = req.getHeader(key);
        if (value) {
          span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, Array.isArray(value) ? value.toString() : value);
        }
      });
    }
    __name(addRequestHeaders, "addRequestHeaders");
    function normalizeClientConfig(config) {
      const validateStatus = getStatusValidator(config);
      const filter = getFilter(config);
      const propagationFilter = getFilter({ blocklist: config.propagationBlocklist });
      const headers = getHeaders(config);
      const hooks = getHooks(config);
      return Object.assign({}, config, {
        validateStatus,
        filter,
        propagationFilter,
        headers,
        hooks
      });
    }
    __name(normalizeClientConfig, "normalizeClientConfig");
    function getStatusValidator(config) {
      if (typeof config.validateStatus === "function") {
        return config.validateStatus;
      } else if (config.hasOwnProperty("validateStatus")) {
        log.error("Expected `validateStatus` to be a function.");
      }
      return (code) => code < 400 || code >= 500;
    }
    __name(getStatusValidator, "getStatusValidator");
    function getFilter(config) {
      config = Object.assign({}, config, {
        blocklist: config.blocklist || []
      });
      return urlFilter.getFilter(config);
    }
    __name(getFilter, "getFilter");
    function getHeaders(config) {
      if (!Array.isArray(config.headers))
        return [];
      return config.headers.filter((key) => typeof key === "string").map((key) => key.toLowerCase());
    }
    __name(getHeaders, "getHeaders");
    function getHooks(config) {
      const noop = /* @__PURE__ */ __name(() => {
      }, "noop");
      const request = config.hooks && config.hooks.request || noop;
      return { request };
    }
    __name(getHooks, "getHooks");
    function hasAmazonSignature(options) {
      if (!options) {
        return false;
      }
      if (options.headers) {
        const headers = Object.keys(options.headers).reduce((prev, next) => Object.assign(prev, {
          [next.toLowerCase()]: options.headers[next]
        }), {});
        if (headers["x-amz-signature"]) {
          return true;
        }
        if ([].concat(headers["authorization"]).some(startsWith("AWS4-HMAC-SHA256"))) {
          return true;
        }
      }
      return options.path && options.path.toLowerCase().indexOf("x-amz-signature=") !== -1;
    }
    __name(hasAmazonSignature, "hasAmazonSignature");
    function getServiceName(tracer2, config, options) {
      if (config.splitByDomain) {
        return getHost(options);
      } else if (config.service) {
        return config.service;
      }
      return tracer2._service;
    }
    __name(getServiceName, "getServiceName");
    function getHost(options) {
      if (typeof options === "string") {
        return url.parse(options).host;
      }
      const hostname = options.hostname || options.host || "localhost";
      const port = options.port;
      return [hostname, port].filter((val) => val).join(":");
    }
    __name(getHost, "getHost");
    function startsWith(searchString) {
      return (value) => String(value).startsWith(searchString);
    }
    __name(startsWith, "startsWith");
    module2.exports = HttpClientPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-http/src/index.js
var require_src26 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-http/src/index.js"(exports2, module2) {
    "use strict";
    var HttpServerPlugin = require_server3();
    var HttpClientPlugin = require_client5();
    var CompositePlugin = require_composite();
    var HttpPlugin = class extends CompositePlugin {
      static get name() {
        return "http";
      }
      static get plugins() {
        return {
          server: HttpServerPlugin,
          client: HttpClientPlugin
        };
      }
    };
    module2.exports = HttpPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js
var require_server4 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-http2/src/server.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var web = require_web();
    var { incomingHttpRequestStart } = require_channels2();
    var { COMPONENT } = require_constants();
    var Http2ServerPlugin = class extends Plugin {
      static get name() {
        return "http2";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:http2:server:request:start", ({ req, res }) => {
          const store = storage.getStore();
          const span = web.startSpan(this.tracer, this.config, req, res, "web.request");
          span.setTag(COMPONENT, this.constructor.name);
          this.enter(span, { ...store, req });
          const context = web.getContext(req);
          if (!context.instrumented) {
            context.res.writeHead = web.wrapWriteHead(context);
            context.instrumented = true;
          }
          if (incomingHttpRequestStart.hasSubscribers) {
            incomingHttpRequestStart.publish({ req, res });
          }
        });
        this.addSub("apm:http2:server:request:error", (error) => {
          web.addError(error);
        });
        this.addSub("apm:http2:server:request:finish", ({ req }) => {
          const context = web.getContext(req);
          if (!context || !context.res)
            return;
          web.finishAll(context);
        });
      }
      configure(config) {
        return super.configure(web.normalizeConfig(config));
      }
    };
    module2.exports = Http2ServerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js
var require_client6 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var Plugin = require_plugin();
    var URL2 = __require("url").URL;
    var log = require_log();
    var tags = require_tags();
    var kinds = require_kinds();
    var formats = require_formats();
    var analyticsSampler = require_analytics_sampler();
    var { COMPONENT } = require_constants();
    var urlFilter = require_urlfilter();
    var HTTP_HEADERS = formats.HTTP_HEADERS;
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE;
    var HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS;
    var HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS;
    var SPAN_KIND = tags.SPAN_KIND;
    var CLIENT = kinds.CLIENT;
    var HTTP2_HEADER_METHOD = ":method";
    var HTTP2_HEADER_PATH = ":path";
    var HTTP2_HEADER_STATUS = ":status";
    var HTTP2_METHOD_GET = "GET";
    var Http2ClientPlugin = class extends Plugin {
      static get name() {
        return "http2";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:http2:client:request:start", ({ authority, options, headers = {} }) => {
          const sessionDetails = extractSessionDetails(authority, options);
          const path = headers[HTTP2_HEADER_PATH] || "/";
          const pathname = path.split(/[?#]/)[0];
          const method = headers[HTTP2_HEADER_METHOD] || HTTP2_METHOD_GET;
          const uri = `${sessionDetails.protocol}//${sessionDetails.host}:${sessionDetails.port}${pathname}`;
          const allowed = this.config.filter(uri);
          const store = storage.getStore();
          const childOf = store && allowed ? store.span : null;
          const span = this.tracer.startSpan("http.request", {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.name,
              [SPAN_KIND]: CLIENT,
              "service.name": getServiceName(this.tracer, this.config, sessionDetails),
              "resource.name": method,
              "span.type": "http",
              "http.method": method,
              "http.url": uri
            }
          });
          if (!allowed) {
            span._spanContext._trace.record = false;
          }
          addHeaderTags(span, headers, HTTP_REQUEST_HEADERS, this.config);
          if (!hasAmazonSignature(headers, path)) {
            this.tracer.inject(span, HTTP_HEADERS, headers);
          }
          analyticsSampler.sample(span, this.config.measured);
          this.enter(span, store);
        });
        this.addSub("apm:http2:client:response", (headers) => {
          const span = storage.getStore().span;
          const status = headers && headers[HTTP2_HEADER_STATUS];
          span.setTag(HTTP_STATUS_CODE, status);
          if (!this.config.validateStatus(status)) {
            this.addError();
          }
          addHeaderTags(span, headers, HTTP_RESPONSE_HEADERS, this.config);
        });
        this.addSub("apm:http2:client:request:finish", () => {
          const span = storage.getStore().span;
          span.finish();
        });
        this.addSub("apm:http2:client:request:error", this.addError);
      }
      configure(config) {
        return super.configure(normalizeConfig(config));
      }
    };
    function extractSessionDetails(authority, options) {
      if (typeof authority === "string") {
        authority = new URL2(authority);
      }
      const protocol = authority.protocol || options.protocol || "https:";
      let port = "" + (authority.port !== "" ? authority.port : authority.protocol === "http:" ? 80 : 443);
      let host = authority.hostname || authority.host || "localhost";
      if (protocol === "https:" && options) {
        port = options.port || port;
        host = options.host || host;
      }
      return { protocol, port, host };
    }
    __name(extractSessionDetails, "extractSessionDetails");
    function getFormattedHostString(host, port) {
      return [host, port].filter((val) => val).join(":");
    }
    __name(getFormattedHostString, "getFormattedHostString");
    function getServiceName(tracer2, config, sessionDetails) {
      if (config.splitByDomain) {
        return getFormattedHostString(sessionDetails.host, sessionDetails.port);
      } else if (config.service) {
        return config.service;
      }
      return tracer2._service;
    }
    __name(getServiceName, "getServiceName");
    function hasAmazonSignature(headers, path) {
      if (headers) {
        headers = Object.keys(headers).reduce((prev, next) => Object.assign(prev, {
          [next.toLowerCase()]: headers[next]
        }), {});
        if (headers["x-amz-signature"]) {
          return true;
        }
        if ([].concat(headers["authorization"]).some(startsWith("AWS4-HMAC-SHA256"))) {
          return true;
        }
      }
      return path && path.toLowerCase().indexOf("x-amz-signature=") !== -1;
    }
    __name(hasAmazonSignature, "hasAmazonSignature");
    function startsWith(searchString) {
      return (value) => String(value).startsWith(searchString);
    }
    __name(startsWith, "startsWith");
    function getStatusValidator(config) {
      if (typeof config.validateStatus === "function") {
        return config.validateStatus;
      } else if (config.hasOwnProperty("validateStatus")) {
        log.error("Expected `validateStatus` to be a function.");
      }
      return (code) => code < 400 || code >= 500;
    }
    __name(getStatusValidator, "getStatusValidator");
    function normalizeConfig(config) {
      const validateStatus = getStatusValidator(config);
      const filter = getFilter(config);
      const headers = getHeaders(config);
      return Object.assign({}, config, {
        validateStatus,
        filter,
        headers
      });
    }
    __name(normalizeConfig, "normalizeConfig");
    function getFilter(config) {
      config = Object.assign({}, config, {
        blocklist: config.blocklist || []
      });
      return urlFilter.getFilter(config);
    }
    __name(getFilter, "getFilter");
    function addHeaderTags(span, headers, prefix, config) {
      if (!headers)
        return;
      config.headers.forEach((key) => {
        const value = headers[key];
        if (value) {
          span.setTag(`${prefix}.${key}`, value);
        }
      });
    }
    __name(addHeaderTags, "addHeaderTags");
    function getHeaders(config) {
      if (!Array.isArray(config.headers))
        return [];
      return config.headers.filter((key) => typeof key === "string").map((key) => key.toLowerCase());
    }
    __name(getHeaders, "getHeaders");
    module2.exports = Http2ClientPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-http2/src/index.js
var require_src27 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-http2/src/index.js"(exports2, module2) {
    "use strict";
    var Http2ServerPlugin = require_server4();
    var Http2ClientPlugin = require_client6();
    var CompositePlugin = require_composite();
    var Http2Plugin = class extends CompositePlugin {
      static get name() {
        return "http2";
      }
      static get plugins() {
        return {
          server: Http2ServerPlugin,
          client: Http2ClientPlugin
        };
      }
    };
    module2.exports = Http2Plugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js
var require_src28 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-ioredis/src/index.js"(exports2, module2) {
    "use strict";
    var RedisPlugin = require_src12();
    var IORedisPlugin = class extends RedisPlugin {
      static get name() {
        return "ioredis";
      }
    };
    module2.exports = IORedisPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/producer.js
var require_producer5 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/producer.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer();
    var KafkajsProducerPlugin = class extends ProducerPlugin {
      static get name() {
        return "kafkajs";
      }
      static get operation() {
        return "produce";
      }
      start({ topic, messages }) {
        const span = this.startSpan("kafka.produce", {
          service: this.config.service || `${this.tracer._service}-kafka`,
          resource: topic,
          kind: "producer",
          meta: {
            "component": "kafkajs",
            "kafka.topic": topic
          },
          metrics: {
            "kafka.batch_size": messages.length
          }
        });
        for (const message of messages) {
          if (typeof message === "object") {
            this.tracer.inject(span, "text_map", message.headers);
          }
        }
      }
    };
    module2.exports = KafkajsProducerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/consumer.js
var require_consumer5 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/consumer.js"(exports2, module2) {
    "use strict";
    var ConsumerPlugin = require_consumer();
    var KafkajsConsumerPlugin = class extends ConsumerPlugin {
      static get name() {
        return "kafkajs";
      }
      static get operation() {
        return "consume";
      }
      start({ topic, partition, message }) {
        const childOf = extract(this.tracer, message.headers);
        this.startSpan("kafka.consume", {
          childOf,
          service: this.config.service || `${this.tracer._service}-kafka`,
          resource: topic,
          kind: "consumer",
          type: "worker",
          meta: {
            "component": "kafkajs",
            "kafka.topic": topic,
            "kafka.message.offset": message.offset
          },
          metrics: {
            "kafka.partition": partition
          }
        });
      }
    };
    function extract(tracer2, bufferMap) {
      if (!bufferMap)
        return null;
      const textMap = {};
      for (const key of Object.keys(bufferMap)) {
        textMap[key] = bufferMap[key].toString();
      }
      return tracer2.extract("text_map", textMap);
    }
    __name(extract, "extract");
    module2.exports = KafkajsConsumerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/index.js
var require_src29 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer5();
    var ConsumerPlugin = require_consumer5();
    var CompositePlugin = require_composite();
    var KafkajsPlugin = class extends CompositePlugin {
      static get name() {
        return "kafkajs";
      }
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin
        };
      }
    };
    module2.exports = KafkajsPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js
var require_src30 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-mysql/src/index.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var MySQLPlugin = class extends DatabasePlugin {
      static get name() {
        return "mysql";
      }
      static get system() {
        return "mysql";
      }
      start(payload2) {
        const service = getServiceName(this.config, payload2.conf);
        this.startSpan(`${this.system}.query`, {
          service,
          resource: payload2.sql,
          type: "sql",
          kind: "client",
          meta: {
            "db.type": this.system,
            "db.user": payload2.conf.user,
            "db.name": payload2.conf.database,
            "out.host": payload2.conf.host,
            "out.port": payload2.conf.port
          }
        });
        payload2.sql = this.injectDbmQuery(payload2.sql, service);
      }
    };
    function getServiceName(config, dbConfig) {
      if (typeof config.service === "function") {
        return config.service(dbConfig);
      }
      return config.service;
    }
    __name(getServiceName, "getServiceName");
    module2.exports = MySQLPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-mariadb/src/index.js
var require_src31 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-mariadb/src/index.js"(exports2, module2) {
    "use strict";
    var MySQLPlugin = require_src30();
    var MariadbPlugin = class extends MySQLPlugin {
      static get name() {
        return "mariadb";
      }
      static get system() {
        return "mariadb";
      }
    };
    module2.exports = MariadbPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js
var require_src32 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js"(exports2, module2) {
    "use strict";
    var CachePlugin = require_cache();
    var MemcachedPlugin = class extends CachePlugin {
      static get name() {
        return "memcached";
      }
      start({ client, server, query }) {
        const address = getAddress(client, server, query);
        this.startSpan("memcached.command", {
          service: this.config.service,
          resource: query.type,
          type: "memcached",
          kind: "client",
          meta: {
            "memcached.command": query.command,
            "out.host": address[0],
            "out.port": address[1]
          }
        });
      }
    };
    function getAddress(client, server, query) {
      if (!server) {
        if (client.servers.length === 1) {
          server = client.servers[0];
        } else {
          let redundancy = client.redundancy && client.redundancy < client.servers.length;
          const queryRedundancy = query.redundancyEnabled;
          if (redundancy && queryRedundancy) {
            redundancy = client.HashRing.range(query.key, client.redundancy + 1, true);
            server = redundancy.shift();
          } else {
            server = client.HashRing.get(query.key);
          }
        }
      }
      return server && server.split(":");
    }
    __name(getAddress, "getAddress");
    module2.exports = MemcachedPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js
var require_src33 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-microgateway-core/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src8();
    var web = require_web();
    var MicrogatewayCorePlugin = class extends RouterPlugin {
      static get name() {
        return "microgateway-core";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:microgateway-core:request:handle", ({ req }) => {
          this.setFramework(req, "microgateway", this.config);
        });
        this.addSub("apm:microgateway-core:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
        this.addSub("apm:microgateway-core:request:error", this.addError);
      }
    };
    module2.exports = MicrogatewayCorePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-mocha/src/index.js
var require_src34 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-mocha/src/index.js"(exports2, module2) {
    "use strict";
    var CiPlugin = require_ci_plugin();
    var { storage } = require_datadog_core();
    var {
      TEST_STATUS,
      TEST_PARAMETERS,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestParametersString,
      getTestSuiteCommonTags,
      addIntelligentTestRunnerSpanTags
    } = require_test();
    var { COMPONENT } = require_constants();
    var MochaPlugin = class extends CiPlugin {
      static get name() {
        return "mocha";
      }
      constructor(...args) {
        super(...args);
        this._testSuites = /* @__PURE__ */ new Map();
        this._testNameToParams = {};
        this.sourceRoot = process.cwd();
        this.addSub("ci:mocha:test-suite:code-coverage", ({ coverageFiles, suiteFile }) => {
          if (!this.itrConfig || !this.itrConfig.isCodeCoverageEnabled) {
            return;
          }
          const testSuiteSpan = this._testSuites.get(suiteFile);
          const relativeCoverageFiles = [...coverageFiles, suiteFile].map((filename) => getTestSuitePath(filename, this.sourceRoot));
          this.tracer._exporter.exportCoverage({
            span: testSuiteSpan,
            coverageFiles: relativeCoverageFiles
          });
        });
        this.addSub("ci:mocha:test-suite:start", (suite) => {
          const store = storage.getStore();
          const testSuiteMetadata = getTestSuiteCommonTags(
            this.command,
            this.frameworkVersion,
            getTestSuitePath(suite.file, this.sourceRoot)
          );
          const testSuiteSpan = this.tracer.startSpan("mocha.test_suite", {
            childOf: this.testModuleSpan,
            tags: {
              [COMPONENT]: this.constructor.name,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata
            }
          });
          this.enter(testSuiteSpan, store);
          this._testSuites.set(suite.file, testSuiteSpan);
        });
        this.addSub("ci:mocha:test-suite:finish", (status) => {
          const store = storage.getStore();
          if (store && store.span) {
            const span = storage.getStore().span;
            if (!span.context()._tags[TEST_STATUS]) {
              span.setTag(TEST_STATUS, status);
            }
            span.finish();
          }
        });
        this.addSub("ci:mocha:test-suite:error", (err) => {
          const store = storage.getStore();
          if (store && store.span) {
            const span = storage.getStore().span;
            span.setTag("error", err);
            span.setTag(TEST_STATUS, "fail");
          }
        });
        this.addSub("ci:mocha:test:start", (test) => {
          const store = storage.getStore();
          const span = this.startTestSpan(test);
          this.enter(span, store);
        });
        this.addSub("ci:mocha:test:finish", (status) => {
          const store = storage.getStore();
          if (store && store.span) {
            const span = storage.getStore().span;
            span.setTag(TEST_STATUS, status);
            span.finish();
            finishAllTraceSpans(span);
          }
        });
        this.addSub("ci:mocha:test:skip", (test) => {
          const store = storage.getStore();
          if (!store) {
            const testSpan = this.startTestSpan(test);
            this.enter(testSpan, store);
          }
        });
        this.addSub("ci:mocha:test:error", (err) => {
          const store = storage.getStore();
          if (err && store && store.span) {
            const span = store.span;
            if (err.constructor.name === "Pending" && !this.forbidPending) {
              span.setTag(TEST_STATUS, "skip");
            } else {
              span.setTag(TEST_STATUS, "fail");
              span.setTag("error", err);
            }
          }
        });
        this.addSub("ci:mocha:test:parameterize", ({ name, params }) => {
          this._testNameToParams[name] = params;
        });
        this.addSub("ci:mocha:session:finish", ({ status, isSuitesSkipped }) => {
          if (this.testSessionSpan) {
            const { isSuitesSkippingEnabled, isCodeCoverageEnabled } = this.itrConfig || {};
            this.testSessionSpan.setTag(TEST_STATUS, status);
            this.testModuleSpan.setTag(TEST_STATUS, status);
            addIntelligentTestRunnerSpanTags(
              this.testSessionSpan,
              this.testModuleSpan,
              { isSuitesSkipped, isSuitesSkippingEnabled, isCodeCoverageEnabled }
            );
            this.testModuleSpan.finish();
            this.testSessionSpan.finish();
            finishAllTraceSpans(this.testSessionSpan);
          }
          this.itrConfig = null;
          this.tracer._exporter.flush();
        });
      }
      startTestSpan(test) {
        const testName = test.fullTitle();
        const { file: testSuiteAbsolutePath, title } = test;
        const extraTags = {};
        const testParametersString = getTestParametersString(this._testNameToParams, title);
        if (testParametersString) {
          extraTags[TEST_PARAMETERS] = testParametersString;
        }
        const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.sourceRoot);
        const testSuiteSpan = this._testSuites.get(testSuiteAbsolutePath);
        return super.startTestSpan(testName, testSuite, testSuiteSpan, extraTags);
      }
    };
    module2.exports = MochaPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-moleculer/src/util.js
var require_util6 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-moleculer/src/util.js"(exports2, module2) {
    "use strict";
    function moleculerTags(broker, ctx, config) {
      const service = ctx.service || {};
      const action = ctx.action || {};
      const meta = config.meta && ctx.meta;
      return {
        "moleculer.context.action": action.name,
        "moleculer.context.meta": meta,
        "moleculer.context.node_id": ctx.nodeID,
        "moleculer.context.request_id": ctx.requestID,
        "moleculer.context.service": service.name,
        "moleculer.namespace": broker.namespace,
        "moleculer.node_id": broker.nodeID
      };
    }
    __name(moleculerTags, "moleculerTags");
    module2.exports = { moleculerTags };
  }
});

// node_modules/dd-trace/packages/datadog-plugin-moleculer/src/server.js
var require_server5 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-moleculer/src/server.js"(exports2, module2) {
    "use strict";
    var ServerPlugin = require_server();
    var { moleculerTags } = require_util6();
    var MoleculerServerPlugin = class extends ServerPlugin {
      static get name() {
        return "moleculer";
      }
      static get operation() {
        return "action";
      }
      start({ action, ctx, broker }) {
        const followsFrom = this.tracer.extract("text_map", ctx.meta);
        this.startSpan("moleculer.action", {
          childOf: followsFrom || this.activeSpan,
          service: this.config.service,
          resource: action.name,
          kind: "server",
          type: "web",
          meta: {
            "resource.name": action.name,
            ...moleculerTags(broker, ctx, this.config)
          }
        });
      }
    };
    module2.exports = MoleculerServerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-moleculer/src/client.js
var require_client7 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-moleculer/src/client.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client();
    var { moleculerTags } = require_util6();
    var MoleculerClientPlugin = class extends ClientPlugin {
      static get name() {
        return "moleculer";
      }
      static get operation() {
        return "call";
      }
      start({ actionName, opts }) {
        const span = this.startSpan("moleculer.call", {
          service: this.config.service,
          resource: actionName,
          kind: "client"
        });
        this.tracer.inject(span, "text_map", opts.meta);
      }
      finish({ broker, ctx }) {
        const span = this.activeSpan;
        if (ctx) {
          const endpoint = ctx.endpoint || {};
          const node = endpoint.node || {};
          this.addHost(node.hostname, node.port);
          span.addTags(moleculerTags(broker, ctx, this.config));
        }
        span.finish();
      }
    };
    module2.exports = MoleculerClientPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-moleculer/src/index.js
var require_src35 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-moleculer/src/index.js"(exports2, module2) {
    "use strict";
    var MoleculerServerPlugin = require_server5();
    var MoleculerClientPlugin = require_client7();
    var CompositePlugin = require_composite();
    var MoleculerPlugin = class extends CompositePlugin {
      static get name() {
        return "moleculer";
      }
      static get plugins() {
        return {
          server: MoleculerServerPlugin,
          client: MoleculerClientPlugin
        };
      }
    };
    module2.exports = MoleculerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js
var require_src36 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-mongodb-core/src/index.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var MongodbCorePlugin = class extends DatabasePlugin {
      static get name() {
        return "mongodb-core";
      }
      static get component() {
        return "mongodb";
      }
      start({ ns, ops, options = {}, name }) {
        const query = getQuery(ops);
        const resource = truncate(getResource(this, ns, query, name));
        this.startSpan("mongodb.query", {
          service: this.config.service,
          resource,
          type: "mongodb",
          kind: "client",
          meta: {
            "db.name": ns,
            "mongodb.query": query,
            "out.host": options.host,
            "out.port": options.port
          }
        });
      }
    };
    function getQuery(cmd) {
      if (!cmd || typeof cmd !== "object" || Array.isArray(cmd))
        return;
      if (cmd.query)
        return JSON.stringify(limitDepth(cmd.query));
      if (cmd.filter)
        return JSON.stringify(limitDepth(cmd.filter));
    }
    __name(getQuery, "getQuery");
    function getResource(plugin, ns, query, operationName) {
      const parts = [operationName, ns];
      if (plugin.config.queryInResourceName && query) {
        parts.push(query);
      }
      return parts.join(" ");
    }
    __name(getResource, "getResource");
    function truncate(input) {
      return input.slice(0, Math.min(input.length, 1e4));
    }
    __name(truncate, "truncate");
    function shouldSimplify(input) {
      return !isObject(input);
    }
    __name(shouldSimplify, "shouldSimplify");
    function shouldHide(input) {
      return Buffer.isBuffer(input) || typeof input === "function" || isBinary(input);
    }
    __name(shouldHide, "shouldHide");
    function limitDepth(input) {
      if (isBSON(input)) {
        input = input.toJSON();
      }
      if (shouldHide(input))
        return "?";
      if (shouldSimplify(input))
        return input;
      const output = {};
      const queue = [{
        input,
        output,
        depth: 0
      }];
      while (queue.length) {
        const {
          input: input2,
          output: output2,
          depth
        } = queue.pop();
        const nextDepth = depth + 1;
        for (const key in input2) {
          if (typeof input2[key] === "function")
            continue;
          let child = input2[key];
          if (isBSON(child)) {
            child = typeof child.toJSON === "function" ? child.toJSON() : "?";
          }
          if (depth >= 10 || shouldHide(child)) {
            output2[key] = "?";
          } else if (shouldSimplify(child)) {
            output2[key] = child;
          } else {
            queue.push({
              input: child,
              output: output2[key] = {},
              depth: nextDepth
            });
          }
        }
      }
      return output;
    }
    __name(limitDepth, "limitDepth");
    function isObject(val) {
      return typeof val === "object" && val !== null && !(val instanceof Array);
    }
    __name(isObject, "isObject");
    function isBSON(val) {
      return val && val._bsontype && !isBinary(val);
    }
    __name(isBSON, "isBSON");
    function isBinary(val) {
      return val && val._bsontype === "Binary";
    }
    __name(isBinary, "isBinary");
    module2.exports = MongodbCorePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js
var require_src37 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-mysql2/src/index.js"(exports2, module2) {
    "use strict";
    var MySQLPlugin = require_src30();
    var MySQL2Plugin = class extends MySQLPlugin {
      static get name() {
        return "mysql2";
      }
    };
    module2.exports = MySQL2Plugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-net/src/index.js
var require_src38 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-net/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var analyticsSampler = require_analytics_sampler();
    var { COMPONENT } = require_constants();
    var NetPlugin = class extends Plugin {
      static get name() {
        return "net";
      }
      constructor(...args) {
        super(...args);
        this.addSub(`apm:net:ipc:start`, ({ options }) => {
          const store = storage.getStore();
          const childOf = store ? store.span : store;
          const span = this.tracer.startSpan("ipc.connect", {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.name,
              "resource.name": options.path,
              "ipc.path": options.path,
              "span.kind": "client",
              "service.name": this.config.service || this.tracer._service
            }
          });
          analyticsSampler.sample(span, this.config.measured);
          this.enter(span, store);
        });
        this.addSub(`apm:net:ipc:error`, errorHandler);
        this.addSub(`apm:net:ipc:finish`, defaultFinish);
        this.addSub(`apm:net:tcp:start`, ({ options }) => {
          const store = storage.getStore();
          const childOf = store ? store.span : store;
          const host = options.host || "localhost";
          const port = options.port || 0;
          const family = options.family || 4;
          const span = this.tracer.startSpan("tcp.connect", {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.name,
              "resource.name": [host, port].filter((val) => val).join(":"),
              "tcp.remote.host": host,
              "tcp.remote.port": port,
              "tcp.family": `IPv${family}`,
              "out.host": host,
              "out.port": port,
              "span.kind": "client",
              "service.name": this.config.service || this.tracer._service
            }
          });
          analyticsSampler.sample(span, this.config.measured);
          this.enter(span, store);
        });
        this.addSub(`apm:net:tcp:error`, errorHandler);
        this.addSub(`apm:net:tcp:finish`, defaultFinish);
        this.addSub(`apm:net:tcp:connection`, ({ socket }) => {
          const span = storage.getStore().span;
          span.addTags({
            [COMPONENT]: this.constructor.name,
            "tcp.local.address": socket.localAddress,
            "tcp.local.port": socket.localPort
          });
        });
      }
    };
    function defaultFinish() {
      storage.getStore().span.finish();
    }
    __name(defaultFinish, "defaultFinish");
    function errorHandler(error) {
      storage.getStore().span.setTag("error", error);
    }
    __name(errorHandler, "errorHandler");
    module2.exports = NetPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-next/src/index.js
var require_src39 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-next/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var analyticsSampler = require_analytics_sampler();
    var { COMPONENT } = require_constants();
    var NextPlugin = class extends Plugin {
      static get name() {
        return "next";
      }
      constructor(...args) {
        super(...args);
        this._requests = /* @__PURE__ */ new WeakMap();
        this.addSub("apm:next:request:start", ({ req, res }) => {
          const store = storage.getStore();
          const childOf = store ? store.span : store;
          const span = this.tracer.startSpan("next.request", {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.name,
              "service.name": this.config.service || this.tracer._service,
              "resource.name": req.method,
              "span.type": "web",
              "span.kind": "server",
              "http.method": req.method
            }
          });
          analyticsSampler.sample(span, this.config.measured, true);
          this.enter(span, store);
          this._requests.set(span, req);
        });
        this.addSub("apm:next:request:error", this.addError);
        this.addSub("apm:next:request:finish", ({ req, res }) => {
          const store = storage.getStore();
          if (!store)
            return;
          const span = store.span;
          const error = span.context()._tags["error"];
          if (!this.config.validateStatus(res.statusCode) && !error) {
            span.setTag("error", true);
          }
          span.addTags({
            "http.status_code": res.statusCode
          });
          this.config.hooks.request(span, req, res);
          span.finish();
        });
        this.addSub("apm:next:page:load", ({ page }) => {
          const store = storage.getStore();
          if (!store)
            return;
          const span = store.span;
          const req = this._requests.get(span);
          span.addTags({
            [COMPONENT]: this.constructor.name,
            "resource.name": `${req.method} ${page}`.trim(),
            "next.page": page
          });
        });
      }
      configure(config) {
        return super.configure(normalizeConfig(config));
      }
    };
    function normalizeConfig(config) {
      const hooks = getHooks(config);
      const validateStatus = typeof config.validateStatus === "function" ? config.validateStatus : (code) => code < 500;
      return Object.assign({}, config, { hooks, validateStatus });
    }
    __name(normalizeConfig, "normalizeConfig");
    function getHooks(config) {
      const noop = /* @__PURE__ */ __name(() => {
      }, "noop");
      const request = config.hooks && config.hooks.request || noop;
      return { request };
    }
    __name(getHooks, "getHooks");
    module2.exports = NextPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-oracledb/src/index.js
var require_src40 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-oracledb/src/index.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var log = require_log();
    var OracledbPlugin = class extends DatabasePlugin {
      static get name() {
        return "oracledb";
      }
      static get system() {
        return "oracle";
      }
      start({ query, connAttrs }) {
        const service = getServiceName(this.config, connAttrs);
        const url = getUrl(connAttrs.connectString);
        this.startSpan("oracle.query", {
          service,
          resource: query,
          type: "sql",
          kind: "client",
          meta: {
            "db.user": this.config.user,
            "db.instance": url.pathname && url.pathname.substring(1),
            "db.hostname": url.hostname,
            "db.port": url.port
          }
        });
      }
    };
    function getServiceName(config, connAttrs) {
      if (typeof config.service === "function") {
        return config.service(connAttrs);
      }
      return config.service;
    }
    __name(getServiceName, "getServiceName");
    function getUrl(connectString) {
      try {
        return new URL(`http://${connectString}`);
      } catch (e) {
        log.error(e);
        return {};
      }
    }
    __name(getUrl, "getUrl");
    module2.exports = OracledbPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-paperplane/src/logger.js
var require_logger = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-paperplane/src/logger.js"(exports2, module2) {
    "use strict";
    var LogPlugin = require_log_plugin();
    var PaperplaneLoggerPlugin = class extends LogPlugin {
      static get name() {
        return "paperplane";
      }
    };
    module2.exports = PaperplaneLoggerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-paperplane/src/server.js
var require_server6 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-paperplane/src/server.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src8();
    var web = require_web();
    var PaperplaneServerPlugin = class extends RouterPlugin {
      static get name() {
        return "paperplane";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:paperplane:request:handle", (req) => {
          this.setFramework(req, "paperplane", this.config);
        });
        this.addSub("apm:paperplane:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
      }
    };
    module2.exports = PaperplaneServerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-paperplane/src/index.js
var require_src41 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-paperplane/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var PaperplaneLoggerPlugin = require_logger();
    var PaperplaneServerPlugin = require_server6();
    var PaperplanePlugin = class extends Plugin {
      static get name() {
        return "paperplane";
      }
      constructor(...args) {
        super(...args);
        this.server = new PaperplaneServerPlugin(...args);
        this.logger = new PaperplaneLoggerPlugin(...args);
      }
      configure(config) {
        this.server.configure(config);
        this.logger.configure(config);
      }
    };
    module2.exports = PaperplanePlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js
var require_src42 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-pg/src/index.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var PGPlugin = class extends DatabasePlugin {
      static get name() {
        return "pg";
      }
      static get operation() {
        return "query";
      }
      static get system() {
        return "postgres";
      }
      start({ params = {}, query, processId }) {
        const service = getServiceName(this.config, params);
        const originalStatement = query.text;
        this.startSpan("pg.query", {
          service,
          resource: originalStatement,
          type: "sql",
          kind: "client",
          meta: {
            "db.type": "postgres",
            "db.pid": processId,
            "db.name": params.database,
            "db.user": params.user,
            "out.host": params.host,
            "out.port": params.port
          }
        });
        query.text = this.injectDbmQuery(query.text, service);
      }
    };
    function getServiceName(config, params) {
      if (typeof config.service === "function") {
        return config.service(params);
      }
      return config.service;
    }
    __name(getServiceName, "getServiceName");
    module2.exports = PGPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js
var require_src43 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-pino/src/index.js"(exports2, module2) {
    "use strict";
    var LogPlugin = require_log_plugin();
    var PinoPlugin = class extends LogPlugin {
      static get name() {
        return "pino";
      }
    };
    module2.exports = PinoPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js
var require_src44 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-restify/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src8();
    var web = require_web();
    var RestifyPlugin = class extends RouterPlugin {
      static get name() {
        return "restify";
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:restify:request:handle", ({ req }) => {
          this.setFramework(req, "restify", this.config);
        });
        this.addSub("apm:restify:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
      }
      configure(config) {
        return super.configure({
          ...config,
          middleware: false
        });
      }
    };
    module2.exports = RestifyPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-rhea/src/producer.js
var require_producer6 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-rhea/src/producer.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer();
    var RheaProducerPlugin = class extends ProducerPlugin {
      static get name() {
        return "rhea";
      }
      static get operation() {
        return "send";
      }
      constructor(...args) {
        super(...args);
        this.addTraceSub("encode", this.encode.bind(this));
      }
      start({ targetAddress, host, port }) {
        const name = targetAddress || "amq.topic";
        this.startSpan("amqp.send", {
          service: this.config.service || `${this.tracer._service}-amqp-producer`,
          resource: name,
          kind: "producer",
          meta: {
            "component": "rhea",
            "amqp.link.target.address": name,
            "amqp.link.role": "sender",
            "out.host": host,
            "out.port": port
          }
        });
      }
      encode(msg) {
        addDeliveryAnnotations(msg, this.tracer, this.activeSpan);
      }
    };
    function addDeliveryAnnotations(msg, tracer2, span) {
      if (msg) {
        msg.delivery_annotations = msg.delivery_annotations || {};
        tracer2.inject(span, "text_map", msg.delivery_annotations);
      }
    }
    __name(addDeliveryAnnotations, "addDeliveryAnnotations");
    module2.exports = RheaProducerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-rhea/src/consumer.js
var require_consumer6 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-rhea/src/consumer.js"(exports2, module2) {
    "use strict";
    var ConsumerPlugin = require_consumer();
    var { storage } = require_datadog_core();
    var RheaConsumerPlugin = class extends ConsumerPlugin {
      static get name() {
        return "rhea";
      }
      constructor(...args) {
        super(...args);
        this.addTraceSub("dispatch", ({ state }) => {
          const span = storage.getStore().span;
          span.setTag("amqp.delivery.state", state);
        });
      }
      start({ msgObj }) {
        const name = getResourceNameFromMessage(msgObj);
        const childOf = extractTextMap(msgObj, this.tracer);
        this.startSpan("amqp.receive", {
          childOf,
          service: this.config.service,
          resource: name,
          type: "worker",
          kind: "consumer",
          meta: {
            "component": "rhea",
            "amqp.link.source.address": name,
            "amqp.link.role": "receiver"
          }
        });
      }
    };
    function getResourceNameFromMessage(msgObj) {
      let resourceName = "amq.topic";
      let options = {};
      if (msgObj.receiver && msgObj.receiver.options) {
        options = msgObj.receiver.options;
      }
      if (options.source && options.source.address) {
        resourceName = options.source.address;
      }
      return resourceName;
    }
    __name(getResourceNameFromMessage, "getResourceNameFromMessage");
    function extractTextMap(msgObj, tracer2) {
      if (msgObj.message) {
        return tracer2.extract("text_map", msgObj.message.delivery_annotations);
      }
    }
    __name(extractTextMap, "extractTextMap");
    module2.exports = RheaConsumerPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js
var require_src45 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer6();
    var ConsumerPlugin = require_consumer6();
    var CompositePlugin = require_composite();
    var RheaPlugin = class extends CompositePlugin {
      static get name() {
        return "rhea";
      }
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin
        };
      }
    };
    module2.exports = RheaPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-sharedb/src/index.js
var require_src46 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-sharedb/src/index.js"(exports2, module2) {
    "use strict";
    var ServerPlugin = require_server();
    var SharedbPlugin = class extends ServerPlugin {
      static get name() {
        return "sharedb";
      }
      start({ actionName, request }) {
        const span = this.startSpan("sharedb.request", {
          service: this.config.service,
          resource: getReadableResourceName(actionName, request.c, request.q),
          kind: "server",
          meta: {
            "sharedb.action": actionName
          }
        });
        if (this.config.hooks && this.config.hooks.receive) {
          this.config.hooks.receive(span, request);
        }
      }
      finish({ request, res }) {
        const span = this.activeSpan;
        if (this.config.hooks && this.config.hooks.reply) {
          this.config.hooks.reply(span, request, res);
        }
        span.finish();
      }
    };
    function getReadableResourceName(readableActionName, collection, query) {
      if (collection) {
        readableActionName += " " + collection;
      }
      if (query) {
        readableActionName += " " + JSON.stringify(sanitize(query));
      }
      return readableActionName;
    }
    __name(getReadableResourceName, "getReadableResourceName");
    function sanitize(input) {
      const output = {};
      if (!isObject(input) || Buffer.isBuffer(input))
        return "?";
      for (const key in input) {
        if (typeof input[key] === "function")
          continue;
        output[key] = sanitize(input[key]);
      }
      return output;
    }
    __name(sanitize, "sanitize");
    function isObject(val) {
      return typeof val === "object" && val !== null && !(val instanceof Array);
    }
    __name(isObject, "isObject");
    module2.exports = SharedbPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js
var require_src47 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-tedious/src/index.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var TediousPlugin = class extends DatabasePlugin {
      static get name() {
        return "tedious";
      }
      static get operation() {
        return "request";
      }
      static get system() {
        return "mssql";
      }
      start({ queryOrProcedure, connectionConfig }) {
        this.startSpan("tedious.request", {
          service: this.config.service,
          resource: queryOrProcedure,
          type: "sql",
          kind: "client",
          meta: {
            "db.type": "mssql",
            "component": "tedious",
            "out.host": connectionConfig.server,
            "out.port": connectionConfig.options.port,
            "db.user": connectionConfig.userName || connectionConfig.authentication.options.userName,
            "db.name": connectionConfig.options.database,
            "db.instance": connectionConfig.options.instanceName
          }
        });
      }
    };
    module2.exports = TediousPlugin;
  }
});

// node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js
var require_src48 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js"(exports2, module2) {
    "use strict";
    var LogPlugin = require_log_plugin();
    var WinstonPlugin = class extends LogPlugin {
      static get name() {
        return "winston";
      }
    };
    module2.exports = WinstonPlugin;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugins/index.js
var require_plugins = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugins/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      get "@aws-sdk/smithy-client"() {
        return require_src();
      },
      get "@cucumber/cucumber"() {
        return require_src2();
      },
      get "@playwright/test"() {
        return require_src3();
      },
      get "@elastic/elasticsearch"() {
        return require_src4();
      },
      get "@elastic/transport"() {
        return require_src4();
      },
      get "@google-cloud/pubsub"() {
        return require_src5();
      },
      get "@grpc/grpc-js"() {
        return require_src6();
      },
      get "@hapi/hapi"() {
        return require_src9();
      },
      get "@jest/core"() {
        return require_src10();
      },
      get "@koa/router"() {
        return require_src11();
      },
      get "@node-redis/client"() {
        return require_src12();
      },
      get "@opensearch-project/opensearch"() {
        return require_src13();
      },
      get "@redis/client"() {
        return require_src12();
      },
      get "amqp10"() {
        return require_src14();
      },
      get "amqplib"() {
        return require_src15();
      },
      get "aws-sdk"() {
        return require_src();
      },
      get "bunyan"() {
        return require_src16();
      },
      get "cassandra-driver"() {
        return require_src17();
      },
      get "connect"() {
        return require_src18();
      },
      get "couchbase"() {
        return require_src19();
      },
      get "cypress"() {
        return require_src20();
      },
      get "dns"() {
        return require_src21();
      },
      get "elasticsearch"() {
        return require_src4();
      },
      get "express"() {
        return require_src22();
      },
      get "fastify"() {
        return require_src23();
      },
      get "find-my-way"() {
        return require_src24();
      },
      get "graphql"() {
        return require_src25();
      },
      get "grpc"() {
        return require_src6();
      },
      get "hapi"() {
        return require_src9();
      },
      get "http"() {
        return require_src26();
      },
      get "http2"() {
        return require_src27();
      },
      get "https"() {
        return require_src26();
      },
      get "ioredis"() {
        return require_src28();
      },
      get "jest-circus"() {
        return require_src10();
      },
      get "jest-config"() {
        return require_src10();
      },
      get "jest-environment-node"() {
        return require_src10();
      },
      get "jest-environment-jsdom"() {
        return require_src10();
      },
      get "jest-jasmine2"() {
        return require_src10();
      },
      get "koa"() {
        return require_src11();
      },
      get "koa-router"() {
        return require_src11();
      },
      get "kafkajs"() {
        return require_src29();
      },
      get "mariadb"() {
        return require_src31();
      },
      get "memcached"() {
        return require_src32();
      },
      get "microgateway-core"() {
        return require_src33();
      },
      get "mocha"() {
        return require_src34();
      },
      get "mocha-each"() {
        return require_src34();
      },
      get "moleculer"() {
        return require_src35();
      },
      get "mongodb"() {
        return require_src36();
      },
      get "mongodb-core"() {
        return require_src36();
      },
      get "mysql"() {
        return require_src30();
      },
      get "mysql2"() {
        return require_src37();
      },
      get "net"() {
        return require_src38();
      },
      get "next"() {
        return require_src39();
      },
      get "oracledb"() {
        return require_src40();
      },
      get "paperplane"() {
        return require_src41();
      },
      get "pg"() {
        return require_src42();
      },
      get "pino"() {
        return require_src43();
      },
      get "pino-pretty"() {
        return require_src43();
      },
      get "redis"() {
        return require_src12();
      },
      get "restify"() {
        return require_src44();
      },
      get "rhea"() {
        return require_src45();
      },
      get "router"() {
        return require_src8();
      },
      get "sharedb"() {
        return require_src46();
      },
      get "tedious"() {
        return require_src47();
      },
      get "winston"() {
        return require_src48();
      }
    };
  }
});

// node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS({
  "node_modules/import-in-the-middle/lib/register.js"(exports2) {
    var importHooks = [];
    var setters = /* @__PURE__ */ new WeakMap();
    var specifiers = /* @__PURE__ */ new Map();
    var toHook = [];
    var proxyHandler = {
      set(target, name, value) {
        return setters.get(target)[name](value);
      },
      defineProperty(target, property, descriptor) {
        if (!("value" in descriptor)) {
          throw new Error("Getters/setters are not supported for exports property descriptors.");
        }
        return setters.get(target)[property](descriptor.value);
      }
    };
    function register(name, namespace, set, specifier) {
      specifiers.set(name, specifier);
      setters.set(namespace, set);
      const proxy = new Proxy(namespace, proxyHandler);
      importHooks.forEach((hook) => hook(name, proxy));
      toHook.push([name, proxy]);
    }
    __name(register, "register");
    exports2.register = register;
    exports2.importHooks = importHooks;
    exports2.specifiers = specifiers;
    exports2.toHook = toHook;
  }
});

// node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS({
  "node_modules/import-in-the-middle/index.js"(exports2, module2) {
    var path = __require("path");
    var parse = require_module_details_from_path();
    var { fileURLToPath } = __require("url");
    var {
      importHooks,
      specifiers,
      toHook
    } = require_register();
    function addHook(hook) {
      importHooks.push(hook);
      toHook.forEach(([name, namespace]) => hook(name, namespace));
    }
    __name(addHook, "addHook");
    function removeHook(hook) {
      const index = importHooks.indexOf(hook);
      if (index > -1) {
        importHooks.splice(index, 1);
      }
    }
    __name(removeHook, "removeHook");
    function callHookFn(hookFn, namespace, name, baseDir) {
      const newDefault = hookFn(namespace, name, baseDir);
      if (newDefault && newDefault !== namespace) {
        namespace.default = newDefault;
      }
    }
    __name(callHookFn, "callHookFn");
    function Hook(modules, options, hookFn) {
      if (this instanceof Hook === false)
        return new Hook(modules, options, hookFn);
      if (typeof modules === "function") {
        hookFn = modules;
        modules = null;
        options = null;
      } else if (typeof options === "function") {
        hookFn = options;
        options = null;
      }
      const internals = options ? options.internals === true : false;
      this._iitmHook = (name, namespace) => {
        const filename = name;
        const isBuiltin = name.startsWith("node:");
        let baseDir;
        if (isBuiltin) {
          name = name.replace(/^node:/, "");
        } else {
          if (name.startsWith("file://")) {
            try {
              name = fileURLToPath(name);
            } catch (e) {
            }
          }
          const details = parse(name);
          if (details) {
            name = details.name;
            baseDir = details.basedir;
          }
        }
        if (modules) {
          for (const moduleName2 of modules) {
            if (moduleName2 === name) {
              if (baseDir) {
                if (internals) {
                  name = name + path.sep + path.relative(baseDir, fileURLToPath(filename));
                } else {
                  if (!baseDir.endsWith(specifiers.get(filename)))
                    continue;
                }
              }
              callHookFn(hookFn, namespace, name, baseDir);
            }
          }
        } else {
          callHookFn(hookFn, namespace, name, baseDir);
        }
      };
      addHook(this._iitmHook);
    }
    __name(Hook, "Hook");
    Hook.prototype.unhook = function() {
      removeHook(this._iitmHook);
    };
    module2.exports = Hook;
    module2.exports.addHook = addHook;
    module2.exports.removeHook = removeHook;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/iitm.js
var require_iitm = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/iitm.js"(exports2, module2) {
    "use strict";
    var semver = require_semver();
    var logger = require_log();
    var { addHook } = require_import_in_the_middle();
    var dc = __require("diagnostics_channel");
    if (semver.satisfies(process.versions.node, ">=14.13.1")) {
      const moduleLoadStartChannel = dc.channel("dd-trace:moduleLoadStart");
      addHook((name, namespace) => {
        if (moduleLoadStartChannel.hasSubscribers) {
          moduleLoadStartChannel.publish({
            filename: name,
            module: namespace
          });
        }
      });
      module2.exports = require_import_in_the_middle();
    } else {
      logger.warn("ESM is not fully supported by this version of Node.js, so dd-trace will not intercept ESM loading.");
      module2.exports = () => ({
        unhook: () => {
        }
      });
      module2.exports.addHook = () => {
      };
      module2.exports.removeHook = () => {
      };
    }
  }
});

// node_modules/dd-trace/packages/dd-trace/src/ritm.js
var require_ritm = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/ritm.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var Module = __require("module");
    var parse = require_module_details_from_path();
    var dc = __require("diagnostics_channel");
    var origRequire = Module.prototype.require;
    module2.exports = Hook;
    var moduleHooks = /* @__PURE__ */ Object.create(null);
    var cache = /* @__PURE__ */ Object.create(null);
    var patching = /* @__PURE__ */ Object.create(null);
    var patchedRequire = null;
    var moduleLoadStartChannel = dc.channel("dd-trace:moduleLoadStart");
    var moduleLoadEndChannel = dc.channel("dd-trace:moduleLoadEnd");
    function Hook(modules, options, onrequire) {
      if (!(this instanceof Hook))
        return new Hook(modules, options, onrequire);
      if (typeof modules === "function") {
        onrequire = modules;
        modules = null;
        options = {};
      } else if (typeof options === "function") {
        onrequire = options;
        options = {};
      }
      modules = modules || [];
      options = options || {};
      this.modules = modules;
      this.options = options;
      this.onrequire = onrequire;
      if (Array.isArray(modules)) {
        for (const mod2 of modules) {
          const hooks = moduleHooks[mod2];
          if (hooks) {
            hooks.push(onrequire);
          } else {
            moduleHooks[mod2] = [onrequire];
          }
        }
      }
      if (patchedRequire)
        return;
      patchedRequire = Module.prototype.require = function(request) {
        const filename = Module._resolveFilename(request, this);
        const core = filename.indexOf(path.sep) === -1;
        let name, basedir, hooks;
        if (cache[filename]) {
          if (__require.cache[filename] && __require.cache[filename].exports !== cache[filename].original) {
            return __require.cache[filename].exports;
          }
          return cache[filename].exports;
        }
        const patched = patching[filename];
        if (patched) {
          return origRequire.apply(this, arguments);
        } else {
          patching[filename] = true;
        }
        const payload2 = {
          filename,
          request
        };
        if (moduleLoadStartChannel.hasSubscribers) {
          moduleLoadStartChannel.publish(payload2);
        }
        const exports3 = origRequire.apply(this, arguments);
        payload2.module = exports3;
        if (moduleLoadEndChannel.hasSubscribers) {
          moduleLoadEndChannel.publish(payload2);
        }
        delete patching[filename];
        if (core) {
          hooks = moduleHooks[filename];
          if (!hooks)
            return exports3;
          name = filename;
        } else {
          const inAWSLambda = process.env.AWS_LAMBDA_FUNCTION_NAME !== void 0;
          const hasLambdaHandler = process.env.DD_LAMBDA_HANDLER !== void 0;
          const segments = filename.split(path.sep);
          const filenameFromNodeModule = segments.lastIndexOf("node_modules") !== -1;
          const stat = inAWSLambda && hasLambdaHandler && !filenameFromNodeModule ? { name: filename } : parse(filename);
          if (!stat)
            return exports3;
          name = stat.name;
          basedir = stat.basedir;
          hooks = moduleHooks[name];
          if (!hooks)
            return exports3;
          const paths = Module._resolveLookupPaths(name, this, true);
          if (!paths) {
            return exports3;
          }
          const res = Module._findPath(name, [basedir, ...paths]);
          if (res !== filename) {
            name = name + path.sep + path.relative(basedir, filename);
          }
        }
        cache[filename] = { exports: exports3 };
        cache[filename].original = exports3;
        for (const hook of hooks) {
          cache[filename].exports = hook(cache[filename].exports, name, basedir);
        }
        return cache[filename].exports;
      };
    }
    __name(Hook, "Hook");
    Hook.reset = function() {
      Module.prototype.require = origRequire;
      patchedRequire = null;
      patching = /* @__PURE__ */ Object.create(null);
      cache = /* @__PURE__ */ Object.create(null);
      moduleHooks = /* @__PURE__ */ Object.create(null);
    };
    Hook.prototype.unhook = function() {
      for (const mod2 of this.modules) {
        const hooks = (moduleHooks[mod2] || []).filter((hook) => hook !== this.onrequire);
        if (hooks.length > 0) {
          moduleHooks[mod2] = hooks;
        } else {
          delete moduleHooks[mod2];
        }
      }
      if (Object.keys(moduleHooks).length === 0) {
        Hook.reset();
      }
    };
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hook.js
var require_hook = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hook.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var iitm = require_iitm();
    var ritm = require_ritm();
    function Hook(modules, onrequire) {
      if (!(this instanceof Hook))
        return new Hook(modules, onrequire);
      this._patched = /* @__PURE__ */ Object.create(null);
      const safeHook = /* @__PURE__ */ __name((moduleExports, moduleName2, moduleBaseDir) => {
        const parts = [moduleBaseDir, moduleName2].filter((v) => v);
        const filename = path.join(...parts);
        if (this._patched[filename])
          return moduleExports;
        this._patched[filename] = true;
        return onrequire(moduleExports, moduleName2, moduleBaseDir);
      }, "safeHook");
      this._ritmHook = ritm(modules, {}, safeHook);
      this._iitmHook = iitm(modules, {}, (moduleExports, moduleName2, moduleBaseDir) => {
        if (moduleExports && moduleExports.default) {
          moduleExports.default = safeHook(moduleExports.default, moduleName2, moduleBaseDir);
          return moduleExports;
        } else {
          return safeHook(moduleExports, moduleName2, moduleBaseDir);
        }
      });
    }
    __name(Hook, "Hook");
    Hook.prototype.unhook = function() {
      this._ritmHook.unhook();
      this._iitmHook.unhook();
      this._patched = /* @__PURE__ */ Object.create(null);
    };
    module2.exports = Hook;
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrumentations.js
var require_instrumentations = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrumentations.js"(exports2, module2) {
    "use strict";
    var sym = Symbol.for("_ddtrace_instrumentations");
    global[sym] = global[sym] || {};
    module2.exports = global[sym];
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js
var require_instrument = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/instrument.js"(exports2) {
    "use strict";
    var dc = __require("diagnostics_channel");
    var semver = require_semver();
    var instrumentations = require_instrumentations();
    var { AsyncResource } = __require("async_hooks");
    var channelMap = {};
    exports2.channel = function(name) {
      const maybe = channelMap[name];
      if (maybe)
        return maybe;
      const ch = dc.channel(name);
      channelMap[name] = ch;
      return ch;
    };
    exports2.addHook = /* @__PURE__ */ __name(function addHook({ name, versions, file }, hook) {
      if (!instrumentations[name]) {
        instrumentations[name] = [];
      }
      instrumentations[name].push({ name, versions, file, hook });
    }, "addHook");
    if (semver.satisfies(process.versions.node, ">=17.8.0")) {
      exports2.AsyncResource = AsyncResource;
    } else {
      exports2.AsyncResource = class extends AsyncResource {
        static bind(fn, type, thisArg) {
          type = type || fn.name;
          return new exports2.AsyncResource(type || "bound-anonymous-fn").bind(fn, thisArg);
        }
        bind(fn, thisArg) {
          let bound;
          if (thisArg === void 0) {
            const resource = this;
            bound = /* @__PURE__ */ __name(function(...args) {
              args.unshift(fn, this);
              return Reflect.apply(resource.runInAsyncScope, resource, args);
            }, "bound");
          } else {
            bound = this.runInAsyncScope.bind(this, fn, thisArg);
          }
          Object.defineProperties(bound, {
            "length": {
              configurable: true,
              enumerable: false,
              value: fn.length,
              writable: false
            },
            "asyncResource": {
              configurable: true,
              enumerable: true,
              value: this,
              writable: true
            }
          });
          return bound;
        }
      };
    }
  }
});

// node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js
var require_shimmer = __commonJS({
  "node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js"(exports2, module2) {
    "use strict";
    var unwrappers = /* @__PURE__ */ new WeakMap();
    function copyProperties(original, wrapped) {
      Object.setPrototypeOf(wrapped, original);
      const props = Object.getOwnPropertyDescriptors(original);
      const keys = Reflect.ownKeys(props);
      for (const key of keys) {
        try {
          Object.defineProperty(wrapped, key, props[key]);
        } catch (e) {
        }
      }
    }
    __name(copyProperties, "copyProperties");
    function wrapFn(original, delegate) {
      assertFunction(delegate);
      assertNotClass(original);
      const shim = /* @__PURE__ */ __name(function shim2() {
        return delegate.apply(this, arguments);
      }, "shim");
      unwrappers.set(shim, () => {
        delegate = original;
      });
      copyProperties(original, shim);
      return shim;
    }
    __name(wrapFn, "wrapFn");
    function wrapMethod(target, name, wrapper) {
      assertMethod(target, name);
      assertFunction(wrapper);
      const original = target[name];
      const wrapped = wrapper(original);
      const descriptor = Object.getOwnPropertyDescriptor(target, name);
      const attributes = {
        configurable: true,
        ...descriptor
      };
      copyProperties(original, wrapped);
      if (descriptor) {
        unwrappers.set(wrapped, () => Object.defineProperty(target, name, descriptor));
        if (descriptor.get || descriptor.set) {
          attributes.get = () => wrapped;
        } else {
          attributes.value = wrapped;
        }
        if (descriptor.configurable === false) {
          return Object.create(target, {
            [name]: attributes
          });
        }
      } else {
        unwrappers.set(wrapped, () => delete target[name]);
        attributes.value = wrapped;
        attributes.writable = true;
      }
      Object.defineProperty(target, name, attributes);
      return target;
    }
    __name(wrapMethod, "wrapMethod");
    function wrap(target, name, wrapper) {
      return typeof name === "function" ? wrapFn(target, name) : wrapMethod(target, name, wrapper);
    }
    __name(wrap, "wrap");
    function unwrap(target, name) {
      if (!target)
        return target;
      const unwrapper = unwrappers.get(name ? target[name] : target);
      if (!unwrapper)
        return target;
      unwrapper();
      return target;
    }
    __name(unwrap, "unwrap");
    function massWrap(targets, names, wrapper) {
      targets = toArray(targets);
      names = toArray(names);
      for (const target of targets) {
        for (const name of names) {
          wrap(target, name, wrapper);
        }
      }
    }
    __name(massWrap, "massWrap");
    function massUnwrap(targets, names) {
      targets = toArray(targets);
      names = toArray(names);
      for (const target of targets) {
        for (const name of names) {
          unwrap(target, name);
        }
      }
    }
    __name(massUnwrap, "massUnwrap");
    function toArray(maybeArray) {
      return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
    }
    __name(toArray, "toArray");
    function assertMethod(target, name) {
      if (!target) {
        throw new Error("No target object provided.");
      }
      if (typeof target !== "object" && typeof target !== "function") {
        throw new Error("Invalid target.");
      }
      if (!target[name]) {
        throw new Error(`No original method ${name}.`);
      }
      if (typeof target[name] !== "function") {
        throw new Error(`Original method ${name} is not a function.`);
      }
    }
    __name(assertMethod, "assertMethod");
    function assertFunction(target) {
      if (!target) {
        throw new Error("No function provided.");
      }
      if (typeof target !== "function") {
        throw new Error("Target is not a function.");
      }
    }
    __name(assertFunction, "assertFunction");
    function assertNotClass(target) {
      if (Function.prototype.toString.call(target).startsWith("class")) {
        throw new Error("Target is a native class constructor and cannot be wrapped.");
      }
    }
    __name(assertNotClass, "assertNotClass");
    module2.exports = {
      wrap,
      massWrap,
      unwrap,
      massUnwrap
    };
  }
});

// node_modules/dd-trace/packages/datadog-shimmer/index.js
var require_datadog_shimmer = __commonJS({
  "node_modules/dd-trace/packages/datadog-shimmer/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_shimmer();
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/aws-sdk.js
var require_aws_sdk = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/aws-sdk.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function wrapRequest(send) {
      return /* @__PURE__ */ __name(function wrappedRequest(cb) {
        if (!this.service)
          return send.apply(this, arguments);
        const serviceIdentifier = this.service.serviceIdentifier;
        const channelSuffix = getChannelSuffix(serviceIdentifier);
        const startCh = channel(`apm:aws:request:start:${channelSuffix}`);
        if (!startCh.hasSubscribers)
          return send.apply(this, arguments);
        const innerAr = new AsyncResource("apm:aws:request:inner");
        const outerAr = new AsyncResource("apm:aws:request:outer");
        return innerAr.runInAsyncScope(() => {
          this.on("complete", innerAr.bind((response) => {
            channel(`apm:aws:request:complete:${channelSuffix}`).publish({ response });
          }));
          startCh.publish({
            serviceIdentifier,
            operation: this.operation,
            awsRegion: this.service.config && this.service.config.region,
            awsService: this.service.api && this.service.api.className,
            request: this
          });
          if (typeof cb === "function") {
            arguments[0] = wrapCb(cb, channelSuffix, this, outerAr);
          }
          return send.apply(this, arguments);
        });
      }, "wrappedRequest");
    }
    __name(wrapRequest, "wrapRequest");
    function wrapSmithySend(send) {
      return function(command, ...args) {
        const cb = args[args.length - 1];
        const innerAr = new AsyncResource("apm:aws:request:inner");
        const outerAr = new AsyncResource("apm:aws:request:outer");
        const serviceIdentifier = this.config.serviceId.toLowerCase();
        const channelSuffix = getChannelSuffix(serviceIdentifier);
        const commandName = command.constructor.name;
        const clientName = this.constructor.name.replace(/Client$/, "");
        const operation = `${commandName[0].toLowerCase()}${commandName.slice(1).replace(/Command$/, "")}`;
        const request = {
          operation,
          params: command.input
        };
        const startCh = channel(`apm:aws:request:start:${channelSuffix}`);
        const regionCh = channel(`apm:aws:request:region:${channelSuffix}`);
        const completeChannel = channel(`apm:aws:request:complete:${channelSuffix}`);
        const responseStartChannel = channel(`apm:aws:response:start:${channelSuffix}`);
        const responseFinishChannel = channel(`apm:aws:response:finish:${channelSuffix}`);
        return innerAr.runInAsyncScope(() => {
          startCh.publish({
            serviceIdentifier,
            operation,
            awsService: clientName,
            request
          });
          this.config.region().then((region) => {
            regionCh.publish(region);
          });
          if (typeof cb === "function") {
            args[args.length - 1] = function(err, result) {
              const message = getMessage(request, err, result);
              completeChannel.publish(message);
              outerAr.runInAsyncScope(() => {
                responseStartChannel.publish(message);
                cb.apply(this, arguments);
                if (message.needsFinish) {
                  responseFinishChannel.publish(message.response.error);
                }
              });
            };
          } else {
            return send.call(this, command, ...args).then(
              (result) => {
                const message = getMessage(request, null, result);
                completeChannel.publish(message);
                return result;
              },
              (error) => {
                const message = getMessage(request, error);
                completeChannel.publish(message);
                throw error;
              }
            );
          }
          return send.call(this, command, ...args);
        });
      };
    }
    __name(wrapSmithySend, "wrapSmithySend");
    function wrapCb(cb, serviceName, request, ar) {
      return /* @__PURE__ */ __name(function wrappedCb(err, response) {
        const obj = { request, response };
        return ar.runInAsyncScope(() => {
          channel(`apm:aws:response:start:${serviceName}`).publish(obj);
          if (!obj.needsFinish) {
            return cb.apply(this, arguments);
          }
          const finishChannel = channel(`apm:aws:response:finish:${serviceName}`);
          try {
            let result = cb.apply(this, arguments);
            if (result && result.then) {
              result = result.then((x) => {
                finishChannel.publish();
                return x;
              }, (e) => {
                finishChannel.publish(e);
                throw e;
              });
            } else {
              finishChannel.publish();
            }
            return result;
          } catch (e) {
            finishChannel.publish(e);
            throw e;
          }
        });
      }, "wrappedCb");
    }
    __name(wrapCb, "wrapCb");
    function getMessage(request, error, result) {
      const response = { request, error, ...result };
      if (result && result.$metadata) {
        response.requestId = result.$metadata.requestId;
      }
      return { request, response };
    }
    __name(getMessage, "getMessage");
    function getChannelSuffix(name) {
      return [
        "cloudwatchlogs",
        "dynamodb",
        "eventbridge",
        "kinesis",
        "lambda",
        "redshift",
        "s3",
        "sns",
        "sqs"
      ].includes(name) ? name : "default";
    }
    __name(getChannelSuffix, "getChannelSuffix");
    addHook({ name: "@aws-sdk/smithy-client", versions: [">=3"] }, (smithy) => {
      shimmer.wrap(smithy.Client.prototype, "send", wrapSmithySend);
      return smithy;
    });
    addHook({ name: "aws-sdk", versions: [">=2.3.0"] }, (AWS2) => {
      shimmer.wrap(AWS2.Request.prototype, "promise", wrapRequest);
      shimmer.wrap(AWS2.config, "setPromisesDependency", (setPromisesDependency) => {
        return /* @__PURE__ */ __name(function wrappedSetPromisesDependency(dep) {
          const result = setPromisesDependency.apply(this, arguments);
          shimmer.wrap(AWS2.Request.prototype, "promise", wrapRequest);
          return result;
        }, "wrappedSetPromisesDependency");
      });
      return AWS2;
    });
    addHook({ name: "aws-sdk", versions: [">=2.1.35"] }, (AWS2) => {
      shimmer.wrap(AWS2.Request.prototype, "send", wrapRequest);
      return AWS2;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/cucumber.js
var require_cucumber = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/cucumber.js"() {
    "use strict";
    var { addHook, channel, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var testStartCh = channel("ci:cucumber:test:start");
    var testFinishCh = channel("ci:cucumber:test:finish");
    var testStepStartCh = channel("ci:cucumber:test-step:start");
    var errorCh = channel("ci:cucumber:error");
    var testSuiteStartCh = channel("ci:cucumber:test-suite:start");
    var testSuiteFinishCh = channel("ci:cucumber:test-suite:finish");
    var sessionStartCh = channel("ci:cucumber:session:start");
    var sessionFinishCh = channel("ci:cucumber:session:finish");
    var patched = /* @__PURE__ */ new WeakSet();
    var pickleByFile = {};
    var pickleResultByFile = {};
    function getSuiteStatusFromTestStatuses(testStatuses) {
      if (testStatuses.some((status) => status === "fail")) {
        return "fail";
      }
      if (testStatuses.every((status) => status === "skip")) {
        return "skip";
      }
      return "pass";
    }
    __name(getSuiteStatusFromTestStatuses, "getSuiteStatusFromTestStatuses");
    function getStatusFromResult(result) {
      if (result.status === 1) {
        return { status: "pass" };
      }
      if (result.status === 2) {
        return { status: "skip" };
      }
      if (result.status === 4) {
        return { status: "skip", skipReason: "not implemented" };
      }
      return { status: "fail", errorMessage: result.message };
    }
    __name(getStatusFromResult, "getStatusFromResult");
    function getStatusFromResultLatest(result) {
      if (result.status === "PASSED") {
        return { status: "pass" };
      }
      if (result.status === "SKIPPED" || result.status === "PENDING") {
        return { status: "skip" };
      }
      if (result.status === "UNDEFINED") {
        return { status: "skip", skipReason: "not implemented" };
      }
      return { status: "fail", errorMessage: result.message };
    }
    __name(getStatusFromResultLatest, "getStatusFromResultLatest");
    function wrapRun(pl, isLatestVersion) {
      if (patched.has(pl))
        return;
      patched.add(pl);
      shimmer.wrap(pl.prototype, "run", (run) => function() {
        if (!testStartCh.hasSubscribers) {
          return run.apply(this, arguments);
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          const testSuiteFullPath = this.pickle.uri;
          if (!pickleResultByFile[testSuiteFullPath]) {
            testSuiteStartCh.publish(testSuiteFullPath);
          }
          testStartCh.publish({ testName: this.pickle.name, fullTestSuite: testSuiteFullPath });
          try {
            const promise = run.apply(this, arguments);
            promise.finally(() => {
              const result = this.getWorstStepResult();
              const { status, skipReason, errorMessage } = isLatestVersion ? getStatusFromResultLatest(result) : getStatusFromResult(result);
              if (!pickleResultByFile[testSuiteFullPath]) {
                pickleResultByFile[testSuiteFullPath] = [status];
              } else {
                pickleResultByFile[testSuiteFullPath].push(status);
              }
              if (pickleResultByFile[testSuiteFullPath].length === pickleByFile[testSuiteFullPath].length) {
                const testSuiteStatus = getSuiteStatusFromTestStatuses(pickleResultByFile[testSuiteFullPath]);
                testSuiteFinishCh.publish(testSuiteStatus);
              }
              testFinishCh.publish({ status, skipReason, errorMessage });
            });
            return promise;
          } catch (err) {
            errorCh.publish(err);
            throw err;
          }
        });
      });
      shimmer.wrap(pl.prototype, "runStep", (runStep) => function() {
        if (!testStepStartCh.hasSubscribers) {
          return runStep.apply(this, arguments);
        }
        const testStep = arguments[0];
        let resource;
        if (isLatestVersion) {
          resource = testStep.text;
        } else {
          resource = testStep.isHook ? "hook" : testStep.pickleStep.text;
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          testStepStartCh.publish({ resource });
          try {
            const promise = runStep.apply(this, arguments);
            promise.then((result) => {
              const { status, skipReason, errorMessage } = isLatestVersion ? getStatusFromResultLatest(result) : getStatusFromResult(result);
              testFinishCh.publish({ isStep: true, status, skipReason, errorMessage });
            });
            return promise;
          } catch (err) {
            errorCh.publish(err);
            throw err;
          }
        });
      });
    }
    __name(wrapRun, "wrapRun");
    function pickleHook(PickleRunner) {
      const pl = PickleRunner.default;
      wrapRun(pl, false);
      return PickleRunner;
    }
    __name(pickleHook, "pickleHook");
    function testCaseHook(TestCaseRunner) {
      const pl = TestCaseRunner.default;
      wrapRun(pl, true);
      return TestCaseRunner;
    }
    __name(testCaseHook, "testCaseHook");
    addHook({
      name: "@cucumber/cucumber",
      versions: ["7.0.0 - 7.2.1"],
      file: "lib/runtime/pickle_runner.js"
    }, pickleHook);
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=7.3.0"],
      file: "lib/runtime/test_case_runner.js"
    }, testCaseHook);
    function getPickleByFile(runtime) {
      return runtime.pickleIds.reduce((acc, pickleId) => {
        const test = runtime.eventDataCollector.getPickle(pickleId);
        if (acc[test.uri]) {
          acc[test.uri].push(test);
        } else {
          acc[test.uri] = [test];
        }
        return acc;
      }, {});
    }
    __name(getPickleByFile, "getPickleByFile");
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=7.0.0"],
      file: "lib/runtime/index.js"
    }, (runtimePackage, cucumberVersion) => {
      shimmer.wrap(runtimePackage.default.prototype, "start", (start) => async function() {
        pickleByFile = getPickleByFile(this);
        const processArgv = process.argv.slice(2).join(" ");
        const command = process.env.npm_lifecycle_script || `cucumber-js ${processArgv}`;
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        asyncResource.runInAsyncScope(() => {
          sessionStartCh.publish({ command, frameworkVersion: cucumberVersion });
        });
        const success = await start.apply(this, arguments);
        asyncResource.runInAsyncScope(() => {
          sessionFinishCh.publish(success ? "pass" : "fail");
        });
        return success;
      });
      return runtimePackage;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/playwright.js
var require_playwright = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/playwright.js"() {
    var { addHook, channel, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var testStartCh = channel("ci:playwright:test:start");
    var testFinishCh = channel("ci:playwright:test:finish");
    var testSessionStartCh = channel("ci:playwright:session:start");
    var testSessionFinishCh = channel("ci:playwright:session:finish");
    var testSuiteStartCh = channel("ci:playwright:test-suite:start");
    var testSuiteFinishCh = channel("ci:playwright:test-suite:finish");
    var testToAr = /* @__PURE__ */ new WeakMap();
    var testSuiteToAr = /* @__PURE__ */ new Map();
    var testSuiteToTestStatuses = /* @__PURE__ */ new Map();
    var startedSuites = [];
    var STATUS_TO_TEST_STATUS = {
      passed: "pass",
      failed: "fail",
      timedOut: "fail",
      skipped: "skip"
    };
    var remainingTestsByFile = {};
    function getTestsBySuiteFromTestsById(testsById) {
      const testsByTestSuite = {};
      for (const { test } of testsById.values()) {
        const { _requireFile } = test;
        if (test._type === "beforeAll" || test._type === "afterAll") {
          continue;
        }
        if (testsByTestSuite[_requireFile]) {
          testsByTestSuite[_requireFile].push(test);
        } else {
          testsByTestSuite[_requireFile] = [test];
        }
      }
      return testsByTestSuite;
    }
    __name(getTestsBySuiteFromTestsById, "getTestsBySuiteFromTestsById");
    function getPlaywrightConfig(playwrightRunner) {
      try {
        return playwrightRunner._configLoader.fullConfig();
      } catch (e) {
        try {
          return playwrightRunner._loader.fullConfig();
        } catch (e2) {
          return {};
        }
      }
    }
    __name(getPlaywrightConfig, "getPlaywrightConfig");
    function getRootDir(playwrightRunner) {
      const config = getPlaywrightConfig(playwrightRunner);
      if (config.rootDir) {
        return config.rootDir;
      }
      if (playwrightRunner._configDir) {
        return playwrightRunner._configDir;
      }
      return process.cwd();
    }
    __name(getRootDir, "getRootDir");
    function testBeginHandler(test) {
      const { title: testName, location: { file: testSuiteAbsolutePath }, _type } = test;
      if (_type === "beforeAll" || _type === "afterAll") {
        return;
      }
      const isNewTestSuite = !startedSuites.includes(testSuiteAbsolutePath);
      if (isNewTestSuite) {
        startedSuites.push(testSuiteAbsolutePath);
        const testSuiteAsyncResource = new AsyncResource("bound-anonymous-fn");
        testSuiteToAr.set(testSuiteAbsolutePath, testSuiteAsyncResource);
        testSuiteAsyncResource.runInAsyncScope(() => {
          testSuiteStartCh.publish(testSuiteAbsolutePath);
        });
      }
      const testAsyncResource = new AsyncResource("bound-anonymous-fn");
      testToAr.set(test, testAsyncResource);
      testAsyncResource.runInAsyncScope(() => {
        testStartCh.publish({ testName, testSuiteAbsolutePath });
      });
    }
    __name(testBeginHandler, "testBeginHandler");
    function testEndHandler(test, testStatus, error) {
      const { location: { file: testSuiteAbsolutePath }, results, _type } = test;
      if (_type === "beforeAll" || _type === "afterAll") {
        return;
      }
      const testResult = results[results.length - 1];
      const testAsyncResource = testToAr.get(test);
      testAsyncResource.runInAsyncScope(() => {
        testFinishCh.publish({ testStatus, steps: testResult.steps, error });
      });
      if (!testSuiteToTestStatuses.has(testSuiteAbsolutePath)) {
        testSuiteToTestStatuses.set(testSuiteAbsolutePath, [testStatus]);
      } else {
        testSuiteToTestStatuses.get(testSuiteAbsolutePath).push(testStatus);
      }
      remainingTestsByFile[testSuiteAbsolutePath] = remainingTestsByFile[testSuiteAbsolutePath].filter((currentTest) => currentTest !== test);
      if (!remainingTestsByFile[testSuiteAbsolutePath].length) {
        const testStatuses = testSuiteToTestStatuses.get(testSuiteAbsolutePath);
        let testSuiteStatus = "pass";
        if (testStatuses.some((status) => status === "fail")) {
          testSuiteStatus = "fail";
        } else if (testStatuses.every((status) => status === "skip")) {
          testSuiteStatus = "skip";
        }
        const testSuiteAsyncResource = testSuiteToAr.get(testSuiteAbsolutePath);
        testSuiteAsyncResource.runInAsyncScope(() => {
          testSuiteFinishCh.publish(testSuiteStatus);
        });
      }
    }
    __name(testEndHandler, "testEndHandler");
    function dispatcherRunWrapper(run) {
      return function() {
        remainingTestsByFile = getTestsBySuiteFromTestsById(this._testById);
        return run.apply(this, arguments);
      };
    }
    __name(dispatcherRunWrapper, "dispatcherRunWrapper");
    function dispatcherHook(dispatcherExport) {
      shimmer.wrap(dispatcherExport.Dispatcher.prototype, "run", dispatcherRunWrapper);
      shimmer.wrap(dispatcherExport.Dispatcher.prototype, "_createWorker", (createWorker) => function() {
        const dispatcher = this;
        const worker = createWorker.apply(this, arguments);
        worker.process.on("message", ({ method, params }) => {
          if (method === "testBegin") {
            const { test } = dispatcher._testById.get(params.testId);
            testBeginHandler(test);
          } else if (method === "testEnd") {
            const { test } = dispatcher._testById.get(params.testId);
            const { results } = test;
            const testResult = results[results.length - 1];
            testEndHandler(test, STATUS_TO_TEST_STATUS[testResult.status], testResult.error);
          }
        });
        return worker;
      });
      return dispatcherExport;
    }
    __name(dispatcherHook, "dispatcherHook");
    function dispatcherHookNew(dispatcherExport) {
      shimmer.wrap(dispatcherExport.Dispatcher.prototype, "run", dispatcherRunWrapper);
      shimmer.wrap(dispatcherExport.Dispatcher.prototype, "_createWorker", (createWorker) => function() {
        const dispatcher = this;
        const worker = createWorker.apply(this, arguments);
        worker.on("testBegin", ({ testId }) => {
          const { test } = dispatcher._testById.get(testId);
          testBeginHandler(test);
        });
        worker.on("testEnd", ({ testId, status, errors }) => {
          const { test } = dispatcher._testById.get(testId);
          testEndHandler(test, STATUS_TO_TEST_STATUS[status], errors && errors[0]);
        });
        return worker;
      });
      return dispatcherExport;
    }
    __name(dispatcherHookNew, "dispatcherHookNew");
    function runnerHook(runnerExport, playwrightVersion) {
      shimmer.wrap(runnerExport.Runner.prototype, "runAllTests", (runAllTests) => async function() {
        const testSessionAsyncResource = new AsyncResource("bound-anonymous-fn");
        const rootDir = getRootDir(this);
        const processArgv = process.argv.slice(2).join(" ");
        const command = `playwright ${processArgv}`;
        testSessionAsyncResource.runInAsyncScope(() => {
          testSessionStartCh.publish({ command, frameworkVersion: playwrightVersion, rootDir });
        });
        const res = await runAllTests.apply(this, arguments);
        const sessionStatus = STATUS_TO_TEST_STATUS[res.status];
        let onDone;
        const flushWait = new Promise((resolve) => {
          onDone = resolve;
        });
        testSessionAsyncResource.runInAsyncScope(() => {
          testSessionFinishCh.publish({ status: sessionStatus, onDone });
        });
        await flushWait;
        startedSuites = [];
        remainingTestsByFile = {};
        return res;
      });
      return runnerExport;
    }
    __name(runnerHook, "runnerHook");
    addHook({
      name: "@playwright/test",
      file: "lib/runner.js",
      versions: [">=1.18.0"]
    }, runnerHook);
    addHook({
      name: "@playwright/test",
      file: "lib/dispatcher.js",
      versions: [">=1.18.0  <1.30.0"]
    }, dispatcherHook);
    addHook({
      name: "@playwright/test",
      file: "lib/dispatcher.js",
      versions: [">=1.30.0"]
    }, dispatcherHookNew);
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/elasticsearch.js
var require_elasticsearch = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/elasticsearch.js"(exports2, module2) {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "@elastic/transport", file: "lib/Transport.js", versions: [">=8"] }, (exports3) => {
      shimmer.wrap(exports3.default.prototype, "request", createWrapRequest("elasticsearch"));
      return exports3;
    });
    addHook({ name: "@elastic/elasticsearch", file: "lib/Transport.js", versions: [">=5.6.16 <8", ">=8"] }, (Transport) => {
      shimmer.wrap(Transport.prototype, "request", createWrapRequest("elasticsearch"));
      return Transport;
    });
    addHook({ name: "elasticsearch", file: "src/lib/transport.js", versions: [">=10"] }, (Transport) => {
      shimmer.wrap(Transport.prototype, "request", createWrapRequest("elasticsearch"));
      return Transport;
    });
    function createWrapRequest(name) {
      const startCh = channel(`apm:${name}:query:start`);
      const finishCh = channel(`apm:${name}:query:finish`);
      const errorCh = channel(`apm:${name}:query:error`);
      return /* @__PURE__ */ __name(function wrapRequest(request) {
        return function(params, options, cb) {
          if (!startCh.hasSubscribers) {
            return request.apply(this, arguments);
          }
          if (!params)
            return request.apply(this, arguments);
          const parentResource = new AsyncResource("bound-anonymous-fn");
          const asyncResource = new AsyncResource("bound-anonymous-fn");
          return asyncResource.runInAsyncScope(() => {
            startCh.publish({ params });
            try {
              const lastIndex = arguments.length - 1;
              cb = arguments[lastIndex];
              if (typeof cb === "function") {
                cb = parentResource.bind(cb);
                arguments[lastIndex] = asyncResource.bind(function(error) {
                  finish(params, error);
                  return cb.apply(null, arguments);
                });
                return request.apply(this, arguments);
              } else {
                const promise = request.apply(this, arguments);
                if (promise && typeof promise.then === "function") {
                  const onResolve = asyncResource.bind(() => finish(params));
                  const onReject = asyncResource.bind((e) => finish(params, e));
                  promise.then(onResolve, onReject);
                } else {
                  finish(params);
                }
                return promise;
              }
            } catch (err) {
              err.stack;
              errorCh.publish(err);
              throw err;
            }
          });
        };
      }, "wrapRequest");
      function finish(params, error) {
        if (error) {
          errorCh.publish(error);
        }
        finishCh.publish({ params });
      }
      __name(finish, "finish");
    }
    __name(createWrapRequest, "createWrapRequest");
    module2.exports = { createWrapRequest };
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/google-cloud-pubsub.js
var require_google_cloud_pubsub = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/google-cloud-pubsub.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var requestStartCh = channel("apm:google-cloud-pubsub:request:start");
    var requestFinishCh = channel("apm:google-cloud-pubsub:request:finish");
    var requestErrorCh = channel("apm:google-cloud-pubsub:request:error");
    var receiveStartCh = channel(`apm:google-cloud-pubsub:receive:start`);
    var receiveFinishCh = channel("apm:google-cloud-pubsub:receive:finish");
    var receiveErrorCh = channel("apm:google-cloud-pubsub:receive:error");
    addHook({ name: "@google-cloud/pubsub", versions: [">=1.2"] }, (obj) => {
      const PubSub = obj.PubSub;
      const Subscription = obj.Subscription;
      shimmer.wrap(PubSub.prototype, "request", (request) => function(cfg = { reqOpts: {} }, cb) {
        if (!requestStartCh.hasSubscribers) {
          return request.apply(this, arguments);
        }
        const innerAsyncResource = new AsyncResource("bound-anonymous-fn");
        const outerAsyncResource = new AsyncResource("bound-anonymous-fn");
        return innerAsyncResource.runInAsyncScope(() => {
          let messages = [];
          if (cfg.reqOpts && cfg.method === "publish") {
            messages = cfg.reqOpts.messages;
          }
          requestStartCh.publish({ cfg, projectId: this.projectId, messages });
          cb = outerAsyncResource.bind(cb);
          const fn = /* @__PURE__ */ __name(() => {
            arguments[1] = innerAsyncResource.bind(function(error) {
              if (error) {
                requestErrorCh.publish(error);
              }
              requestFinishCh.publish(void 0);
              return cb.apply(this, arguments);
            });
            return request.apply(this, arguments);
          }, "fn");
          try {
            return fn.apply(this, arguments);
          } catch (e) {
            requestErrorCh.publish(e);
            throw e;
          }
        });
      });
      shimmer.wrap(Subscription.prototype, "emit", (emit) => function(eventName, message) {
        if (eventName !== "message" || !message)
          return emit.apply(this, arguments);
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          try {
            return emit.apply(this, arguments);
          } catch (err) {
            receiveErrorCh.publish(err);
            throw err;
          }
        });
      });
      return obj;
    });
    addHook({ name: "@google-cloud/pubsub", versions: [">=1.2"], file: "build/src/lease-manager.js" }, (obj) => {
      const LeaseManager = obj.LeaseManager;
      shimmer.wrap(LeaseManager.prototype, "_dispense", (dispense) => function(message) {
        if (receiveStartCh.hasSubscribers) {
          receiveStartCh.publish({ message });
        }
        return dispense.apply(this, arguments);
      });
      shimmer.wrap(LeaseManager.prototype, "remove", (remove) => function(message) {
        receiveFinishCh.publish({ message });
        return remove.apply(this, arguments);
      });
      shimmer.wrap(LeaseManager.prototype, "clear", (clear) => function() {
        for (const message of this._messages) {
          receiveFinishCh.publish({ message });
        }
        return clear.apply(this, arguments);
      });
      return obj;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/types.js
var require_types2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/types.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      unary: "unary",
      bidi: "bidi_streaming",
      client_stream: "client_streaming",
      clientStream: "client_streaming",
      server_stream: "server_streaming",
      serverStream: "server_streaming"
    };
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/client.js
var require_client8 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/client.js"() {
    "use strict";
    var types = require_types2();
    var { addHook, channel, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var patched = /* @__PURE__ */ new WeakSet();
    var instances = /* @__PURE__ */ new WeakMap();
    var startChannel = channel("apm:grpc:client:request:start");
    var errorChannel = channel("apm:grpc:client:request:error");
    var finishChannel = channel("apm:grpc:client:request:finish");
    function createWrapMakeRequest(type) {
      return /* @__PURE__ */ __name(function wrapMakeRequest(makeRequest) {
        return function(path) {
          const args = ensureMetadata(this, arguments, 4);
          return callMethod(this, makeRequest, args, path, args[4], type);
        };
      }, "wrapMakeRequest");
    }
    __name(createWrapMakeRequest, "createWrapMakeRequest");
    function createWrapLoadPackageDefinition() {
      return /* @__PURE__ */ __name(function wrapLoadPackageDefinition(loadPackageDefinition) {
        return function(packageDef) {
          const result = loadPackageDefinition.apply(this, arguments);
          if (!result)
            return result;
          wrapPackageDefinition(result);
          return result;
        };
      }, "wrapLoadPackageDefinition");
    }
    __name(createWrapLoadPackageDefinition, "createWrapLoadPackageDefinition");
    function createWrapMakeClientConstructor() {
      return /* @__PURE__ */ __name(function wrapMakeClientConstructor(makeClientConstructor) {
        return function(methods) {
          const ServiceClient = makeClientConstructor.apply(this, arguments);
          wrapClientConstructor(ServiceClient, methods);
          return ServiceClient;
        };
      }, "wrapMakeClientConstructor");
    }
    __name(createWrapMakeClientConstructor, "createWrapMakeClientConstructor");
    function wrapPackageDefinition(def) {
      for (const name in def) {
        if (def[name].format)
          continue;
        if (def[name].service && def[name].prototype) {
          wrapClientConstructor(def[name], def[name].service);
        } else {
          wrapPackageDefinition(def[name]);
        }
      }
    }
    __name(wrapPackageDefinition, "wrapPackageDefinition");
    function wrapClientConstructor(ServiceClient, methods) {
      const proto = ServiceClient.prototype;
      if (typeof methods !== "object" || "format" in methods)
        return;
      Object.keys(methods).forEach((name) => {
        if (!methods[name])
          return;
        const originalName = methods[name].originalName;
        const path = methods[name].path;
        const type = getType(methods[name]);
        if (methods[name]) {
          proto[name] = wrapMethod(proto[name], path, type);
        }
        if (originalName) {
          proto[originalName] = wrapMethod(proto[originalName], path, type);
        }
      });
    }
    __name(wrapClientConstructor, "wrapClientConstructor");
    function wrapMethod(method, path, type) {
      if (typeof method !== "function" || patched.has(method)) {
        return method;
      }
      const wrapped = /* @__PURE__ */ __name(function() {
        const args = ensureMetadata(this, arguments, 1);
        return callMethod(this, method, args, path, args[1], type);
      }, "wrapped");
      Object.assign(wrapped, method);
      patched.add(wrapped);
      return wrapped;
    }
    __name(wrapMethod, "wrapMethod");
    function wrapCallback(requestResource, parentResource, callback) {
      return function(err) {
        if (err) {
          requestResource.runInAsyncScope(() => {
            errorChannel.publish(err);
          });
        }
        if (callback) {
          return parentResource.runInAsyncScope(() => {
            return callback.apply(this, arguments);
          });
        }
      };
    }
    __name(wrapCallback, "wrapCallback");
    function wrapStream(call, requestResource, parentResource) {
      if (!call || typeof call.emit !== "function")
        return;
      shimmer.wrap(call, "emit", (emit) => {
        return function(eventName, ...args) {
          requestResource.runInAsyncScope(() => {
            switch (eventName) {
              case "error":
                errorChannel.publish(args[0]);
                break;
              case "status":
                finishChannel.publish(args[0]);
                break;
            }
          });
          return parentResource.runInAsyncScope(() => {
            return emit.apply(this, arguments);
          });
        };
      });
    }
    __name(wrapStream, "wrapStream");
    function callMethod(client, method, args, path, metadata, type) {
      if (!startChannel.hasSubscribers)
        return method.apply(client, args);
      const length = args.length;
      const callback = args[length - 1];
      const parentResource = new AsyncResource("bound-anonymous-fn");
      const requestResource = new AsyncResource("bound-anonymous-fn");
      return requestResource.runInAsyncScope(() => {
        startChannel.publish({ metadata, path, type });
        if (type === types.unary || type === types.client_stream) {
          if (typeof callback === "function") {
            args[length - 1] = wrapCallback(requestResource, parentResource, callback);
          } else {
            args[length] = wrapCallback(requestResource, parentResource);
          }
        }
        const call = method.apply(client, args);
        wrapStream(call, requestResource, parentResource);
        return call;
      });
    }
    __name(callMethod, "callMethod");
    function ensureMetadata(client, args, index) {
      const grpc = getGrpc(client);
      if (!client || !grpc)
        return args;
      const meta = args[index];
      const normalized = [];
      for (let i = 0; i < index; i++) {
        normalized.push(args[i]);
      }
      if (!meta || !meta.constructor || meta.constructor.name !== "Metadata") {
        normalized.push(new grpc.Metadata());
      }
      if (meta) {
        normalized.push(meta);
      }
      for (let i = index + 1; i < args.length; i++) {
        normalized.push(args[i]);
      }
      return normalized;
    }
    __name(ensureMetadata, "ensureMetadata");
    function getType(definition) {
      if (definition.requestStream) {
        if (definition.responseStream) {
          return types.bidi;
        }
        return types.client_stream;
      }
      if (definition.responseStream) {
        return types.server_stream;
      }
      return types.unary;
    }
    __name(getType, "getType");
    function getGrpc(client) {
      let proto = client;
      do {
        const instance = instances.get(proto);
        if (instance)
          return instance;
      } while (proto = Object.getPrototypeOf(proto));
    }
    __name(getGrpc, "getGrpc");
    function patch(grpc) {
      const proto = grpc.Client.prototype;
      instances.set(proto, grpc);
      shimmer.wrap(proto, "makeBidiStreamRequest", createWrapMakeRequest(types.bidi));
      shimmer.wrap(proto, "makeClientStreamRequest", createWrapMakeRequest(types.clientStream));
      shimmer.wrap(proto, "makeServerStreamRequest", createWrapMakeRequest(types.serverStream));
      shimmer.wrap(proto, "makeUnaryRequest", createWrapMakeRequest(types.unary));
      return grpc;
    }
    __name(patch, "patch");
    addHook({ name: "grpc", versions: [">=1.24.3"] }, patch);
    addHook({ name: "grpc", versions: [">=1.24.3"], file: "src/client.js" }, (client) => {
      shimmer.wrap(client, "makeClientConstructor", createWrapMakeClientConstructor());
      return client;
    });
    addHook({ name: "@grpc/grpc-js", versions: [">=1.0.3"] }, patch);
    addHook({ name: "@grpc/grpc-js", versions: [">=1.0.3"], file: "build/src/make-client.js" }, (client) => {
      shimmer.wrap(client, "makeClientConstructor", createWrapMakeClientConstructor());
      shimmer.wrap(client, "loadPackageDefinition", createWrapLoadPackageDefinition());
      return client;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/server.js
var require_server7 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/server.js"() {
    "use strict";
    var types = require_types2();
    var { channel, addHook, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startChannel = channel("apm:grpc:server:request:start");
    var errorChannel = channel("apm:grpc:server:request:error");
    var updateChannel = channel("apm:grpc:server:request:update");
    var finishChannel = channel("apm:grpc:server:request:finish");
    var OK = 0;
    var CANCELLED = 1;
    function wrapHandler(func, name) {
      const isValid = /* @__PURE__ */ __name((server, args) => {
        if (!startChannel.hasSubscribers)
          return false;
        if (!server || !server.type)
          return false;
        if (!args[0])
          return false;
        if (server.type !== "unary" && !isEmitter(args[0]))
          return false;
        if (server.type === "unary" && typeof args[1] !== "function")
          return false;
        return true;
      }, "isValid");
      return function(call, callback) {
        if (!isValid(this, arguments))
          return func.apply(this, arguments);
        const metadata = call.metadata;
        const type = types[this.type];
        const isStream = type !== "unary";
        const parentResource = new AsyncResource("bound-anonymous-fn");
        const requestResource = new AsyncResource("bound-anonymous-fn");
        return requestResource.runInAsyncScope(() => {
          startChannel.publish({ name, metadata, type });
          const onCancel = requestResource.bind(() => {
            finishChannel.publish({ code: CANCELLED });
          });
          call.once("cancelled", onCancel);
          if (isStream) {
            wrapStream(call, requestResource, onCancel);
          } else {
            arguments[1] = wrapCallback(callback, call, requestResource, parentResource, onCancel);
          }
          shimmer.wrap(call, "emit", (emit) => requestResource.bind(emit));
          return func.apply(this, arguments);
        });
      };
    }
    __name(wrapHandler, "wrapHandler");
    function wrapRegister(register) {
      return function(name, handler2, serialize, deserialize, type) {
        if (typeof handler2 === "function") {
          arguments[1] = wrapHandler(handler2, name);
        }
        return register.apply(this, arguments);
      };
    }
    __name(wrapRegister, "wrapRegister");
    function wrapStream(call, requestResource, onCancel) {
      if (call.call && call.call.sendStatus) {
        call.call.sendStatus = wrapSendStatus(call.call.sendStatus, requestResource);
      }
      shimmer.wrap(call, "emit", (emit) => {
        return function(eventName, ...args) {
          switch (eventName) {
            case "error":
              errorChannel.publish(args[0]);
              finishChannel.publish({ code: args[0].code });
              call.removeListener("cancelled", onCancel);
              break;
            case "finish":
              if (call.status) {
                updateChannel.publish(call.status);
              }
              if (!call.status || call.status.code === 0) {
                finishChannel.publish();
              }
              call.removeListener("cancelled", onCancel);
              break;
          }
          return emit.apply(this, arguments);
        };
      });
    }
    __name(wrapStream, "wrapStream");
    function wrapCallback(callback, call, requestResource, parentResource, onCancel) {
      return function(err, value, trailer, flags) {
        requestResource.runInAsyncScope(() => {
          if (err instanceof Error) {
            errorChannel.publish(err);
            finishChannel.publish(err);
          } else {
            finishChannel.publish({ code: OK, trailer });
          }
          call.removeListener("cancelled", onCancel);
        });
        if (callback) {
          return parentResource.runInAsyncScope(() => {
            return callback.apply(this, arguments);
          });
        }
      };
    }
    __name(wrapCallback, "wrapCallback");
    function wrapSendStatus(sendStatus, requestResource) {
      return function(status) {
        requestResource.runInAsyncScope(() => {
          updateChannel.publish(status);
        });
        return sendStatus.apply(this, arguments);
      };
    }
    __name(wrapSendStatus, "wrapSendStatus");
    function isEmitter(obj) {
      return typeof obj.emit === "function" && typeof obj.once === "function";
    }
    __name(isEmitter, "isEmitter");
    addHook({ name: "grpc", versions: [">=1.24.3"], file: "src/server.js" }, (server) => {
      shimmer.wrap(server.Server.prototype, "register", wrapRegister);
      return server;
    });
    addHook({ name: "@grpc/grpc-js", versions: [">=1.0.3"], file: "build/src/server.js" }, (server) => {
      shimmer.wrap(server.Server.prototype, "register", wrapRegister);
      return server;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/grpc.js
var require_grpc = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/grpc.js"() {
    "use strict";
    require_client8();
    require_server7();
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/hapi.js
var require_hapi = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/hapi.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel, AsyncResource } = require_instrument();
    var handleChannel = channel("apm:hapi:request:handle");
    var routeChannel = channel("apm:hapi:request:route");
    var errorChannel = channel("apm:hapi:request:error");
    var enterChannel = channel("apm:hapi:extension:enter");
    function wrapServer(server) {
      return function(options) {
        const app = server.apply(this, arguments);
        if (!app)
          return app;
        if (typeof app.ext === "function") {
          app.ext = wrapExt(app.ext);
        }
        if (typeof app.start === "function") {
          app.start = wrapStart(app.start);
        }
        return app;
      };
    }
    __name(wrapServer, "wrapServer");
    function wrapStart(start) {
      return function() {
        if (this && typeof this.ext === "function") {
          this.ext("onPreResponse", onPreResponse);
        }
        return start.apply(this, arguments);
      };
    }
    __name(wrapStart, "wrapStart");
    function wrapExt(ext) {
      return function(events, method, options) {
        if (typeof events === "object") {
          arguments[0] = wrapEvents(events);
        } else {
          arguments[1] = wrapExtension(method);
        }
        return ext.apply(this, arguments);
      };
    }
    __name(wrapExt, "wrapExt");
    function wrapDispatch(dispatch) {
      return function(options) {
        const handler2 = dispatch.apply(this, arguments);
        if (typeof handler2 !== "function")
          return handler2;
        return function(req, res) {
          handleChannel.publish({ req, res });
          return handler2.apply(this, arguments);
        };
      };
    }
    __name(wrapDispatch, "wrapDispatch");
    function wrapRebuild(rebuild) {
      return function(event) {
        const result = rebuild.apply(this, arguments);
        if (this && Array.isArray(this._cycle)) {
          this._cycle = this._cycle.map(wrapHandler);
        }
        return result;
      };
    }
    __name(wrapRebuild, "wrapRebuild");
    function wrapExtension(method) {
      return [].concat(method).map(wrapHandler);
    }
    __name(wrapExtension, "wrapExtension");
    function wrapEvents(events) {
      return [].concat(events).map((event) => {
        if (!event || !event.method)
          return event;
        return Object.assign({}, event, {
          method: wrapExtension(event.method)
        });
      });
    }
    __name(wrapEvents, "wrapEvents");
    function wrapHandler(handler2) {
      if (typeof handler2 !== "function")
        return handler2;
      return function(request, h) {
        const req = request && request.raw && request.raw.req;
        if (!req)
          return handler2.apply(this, arguments);
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          enterChannel.publish({ req });
          return handler2.apply(this, arguments);
        });
      };
    }
    __name(wrapHandler, "wrapHandler");
    function onPreResponse(request, h) {
      if (!request || !request.raw)
        return reply(request, h);
      const req = request.raw.req;
      if (request.response instanceof Error) {
        errorChannel.publish(request.response);
      }
      if (request.route) {
        routeChannel.publish({ req, route: request.route.path });
      }
      return reply(request, h);
    }
    __name(onPreResponse, "onPreResponse");
    function reply(request, h) {
      if (h.continue) {
        return typeof h.continue === "function" ? h.continue() : h.continue;
      } else if (typeof h === "function") {
        return h();
      }
    }
    __name(reply, "reply");
    addHook({ name: "@hapi/hapi", versions: [">=17.9"] }, (hapi) => {
      shimmer.massWrap(hapi, ["server", "Server"], wrapServer);
      return hapi;
    });
    addHook({ name: "@hapi/hapi", versions: [">=17.9"], file: "lib/core.js" }, (Core) => {
      shimmer.wrap(Core.prototype, "_dispatch", wrapDispatch);
      return Core;
    });
    addHook({ name: "@hapi/hapi", versions: [">=17.9"], file: "lib/route.js" }, (Route) => {
      shimmer.wrap(Route.prototype, "rebuild", wrapRebuild);
      return Route;
    });
    addHook({ name: "hapi", versions: [">=17"] }, (hapi) => {
      shimmer.massWrap(hapi, ["server", "Server"], wrapServer);
      return hapi;
    });
    addHook({ name: "hapi", versions: ["16"] }, (hapi) => {
      shimmer.wrap(hapi.Server.prototype, "start", wrapStart);
      shimmer.wrap(hapi.Server.prototype, "ext", wrapExt);
      return hapi;
    });
    addHook({ name: "hapi", versions: ["16"], file: "lib/connection.js" }, (Connection) => {
      shimmer.wrap(Connection.prototype, "_dispatch", wrapDispatch);
      return Connection;
    });
    addHook({ name: "hapi", versions: [">=17"], file: "lib/core.js" }, (Core) => {
      shimmer.wrap(Core.prototype, "_dispatch", wrapDispatch);
      return Core;
    });
    addHook({ name: "hapi", versions: [">=16"], file: "lib/route.js" }, (Route) => {
      shimmer.wrap(Route.prototype, "rebuild", wrapRebuild);
      return Route;
    });
  }
});

// node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js
var require_util7 = __commonJS({
  "node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js"(exports2, module2) {
    function getFormattedJestTestParameters(testParameters) {
      if (!testParameters || !testParameters.length) {
        return;
      }
      const [parameterArray, ...parameterValues] = testParameters;
      if (parameterValues.length === 0) {
        return parameterArray;
      }
      const parameterKeys = parameterArray[0].split("|").map((key) => key.trim());
      const formattedParameters = [];
      for (let index = 0; index < parameterValues.length; index++) {
        const parameterValue = parameterValues[index];
        const parameterIndex = index % parameterKeys.length;
        if (!parameterIndex) {
          formattedParameters.push({});
        }
        const parameterKey = parameterKeys[parameterIndex];
        const lastFormattedParameter = formattedParameters[formattedParameters.length - 1];
        lastFormattedParameter[parameterKey] = parameterValue;
      }
      return formattedParameters;
    }
    __name(getFormattedJestTestParameters, "getFormattedJestTestParameters");
    function getJestTestName(test) {
      const titles = [];
      let parent = test;
      do {
        titles.unshift(parent.name);
      } while (parent = parent.parent);
      titles.shift();
      return titles.join(" ");
    }
    __name(getJestTestName, "getJestTestName");
    module2.exports = { getFormattedJestTestParameters, getJestTestName };
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/jest.js
var require_jest = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/jest.js"() {
    "use strict";
    var { addHook, channel, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var log = require_log();
    var { getCoveredFilenamesFromCoverage } = require_test();
    var testSessionStartCh = channel("ci:jest:session:start");
    var testSessionFinishCh = channel("ci:jest:session:finish");
    var testSessionConfigurationCh = channel("ci:jest:session:configuration");
    var testSuiteStartCh = channel("ci:jest:test-suite:start");
    var testSuiteFinishCh = channel("ci:jest:test-suite:finish");
    var testSuiteCodeCoverageCh = channel("ci:jest:test-suite:code-coverage");
    var testStartCh = channel("ci:jest:test:start");
    var testSkippedCh = channel("ci:jest:test:skip");
    var testRunFinishCh = channel("ci:jest:test:finish");
    var testErrCh = channel("ci:jest:test:err");
    var skippableSuitesCh = channel("ci:jest:test-suite:skippable");
    var jestItrConfigurationCh = channel("ci:jest:itr-configuration");
    var skippableSuites = [];
    var isCodeCoverageEnabled = false;
    var isSuitesSkippingEnabled = false;
    var {
      getTestSuitePath,
      getTestParametersString
    } = require_test();
    var { getFormattedJestTestParameters, getJestTestName } = require_util7();
    var sessionAsyncResource = new AsyncResource("bound-anonymous-fn");
    var specStatusToTestStatus = {
      "pending": "skip",
      "disabled": "skip",
      "todo": "skip",
      "passed": "pass",
      "failed": "fail"
    };
    var asyncResources = /* @__PURE__ */ new WeakMap();
    var originalTestFns = /* @__PURE__ */ new WeakMap();
    function formatJestError(errors) {
      let error;
      if (Array.isArray(errors)) {
        const [originalError, asyncError] = errors;
        if (originalError === null || !originalError.stack) {
          error = asyncError;
          error.message = originalError;
        } else {
          error = originalError;
        }
      } else {
        error = errors;
      }
      return error;
    }
    __name(formatJestError, "formatJestError");
    function getTestEnvironmentOptions(config) {
      if (config.projectConfig && config.projectConfig.testEnvironmentOptions) {
        return config.projectConfig.testEnvironmentOptions;
      }
      if (config.testEnvironmentOptions) {
        return config.testEnvironmentOptions;
      }
      return {};
    }
    __name(getTestEnvironmentOptions, "getTestEnvironmentOptions");
    function getWrappedEnvironment(BaseEnvironment, jestVersion) {
      return /* @__PURE__ */ __name(class DatadogEnvironment extends BaseEnvironment {
        constructor(config, context) {
          super(config, context);
          const rootDir = config.globalConfig ? config.globalConfig.rootDir : config.rootDir;
          this.rootDir = rootDir;
          this.testSuite = getTestSuitePath(context.testPath, rootDir);
          this.nameToParams = {};
          this.global._ddtrace = global._ddtrace;
          this.testEnvironmentOptions = getTestEnvironmentOptions(config);
        }
        async handleTestEvent(event, state) {
          if (super.handleTestEvent) {
            await super.handleTestEvent(event, state);
          }
          const setNameToParams = /* @__PURE__ */ __name((name, params) => {
            this.nameToParams[name] = params;
          }, "setNameToParams");
          if (event.name === "setup") {
            if (this.global.test) {
              shimmer.wrap(this.global.test, "each", (each) => function() {
                const testParameters = getFormattedJestTestParameters(arguments);
                const eachBind = each.apply(this, arguments);
                return function() {
                  const [testName] = arguments;
                  setNameToParams(testName, testParameters);
                  return eachBind.apply(this, arguments);
                };
              });
            }
          }
          if (event.name === "test_start") {
            const testParameters = getTestParametersString(this.nameToParams, event.test.name);
            const asyncResource = new AsyncResource("bound-anonymous-fn");
            asyncResources.set(event.test, asyncResource);
            asyncResource.runInAsyncScope(() => {
              testStartCh.publish({
                name: getJestTestName(event.test),
                suite: this.testSuite,
                runner: "jest-circus",
                testParameters,
                frameworkVersion: jestVersion
              });
              originalTestFns.set(event.test, event.test.fn);
              event.test.fn = asyncResource.bind(event.test.fn);
            });
          }
          if (event.name === "test_done") {
            const asyncResource = asyncResources.get(event.test);
            asyncResource.runInAsyncScope(() => {
              let status = "pass";
              if (event.test.errors && event.test.errors.length) {
                status = "fail";
                const formattedError = formatJestError(event.test.errors[0]);
                testErrCh.publish(formattedError);
              }
              testRunFinishCh.publish(status);
              event.test.fn = originalTestFns.get(event.test);
            });
          }
          if (event.name === "test_skip" || event.name === "test_todo") {
            const asyncResource = new AsyncResource("bound-anonymous-fn");
            asyncResource.runInAsyncScope(() => {
              testSkippedCh.publish({
                name: getJestTestName(event.test),
                suite: this.testSuite,
                runner: "jest-circus",
                frameworkVersion: jestVersion
              });
            });
          }
        }
      }, "DatadogEnvironment");
    }
    __name(getWrappedEnvironment, "getWrappedEnvironment");
    function getTestEnvironment(pkg, jestVersion) {
      if (pkg.default) {
        const wrappedTestEnvironment = getWrappedEnvironment(pkg.default, jestVersion);
        pkg.default = wrappedTestEnvironment;
        pkg.TestEnvironment = wrappedTestEnvironment;
        return pkg;
      }
      return getWrappedEnvironment(pkg, jestVersion);
    }
    __name(getTestEnvironment, "getTestEnvironment");
    addHook({
      name: "jest-environment-node",
      versions: [">=24.8.0"]
    }, getTestEnvironment);
    addHook({
      name: "jest-environment-jsdom",
      versions: [">=24.8.0"]
    }, getTestEnvironment);
    function cliWrapper(cli, jestVersion) {
      const wrapped = shimmer.wrap(cli, "runCLI", (runCLI) => async function() {
        let onDone;
        const configurationPromise = new Promise((resolve) => {
          onDone = resolve;
        });
        if (!jestItrConfigurationCh.hasSubscribers) {
          return runCLI.apply(this, arguments);
        }
        sessionAsyncResource.runInAsyncScope(() => {
          jestItrConfigurationCh.publish({ onDone });
        });
        try {
          const { err, itrConfig } = await configurationPromise;
          if (!err) {
            isCodeCoverageEnabled = itrConfig.isCodeCoverageEnabled;
            isSuitesSkippingEnabled = itrConfig.isSuitesSkippingEnabled;
          }
        } catch (err) {
          log.error(err);
        }
        if (isSuitesSkippingEnabled) {
          const skippableSuitesPromise = new Promise((resolve) => {
            onDone = resolve;
          });
          sessionAsyncResource.runInAsyncScope(() => {
            skippableSuitesCh.publish({ onDone });
          });
          try {
            const { err, skippableSuites: receivedSkippableSuites } = await skippableSuitesPromise;
            if (!err) {
              skippableSuites = receivedSkippableSuites;
            }
          } catch (err) {
            log.error(err);
          }
        }
        const isSuitesSkipped = !!skippableSuites.length;
        const processArgv = process.argv.slice(2).join(" ");
        sessionAsyncResource.runInAsyncScope(() => {
          testSessionStartCh.publish({ command: `jest ${processArgv}`, frameworkVersion: jestVersion });
        });
        const result = await runCLI.apply(this, arguments);
        const { results: { success, coverageMap } } = result;
        let testCodeCoverageLinesTotal;
        try {
          const { pct, total } = coverageMap.getCoverageSummary().lines;
          testCodeCoverageLinesTotal = total !== 0 ? pct : 0;
        } catch (e) {
        }
        sessionAsyncResource.runInAsyncScope(() => {
          testSessionFinishCh.publish({
            status: success ? "pass" : "fail",
            isSuitesSkipped,
            isSuitesSkippingEnabled,
            isCodeCoverageEnabled,
            testCodeCoverageLinesTotal
          });
        });
        return result;
      });
      cli.runCLI = wrapped.runCLI;
      return cli;
    }
    __name(cliWrapper, "cliWrapper");
    function coverageReporterWrapper(coverageReporter) {
      const CoverageReporter = coverageReporter.default ? coverageReporter.default : coverageReporter;
      shimmer.wrap(CoverageReporter.prototype, "_addUntestedFiles", (addUntestedFiles) => async function() {
        if (isSuitesSkippingEnabled) {
          return Promise.resolve();
        }
        return addUntestedFiles.apply(this, arguments);
      });
      return coverageReporter;
    }
    __name(coverageReporterWrapper, "coverageReporterWrapper");
    addHook({
      name: "@jest/reporters",
      file: "build/coverage_reporter.js",
      versions: [">=24.8.0 <26.6.2"]
    }, coverageReporterWrapper);
    addHook({
      name: "@jest/reporters",
      file: "build/CoverageReporter.js",
      versions: [">=26.6.2"]
    }, coverageReporterWrapper);
    addHook({
      name: "@jest/core",
      file: "build/cli/index.js",
      versions: [">=24.8.0"]
    }, cliWrapper);
    function jestAdapterWrapper(jestAdapter, jestVersion) {
      const adapter = jestAdapter.default ? jestAdapter.default : jestAdapter;
      const newAdapter = shimmer.wrap(adapter, function() {
        const environment = arguments[2];
        if (!environment) {
          return adapter.apply(this, arguments);
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          testSuiteStartCh.publish({
            testSuite: environment.testSuite,
            testEnvironmentOptions: environment.testEnvironmentOptions,
            frameworkVersion: jestVersion
          });
          return adapter.apply(this, arguments).then((suiteResults) => {
            const { numFailingTests, skipped, failureMessage: errorMessage } = suiteResults;
            let status = "pass";
            if (skipped) {
              status = "skipped";
            } else if (numFailingTests !== 0) {
              status = "fail";
            }
            testSuiteFinishCh.publish({ status, errorMessage });
            const coverageFiles = getCoveredFilenamesFromCoverage(environment.global.__coverage__).map((filename) => getTestSuitePath(filename, environment.rootDir));
            if (coverageFiles && environment.testEnvironmentOptions && environment.testEnvironmentOptions._ddTestCodeCoverageEnabled) {
              asyncResource.runInAsyncScope(() => {
                testSuiteCodeCoverageCh.publish([...coverageFiles, environment.testSuite]);
              });
            }
            return suiteResults;
          });
        });
      });
      if (jestAdapter.default) {
        jestAdapter.default = newAdapter;
      } else {
        jestAdapter = newAdapter;
      }
      return jestAdapter;
    }
    __name(jestAdapterWrapper, "jestAdapterWrapper");
    addHook({
      name: "jest-circus",
      file: "build/legacy-code-todo-rewrite/jestAdapter.js",
      versions: [">=24.8.0"]
    }, jestAdapterWrapper);
    function configureTestEnvironment(readConfigsResult) {
      const { configs } = readConfigsResult;
      sessionAsyncResource.runInAsyncScope(() => {
        testSessionConfigurationCh.publish(configs.map((config) => config.testEnvironmentOptions));
      });
      configs.forEach((config) => {
        config.testEnvironmentOptions._ddTestCodeCoverageEnabled = isCodeCoverageEnabled;
      });
      if (isCodeCoverageEnabled) {
        const globalConfig = {
          ...readConfigsResult.globalConfig,
          collectCoverage: true
        };
        readConfigsResult.globalConfig = globalConfig;
      }
      if (isSuitesSkippingEnabled) {
        const globalConfig = {
          ...readConfigsResult.globalConfig,
          coverageReporters: ["none"],
          passWithNoTests: true
        };
        readConfigsResult.globalConfig = globalConfig;
      }
      return readConfigsResult;
    }
    __name(configureTestEnvironment, "configureTestEnvironment");
    function jestConfigAsyncWrapper(jestConfig) {
      shimmer.wrap(jestConfig, "readConfigs", (readConfigs) => async function() {
        const readConfigsResult = await readConfigs.apply(this, arguments);
        configureTestEnvironment(readConfigsResult);
        return readConfigsResult;
      });
      return jestConfig;
    }
    __name(jestConfigAsyncWrapper, "jestConfigAsyncWrapper");
    function jestConfigSyncWrapper(jestConfig) {
      shimmer.wrap(jestConfig, "readConfigs", (readConfigs) => function() {
        const readConfigsResult = readConfigs.apply(this, arguments);
        configureTestEnvironment(readConfigsResult);
        return readConfigsResult;
      });
      return jestConfig;
    }
    __name(jestConfigSyncWrapper, "jestConfigSyncWrapper");
    addHook({
      name: "@jest/core",
      versions: [">=24.8.0"],
      file: "build/SearchSource.js"
    }, (searchSourcePackage) => {
      const SearchSource = searchSourcePackage.default ? searchSourcePackage.default : searchSourcePackage;
      shimmer.wrap(SearchSource.prototype, "getTestPaths", (getTestPaths) => async function() {
        if (!skippableSuites.length) {
          return getTestPaths.apply(this, arguments);
        }
        const [{ rootDir }] = arguments;
        const testPaths = await getTestPaths.apply(this, arguments);
        const { tests } = testPaths;
        const filteredTests = tests.filter(({ path: testPath }) => {
          const relativePath = testPath.replace(`${rootDir}/`, "");
          return !skippableSuites.includes(relativePath);
        });
        skippableSuites = [];
        return { ...testPaths, tests: filteredTests };
      });
      return searchSourcePackage;
    });
    addHook({
      name: "jest-config",
      versions: [">=25.1.0"]
    }, jestConfigAsyncWrapper);
    addHook({
      name: "jest-config",
      versions: ["24.8.0 - 24.9.0"]
    }, jestConfigSyncWrapper);
    function jasmineAsyncInstallWraper(jasmineAsyncInstallExport, jestVersion) {
      return function(globalConfig, globalInput) {
        globalInput._ddtrace = global._ddtrace;
        shimmer.wrap(globalInput.jasmine.Spec.prototype, "execute", (execute) => function(onComplete) {
          const asyncResource = new AsyncResource("bound-anonymous-fn");
          asyncResource.runInAsyncScope(() => {
            const testSuite = getTestSuitePath(this.result.testPath, globalConfig.rootDir);
            testStartCh.publish({
              name: this.getFullName(),
              suite: testSuite,
              runner: "jest-jasmine2",
              frameworkVersion: jestVersion
            });
            const spec = this;
            const callback = asyncResource.bind(function() {
              if (spec.result.failedExpectations && spec.result.failedExpectations.length) {
                const formattedError = formatJestError(spec.result.failedExpectations[0].error);
                testErrCh.publish(formattedError);
              }
              testRunFinishCh.publish(specStatusToTestStatus[spec.result.status]);
              onComplete.apply(this, arguments);
            });
            arguments[0] = callback;
            execute.apply(this, arguments);
          });
        });
        return jasmineAsyncInstallExport.default(globalConfig, globalInput);
      };
    }
    __name(jasmineAsyncInstallWraper, "jasmineAsyncInstallWraper");
    addHook({
      name: "jest-jasmine2",
      versions: [">=24.8.0"],
      file: "build/jasmineAsyncInstall.js"
    }, jasmineAsyncInstallWraper);
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/koa.js
var require_koa = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/koa.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var enterChannel = channel("apm:koa:middleware:enter");
    var exitChannel = channel("apm:koa:middleware:exit");
    var errorChannel = channel("apm:koa:middleware:error");
    var nextChannel = channel("apm:koa:middleware:next");
    var finishChannel = channel("apm:koa:middleware:finish");
    var handleChannel = channel("apm:koa:request:handle");
    var routeChannel = channel("apm:koa:request:route");
    var originals = /* @__PURE__ */ new WeakMap();
    function wrapCallback(callback) {
      return /* @__PURE__ */ __name(function callbackWithTrace() {
        const handleRequest = callback.apply(this, arguments);
        if (typeof handleRequest !== "function")
          return handleRequest;
        return /* @__PURE__ */ __name(function handleRequestWithTrace(req, res) {
          handleChannel.publish({ req, res });
          return handleRequest.apply(this, arguments);
        }, "handleRequestWithTrace");
      }, "callbackWithTrace");
    }
    __name(wrapCallback, "wrapCallback");
    function wrapUse(use) {
      return /* @__PURE__ */ __name(function useWithTrace() {
        const result = use.apply(this, arguments);
        if (!Array.isArray(this.middleware))
          return result;
        const fn = this.middleware.pop();
        this.middleware.push(wrapMiddleware(fn));
        return result;
      }, "useWithTrace");
    }
    __name(wrapUse, "wrapUse");
    function wrapRegister(register) {
      return /* @__PURE__ */ __name(function registerWithTrace(path, methods, middleware, opts) {
        const route = register.apply(this, arguments);
        if (!Array.isArray(path) && route && Array.isArray(route.stack)) {
          wrapStack(route);
        }
        return route;
      }, "registerWithTrace");
    }
    __name(wrapRegister, "wrapRegister");
    function wrapRouterUse(use) {
      return /* @__PURE__ */ __name(function useWithTrace() {
        const router = use.apply(this, arguments);
        router.stack.forEach(wrapStack);
        return router;
      }, "useWithTrace");
    }
    __name(wrapRouterUse, "wrapRouterUse");
    function wrapStack(layer) {
      layer.stack = layer.stack.map((middleware) => {
        if (typeof middleware !== "function")
          return middleware;
        const original = originals.get(middleware);
        middleware = original || middleware;
        const handler2 = shimmer.wrap(middleware, wrapMiddleware(middleware, layer));
        originals.set(handler2, middleware);
        return handler2;
      });
    }
    __name(wrapStack, "wrapStack");
    function wrapMiddleware(fn, layer) {
      if (typeof fn !== "function")
        return fn;
      const name = fn.name;
      return function(ctx, next) {
        if (!ctx || !enterChannel.hasSubscribers)
          return fn.apply(this, arguments);
        const req = ctx.req;
        const path = layer && layer.path;
        const route = typeof path === "string" && !path.endsWith("(.*)") && !path.endsWith("([^/]*)") && path;
        enterChannel.publish({ req, name, route });
        if (typeof next === "function") {
          arguments[1] = wrapNext(req, next);
        }
        try {
          const result = fn.apply(this, arguments);
          if (result && typeof result.then === "function") {
            return result.then(
              (result2) => {
                fulfill(ctx);
                return result2;
              },
              (err) => {
                fulfill(ctx, err);
                throw err;
              }
            );
          } else {
            fulfill(ctx);
            return result;
          }
        } catch (e) {
          fulfill(ctx, e);
          throw e;
        } finally {
          exitChannel.publish({ req });
        }
      };
    }
    __name(wrapMiddleware, "wrapMiddleware");
    function fulfill(ctx, error) {
      const req = ctx.req;
      const route = ctx.routePath;
      if (error) {
        errorChannel.publish({ req, error });
      }
      if (route) {
        routeChannel.publish({ req, route });
      }
      finishChannel.publish({ req });
    }
    __name(fulfill, "fulfill");
    function wrapNext(req, next) {
      return function() {
        nextChannel.publish({ req });
        return next.apply(this, arguments);
      };
    }
    __name(wrapNext, "wrapNext");
    addHook({ name: "koa", versions: [">=2"] }, (Koa) => {
      shimmer.wrap(Koa.prototype, "callback", wrapCallback);
      shimmer.wrap(Koa.prototype, "use", wrapUse);
      return Koa;
    });
    addHook({ name: "@koa/router", versions: [">=8"] }, (Router) => {
      shimmer.wrap(Router.prototype, "register", wrapRegister);
      shimmer.wrap(Router.prototype, "use", wrapRouterUse);
      return Router;
    });
    addHook({ name: "koa-router", versions: [">=7"] }, (Router) => {
      shimmer.wrap(Router.prototype, "register", wrapRegister);
      shimmer.wrap(Router.prototype, "use", wrapRouterUse);
      return Router;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/redis.js
var require_redis = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/redis.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:redis:command:start");
    var finishCh = channel("apm:redis:command:finish");
    var errorCh = channel("apm:redis:command:error");
    function wrapAddCommand(addCommand) {
      return function(command) {
        if (!startCh.hasSubscribers) {
          return addCommand.apply(this, arguments);
        }
        const name = command[0];
        const args = command.slice(1);
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          start(this, name, args);
          const res = addCommand.apply(this, arguments);
          const onResolve = asyncResource.bind(() => finish(finishCh, errorCh));
          const onReject = asyncResource.bind((err) => finish(finishCh, errorCh, err));
          res.then(onResolve, onReject);
          return res;
        });
      };
    }
    __name(wrapAddCommand, "wrapAddCommand");
    addHook({ name: "@redis/client", file: "dist/lib/client/commands-queue.js", versions: [">=1.1"] }, (redis) => {
      shimmer.wrap(redis.default.prototype, "addCommand", wrapAddCommand);
      return redis;
    });
    addHook({ name: "@node-redis/client", file: "dist/lib/client/commands-queue.js", versions: [">=1"] }, (redis) => {
      shimmer.wrap(redis.default.prototype, "addCommand", wrapAddCommand);
      return redis;
    });
    addHook({ name: "redis", versions: [">=2.6 <4"] }, (redis) => {
      shimmer.wrap(redis.RedisClient.prototype, "internal_send_command", (internalSendCommand) => function(options) {
        if (!startCh.hasSubscribers)
          return internalSendCommand.apply(this, arguments);
        if (!options.callback)
          return internalSendCommand.apply(this, arguments);
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        const cb = callbackResource.bind(options.callback);
        return asyncResource.runInAsyncScope(() => {
          start(this, options.command, options.args);
          options.callback = asyncResource.bind(wrapCallback(finishCh, errorCh, cb));
          try {
            return internalSendCommand.apply(this, arguments);
          } catch (err) {
            errorCh.publish(err);
            throw err;
          }
        });
      });
      return redis;
    });
    addHook({ name: "redis", versions: [">=0.12 <2.6"] }, (redis) => {
      shimmer.wrap(redis.RedisClient.prototype, "send_command", (sendCommand) => function(command, args, callback) {
        if (!startCh.hasSubscribers) {
          return sendCommand.apply(this, arguments);
        }
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          start(this, command, args);
          if (typeof callback === "function") {
            const cb = callbackResource.bind(callback);
            arguments[2] = asyncResource.bind(wrapCallback(finishCh, errorCh, cb));
          } else if (Array.isArray(args) && typeof args[args.length - 1] === "function") {
            const cb = callbackResource.bind(args[args.length - 1]);
            args[args.length - 1] = asyncResource.bind(wrapCallback(finishCh, errorCh, cb));
          } else {
            arguments[2] = asyncResource.bind(wrapCallback(finishCh, errorCh));
          }
          try {
            return sendCommand.apply(this, arguments);
          } catch (err) {
            errorCh.publish(err);
            throw err;
          }
        });
      });
      return redis;
    });
    function start(client, command, args) {
      const db = client.selected_db;
      const connectionOptions = client.connection_options || client.connection_option || client.connectionOption || {};
      startCh.publish({ db, command, args, connectionOptions });
    }
    __name(start, "start");
    function wrapCallback(finishCh2, errorCh2, callback) {
      return function(err) {
        finish(finishCh2, errorCh2, err);
        if (callback) {
          return callback.apply(this, arguments);
        }
      };
    }
    __name(wrapCallback, "wrapCallback");
    function finish(finishCh2, errorCh2, error) {
      if (error) {
        errorCh2.publish(error);
      }
      finishCh2.publish();
    }
    __name(finish, "finish");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/opensearch.js
var require_opensearch = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/opensearch.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var { createWrapRequest } = require_elasticsearch();
    addHook({ name: "@opensearch-project/opensearch", file: "lib/Transport.js", versions: [">=1"] }, (Transport) => {
      shimmer.wrap(Transport.prototype, "request", createWrapRequest("opensearch"));
      return Transport;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/amqp10.js
var require_amqp10 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/amqp10.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "amqp10", file: "lib/sender_link.js", versions: [">=3"] }, (SenderLink) => {
      const startCh = channel("apm:amqp10:send:start");
      const finishCh = channel("apm:amqp10:send:finish");
      const errorCh = channel("apm:amqp10:send:error");
      shimmer.wrap(SenderLink.prototype, "send", (send) => function(msg, options) {
        if (!startCh.hasSubscribers) {
          return send.apply(this, arguments);
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          startCh.publish({ link: this });
          try {
            const promise = send.apply(this, arguments);
            if (!promise) {
              finish(finishCh, errorCh);
              return promise;
            }
            promise.then(
              asyncResource.bind(() => finish(finishCh, errorCh)),
              asyncResource.bind((e) => finish(finishCh, errorCh, e))
            );
            return promise;
          } catch (err) {
            finish(finishCh, errorCh, err);
            throw err;
          }
        });
      });
      return SenderLink;
    });
    addHook({ name: "amqp10", file: "lib/receiver_link.js", versions: [">=3"] }, (ReceiverLink) => {
      const startCh = channel("apm:amqp10:receive:start");
      const finishCh = channel("apm:amqp10:receive:finish");
      const errorCh = channel("apm:amqp10:receive:error");
      shimmer.wrap(ReceiverLink.prototype, "_messageReceived", (messageReceived) => function(transferFrame) {
        if (!transferFrame || transferFrame.aborted || transferFrame.more) {
          return messageReceived.apply(this, arguments);
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          startCh.publish({ link: this });
          try {
            return messageReceived.apply(this, arguments);
          } catch (err) {
            errorCh.publish(err);
            throw err;
          } finally {
            finishCh.publish();
          }
        });
      });
      return ReceiverLink;
    });
    function finish(finishCh, errorCh, error) {
      if (error) {
        errorCh.publish(error);
      }
      finishCh.publish();
    }
    __name(finish, "finish");
  }
});

// node_modules/lodash.kebabcase/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.kebabcase/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    __name(arrayReduce, "arrayReduce");
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    __name(asciiWords, "asciiWords");
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    __name(basePropertyOf, "basePropertyOf");
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    __name(hasUnicodeWord, "hasUnicodeWord");
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    __name(unicodeWords, "unicodeWords");
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(baseToString, "baseToString");
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    __name(createCompounder, "createCompounder");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol, "isSymbol");
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    __name(toString2, "toString");
    function deburr(string) {
      string = toString2(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    __name(deburr, "deburr");
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? "-" : "") + word.toLowerCase();
    });
    function words(string, pattern, guard) {
      string = toString2(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    __name(words, "words");
    module2.exports = kebabCase;
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/amqplib.js
var require_amqplib = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/amqplib.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var kebabCase = require_lodash4();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:amqplib:command:start");
    var finishCh = channel("apm:amqplib:command:finish");
    var errorCh = channel("apm:amqplib:command:error");
    var methods = {};
    addHook({ name: "amqplib", file: "lib/defs.js", versions: [">=0.5"] }, (defs) => {
      methods = Object.keys(defs).filter((key) => Number.isInteger(defs[key])).filter((key) => isCamelCase(key)).reduce((acc, key) => Object.assign(acc, { [defs[key]]: kebabCase(key).replace("-", ".") }), {});
      return defs;
    });
    addHook({ name: "amqplib", file: "lib/channel.js", versions: [">=0.5"] }, (channel2) => {
      shimmer.wrap(channel2.Channel.prototype, "sendImmediately", (sendImmediately) => function(method, fields) {
        return instrument(sendImmediately, this, arguments, methods[method], fields);
      });
      shimmer.wrap(channel2.Channel.prototype, "sendMessage", (sendMessage) => function(fields) {
        return instrument(sendMessage, this, arguments, "basic.publish", fields);
      });
      shimmer.wrap(channel2.BaseChannel.prototype, "dispatchMessage", (dispatchMessage) => function(fields, message) {
        return instrument(dispatchMessage, this, arguments, "basic.deliver", fields, message);
      });
      return channel2;
    });
    function instrument(send, channel2, args, method, fields, message) {
      if (!startCh.hasSubscribers) {
        return send.apply(channel2, args);
      }
      const asyncResource = new AsyncResource("bound-anonymous-fn");
      return asyncResource.runInAsyncScope(() => {
        startCh.publish({ channel: channel2, method, fields, message });
        try {
          return send.apply(channel2, args);
        } catch (err) {
          errorCh.publish(err);
          throw err;
        } finally {
          finishCh.publish();
        }
      });
    }
    __name(instrument, "instrument");
    function isCamelCase(str) {
      return /([A-Z][a-z0-9]+)+/.test(str);
    }
    __name(isCamelCase, "isCamelCase");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js
var require_promise = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/promise.js"(exports2) {
    "use strict";
    var { AsyncResource } = __require("async_hooks");
    exports2.wrapThen = /* @__PURE__ */ __name(function wrapThen(origThen) {
      return /* @__PURE__ */ __name(function then(onFulfilled, onRejected, onProgress) {
        const ar = new AsyncResource("bound-anonymous-fn");
        arguments[0] = wrapCallback(ar, onFulfilled);
        arguments[1] = wrapCallback(ar, onRejected);
        if (onProgress) {
          arguments[2] = wrapCallback(ar, onProgress);
        }
        return origThen.apply(this, arguments);
      }, "then");
    }, "wrapThen");
    function wrapCallback(ar, callback) {
      if (typeof callback !== "function")
        return callback;
      return function() {
        return ar.runInAsyncScope(() => {
          return callback.apply(this, arguments);
        });
      };
    }
    __name(wrapCallback, "wrapCallback");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/bluebird.js
var require_bluebird = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/bluebird.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise();
    var shimmer = require_datadog_shimmer();
    function createGetNewLibraryCopyWrap(originalLib) {
      return /* @__PURE__ */ __name(function wrapGetNewLibraryCopy(getNewLibraryCopy) {
        return /* @__PURE__ */ __name(function getNewLibraryCopyWithTrace() {
          const libraryCopy = getNewLibraryCopy.apply(this, arguments);
          shimmer.wrap(libraryCopy.prototype, "_then", wrapThen);
          shimmer.wrap(libraryCopy, "getNewLibraryCopy", createGetNewLibraryCopyWrap(originalLib));
          return libraryCopy;
        }, "getNewLibraryCopyWithTrace");
      }, "wrapGetNewLibraryCopy");
    }
    __name(createGetNewLibraryCopyWrap, "createGetNewLibraryCopyWrap");
    addHook({ name: "bluebird", versions: [">=2.0.2"] }, (Promise2) => {
      shimmer.wrap(Promise2.prototype, "_then", wrapThen);
      return Promise2;
    });
    addHook({ name: "bluebird", versions: ["^2.11.0", "^3.4.1"] }, (Promise2) => {
      shimmer.wrap(Promise2, "getNewLibraryCopy", createGetNewLibraryCopyWrap(Promise2));
      return Promise2;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/body-parser.js
var require_body_parser = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/body-parser.js"() {
    "use strict";
    var { channel, addHook, AsyncResource } = require_instrument();
    var bodyParserReadCh = channel("datadog:body-parser:read:finish");
    function publishRequestBodyAndNext(request, next) {
      return function() {
        if (bodyParserReadCh.hasSubscribers && request) {
          bodyParserReadCh.publish({ request });
        }
        next.apply(this, arguments);
      };
    }
    __name(publishRequestBodyAndNext, "publishRequestBodyAndNext");
    addHook({
      name: "body-parser",
      file: "lib/read.js",
      versions: [">=1"]
    }, (read) => {
      return function(req, res, next) {
        const nextResource = new AsyncResource("bound-anonymous-fn");
        arguments[2] = nextResource.bind(publishRequestBodyAndNext(req, next));
        read.apply(this, arguments);
      };
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/bunyan.js
var require_bunyan = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/bunyan.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "bunyan", versions: [">=1"] }, (Logger) => {
      const logCh = channel("apm:bunyan:log");
      shimmer.wrap(Logger.prototype, "_emit", (emit) => {
        return /* @__PURE__ */ __name(function wrappedEmit(rec) {
          if (logCh.hasSubscribers) {
            const payload2 = { message: rec };
            logCh.publish(payload2);
            arguments[0] = payload2.message;
          }
          return emit.apply(this, arguments);
        }, "wrappedEmit");
      });
      return Logger;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/cassandra-driver.js
var require_cassandra_driver = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/cassandra-driver.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:cassandra-driver:query:start");
    var finishCh = channel("apm:cassandra-driver:query:finish");
    var errorCh = channel("apm:cassandra-driver:query:error");
    var connectCh = channel(`apm:cassandra-driver:query:connect`);
    addHook({ name: "cassandra-driver", versions: [">=3.0.0"] }, (cassandra) => {
      shimmer.wrap(cassandra.Client.prototype, "batch", (batch) => function(queries, options, callback) {
        if (!startCh.hasSubscribers) {
          return batch.apply(this, arguments);
        }
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        const lastIndex = arguments.length - 1;
        let cb = arguments[lastIndex];
        if (typeof cb === "function") {
          cb = callbackResource.bind(cb);
          arguments[lastIndex] = wrapCallback(finishCh, errorCh, asyncResource, cb);
        }
        return asyncResource.runInAsyncScope(() => {
          startCh.publish({ keyspace: this.keyspace, query: queries });
          try {
            const res = batch.apply(this, arguments);
            if (typeof res === "function" || !res) {
              return wrapCallback(finishCh, errorCh, asyncResource, res);
            } else {
              const promiseAsyncResource = new AsyncResource("bound-anonymous-fn");
              return res.then(
                promiseAsyncResource.bind(() => finish(finishCh, errorCh)),
                promiseAsyncResource.bind((err) => finish(finishCh, errorCh, err))
              );
            }
          } catch (e) {
            finish(finishCh, errorCh, e);
            throw e;
          }
        });
      });
      return cassandra;
    });
    addHook({ name: "cassandra-driver", versions: [">=4.4"] }, (cassandra) => {
      shimmer.wrap(cassandra.Client.prototype, "_execute", (_execute) => function(query, params, execOptions, callback) {
        if (!startCh.hasSubscribers) {
          return _execute.apply(this, arguments);
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          startCh.publish({ keyspace: this.keyspace, query });
          const promise = _execute.apply(this, arguments);
          const promiseAsyncResource = new AsyncResource("bound-anonymous-fn");
          promise.then(
            promiseAsyncResource.bind(() => finish(finishCh, errorCh)),
            promiseAsyncResource.bind((err) => finish(finishCh, errorCh, err))
          );
          return promise;
        });
      });
      return cassandra;
    });
    addHook({ name: "cassandra-driver", versions: ["3 - 4.3"] }, (cassandra) => {
      shimmer.wrap(
        cassandra.Client.prototype,
        "_innerExecute",
        (_innerExecute) => function(query, params, execOptions, callback) {
          if (!startCh.hasSubscribers) {
            return _innerExecute.apply(this, arguments);
          }
          const callbackResource = new AsyncResource("bound-anonymous-fn");
          const asyncResource = new AsyncResource("bound-anonymous-fn");
          const isValid = /* @__PURE__ */ __name((args) => {
            return args.length === 4 || typeof args[3] === "function";
          }, "isValid");
          if (!isValid(arguments)) {
            return _innerExecute.apply(this, arguments);
          }
          return asyncResource.runInAsyncScope(() => {
            startCh.publish({ keyspace: this.keyspace, query });
            const lastIndex = arguments.length - 1;
            let cb = arguments[lastIndex];
            if (typeof cb === "function") {
              cb = callbackResource.bind(cb);
              arguments[lastIndex] = wrapCallback(finishCh, errorCh, asyncResource, cb);
            }
            try {
              return _innerExecute.apply(this, arguments);
            } catch (e) {
              finish(finishCh, errorCh, e);
              throw e;
            }
          });
        }
      );
      return cassandra;
    });
    addHook({ name: "cassandra-driver", versions: [">=3.3"], file: "lib/request-execution.js" }, (RequestExecution) => {
      shimmer.wrap(RequestExecution.prototype, "_sendOnConnection", (_sendOnConnection) => function() {
        if (!startCh.hasSubscribers) {
          return _sendOnConnection.apply(this, arguments);
        }
        connectCh.publish({ hostname: this._connection.address, port: this._connection.port });
        return _sendOnConnection.apply(this, arguments);
      });
      return RequestExecution;
    });
    addHook({ name: "cassandra-driver", versions: ["3.3 - 4.3"], file: "lib/request-execution.js" }, (RequestExecution) => {
      shimmer.wrap(RequestExecution.prototype, "start", (start) => function(getHostCallback) {
        if (!startCh.hasSubscribers) {
          return getHostCallback.apply(this, arguments);
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        const execution = this;
        if (!isRequestValid(this, arguments, 1)) {
          return start.apply(this, arguments);
        }
        getHostCallback = asyncResource.bind(getHostCallback);
        arguments[0] = AsyncResource.bind(function() {
          connectCh.publish({ hostname: execution._connection.address, port: execution._connection.port });
          return getHostCallback.apply(this, arguments);
        });
        return start.apply(this, arguments);
      });
      return RequestExecution;
    });
    addHook({ name: "cassandra-driver", versions: ["3 - 3.2"], file: "lib/request-handler.js" }, (RequestHandler) => {
      shimmer.wrap(RequestHandler.prototype, "send", (send) => function(request, options, callback) {
        if (!startCh.hasSubscribers) {
          return send.apply(this, arguments);
        }
        const handler2 = this;
        if (!isRequestValid(this, arguments, 3)) {
          return send.apply(this, arguments);
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        callback = asyncResource.bind(callback);
        arguments[2] = AsyncResource.bind(function() {
          connectCh.publish({ hostname: handler2.connection.address, port: handler2.connection.port });
          return callback.apply(this, arguments);
        });
        return send.apply(this, arguments);
      });
      return RequestHandler;
    });
    function finish(finishCh2, errorCh2, error) {
      if (error) {
        errorCh2.publish(error);
      }
      finishCh2.publish(void 0);
    }
    __name(finish, "finish");
    function wrapCallback(finishCh2, errorCh2, asyncResource, callback) {
      return asyncResource.bind(function(err) {
        finish(finishCh2, errorCh2, err);
        if (callback) {
          return callback.apply(this, arguments);
        }
      });
    }
    __name(wrapCallback, "wrapCallback");
    function isRequestValid(exec, args, length) {
      if (!exec)
        return false;
      if (args.length !== length || typeof args[length - 1] !== "function")
        return false;
      return true;
    }
    __name(isRequestValid, "isRequestValid");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/child-process.js
var require_child_process = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/child-process.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var childProcessChannel = channel("datadog:child_process:execution:start");
    var execMethods = ["exec", "execFile", "fork", "spawn", "execFileSync", "execSync", "spawnSync"];
    var names = ["child_process", "node:child_process"];
    names.forEach((name) => {
      addHook({ name }, (childProcess) => {
        shimmer.massWrap(childProcess, execMethods, wrapChildProcessMethod());
        return childProcess;
      });
    });
    function wrapChildProcessMethod() {
      function wrapMethod(childProcessMethod) {
        return function() {
          if (childProcessChannel.hasSubscribers && arguments.length > 0) {
            const command = arguments[0];
            childProcessChannel.publish({ command });
          }
          return childProcessMethod.apply(this, arguments);
        };
      }
      __name(wrapMethod, "wrapMethod");
      return wrapMethod;
    }
    __name(wrapChildProcessMethod, "wrapChildProcessMethod");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/connect.js
var require_connect = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/connect.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var enterChannel = channel("apm:connect:middleware:enter");
    var exitChannel = channel("apm:connect:middleware:exit");
    var errorChannel = channel("apm:connect:middleware:error");
    var nextChannel = channel("apm:connect:middleware:next");
    var finishChannel = channel("apm:connect:middleware:finish");
    var handleChannel = channel("apm:connect:request:handle");
    function wrapConnect(connect) {
      if (typeof connect !== "function")
        return connect;
      return /* @__PURE__ */ __name(function connectWithTrace() {
        const app = connect();
        if (!app)
          return app;
        shimmer.wrap(app, "use", wrapUse);
        shimmer.wrap(app, "handle", wrapHandle);
        return app;
      }, "connectWithTrace");
    }
    __name(wrapConnect, "wrapConnect");
    function wrapUse(use) {
      if (typeof use !== "function")
        return use;
      return /* @__PURE__ */ __name(function useWithTrace(route, fn) {
        const result = use.apply(this, arguments);
        if (!this || !Array.isArray(this.stack))
          return result;
        const index = this.stack.length - 1;
        const layer = this.stack[index];
        if (layer && layer.handle) {
          this.stack[index].handle = wrapLayerHandle(layer);
        }
        return result;
      }, "useWithTrace");
    }
    __name(wrapUse, "wrapUse");
    function wrapHandle(handle) {
      return /* @__PURE__ */ __name(function handleWithTrace(req, res) {
        if (handleChannel.hasSubscribers) {
          handleChannel.publish({ req, res });
        }
        return handle.apply(this, arguments);
      }, "handleWithTrace");
    }
    __name(wrapHandle, "wrapHandle");
    function wrapLayerHandle(layer) {
      if (typeof layer.handle !== "function")
        return layer.handle;
      const original = layer.handle;
      return shimmer.wrap(original, function() {
        if (!enterChannel.hasSubscribers)
          return original.apply(this, arguments);
        const lastIndex = arguments.length - 1;
        const name = original._name || original.name;
        const req = arguments[arguments.length > 3 ? 1 : 0];
        const next = arguments[lastIndex];
        if (typeof next === "function") {
          arguments[lastIndex] = wrapNext(req, next);
        }
        const route = layer.route;
        enterChannel.publish({ name, req, route });
        try {
          return original.apply(this, arguments);
        } catch (error) {
          errorChannel.publish({ req, error });
          nextChannel.publish({ req });
          finishChannel.publish({ req });
          throw error;
        } finally {
          exitChannel.publish({ req });
        }
      });
    }
    __name(wrapLayerHandle, "wrapLayerHandle");
    function wrapNext(req, next) {
      return function(error) {
        if (error) {
          errorChannel.publish({ req, error });
        }
        nextChannel.publish({ req });
        finishChannel.publish({ req });
        next.apply(this, arguments);
      };
    }
    __name(wrapNext, "wrapNext");
    addHook({ name: "connect", versions: [">=3"] }, (connect) => {
      return shimmer.wrap(connect, wrapConnect(connect));
    });
    addHook({ name: "connect", versions: ["2.2.2"] }, (connect) => {
      shimmer.wrap(connect.proto, "use", wrapUse);
      shimmer.wrap(connect.proto, "handle", wrapHandle);
      return connect;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/couchbase.js
var require_couchbase = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/couchbase.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function findCallbackIndex(args, lowerbound = 2) {
      for (let i = args.length - 1; i >= lowerbound; i--) {
        if (typeof args[i] === "function")
          return i;
      }
      return -1;
    }
    __name(findCallbackIndex, "findCallbackIndex");
    function getQueryResource(q) {
      return q && (typeof q === "string" ? q : q.statement);
    }
    __name(getQueryResource, "getQueryResource");
    function wrapAllNames(names, action) {
      names.forEach((name) => action(name));
    }
    __name(wrapAllNames, "wrapAllNames");
    function wrapMaybeInvoke(_maybeInvoke) {
      const wrapped = /* @__PURE__ */ __name(function(fn, args) {
        if (!Array.isArray(args))
          return _maybeInvoke.apply(this, arguments);
        const callbackIndex = args.length - 1;
        const callback = args[callbackIndex];
        if (callback instanceof Function) {
          args[callbackIndex] = AsyncResource.bind(callback);
        }
        return _maybeInvoke.apply(this, arguments);
      }, "wrapped");
      return shimmer.wrap(_maybeInvoke, wrapped);
    }
    __name(wrapMaybeInvoke, "wrapMaybeInvoke");
    function wrapQuery(query) {
      const wrapped = /* @__PURE__ */ __name(function(q, params, callback) {
        callback = AsyncResource.bind(arguments[arguments.length - 1]);
        if (typeof callback === "function") {
          arguments[arguments.length - 1] = callback;
        }
        const res = query.apply(this, arguments);
        return res;
      }, "wrapped");
      return shimmer.wrap(query, wrapped);
    }
    __name(wrapQuery, "wrapQuery");
    function wrap(prefix, fn) {
      const startCh = channel(prefix + ":start");
      const finishCh = channel(prefix + ":finish");
      const errorCh = channel(prefix + ":error");
      const wrapped = /* @__PURE__ */ __name(function() {
        if (!startCh.hasSubscribers) {
          return fn.apply(this, arguments);
        }
        const callbackIndex = findCallbackIndex(arguments);
        if (callbackIndex < 0)
          return fn.apply(this, arguments);
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          const cb = callbackResource.bind(arguments[callbackIndex]);
          startCh.publish({ bucket: { name: this.name || this._name } });
          arguments[callbackIndex] = asyncResource.bind(function(error, result) {
            if (error) {
              errorCh.publish(error);
            }
            finishCh.publish(result);
            return cb.apply(this, arguments);
          });
          try {
            return fn.apply(this, arguments);
          } catch (error) {
            error.stack;
            errorCh.publish(error);
            throw error;
          }
        });
      }, "wrapped");
      return shimmer.wrap(fn, wrapped);
    }
    __name(wrap, "wrap");
    function wrapCBandPromise(fn, name, startData, thisArg, args) {
      const startCh = channel(`apm:couchbase:${name}:start`);
      const finishCh = channel(`apm:couchbase:${name}:finish`);
      const errorCh = channel(`apm:couchbase:${name}:error`);
      if (!startCh.hasSubscribers)
        return fn.apply(thisArg, args);
      const asyncResource = new AsyncResource("bound-anonymous-fn");
      const callbackResource = new AsyncResource("bound-anonymous-fn");
      return asyncResource.runInAsyncScope(() => {
        startCh.publish(startData);
        try {
          const cbIndex = findCallbackIndex(args, 1);
          if (cbIndex >= 0) {
            const cb = callbackResource.bind(args[cbIndex]);
            args[cbIndex] = asyncResource.bind(function(error, result) {
              if (error) {
                errorCh.publish(error);
              }
              finishCh.publish({ result });
              return cb.apply(thisArg, arguments);
            });
          }
          const res = fn.apply(thisArg, args);
          res.then(
            asyncResource.bind((result) => finishCh.publish({ result })),
            asyncResource.bind((err) => errorCh.publish(err))
          );
          return res;
        } catch (e) {
          e.stack;
          errorCh.publish(e);
          throw e;
        }
      });
    }
    __name(wrapCBandPromise, "wrapCBandPromise");
    function wrapWithName(name) {
      return function(operation) {
        return function() {
          return wrapCBandPromise(operation, name, {
            collection: { name: this._name || "_default" },
            bucket: { name: this._scope._bucket._name }
          }, this, arguments);
        };
      };
    }
    __name(wrapWithName, "wrapWithName");
    function wrapV3Query(query) {
      return function(q) {
        const resource = getQueryResource(q);
        return wrapCBandPromise(query, "query", { resource }, this, arguments);
      };
    }
    __name(wrapV3Query, "wrapV3Query");
    addHook({ name: "couchbase", file: "lib/bucket.js", versions: ["^2.6.5"] }, (Bucket) => {
      const startCh = channel("apm:couchbase:query:start");
      const finishCh = channel("apm:couchbase:query:finish");
      const errorCh = channel("apm:couchbase:query:error");
      Bucket.prototype._maybeInvoke = wrapMaybeInvoke(Bucket.prototype._maybeInvoke);
      Bucket.prototype.query = wrapQuery(Bucket.prototype.query);
      shimmer.wrap(Bucket.prototype, "_n1qlReq", (_n1qlReq) => function(host, q, adhoc, emitter) {
        if (!startCh.hasSubscribers) {
          return _n1qlReq.apply(this, arguments);
        }
        if (!emitter || !emitter.once)
          return _n1qlReq.apply(this, arguments);
        const n1qlQuery = getQueryResource(q);
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          startCh.publish({ resource: n1qlQuery, bucket: { name: this.name || this._name } });
          emitter.once("rows", asyncResource.bind(() => {
            finishCh.publish(void 0);
          }));
          emitter.once("error", asyncResource.bind((error) => {
            errorCh.publish(error);
            finishCh.publish(void 0);
          }));
          try {
            return _n1qlReq.apply(this, arguments);
          } catch (err) {
            err.stack;
            errorCh.publish(err);
            throw err;
          }
        });
      });
      wrapAllNames(["upsert", "insert", "replace", "append", "prepend"], (name) => {
        Bucket.prototype[name] = wrap(`apm:couchbase:${name}`, Bucket.prototype[name]);
      });
      return Bucket;
    });
    addHook({ name: "couchbase", file: "lib/cluster.js", versions: ["^2.6.5"] }, (Cluster) => {
      Cluster.prototype._maybeInvoke = wrapMaybeInvoke(Cluster.prototype._maybeInvoke);
      Cluster.prototype.query = wrapQuery(Cluster.prototype.query);
      return Cluster;
    });
    addHook({ name: "couchbase", file: "lib/collection.js", versions: [">=3.0.0 <3.2.0"] }, (Collection) => {
      wrapAllNames(["upsert", "insert", "replace"], (name) => {
        shimmer.wrap(Collection.prototype, name, wrapWithName(name));
      });
      return Collection;
    });
    addHook({ name: "couchbase", file: "lib/cluster.js", versions: [">=3.0.0 <3.2.0"] }, (Cluster) => {
      shimmer.wrap(Cluster.prototype, "query", wrapV3Query);
      return Cluster;
    });
    addHook({ name: "couchbase", file: "dist/collection.js", versions: [">=3.2.0"] }, (collection) => {
      const Collection = collection.Collection;
      wrapAllNames(["upsert", "insert", "replace"], (name) => {
        shimmer.wrap(Collection.prototype, name, wrapWithName(name));
      });
      return collection;
    });
    addHook({ name: "couchbase", file: "dist/cluster.js", versions: ["3.2.0 - 3.2.1", ">=3.2.2"] }, (cluster) => {
      const Cluster = cluster.Cluster;
      shimmer.wrap(Cluster.prototype, "query", wrapV3Query);
      return cluster;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/crypto.js
var require_crypto = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/crypto.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var cryptoHashCh = channel("datadog:crypto:hashing:start");
    var cryptoCipherCh = channel("datadog:crypto:cipher:start");
    var hashMethods = ["createHash", "createHmac", "createSign", "createVerify", "sign", "verify"];
    var cipherMethods = ["createCipheriv", "createDecipheriv"];
    addHook({ name: "crypto" }, (crypto2) => {
      shimmer.massWrap(crypto2, hashMethods, wrapCryptoMethod(cryptoHashCh));
      shimmer.massWrap(crypto2, cipherMethods, wrapCryptoMethod(cryptoCipherCh));
      return crypto2;
    });
    function wrapCryptoMethod(channel2) {
      function wrapMethod(cryptoMethod) {
        return function() {
          if (channel2.hasSubscribers && arguments.length > 0) {
            const algorithm = arguments[0];
            channel2.publish({ algorithm });
          }
          return cryptoMethod.apply(this, arguments);
        };
      }
      __name(wrapMethod, "wrapMethod");
      return wrapMethod;
    }
    __name(wrapCryptoMethod, "wrapCryptoMethod");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/cypress.js
var require_cypress = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/cypress.js"() {
    var { addHook } = require_instrument();
    addHook({
      name: "cypress",
      versions: [">=6.7.0"]
    }, (lib) => lib);
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/dns.js
var require_dns = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/dns.js"() {
    "use strict";
    var { channel, addHook, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var rrtypes = {
      resolveAny: "ANY",
      resolve4: "A",
      resolve6: "AAAA",
      resolveCname: "CNAME",
      resolveMx: "MX",
      resolveNs: "NS",
      resolveTxt: "TXT",
      resolveSrv: "SRV",
      resolvePtr: "PTR",
      resolveNaptr: "NAPTR",
      resolveSoa: "SOA"
    };
    var rrtypeMap = /* @__PURE__ */ new WeakMap();
    addHook({ name: "dns" }, (dns) => {
      dns.lookup = wrap("apm:dns:lookup", dns.lookup, 2);
      dns.lookupService = wrap("apm:dns:lookup_service", dns.lookupService, 3);
      dns.resolve = wrap("apm:dns:resolve", dns.resolve, 2);
      dns.reverse = wrap("apm:dns:reverse", dns.reverse, 2);
      patchResolveShorthands(dns);
      if (dns.Resolver) {
        dns.Resolver.prototype.resolve = wrap("apm:dns:resolve", dns.Resolver.prototype.resolve, 2);
        dns.Resolver.prototype.reverse = wrap("apm:dns:reverse", dns.Resolver.prototype.reverse, 2);
        patchResolveShorthands(dns.Resolver.prototype);
      }
      return dns;
    });
    function patchResolveShorthands(prototype) {
      Object.keys(rrtypes).filter((method) => !!prototype[method]).forEach((method) => {
        rrtypeMap.set(prototype[method], rrtypes[method]);
        prototype[method] = wrap("apm:dns:resolve", prototype[method], 2, rrtypes[method]);
      });
    }
    __name(patchResolveShorthands, "patchResolveShorthands");
    function wrap(prefix, fn, expectedArgs, rrtype) {
      const startCh = channel(prefix + ":start");
      const finishCh = channel(prefix + ":finish");
      const errorCh = channel(prefix + ":error");
      const wrapped = /* @__PURE__ */ __name(function() {
        const cb = AsyncResource.bind(arguments[arguments.length - 1]);
        if (!startCh.hasSubscribers || arguments.length < expectedArgs || typeof cb !== "function") {
          return fn.apply(this, arguments);
        }
        const startArgs = Array.from(arguments);
        startArgs.pop();
        if (rrtype) {
          startArgs.push(rrtype);
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          startCh.publish(startArgs);
          arguments[arguments.length - 1] = asyncResource.bind(function(error, result) {
            if (error) {
              errorCh.publish(error);
            }
            finishCh.publish(result);
            cb.apply(this, arguments);
          });
          try {
            return fn.apply(this, arguments);
          } catch (error) {
            error.stack;
            errorCh.publish(error);
            throw error;
          }
        });
      }, "wrapped");
      return shimmer.wrap(fn, wrapped);
    }
    __name(wrap, "wrap");
  }
});

// node_modules/methods/index.js
var require_methods = __commonJS({
  "node_modules/methods/index.js"(exports2, module2) {
    "use strict";
    var http = __require("http");
    module2.exports = getCurrentNodeMethods() || getBasicNodeMethods();
    function getCurrentNodeMethods() {
      return http.METHODS && http.METHODS.map(/* @__PURE__ */ __name(function lowerCaseMethod(method) {
        return method.toLowerCase();
      }, "lowerCaseMethod"));
    }
    __name(getCurrentNodeMethods, "getCurrentNodeMethods");
    function getBasicNodeMethods() {
      return [
        "get",
        "post",
        "put",
        "head",
        "delete",
        "options",
        "trace",
        "copy",
        "lock",
        "mkcol",
        "move",
        "purge",
        "propfind",
        "proppatch",
        "unlock",
        "report",
        "mkactivity",
        "checkout",
        "merge",
        "m-search",
        "notify",
        "subscribe",
        "unsubscribe",
        "patch",
        "search",
        "connect"
      ];
    }
    __name(getBasicNodeMethods, "getBasicNodeMethods");
  }
});

// node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  "node_modules/path-to-regexp/index.js"(exports2, module2) {
    module2.exports = pathtoRegexp;
    var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
    function pathtoRegexp(path, keys, options) {
      options = options || {};
      keys = keys || [];
      var strict = options.strict;
      var end = options.end !== false;
      var flags = options.sensitive ? "" : "i";
      var extraOffset = 0;
      var keysOffset = keys.length;
      var i = 0;
      var name = 0;
      var m;
      if (path instanceof RegExp) {
        while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
          keys.push({
            name: name++,
            optional: false,
            offset: m.index
          });
        }
        return path;
      }
      if (Array.isArray(path)) {
        path = path.map(function(value) {
          return pathtoRegexp(value, keys, options).source;
        });
        return new RegExp("(?:" + path.join("|") + ")", flags);
      }
      path = ("^" + path + (strict ? "" : path[path.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match, slash, format, key, capture, star, optional, offset) {
        slash = slash || "";
        format = format || "";
        capture = capture || "([^\\/" + format + "]+?)";
        optional = optional || "";
        keys.push({
          name: key,
          optional: !!optional,
          offset: offset + extraOffset
        });
        var result = "" + (optional ? "" : slash) + "(?:" + format + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format + "].+?)?)" : "") + ")" + optional;
        extraOffset += result.length - match.length;
        return result;
      }).replace(/\*/g, function(star, index2) {
        var len = keys.length;
        while (len-- > keysOffset && keys[len].offset > index2) {
          keys[len].offset += 3;
        }
        return "(.*)";
      });
      while (m = MATCHING_GROUP_REGEXP.exec(path)) {
        var escapeCount = 0;
        var index = m.index;
        while (path.charAt(--index) === "\\") {
          escapeCount++;
        }
        if (escapeCount % 2 === 1) {
          continue;
        }
        if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
          keys.splice(keysOffset + i, 0, {
            name: name++,
            optional: false,
            offset: m.index
          });
        }
        i++;
      }
      path += end ? "$" : path[path.length - 1] === "/" ? "" : "(?=\\/|$)";
      return new RegExp(path, flags);
    }
    __name(pathtoRegexp, "pathtoRegexp");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/router.js
var require_router = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/router.js"(exports2, module2) {
    "use strict";
    var METHODS = require_methods().concat("all");
    var pathToRegExp = require_path_to_regexp();
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    function createWrapRouterMethod(name) {
      const enterChannel = channel(`apm:${name}:middleware:enter`);
      const exitChannel = channel(`apm:${name}:middleware:exit`);
      const finishChannel = channel(`apm:${name}:middleware:finish`);
      const errorChannel = channel(`apm:${name}:middleware:error`);
      const nextChannel = channel(`apm:${name}:middleware:next`);
      const layerMatchers = /* @__PURE__ */ new WeakMap();
      const regexpCache = /* @__PURE__ */ Object.create(null);
      function wrapLayerHandle(layer, original) {
        original._name = original._name || layer.name;
        const handle = shimmer.wrap(original, function() {
          if (!enterChannel.hasSubscribers)
            return original.apply(this, arguments);
          const matchers = layerMatchers.get(layer);
          const lastIndex = arguments.length - 1;
          const name2 = original._name || original.name;
          const req = arguments[arguments.length > 3 ? 1 : 0];
          const next = arguments[lastIndex];
          if (typeof next === "function") {
            arguments[lastIndex] = wrapNext(req, next);
          }
          let route;
          if (matchers) {
            for (let i = 0; i < matchers.length; i++) {
              if (matchers[i].test(layer)) {
                route = matchers[i].path;
                break;
              }
            }
          }
          enterChannel.publish({ name: name2, req, route });
          try {
            return original.apply(this, arguments);
          } catch (error) {
            errorChannel.publish({ req, error });
            nextChannel.publish({ req });
            finishChannel.publish({ req });
            throw error;
          } finally {
            exitChannel.publish({ req });
          }
        });
        handle._datadog_orig = original;
        return handle;
      }
      __name(wrapLayerHandle, "wrapLayerHandle");
      function wrapStack(stack, offset, matchers) {
        [].concat(stack).slice(offset).forEach((layer) => {
          if (layer.__handle) {
            layer.__handle = wrapLayerHandle(layer, layer.__handle);
          } else {
            layer.handle = wrapLayerHandle(layer, layer.handle);
          }
          layerMatchers.set(layer, matchers);
          if (layer.route) {
            METHODS.forEach((method) => {
              if (typeof layer.route.stack === "function") {
                layer.route.stack = [{ handle: layer.route.stack }];
              }
              layer.route[method] = wrapMethod(layer.route[method]);
            });
          }
        });
      }
      __name(wrapStack, "wrapStack");
      function wrapNext(req, next) {
        return function(error) {
          if (error && error !== "route" && error !== "router") {
            errorChannel.publish({ req, error });
          }
          nextChannel.publish({ req });
          finishChannel.publish({ req });
          next.apply(this, arguments);
        };
      }
      __name(wrapNext, "wrapNext");
      function extractMatchers(fn) {
        const arg = flatten([].concat(fn));
        if (typeof arg[0] === "function") {
          return [];
        }
        return arg.map((pattern) => ({
          path: pattern instanceof RegExp ? `(${pattern})` : pattern,
          test: (layer) => {
            const matchers = layerMatchers.get(layer);
            return !isFastStar(layer, matchers) && !isFastSlash(layer, matchers) && cachedPathToRegExp(pattern).test(layer.path);
          }
        }));
      }
      __name(extractMatchers, "extractMatchers");
      function isFastStar(layer, matchers) {
        if (layer.regexp.fast_star !== void 0) {
          return layer.regexp.fast_star;
        }
        return matchers.some((matcher) => matcher.path === "*");
      }
      __name(isFastStar, "isFastStar");
      function isFastSlash(layer, matchers) {
        if (layer.regexp.fast_slash !== void 0) {
          return layer.regexp.fast_slash;
        }
        return matchers.some((matcher) => matcher.path === "/");
      }
      __name(isFastSlash, "isFastSlash");
      function flatten(arr) {
        return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);
      }
      __name(flatten, "flatten");
      function cachedPathToRegExp(pattern) {
        const maybeCached = regexpCache[pattern];
        if (maybeCached) {
          return maybeCached;
        }
        const regexp = pathToRegExp(pattern);
        regexpCache[pattern] = regexp;
        return regexp;
      }
      __name(cachedPathToRegExp, "cachedPathToRegExp");
      function wrapMethod(original) {
        return /* @__PURE__ */ __name(function methodWithTrace(fn) {
          const offset = this.stack ? [].concat(this.stack).length : 0;
          const router = original.apply(this, arguments);
          if (typeof this.stack === "function") {
            this.stack = [{ handle: this.stack }];
          }
          wrapStack(this.stack, offset, extractMatchers(fn));
          return router;
        }, "methodWithTrace");
      }
      __name(wrapMethod, "wrapMethod");
      return wrapMethod;
    }
    __name(createWrapRouterMethod, "createWrapRouterMethod");
    var wrapRouterMethod = createWrapRouterMethod("router");
    addHook({ name: "router", versions: [">=1"] }, (Router) => {
      shimmer.wrap(Router.prototype, "use", wrapRouterMethod);
      shimmer.wrap(Router.prototype, "route", wrapRouterMethod);
      return Router;
    });
    module2.exports = { createWrapRouterMethod };
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/express.js
var require_express = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/express.js"() {
    "use strict";
    var { createWrapRouterMethod } = require_router();
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var handleChannel = channel("apm:express:request:handle");
    function wrapHandle(handle) {
      return /* @__PURE__ */ __name(function handleWithTrace(req, res) {
        if (handleChannel.hasSubscribers) {
          handleChannel.publish({ req });
        }
        return handle.apply(this, arguments);
      }, "handleWithTrace");
    }
    __name(wrapHandle, "wrapHandle");
    var wrapRouterMethod = createWrapRouterMethod("express");
    addHook({ name: "express", versions: [">=4"] }, (express) => {
      shimmer.wrap(express.application, "handle", wrapHandle);
      shimmer.wrap(express.Router, "use", wrapRouterMethod);
      shimmer.wrap(express.Router, "route", wrapRouterMethod);
      return express;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/fastify.js
var require_fastify = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/fastify.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel, AsyncResource } = require_instrument();
    var errorChannel = channel("apm:fastify:middleware:error");
    var handleChannel = channel("apm:fastify:request:handle");
    var parsingResources = /* @__PURE__ */ new WeakMap();
    function wrapFastify(fastify, hasParsingEvents) {
      if (typeof fastify !== "function")
        return fastify;
      return /* @__PURE__ */ __name(function fastifyWithTrace() {
        const app = fastify.apply(this, arguments);
        if (!app || typeof app.addHook !== "function")
          return app;
        app.addHook("onRequest", onRequest);
        app.addHook("preHandler", preHandler);
        if (hasParsingEvents) {
          app.addHook("preParsing", preParsing);
          app.addHook("preValidation", preValidation);
        } else {
          app.addHook("onRequest", preParsing);
          app.addHook("preHandler", preValidation);
        }
        app.addHook = wrapAddHook(app.addHook);
        return app;
      }, "fastifyWithTrace");
    }
    __name(wrapFastify, "wrapFastify");
    function wrapAddHook(addHook2) {
      return /* @__PURE__ */ __name(function addHookWithTrace(name, fn) {
        fn = arguments[arguments.length - 1];
        if (typeof fn !== "function")
          return addHook2.apply(this, arguments);
        arguments[arguments.length - 1] = shimmer.wrap(fn, function(request, reply, done) {
          const req = getReq(request);
          try {
            if (typeof done === "function") {
              done = arguments[arguments.length - 1];
              arguments[arguments.length - 1] = function(err) {
                publishError(err, req);
                if (name === "onRequest" || name === "preParsing") {
                  const parsingResource = new AsyncResource("bound-anonymous-fn");
                  parsingResources.set(req, parsingResource);
                  return parsingResource.runInAsyncScope(() => {
                    return done.apply(this, arguments);
                  });
                } else {
                  return done.apply(this, arguments);
                }
              };
              return fn.apply(this, arguments);
            } else {
              const promise = fn.apply(this, arguments);
              if (promise && typeof promise.catch === "function") {
                return promise.catch((err) => publishError(err, req));
              }
              return promise;
            }
          } catch (e) {
            throw publishError(e, req);
          }
        });
        return addHook2.apply(this, arguments);
      }, "addHookWithTrace");
    }
    __name(wrapAddHook, "wrapAddHook");
    function onRequest(request, reply, done) {
      if (typeof done !== "function")
        return;
      const req = getReq(request);
      const res = getRes(reply);
      handleChannel.publish({ req, res });
      return done();
    }
    __name(onRequest, "onRequest");
    function preHandler(request, reply, done) {
      if (typeof done !== "function")
        return;
      if (!reply || typeof reply.send !== "function")
        return done();
      const req = getReq(request);
      reply.send = wrapSend(reply.send, req);
      done();
    }
    __name(preHandler, "preHandler");
    function preValidation(request, reply, done) {
      const req = getReq(request);
      const parsingResource = parsingResources.get(req);
      if (!parsingResource)
        return done();
      parsingResource.runInAsyncScope(() => done());
    }
    __name(preValidation, "preValidation");
    function preParsing(request, reply, payload2, done) {
      if (typeof done !== "function") {
        done = payload2;
      }
      const req = getReq(request);
      const parsingResource = new AsyncResource("bound-anonymous-fn");
      parsingResources.set(req, parsingResource);
      parsingResource.runInAsyncScope(() => done());
    }
    __name(preParsing, "preParsing");
    function wrapSend(send, req) {
      return /* @__PURE__ */ __name(function sendWithTrace(error) {
        if (error instanceof Error) {
          errorChannel.publish({ req, error });
        }
        return send.apply(this, arguments);
      }, "sendWithTrace");
    }
    __name(wrapSend, "wrapSend");
    function getReq(request) {
      return request && (request.raw || request.req || request);
    }
    __name(getReq, "getReq");
    function getRes(reply) {
      return reply && (reply.raw || reply.res || reply);
    }
    __name(getRes, "getRes");
    function publishError(error, req) {
      if (error) {
        errorChannel.publish({ error, req });
      }
      return error;
    }
    __name(publishError, "publishError");
    addHook({ name: "fastify", versions: [">=3"] }, (fastify) => {
      const wrapped = shimmer.wrap(fastify, wrapFastify(fastify, true));
      wrapped.fastify = wrapped;
      wrapped.default = wrapped;
      return wrapped;
    });
    addHook({ name: "fastify", versions: ["2"] }, (fastify) => {
      return shimmer.wrap(fastify, wrapFastify(fastify, true));
    });
    addHook({ name: "fastify", versions: ["1"] }, (fastify) => {
      return shimmer.wrap(fastify, wrapFastify(fastify, false));
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/find-my-way.js
var require_find_my_way = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/find-my-way.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var routeChannel = channel("apm:find-my-way:request:route");
    function wrapOn(on) {
      return /* @__PURE__ */ __name(function onWithTrace(method, path, opts) {
        const index = typeof opts === "function" ? 2 : 3;
        const handler2 = arguments[index];
        const wrapper = /* @__PURE__ */ __name(function(req) {
          routeChannel.publish({ req, route: path });
          return handler2.apply(this, arguments);
        }, "wrapper");
        if (typeof handler2 === "function") {
          arguments[index] = wrapper;
        }
        return on.apply(this, arguments);
      }, "onWithTrace");
    }
    __name(wrapOn, "wrapOn");
    addHook({ name: "find-my-way", versions: [">=1"] }, (Router) => {
      shimmer.wrap(Router.prototype, "on", wrapOn);
      return Router;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/fs.js
var require_fs = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/fs.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startChannel = channel("apm:fs:operation:start");
    var finishChannel = channel("apm:fs:operation:finish");
    var errorChannel = channel("apm:fs:operation:error");
    var ddFhSym = Symbol("ddFileHandle");
    var kHandle;
    var kDirReadPromisified;
    var kDirClosePromisified;
    var paramsByMethod = {
      access: ["path", "mode"],
      appendFile: ["path", "data", "options"],
      chmod: ["path", "mode"],
      chown: ["path", "uid", "gid"],
      close: ["fd"],
      copyFile: ["src", "dest", "mode"],
      cp: ["src", "dest", "options"],
      exists: ["path"],
      fchmod: ["fd", "mode"],
      fchown: ["fd", "uid", "gid"],
      fdatasync: ["fd"],
      fstat: ["fd", "options"],
      fsync: ["fd"],
      ftruncate: ["fd", "len"],
      futimes: ["fd", "atime", "mtime"],
      lchmod: ["path", "mode"],
      lchown: ["path", "uid", "gid"],
      link: ["existingPath", "newPath"],
      lstat: ["path", "options"],
      lutimes: ["path", "atime", "mtime"],
      mkdir: ["path", "options"],
      mkdtemp: ["prefix", "options"],
      open: ["path", "flag", "mode"],
      opendir: ["path", "options"],
      read: ["fd"],
      readdir: ["path", "options"],
      readFile: ["path", "options"],
      readlink: ["path", "options"],
      readv: ["fd"],
      realpath: ["path", "options"],
      rename: ["oldPath", "newPath"],
      rmdir: ["path", "options"],
      rm: ["path", "options"],
      stat: ["path", "options"],
      symlink: ["target", "path", "type"],
      truncate: ["path", "len"],
      unlink: ["path"],
      utimes: ["path", "atime", "mtime"],
      write: ["fd"],
      writeFile: ["file", "data", "options"],
      writev: ["fd"]
    };
    var watchMethods = {
      unwatchFile: ["path", "listener"],
      watch: ["path", "options", "listener"],
      watchFile: ["path", "options", "listener"]
    };
    var paramsByFileHandleMethods = {
      appendFile: ["data", "options"],
      chmod: ["mode"],
      chown: ["uid", "gid"],
      close: [],
      createReadStream: ["options"],
      createWriteStream: ["options"],
      datasync: [],
      read: ["buffer", "offset", "length", "position"],
      readableWebStream: [],
      readFile: ["options"],
      readLines: ["options"],
      readv: ["buffers", "position"],
      stat: ["options"],
      sync: [],
      truncate: ["len"],
      utimes: ["atime", "mtime"],
      write: ["buffer", "offset", "length", "position"],
      writeFile: ["data", "options"],
      writev: ["buffers", "position"]
    };
    var names = ["fs", "node:fs"];
    names.forEach((name) => {
      addHook({ name }, (fs) => {
        const asyncMethods = Object.keys(paramsByMethod);
        const syncMethods = asyncMethods.map((name2) => `${name2}Sync`);
        massWrap(fs, asyncMethods, createWrapFunction());
        massWrap(fs, syncMethods, createWrapFunction());
        massWrap(fs.promises, asyncMethods, createWrapFunction("promises."));
        wrap(fs.realpath, "native", createWrapFunction("", "realpath.native"));
        wrap(fs.realpathSync, "native", createWrapFunction("", "realpath.native"));
        wrap(fs.promises.realpath, "native", createWrapFunction("", "realpath.native"));
        wrap(fs, "createReadStream", wrapCreateStream);
        wrap(fs, "createWriteStream", wrapCreateStream);
        if (fs.Dir) {
          wrap(fs.Dir.prototype, "close", createWrapFunction("dir."));
          wrap(fs.Dir.prototype, "closeSync", createWrapFunction("dir."));
          wrap(fs.Dir.prototype, "read", createWrapFunction("dir."));
          wrap(fs.Dir.prototype, "readSync", createWrapFunction("dir."));
          wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator());
        }
        wrap(fs, "unwatchFile", createWatchWrapFunction());
        wrap(fs, "watch", createWatchWrapFunction());
        wrap(fs, "watchFile", createWatchWrapFunction());
        return fs;
      });
    });
    function isFirstMethodReturningFileHandle(original) {
      return !kHandle && original.name === "open";
    }
    __name(isFirstMethodReturningFileHandle, "isFirstMethodReturningFileHandle");
    function wrapFileHandle(fh) {
      const fileHandlePrototype = getFileHandlePrototype(fh);
      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle);
      if (!desc || !desc.get) {
        Reflect.defineProperty(fileHandlePrototype, kHandle, {
          get() {
            return this[ddFhSym];
          },
          set(h) {
            this[ddFhSym] = h;
            wrap(this, "close", createWrapFunction("filehandle."));
          },
          configurable: true
        });
      }
      for (const name of Reflect.ownKeys(fileHandlePrototype)) {
        if (typeof name !== "string" || name === "constructor" || name === "fd" || name === "getAsyncId") {
          continue;
        }
        wrap(fileHandlePrototype, name, createWrapFunction("filehandle."));
      }
    }
    __name(wrapFileHandle, "wrapFileHandle");
    function getFileHandlePrototype(fh) {
      if (!kHandle) {
        kHandle = Reflect.ownKeys(fh).find((key) => typeof key === "symbol" && key.toString().includes("kHandle"));
      }
      return Object.getPrototypeOf(fh);
    }
    __name(getFileHandlePrototype, "getFileHandlePrototype");
    function getSymbolName(sym) {
      return sym.description || sym.toString();
    }
    __name(getSymbolName, "getSymbolName");
    function initDirAsyncIteratorProperties(iterator) {
      const keys = Reflect.ownKeys(iterator);
      for (const key of keys) {
        if (kDirReadPromisified && kDirClosePromisified)
          break;
        if (typeof key !== "symbol")
          continue;
        if (!kDirReadPromisified && getSymbolName(key).includes("kDirReadPromisified")) {
          kDirReadPromisified = key;
        }
        if (!kDirClosePromisified && getSymbolName(key).includes("kDirClosePromisified")) {
          kDirClosePromisified = key;
        }
      }
    }
    __name(initDirAsyncIteratorProperties, "initDirAsyncIteratorProperties");
    function createWrapDirAsyncIterator() {
      return /* @__PURE__ */ __name(function wrapDirAsyncIterator(asyncIterator) {
        return /* @__PURE__ */ __name(function wrappedAsyncIterator() {
          if (!kDirReadPromisified || !kDirClosePromisified) {
            initDirAsyncIteratorProperties(this);
          }
          wrap(this, kDirReadPromisified, createWrapFunction("dir.", "read"));
          wrap(this, kDirClosePromisified, createWrapFunction("dir.", "close"));
          return asyncIterator.apply(this, arguments);
        }, "wrappedAsyncIterator");
      }, "wrapDirAsyncIterator");
    }
    __name(createWrapDirAsyncIterator, "createWrapDirAsyncIterator");
    function wrapCreateStream(original) {
      const classes = {
        createReadStream: "ReadStream",
        createWriteStream: "WriteStream"
      };
      const name = classes[original.name];
      return function(path, options) {
        if (!startChannel.hasSubscribers)
          return original.apply(this, arguments);
        const innerResource = new AsyncResource("bound-anonymous-fn");
        const message = getMessage(name, ["path", "options"], arguments);
        return innerResource.runInAsyncScope(() => {
          startChannel.publish(message);
          try {
            const stream = original.apply(this, arguments);
            const onError = innerResource.bind((error) => {
              errorChannel.publish(error);
              onFinish();
            });
            const onFinish = innerResource.bind(() => {
              finishChannel.publish();
              stream.off("close", onFinish);
              stream.off("end", onFinish);
              stream.off("finish", onFinish);
              stream.off("error", onError);
            });
            stream.once("close", onFinish);
            stream.once("end", onFinish);
            stream.once("finish", onFinish);
            stream.once("error", onError);
            return stream;
          } catch (error) {
            errorChannel.publish(error);
            finishChannel.publish();
          }
        });
      };
    }
    __name(wrapCreateStream, "wrapCreateStream");
    function getMethodParamsRelationByPrefix(prefix) {
      if (prefix === "filehandle.") {
        return paramsByFileHandleMethods;
      }
      return paramsByMethod;
    }
    __name(getMethodParamsRelationByPrefix, "getMethodParamsRelationByPrefix");
    function createWatchWrapFunction(override = "") {
      return /* @__PURE__ */ __name(function wrapFunction(original) {
        const name = override || original.name;
        const method = name;
        const operation = name;
        return function() {
          if (!startChannel.hasSubscribers)
            return original.apply(this, arguments);
          const message = getMessage(method, watchMethods[operation], arguments, this);
          const innerResource = new AsyncResource("bound-anonymous-fn");
          return innerResource.runInAsyncScope(() => {
            startChannel.publish(message);
            try {
              const result = original.apply(this, arguments);
              finishChannel.publish();
              return result;
            } catch (error) {
              errorChannel.publish(error);
              finishChannel.publish();
              throw error;
            }
          });
        };
      }, "wrapFunction");
    }
    __name(createWatchWrapFunction, "createWatchWrapFunction");
    function createWrapFunction(prefix = "", override = "") {
      return /* @__PURE__ */ __name(function wrapFunction(original) {
        const name = override || original.name;
        const method = `${prefix}${name}`;
        const operation = name.match(/^(.+?)(Sync)?(\.native)?$/)[1];
        return function() {
          if (!startChannel.hasSubscribers)
            return original.apply(this, arguments);
          const lastIndex = arguments.length - 1;
          const cb = typeof arguments[lastIndex] === "function" && arguments[lastIndex];
          const innerResource = new AsyncResource("bound-anonymous-fn");
          const message = getMessage(method, getMethodParamsRelationByPrefix(prefix)[operation], arguments, this);
          if (cb) {
            const outerResource = new AsyncResource("bound-anonymous-fn");
            arguments[lastIndex] = innerResource.bind(function(e) {
              if (typeof e === "object") {
                errorChannel.publish(e);
              }
              finishChannel.publish();
              return outerResource.runInAsyncScope(() => cb.apply(this, arguments));
            });
          }
          return innerResource.runInAsyncScope(() => {
            startChannel.publish(message);
            try {
              const result = original.apply(this, arguments);
              if (cb)
                return result;
              if (result && typeof result.then === "function") {
                return result.then(
                  (value) => {
                    if (isFirstMethodReturningFileHandle(original)) {
                      wrapFileHandle(value);
                    }
                    finishChannel.publish();
                    return value;
                  },
                  (error) => {
                    errorChannel.publish(error);
                    finishChannel.publish();
                    throw error;
                  }
                );
              }
              finishChannel.publish();
              return result;
            } catch (error) {
              errorChannel.publish(error);
              finishChannel.publish();
              throw error;
            }
          });
        };
      }, "wrapFunction");
    }
    __name(createWrapFunction, "createWrapFunction");
    function getMessage(operation, params, args, self2) {
      const metadata = {};
      if (params) {
        for (let i = 0; i < params.length; i++) {
          if (!params[i] || typeof args[i] === "function")
            continue;
          metadata[params[i]] = args[i];
        }
      }
      if (self2) {
        if (self2.path) {
          metadata.path = self2.path;
        }
        if (self2.fd) {
          metadata.fd = self2.fd;
        }
      }
      return { operation, ...metadata };
    }
    __name(getMessage, "getMessage");
    function massWrap(target, methods, wrapper) {
      for (const method of methods) {
        wrap(target, method, wrapper);
      }
    }
    __name(massWrap, "massWrap");
    function wrap(target, method, wrapper) {
      try {
        shimmer.wrap(target, method, wrapper);
      } catch (e) {
      }
    }
    __name(wrap, "wrap");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/graphql.js
var require_graphql = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/graphql.js"() {
    "use strict";
    var {
      addHook,
      channel,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var contexts = /* @__PURE__ */ new WeakMap();
    var documentSources = /* @__PURE__ */ new WeakMap();
    var patchedResolvers = /* @__PURE__ */ new WeakSet();
    var patchedTypes = /* @__PURE__ */ new WeakSet();
    var startExecuteCh = channel("apm:graphql:execute:start");
    var finishExecuteCh = channel("apm:graphql:execute:finish");
    var executeErrorCh = channel("apm:graphql:execute:error");
    var startResolveCh = channel("apm:graphql:resolve:start");
    var finishResolveCh = channel("apm:graphql:resolve:finish");
    var updateFieldCh = channel("apm:graphql:resolve:updateField");
    var resolveErrorCh = channel("apm:graphql:resolve:error");
    var parseStartCh = channel("apm:graphql:parser:start");
    var parseFinishCh = channel("apm:graphql:parser:finish");
    var parseErrorCh = channel("apm:graphql:parser:error");
    var validateStartCh = channel("apm:graphql:validate:start");
    var validateFinishCh = channel("apm:graphql:validate:finish");
    var validateErrorCh = channel("apm:graphql:validate:error");
    function getOperation(document, operationName) {
      if (!document || !Array.isArray(document.definitions)) {
        return;
      }
      const definitions = document.definitions.filter((def) => def);
      const types = ["query", "mutation", "subscription"];
      if (operationName) {
        return definitions.filter((def) => types.indexOf(def.operation) !== -1).find((def) => operationName === (def.name && def.name.value));
      } else {
        return definitions.find((def) => types.indexOf(def.operation) !== -1);
      }
    }
    __name(getOperation, "getOperation");
    function normalizeArgs(args, defaultFieldResolver) {
      if (args.length !== 1)
        return normalizePositional(args, defaultFieldResolver);
      args[0].contextValue = args[0].contextValue || {};
      args[0].fieldResolver = wrapResolve(args[0].fieldResolver || defaultFieldResolver);
      return args[0];
    }
    __name(normalizeArgs, "normalizeArgs");
    function normalizePositional(args, defaultFieldResolver) {
      args[3] = args[3] || {};
      args[6] = wrapResolve(args[6] || defaultFieldResolver);
      args.length = Math.max(args.length, 7);
      return {
        schema: args[0],
        document: args[1],
        rootValue: args[2],
        contextValue: args[3],
        variableValues: args[4],
        operationName: args[5],
        fieldResolver: args[6]
      };
    }
    __name(normalizePositional, "normalizePositional");
    function wrapParse(parse) {
      return function(source) {
        if (!parseStartCh.hasSubscribers) {
          return parse.apply(this, arguments);
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          parseStartCh.publish();
          let document;
          try {
            document = parse.apply(this, arguments);
            const operation = getOperation(document);
            if (!operation)
              return document;
            if (source) {
              documentSources.set(document, source.body || source);
            }
            return document;
          } catch (err) {
            err.stack;
            parseErrorCh.publish(err);
            throw err;
          } finally {
            parseFinishCh.publish({ source, document, docSource: documentSources.get(document) });
          }
        });
      };
    }
    __name(wrapParse, "wrapParse");
    function wrapValidate(validate) {
      return function(_schema, document, _rules, _typeInfo) {
        if (!validateStartCh.hasSubscribers) {
          return validate.apply(this, arguments);
        }
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          validateStartCh.publish({ docSource: documentSources.get(document), document });
          let errors;
          try {
            errors = validate.apply(this, arguments);
            if (errors && errors[0]) {
              validateErrorCh.publish(errors && errors[0]);
            }
            return errors;
          } catch (err) {
            err.stack;
            validateErrorCh.publish(err);
            throw err;
          } finally {
            validateFinishCh.publish({ document, errors });
          }
        });
      };
    }
    __name(wrapValidate, "wrapValidate");
    function wrapExecute(execute) {
      return function(exe) {
        const defaultFieldResolver = execute.defaultFieldResolver;
        return function() {
          if (!startExecuteCh.hasSubscribers) {
            return exe.apply(this, arguments);
          }
          const asyncResource = new AsyncResource("bound-anonymous-fn");
          return asyncResource.runInAsyncScope(() => {
            const args = normalizeArgs(arguments, defaultFieldResolver);
            const schema = args.schema;
            const document = args.document;
            const source = documentSources.get(document);
            const contextValue = args.contextValue;
            const operation = getOperation(document, args.operationName);
            if (contexts.has(contextValue)) {
              return exe.apply(this, arguments);
            }
            if (schema) {
              wrapFields(schema._queryType);
              wrapFields(schema._mutationType);
            }
            startExecuteCh.publish({
              operation,
              args,
              docSource: documentSources.get(document)
            });
            const context = { source, asyncResource, fields: {} };
            contexts.set(contextValue, context);
            return callInAsyncScope(exe, asyncResource, this, arguments, (err, res) => {
              if (finishResolveCh.hasSubscribers)
                finishResolvers(context);
              const error = err || res && res.errors && res.errors[0];
              if (error) {
                executeErrorCh.publish(error);
              }
              finishExecuteCh.publish({ res, args });
            });
          });
        };
      };
    }
    __name(wrapExecute, "wrapExecute");
    function wrapResolve(resolve) {
      if (typeof resolve !== "function" || patchedResolvers.has(resolve))
        return resolve;
      function resolveAsync(source, args, contextValue, info) {
        if (!startResolveCh.hasSubscribers)
          return resolve.apply(this, arguments);
        const context = contexts.get(contextValue);
        if (!context)
          return resolve.apply(this, arguments);
        const field = assertField(context, info);
        return callInAsyncScope(resolve, field.asyncResource, this, arguments, (err) => {
          updateFieldCh.publish({ field, info, err });
        });
      }
      __name(resolveAsync, "resolveAsync");
      patchedResolvers.add(resolveAsync);
      return resolveAsync;
    }
    __name(wrapResolve, "wrapResolve");
    function callInAsyncScope(fn, aR, thisArg, args, cb) {
      cb = cb || (() => {
      });
      return aR.runInAsyncScope(() => {
        try {
          const result = fn.apply(thisArg, args);
          if (result && typeof result.then === "function") {
            result.then(
              aR.bind((res) => cb(null, res)),
              aR.bind((err) => cb(err))
            );
          } else {
            cb(null, result);
          }
          return result;
        } catch (err) {
          cb(err);
          throw err;
        }
      });
    }
    __name(callInAsyncScope, "callInAsyncScope");
    function pathToArray(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    __name(pathToArray, "pathToArray");
    function assertField(context, info) {
      const pathInfo = info && info.path;
      const path = pathToArray(pathInfo);
      const pathString = path.join(".");
      const fields = context.fields;
      let field = fields[pathString];
      if (!field) {
        const parent = getParentField(context, path);
        parent.asyncResource.runInAsyncScope(() => {
          const childResource = new AsyncResource("bound-anonymous-fn");
          childResource.runInAsyncScope(() => {
            startResolveCh.publish({
              info,
              context
            });
          });
          field = fields[pathString] = {
            parent,
            asyncResource: childResource,
            error: null
          };
        });
      }
      return field;
    }
    __name(assertField, "assertField");
    function getParentField(context, path) {
      for (let i = path.length - 1; i > 0; i--) {
        const field = getField(context, path.slice(0, i));
        if (field) {
          return field;
        }
      }
      return {
        asyncResource: context.asyncResource
      };
    }
    __name(getParentField, "getParentField");
    function getField(context, path) {
      return context.fields[path.join(".")];
    }
    __name(getField, "getField");
    function wrapFields(type) {
      if (!type || !type._fields || patchedTypes.has(type)) {
        return;
      }
      patchedTypes.add(type);
      Object.keys(type._fields).forEach((key) => {
        const field = type._fields[key];
        wrapFieldResolve(field);
        wrapFieldType(field);
      });
    }
    __name(wrapFields, "wrapFields");
    function wrapFieldResolve(field) {
      if (!field || !field.resolve)
        return;
      field.resolve = wrapResolve(field.resolve);
    }
    __name(wrapFieldResolve, "wrapFieldResolve");
    function wrapFieldType(field) {
      if (!field || !field.type)
        return;
      let unwrappedType = field.type;
      while (unwrappedType.ofType) {
        unwrappedType = unwrappedType.ofType;
      }
      wrapFields(unwrappedType);
    }
    __name(wrapFieldType, "wrapFieldType");
    function finishResolvers({ fields }) {
      Object.keys(fields).reverse().forEach((key) => {
        const field = fields[key];
        const asyncResource = field.asyncResource;
        asyncResource.runInAsyncScope(() => {
          if (field.error) {
            resolveErrorCh.publish(field.error);
          }
          finishResolveCh.publish(field.finishTime);
        });
      });
    }
    __name(finishResolvers, "finishResolvers");
    addHook({ name: "graphql", file: "execution/execute.js", versions: [">=0.10"] }, (execute) => {
      shimmer.wrap(execute, "execute", wrapExecute(execute));
      return execute;
    });
    addHook({ name: "graphql", file: "language/parser.js", versions: [">=0.10"] }, (parser) => {
      shimmer.wrap(parser, "parse", wrapParse);
      return parser;
    });
    addHook({ name: "graphql", file: "validation/validate.js", versions: [">=0.10"] }, (validate) => {
      shimmer.wrap(validate, "validate", wrapValidate);
      return validate;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/http/client.js
var require_client9 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/http/client.js"() {
    "use strict";
    var url = __require("url");
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var log = require_log();
    var startClientCh = channel("apm:http:client:request:start");
    var finishClientCh = channel("apm:http:client:request:finish");
    var errorClientCh = channel("apm:http:client:request:error");
    addHook({ name: "https" }, hookFn);
    addHook({ name: "http" }, hookFn);
    function hookFn(http) {
      patch(http, "request");
      patch(http, "get");
      return http;
    }
    __name(hookFn, "hookFn");
    function patch(http, methodName) {
      shimmer.wrap(http, methodName, instrumentRequest);
      function instrumentRequest(request) {
        return function() {
          if (!startClientCh.hasSubscribers) {
            return request.apply(this, arguments);
          }
          let args;
          try {
            args = normalizeArgs.apply(null, arguments);
          } catch (e) {
            log.error(e);
            return request.apply(this, arguments);
          }
          const callbackResource = new AsyncResource("bound-anonymous-fn");
          const asyncResource = new AsyncResource("bound-anonymous-fn");
          return asyncResource.runInAsyncScope(() => {
            startClientCh.publish({ args, http });
            let finished = false;
            let callback = args.callback;
            if (callback) {
              callback = callbackResource.bind(callback);
            }
            const options = args.options;
            const req = request.call(this, options, callback);
            const emit = req.emit;
            const finish = /* @__PURE__ */ __name((req2, res) => {
              if (!finished) {
                finished = true;
                finishClientCh.publish({ req: req2, res });
              }
            }, "finish");
            req.emit = function(eventName, arg) {
              asyncResource.runInAsyncScope(() => {
                switch (eventName) {
                  case "response": {
                    const res = arg;
                    const listener = asyncResource.bind(() => finish(req, res));
                    res.on("end", listener);
                    res.on("error", listener);
                    break;
                  }
                  case "connect":
                  case "upgrade":
                    finish(req, arg);
                    break;
                  case "error":
                  case "timeout":
                    errorClientCh.publish(arg);
                  case "abort":
                  case "close":
                    finish(req);
                }
              });
              return emit.apply(this, arguments);
            };
            return req;
          });
        };
      }
      __name(instrumentRequest, "instrumentRequest");
      function normalizeArgs(inputURL, inputOptions, cb) {
        inputURL = normalizeOptions(inputURL);
        const [callback, inputOptionsNormalized] = normalizeCallback(inputOptions, cb, inputURL);
        const options = combineOptions(inputURL, inputOptionsNormalized);
        normalizeHeaders(options);
        const uri = url.format(options);
        return { uri, options, callback };
      }
      __name(normalizeArgs, "normalizeArgs");
      function combineOptions(inputURL, inputOptions) {
        if (typeof inputOptions === "object") {
          return Object.assign(inputURL || {}, inputOptions);
        } else {
          return inputURL;
        }
      }
      __name(combineOptions, "combineOptions");
      function normalizeHeaders(options) {
        options.headers = options.headers || {};
      }
      __name(normalizeHeaders, "normalizeHeaders");
      function normalizeCallback(inputOptions, callback, inputURL) {
        if (typeof inputOptions === "function") {
          return [inputOptions, inputURL || {}];
        } else {
          return [callback, inputOptions];
        }
      }
      __name(normalizeCallback, "normalizeCallback");
      function normalizeOptions(inputURL) {
        if (typeof inputURL === "string") {
          try {
            return urlToOptions(new url.URL(inputURL));
          } catch (e) {
            return url.parse(inputURL);
          }
        } else if (inputURL instanceof url.URL) {
          return urlToOptions(inputURL);
        } else {
          return inputURL;
        }
      }
      __name(normalizeOptions, "normalizeOptions");
      function urlToOptions(url2) {
        const agent = url2.agent || http.globalAgent;
        const options = {
          protocol: url2.protocol || agent.protocol,
          hostname: typeof url2.hostname === "string" && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname || url2.host || "localhost",
          hash: url2.hash,
          search: url2.search,
          pathname: url2.pathname,
          path: `${url2.pathname || ""}${url2.search || ""}`,
          href: url2.href
        };
        if (url2.port !== "") {
          options.port = Number(url2.port);
        }
        if (url2.username || url2.password) {
          options.auth = `${url2.username}:${url2.password}`;
        }
        return options;
      }
      __name(urlToOptions, "urlToOptions");
    }
    __name(patch, "patch");
  }
});

// node_modules/node-abort-controller/index.js
var require_node_abort_controller = __commonJS({
  "node_modules/node-abort-controller/index.js"(exports2, module2) {
    var { EventEmitter } = __require("events");
    var AbortSignal2 = class {
      constructor() {
        this.eventEmitter = new EventEmitter();
        this.onabort = null;
        this.aborted = false;
        this.reason = void 0;
      }
      toString() {
        return "[object AbortSignal]";
      }
      get [Symbol.toStringTag]() {
        return "AbortSignal";
      }
      removeEventListener(name, handler2) {
        this.eventEmitter.removeListener(name, handler2);
      }
      addEventListener(name, handler2) {
        this.eventEmitter.on(name, handler2);
      }
      dispatchEvent(type) {
        const event = { type, target: this };
        const handlerName = `on${type}`;
        if (typeof this[handlerName] === "function")
          this[handlerName](event);
        this.eventEmitter.emit(type, event);
      }
      throwIfAborted() {
        if (this.aborted) {
          throw this.reason;
        }
      }
      static abort(reason) {
        const controller = new AbortController2();
        controller.abort();
        return controller.signal;
      }
      static timeout(time) {
        const controller = new AbortController2();
        setTimeout(() => controller.abort(new Error("TimeoutError")), time);
        return controller.signal;
      }
    };
    __name(AbortSignal2, "AbortSignal");
    var AbortController2 = class {
      constructor() {
        this.signal = new AbortSignal2();
      }
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.aborted = true;
        if (reason)
          this.signal.reason = reason;
        else
          this.signal.reason = new Error("AbortError");
        this.signal.dispatchEvent("abort");
      }
      toString() {
        return "[object AbortController]";
      }
      get [Symbol.toStringTag]() {
        return "AbortController";
      }
    };
    __name(AbortController2, "AbortController");
    module2.exports = { AbortController: AbortController2, AbortSignal: AbortSignal2 };
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/http/server.js
var require_server8 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/http/server.js"() {
    "use strict";
    var { AbortController: AbortController2 } = require_node_abort_controller();
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startServerCh = channel("apm:http:server:request:start");
    var exitServerCh = channel("apm:http:server:request:exit");
    var errorServerCh = channel("apm:http:server:request:error");
    var finishServerCh = channel("apm:http:server:request:finish");
    var requestFinishedSet = /* @__PURE__ */ new WeakSet();
    addHook({ name: "https" }, (http) => {
      shimmer.wrap(http.Server.prototype, "emit", wrapEmit);
      return http;
    });
    addHook({ name: "http" }, (http) => {
      shimmer.wrap(http.ServerResponse.prototype, "emit", wrapResponseEmit);
      shimmer.wrap(http.Server.prototype, "emit", wrapEmit);
      return http;
    });
    function wrapResponseEmit(emit) {
      return function(eventName, event) {
        if (!startServerCh.hasSubscribers) {
          return emit.apply(this, arguments);
        }
        if (["finish", "close"].includes(eventName) && !requestFinishedSet.has(this)) {
          finishServerCh.publish({ req: this.req });
          requestFinishedSet.add(this);
        }
        return emit.apply(this, arguments);
      };
    }
    __name(wrapResponseEmit, "wrapResponseEmit");
    function wrapEmit(emit) {
      return function(eventName, req, res) {
        if (!startServerCh.hasSubscribers) {
          return emit.apply(this, arguments);
        }
        if (eventName === "request") {
          res.req = req;
          const abortController = new AbortController2();
          startServerCh.publish({ req, res, abortController });
          try {
            if (abortController.signal.aborted) {
              return res.end();
            }
            return emit.apply(this, arguments);
          } catch (err) {
            errorServerCh.publish(err);
            throw err;
          } finally {
            exitServerCh.publish({ req });
          }
        }
        return emit.apply(this, arguments);
      };
    }
    __name(wrapEmit, "wrapEmit");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/http.js
var require_http2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/http.js"() {
    "use strict";
    require_client9();
    require_server8();
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/http2/client.js
var require_client10 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/http2/client.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel, AsyncResource } = require_instrument();
    var startChannel = channel("apm:http2:client:request:start");
    var finishChannel = channel("apm:http2:client:request:finish");
    var errorChannel = channel("apm:http2:client:request:error");
    var responseChannel = channel("apm:http2:client:response");
    function createWrapEmit(requestResource, parentResource) {
      return /* @__PURE__ */ __name(function wrapEmit(emit) {
        return function(event, arg1) {
          requestResource.runInAsyncScope(() => {
            switch (event) {
              case "response":
                responseChannel.publish(arg1);
                break;
              case "error":
                errorChannel.publish(arg1);
              case "close":
                finishChannel.publish();
                break;
            }
          });
          return parentResource.runInAsyncScope(() => {
            return emit.apply(this, arguments);
          });
        };
      }, "wrapEmit");
    }
    __name(createWrapEmit, "createWrapEmit");
    function createWrapRequest(authority, options) {
      return /* @__PURE__ */ __name(function wrapRequest(request) {
        return function(headers) {
          const parentResource = new AsyncResource("bound-anonymous-fn");
          const requestResource = new AsyncResource("bound-anonymous-fn");
          return requestResource.runInAsyncScope(() => {
            startChannel.publish({ headers, authority, options });
            const req = request.apply(this, arguments);
            shimmer.wrap(req, "emit", createWrapEmit(requestResource, parentResource));
            return req;
          });
        };
      }, "wrapRequest");
    }
    __name(createWrapRequest, "createWrapRequest");
    function wrapConnect(connect) {
      return function(authority, options) {
        const session = connect.apply(this, arguments);
        shimmer.wrap(session, "request", createWrapRequest(authority, options));
        return session;
      };
    }
    __name(wrapConnect, "wrapConnect");
    addHook({ name: "http2" }, (http2) => {
      shimmer.wrap(http2, "connect", wrapConnect);
      return http2;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/http2/server.js
var require_server9 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/http2/server.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startServerCh = channel("apm:http2:server:request:start");
    var errorServerCh = channel("apm:http2:server:request:error");
    var finishServerCh = channel("apm:http2:server:request:finish");
    addHook({ name: "http2" }, (http2) => {
      shimmer.wrap(http2, "createSecureServer", wrapCreateServer);
      shimmer.wrap(http2, "createServer", wrapCreateServer);
      return http2;
    });
    function wrapCreateServer(createServer) {
      return function(...args) {
        const server = createServer.apply(this, args);
        shimmer.wrap(server, "emit", wrapEmit);
        return server;
      };
    }
    __name(wrapCreateServer, "wrapCreateServer");
    function wrapResponseEmit(emit) {
      const asyncResource = new AsyncResource("bound-anonymous-fn");
      return function(eventName, event) {
        return asyncResource.runInAsyncScope(() => {
          if (eventName === "close" && finishServerCh.hasSubscribers) {
            finishServerCh.publish({ req: this.req });
          }
          return emit.apply(this, arguments);
        });
      };
    }
    __name(wrapResponseEmit, "wrapResponseEmit");
    function wrapEmit(emit) {
      return function(eventName, req, res) {
        if (!startServerCh.hasSubscribers) {
          return emit.apply(this, arguments);
        }
        if (eventName === "request") {
          res.req = req;
          const asyncResource = new AsyncResource("bound-anonymous-fn");
          return asyncResource.runInAsyncScope(() => {
            startServerCh.publish({ req, res });
            shimmer.wrap(res, "emit", wrapResponseEmit);
            try {
              return emit.apply(this, arguments);
            } catch (err) {
              errorServerCh.publish(err);
              throw err;
            }
          });
        }
        return emit.apply(this, arguments);
      };
    }
    __name(wrapEmit, "wrapEmit");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/http2.js
var require_http22 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/http2.js"() {
    "use strict";
    require_client10();
    require_server9();
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/ioredis.js
var require_ioredis = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/ioredis.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:ioredis:command:start");
    var finishCh = channel("apm:ioredis:command:finish");
    var errorCh = channel("apm:ioredis:command:error");
    addHook({ name: "ioredis", versions: [">=2"] }, (Redis) => {
      shimmer.wrap(Redis.prototype, "sendCommand", (sendCommand) => function(command, stream) {
        if (!startCh.hasSubscribers)
          return sendCommand.apply(this, arguments);
        if (!command || !command.promise)
          return sendCommand.apply(this, arguments);
        const options = this.options || {};
        const connectionName = options.connectionName;
        const db = options.db;
        const connectionOptions = { host: options.host, port: options.port };
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          startCh.publish({ db, command: command.name, args: command.args, connectionOptions, connectionName });
          const onResolve = asyncResource.bind(() => finish(finishCh, errorCh));
          const onReject = asyncResource.bind((err) => finish(finishCh, errorCh, err));
          command.promise.then(onResolve, onReject);
          try {
            return sendCommand.apply(this, arguments);
          } catch (err) {
            errorCh.publish(err);
            throw err;
          }
        });
      });
      return Redis;
    });
    function finish(finishCh2, errorCh2, error) {
      if (error) {
        errorCh2.publish(error);
      }
      finishCh2.publish();
    }
    __name(finish, "finish");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/kafkajs.js
var require_kafkajs = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/kafkajs.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var producerStartCh = channel("apm:kafkajs:produce:start");
    var producerFinishCh = channel("apm:kafkajs:produce:finish");
    var producerErrorCh = channel("apm:kafkajs:produce:error");
    var consumerStartCh = channel("apm:kafkajs:consume:start");
    var consumerFinishCh = channel("apm:kafkajs:consume:finish");
    var consumerErrorCh = channel("apm:kafkajs:consume:error");
    addHook({ name: "kafkajs", versions: [">=1.4"] }, (obj) => {
      const Kafka = obj.Kafka;
      shimmer.wrap(Kafka.prototype, "producer", (createProducer) => function() {
        const producer = createProducer.apply(this, arguments);
        const send = producer.send;
        producer.send = function() {
          const innerAsyncResource = new AsyncResource("bound-anonymous-fn");
          return innerAsyncResource.runInAsyncScope(() => {
            if (!producerStartCh.hasSubscribers) {
              return send.apply(this, arguments);
            }
            try {
              const { topic, messages = [] } = arguments[0];
              for (const message of messages) {
                if (typeof message === "object") {
                  message.headers = message.headers || {};
                }
              }
              producerStartCh.publish({ topic, messages });
              const result = send.apply(this, arguments);
              result.then(
                innerAsyncResource.bind(() => producerFinishCh.publish(void 0)),
                innerAsyncResource.bind((err) => {
                  if (err) {
                    producerErrorCh.publish(err);
                  }
                  producerFinishCh.publish(void 0);
                })
              );
              return result;
            } catch (e) {
              producerErrorCh.publish(e);
              producerFinishCh.publish(void 0);
              throw e;
            }
          });
        };
        return producer;
      });
      shimmer.wrap(Kafka.prototype, "consumer", (createConsumer) => function() {
        if (!consumerStartCh.hasSubscribers) {
          return createConsumer.apply(this, arguments);
        }
        const consumer = createConsumer.apply(this, arguments);
        const run = consumer.run;
        consumer.run = function({ eachMessage, ...runArgs }) {
          if (typeof eachMessage !== "function")
            return run({ eachMessage, ...runArgs });
          return run({
            eachMessage: function(...eachMessageArgs) {
              const innerAsyncResource = new AsyncResource("bound-anonymous-fn");
              return innerAsyncResource.runInAsyncScope(() => {
                const { topic, partition, message } = eachMessageArgs[0];
                consumerStartCh.publish({ topic, partition, message });
                try {
                  const result = eachMessage.apply(this, eachMessageArgs);
                  if (result && typeof result.then === "function") {
                    result.then(
                      innerAsyncResource.bind(() => consumerFinishCh.publish(void 0)),
                      innerAsyncResource.bind((err) => {
                        if (err) {
                          consumerErrorCh.publish(err);
                        }
                        consumerFinishCh.publish(void 0);
                      })
                    );
                  } else {
                    consumerFinishCh.publish(void 0);
                  }
                  return result;
                } catch (e) {
                  consumerErrorCh.publish(e);
                  consumerFinishCh.publish(void 0);
                  throw e;
                }
              });
            },
            ...runArgs
          });
        };
        return consumer;
      });
      return obj;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/ldapjs.js
var require_ldapjs = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/ldapjs.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    __name(isString, "isString");
    function getCallbackArgIndex(args) {
      let callbackIndex = -1;
      for (let i = args.length - 1; i >= 0; i--) {
        if (typeof args[i] === "function") {
          callbackIndex = i;
          break;
        }
      }
      return callbackIndex;
    }
    __name(getCallbackArgIndex, "getCallbackArgIndex");
    function wrapEmitter(corkedEmitter) {
      const callbackMap = /* @__PURE__ */ new WeakMap();
      const addListener = /* @__PURE__ */ __name((on) => function(name, fn) {
        if (typeof fn === "function") {
          let bindedFn = callbackMap.get(fn);
          if (!bindedFn) {
            const callbackResource = new AsyncResource("bound-anonymous-fn");
            bindedFn = callbackResource.bind(fn);
            callbackMap.set(fn, bindedFn);
          }
          arguments[1] = bindedFn;
        }
        on.apply(this, arguments);
      }, "addListener");
      shimmer.wrap(corkedEmitter, "on", addListener);
      shimmer.wrap(corkedEmitter, "addListener", addListener);
      const removeListener = /* @__PURE__ */ __name((off) => function(name, fn) {
        if (typeof fn === "function") {
          const emitterOn = callbackMap.get(fn);
          if (emitterOn) {
            arguments[1] = emitterOn;
          }
        }
        off.apply(this, arguments);
      }, "removeListener");
      shimmer.wrap(corkedEmitter, "off", removeListener);
      shimmer.wrap(corkedEmitter, "removeListener", removeListener);
    }
    __name(wrapEmitter, "wrapEmitter");
    addHook({ name: "ldapjs", versions: [">=2"] }, (ldapjs) => {
      const ldapSearchCh = channel("datadog:ldapjs:client:search");
      shimmer.wrap(ldapjs.Client.prototype, "search", (search) => function(base, options) {
        if (ldapSearchCh.hasSubscribers) {
          let filter;
          if (isString(options)) {
            filter = options;
          } else if (typeof options === "object" && options.filter) {
            if (isString(options.filter)) {
              filter = options.filter;
            }
          }
          ldapSearchCh.publish({ base, filter });
        }
        return search.apply(this, arguments);
      });
      shimmer.wrap(ldapjs.Client.prototype, "_send", (_send) => function() {
        const callbackIndex = getCallbackArgIndex(arguments);
        if (callbackIndex > -1) {
          const callback = arguments[callbackIndex];
          arguments[callbackIndex] = shimmer.wrap(callback, function(err, corkedEmitter) {
            if (typeof corkedEmitter === "object" && typeof corkedEmitter["on"] === "function") {
              wrapEmitter(corkedEmitter);
            }
            callback.apply(this, arguments);
          });
        }
        return _send.apply(this, arguments);
      });
      return ldapjs;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/limitd-client.js
var require_limitd_client = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/limitd-client.js"() {
    "use strict";
    var { addHook, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function wrapRequest(original) {
      return function() {
        const id = arguments.length - 1;
        arguments[id] = AsyncResource.bind(arguments[id]);
        return original.apply(this, arguments);
      };
    }
    __name(wrapRequest, "wrapRequest");
    addHook({
      name: "limitd-client",
      versions: [">=2.8"]
    }, (LimitdClient) => {
      shimmer.wrap(LimitdClient.prototype, "_directRequest", wrapRequest);
      shimmer.wrap(LimitdClient.prototype, "_retriedRequest", wrapRequest);
      return LimitdClient;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/mariadb.js
var require_mariadb = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/mariadb.js"() {
    "use strict";
    var { channel, addHook, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:mariadb:query:start");
    var finishCh = channel("apm:mariadb:query:finish");
    var errorCh = channel("apm:mariadb:query:error");
    function wrapCommandStart(start) {
      return function() {
        if (!startCh.hasSubscribers)
          return start.apply(this, arguments);
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const resolve = callbackResource.bind(this.resolve);
        const reject = callbackResource.bind(this.reject);
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        shimmer.wrap(this, "resolve", /* @__PURE__ */ __name(function wrapResolve() {
          return function() {
            asyncResource.runInAsyncScope(() => {
              finishCh.publish();
            });
            return resolve.apply(this, arguments);
          };
        }, "wrapResolve"));
        shimmer.wrap(this, "reject", /* @__PURE__ */ __name(function wrapReject() {
          return function(error) {
            asyncResource.runInAsyncScope(() => {
              errorCh.publish(error);
              finishCh.publish();
            });
            return reject.apply(this, arguments);
          };
        }, "wrapReject"));
        return asyncResource.runInAsyncScope(() => {
          startCh.publish({ sql: this.sql, conf: this.opts });
          return start.apply(this, arguments);
        });
      };
    }
    __name(wrapCommandStart, "wrapCommandStart");
    var name = "mariadb";
    var versions = [">=2.0.3"];
    addHook({ name, file: "lib/cmd/query.js", versions }, (Query) => {
      shimmer.wrap(Query.prototype, "start", wrapCommandStart);
      return Query;
    });
    addHook({ name, file: "lib/cmd/execute.js", versions }, (Query) => {
      shimmer.wrap(Query.prototype, "start", wrapCommandStart);
      return Query;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/memcached.js
var require_memcached = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/memcached.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "memcached", versions: [">=2.2"] }, (Memcached) => {
      const startCh = channel("apm:memcached:command:start");
      const finishCh = channel("apm:memcached:command:finish");
      const errorCh = channel("apm:memcached:command:error");
      shimmer.wrap(Memcached.prototype, "command", (command) => function(queryCompiler, server) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments);
        }
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        const client = this;
        const wrappedQueryCompiler = asyncResource.bind(function() {
          const query = queryCompiler.apply(this, arguments);
          const callback = callbackResource.bind(query.callback);
          query.callback = asyncResource.bind(function(err) {
            if (err) {
              errorCh.publish(err);
            }
            finishCh.publish();
            return callback.apply(this, arguments);
          });
          startCh.publish({ client, server, query });
          return query;
        });
        return asyncResource.runInAsyncScope(() => {
          arguments[0] = wrappedQueryCompiler;
          const result = command.apply(this, arguments);
          return result;
        });
      });
      return Memcached;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/microgateway-core.js
var require_microgateway_core = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/microgateway-core.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel, AsyncResource } = require_instrument();
    var handleChannel = channel("apm:microgateway-core:request:handle");
    var routeChannel = channel("apm:microgateway-core:request:route");
    var errorChannel = channel("apm:microgateway-core:request:error");
    var name = "microgateway-core";
    var versions = [">=2.1"];
    var requestResources = /* @__PURE__ */ new WeakMap();
    function wrapConfigProxyFactory(configProxyFactory) {
      return function() {
        const configProxy = configProxyFactory.apply(this, arguments);
        return function(req, res, next) {
          const requestResource = new AsyncResource("bound-anonymous-fn");
          requestResources.set(req, requestResource);
          handleChannel.publish({ req, res });
          return configProxy.apply(this, arguments);
        };
      };
    }
    __name(wrapConfigProxyFactory, "wrapConfigProxyFactory");
    function wrapPluginsFactory(pluginsFactory) {
      return function(plugins) {
        const pluginsMiddleware = pluginsFactory.apply(this, arguments);
        return /* @__PURE__ */ __name(function pluginsMiddlewareWithTrace(req, res, next) {
          arguments[2] = wrapNext(req, res, next);
          return pluginsMiddleware.apply(this, arguments);
        }, "pluginsMiddlewareWithTrace");
      };
    }
    __name(wrapPluginsFactory, "wrapPluginsFactory");
    function wrapNext(req, res, next) {
      return /* @__PURE__ */ __name(function nextWithTrace(err) {
        const requestResource = requestResources.get(req);
        requestResource.runInAsyncScope(() => {
          if (err) {
            errorChannel.publish(err);
          }
          if (res.proxy && res.proxy.base_path) {
            routeChannel.publish({ req, res, route: res.proxy.base_path });
          }
        });
        return next.apply(this, arguments);
      }, "nextWithTrace");
    }
    __name(wrapNext, "wrapNext");
    addHook({ name, versions, file: "lib/config-proxy-middleware.js" }, (configProxyFactory) => {
      return shimmer.wrap(configProxyFactory, wrapConfigProxyFactory(configProxyFactory));
    });
    addHook({ name, versions, file: "lib/plugins-middleware.js" }, (pluginsFactory) => {
      return shimmer.wrap(pluginsFactory, wrapPluginsFactory(pluginsFactory));
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/mocha.js
var require_mocha = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/mocha.js"() {
    var { createCoverageMap } = require_istanbul_lib_coverage();
    var { addHook, channel, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var {
      getCoveredFilenamesFromCoverage,
      resetCoverage,
      mergeCoverage,
      getTestSuitePath,
      fromCoverageMapToCoverage
    } = require_test();
    var testStartCh = channel("ci:mocha:test:start");
    var errorCh = channel("ci:mocha:test:error");
    var skipCh = channel("ci:mocha:test:skip");
    var testFinishCh = channel("ci:mocha:test:finish");
    var parameterizedTestCh = channel("ci:mocha:test:parameterize");
    var itrConfigurationCh = channel("ci:mocha:itr-configuration");
    var skippableSuitesCh = channel("ci:mocha:test-suite:skippable");
    var testSessionStartCh = channel("ci:mocha:session:start");
    var testSessionFinishCh = channel("ci:mocha:session:finish");
    var testSuiteStartCh = channel("ci:mocha:test-suite:start");
    var testSuiteFinishCh = channel("ci:mocha:test-suite:finish");
    var testSuiteErrorCh = channel("ci:mocha:test-suite:error");
    var testSuiteCodeCoverageCh = channel("ci:mocha:test-suite:code-coverage");
    var patched = /* @__PURE__ */ new WeakSet();
    var testToAr = /* @__PURE__ */ new WeakMap();
    var originalFns = /* @__PURE__ */ new WeakMap();
    var testFileToSuiteAr = /* @__PURE__ */ new Map();
    var originalCoverageMap = createCoverageMap();
    var suitesToSkip = [];
    var frameworkVersion;
    function getSuitesByTestFile(root) {
      const suitesByTestFile = {};
      function getSuites(suite) {
        if (suite.file) {
          if (suitesByTestFile[suite.file]) {
            suitesByTestFile[suite.file].push(suite);
          } else {
            suitesByTestFile[suite.file] = [suite];
          }
        }
        suite.suites.forEach((suite2) => {
          getSuites(suite2);
        });
      }
      __name(getSuites, "getSuites");
      getSuites(root);
      const numSuitesByTestFile = Object.keys(suitesByTestFile).reduce((acc, testFile) => {
        acc[testFile] = suitesByTestFile[testFile].length;
        return acc;
      }, {});
      return { suitesByTestFile, numSuitesByTestFile };
    }
    __name(getSuitesByTestFile, "getSuitesByTestFile");
    function getTestStatus(test) {
      if (test.isPending()) {
        return "skip";
      }
      if (test.isFailed() || test.timedOut) {
        return "fail";
      }
      return "pass";
    }
    __name(getTestStatus, "getTestStatus");
    function isRetry(test) {
      return test._currentRetry !== void 0 && test._currentRetry !== 0;
    }
    __name(isRetry, "isRetry");
    function getTestAsyncResource(test) {
      if (!test.fn) {
        return testToAr.get(test);
      }
      if (!test.fn.asyncResource) {
        return testToAr.get(test.fn);
      }
      const originalFn = originalFns.get(test.fn);
      return testToAr.get(originalFn);
    }
    __name(getTestAsyncResource, "getTestAsyncResource");
    function getSuitesToRun(originalSuites) {
      return originalSuites.filter(
        (suite) => !suitesToSkip.includes(getTestSuitePath(suite.file, process.cwd()))
      );
    }
    __name(getSuitesToRun, "getSuitesToRun");
    function mochaHook(Runner) {
      if (patched.has(Runner))
        return Runner;
      patched.add(Runner);
      shimmer.wrap(Runner.prototype, "run", (run) => function() {
        if (!testStartCh.hasSubscribers) {
          return run.apply(this, arguments);
        }
        const { suitesByTestFile, numSuitesByTestFile } = getSuitesByTestFile(this.suite);
        const testRunAsyncResource = new AsyncResource("bound-anonymous-fn");
        this.once("end", testRunAsyncResource.bind(function() {
          let status = "pass";
          if (this.stats) {
            status = this.stats.failures === 0 ? "pass" : "fail";
          } else if (this.failures !== 0) {
            status = "fail";
          }
          testFileToSuiteAr.clear();
          const isSuitesSkipped = !!suitesToSkip.length;
          testSessionFinishCh.publish({ status, isSuitesSkipped });
          global.__coverage__ = fromCoverageMapToCoverage(originalCoverageMap);
        }));
        this.once("start", testRunAsyncResource.bind(function() {
          const processArgv = process.argv.slice(2).join(" ");
          const command = `mocha ${processArgv}`;
          testSessionStartCh.publish({ command, frameworkVersion });
        }));
        this.on("suite", function(suite) {
          if (suite.root || !suite.tests.length) {
            return;
          }
          let asyncResource = testFileToSuiteAr.get(suite.file);
          if (!asyncResource) {
            asyncResource = new AsyncResource("bound-anonymous-fn");
            testFileToSuiteAr.set(suite.file, asyncResource);
            asyncResource.runInAsyncScope(() => {
              testSuiteStartCh.publish(suite);
            });
          }
        });
        this.on("suite end", function(suite) {
          if (suite.root) {
            return;
          }
          const suitesInTestFile = suitesByTestFile[suite.file];
          const isLastSuite = --numSuitesByTestFile[suite.file] === 0;
          if (!isLastSuite) {
            return;
          }
          let status = "pass";
          if (suitesInTestFile.every((suite2) => suite2.pending)) {
            status = "skip";
          } else {
            suitesInTestFile.forEach((suite2) => {
              suite2.eachTest((test) => {
                if (test.state === "failed" || test.timedOut) {
                  status = "fail";
                }
              });
            });
          }
          if (global.__coverage__) {
            const coverageFiles = getCoveredFilenamesFromCoverage(global.__coverage__);
            testSuiteCodeCoverageCh.publish({
              coverageFiles,
              suiteFile: suite.file
            });
            mergeCoverage(global.__coverage__, originalCoverageMap);
            resetCoverage(global.__coverage__);
          }
          const asyncResource = testFileToSuiteAr.get(suite.file);
          asyncResource.runInAsyncScope(() => {
            testSuiteFinishCh.publish(status);
          });
        });
        this.on("test", (test) => {
          if (isRetry(test)) {
            return;
          }
          const asyncResource = new AsyncResource("bound-anonymous-fn");
          testToAr.set(test.fn, asyncResource);
          asyncResource.runInAsyncScope(() => {
            testStartCh.publish(test);
          });
        });
        this.on("test end", (test) => {
          const asyncResource = getTestAsyncResource(test);
          const status = getTestStatus(test);
          if (asyncResource && !test.parent._afterEach.length) {
            asyncResource.runInAsyncScope(() => {
              testFinishCh.publish(status);
            });
          }
        });
        this.on("hook end", (hook) => {
          const test = hook.ctx.currentTest;
          if (test && hook.parent._afterEach.includes(hook)) {
            const isLastAfterEach = hook.parent._afterEach.indexOf(hook) === hook.parent._afterEach.length - 1;
            if (isLastAfterEach) {
              const status = getTestStatus(test);
              const asyncResource = getTestAsyncResource(test);
              asyncResource.runInAsyncScope(() => {
                testFinishCh.publish(status);
              });
            }
          }
        });
        this.on("fail", (testOrHook, err) => {
          const testFile = testOrHook.file;
          let test = testOrHook;
          const isHook = testOrHook.type === "hook";
          if (isHook && testOrHook.ctx) {
            test = testOrHook.ctx.currentTest;
          }
          let testAsyncResource;
          if (test) {
            testAsyncResource = getTestAsyncResource(test);
          }
          if (testAsyncResource) {
            testAsyncResource.runInAsyncScope(() => {
              if (isHook) {
                err.message = `${testOrHook.fullTitle()}: ${err.message}`;
                errorCh.publish(err);
                testFinishCh.publish("fail");
              } else {
                errorCh.publish(err);
              }
            });
          }
          const testSuiteAsyncResource = testFileToSuiteAr.get(testFile);
          if (testSuiteAsyncResource) {
            const testSuiteError = new Error(
              `"${testOrHook.parent.fullTitle()}" failed with message "${err.message}"`
            );
            testSuiteError.stack = err.stack;
            testSuiteAsyncResource.runInAsyncScope(() => {
              testSuiteErrorCh.publish(testSuiteError);
            });
          }
        });
        this.on("pending", (test) => {
          const asyncResource = getTestAsyncResource(test);
          if (asyncResource) {
            asyncResource.runInAsyncScope(() => {
              skipCh.publish(test);
            });
          } else {
            const skippedTestAsyncResource = new AsyncResource("bound-anonymous-fn");
            if (test.fn) {
              testToAr.set(test.fn, skippedTestAsyncResource);
            } else {
              testToAr.set(test, skippedTestAsyncResource);
            }
            skippedTestAsyncResource.runInAsyncScope(() => {
              skipCh.publish(test);
            });
          }
        });
        return run.apply(this, arguments);
      });
      return Runner;
    }
    __name(mochaHook, "mochaHook");
    function mochaEachHook(mochaEach) {
      if (patched.has(mochaEach))
        return mochaEach;
      patched.add(mochaEach);
      return shimmer.wrap(mochaEach, function() {
        const [params] = arguments;
        const { it, ...rest } = mochaEach.apply(this, arguments);
        return {
          it: function(name) {
            parameterizedTestCh.publish({ name, params });
            it.apply(this, arguments);
          },
          ...rest
        };
      });
    }
    __name(mochaEachHook, "mochaEachHook");
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/mocha.js"
    }, (Mocha, mochaVersion) => {
      frameworkVersion = mochaVersion;
      const mochaRunAsyncResource = new AsyncResource("bound-anonymous-fn");
      shimmer.wrap(Mocha.prototype, "run", (run) => function() {
        if (!itrConfigurationCh.hasSubscribers) {
          return run.apply(this, arguments);
        }
        this.options.delay = true;
        const runner = run.apply(this, arguments);
        const onReceivedSkippableSuites = /* @__PURE__ */ __name(({ err, skippableSuites }) => {
          if (err) {
            suitesToSkip = [];
          } else {
            suitesToSkip = skippableSuites;
          }
          runner.suite.suites = getSuitesToRun(runner.suite.suites);
          global.run();
        }, "onReceivedSkippableSuites");
        const onReceivedConfiguration = /* @__PURE__ */ __name(({ err }) => {
          if (err) {
            return global.run();
          }
          if (!skippableSuitesCh.hasSubscribers) {
            return global.run();
          }
          skippableSuitesCh.publish({
            onDone: mochaRunAsyncResource.bind(onReceivedSkippableSuites)
          });
        }, "onReceivedConfiguration");
        mochaRunAsyncResource.runInAsyncScope(() => {
          itrConfigurationCh.publish({
            onDone: mochaRunAsyncResource.bind(onReceivedConfiguration)
          });
        });
        return runner;
      });
      return Mocha;
    });
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/runner.js"
    }, mochaHook);
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/cli/run-helpers.js"
    }, (run) => {
      shimmer.wrap(run, "runMocha", (runMocha) => async function() {
        const mocha = arguments[0];
        mocha.options.delay = true;
        return runMocha.apply(this, arguments);
      });
      return run;
    });
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/runnable.js"
    }, (Runnable) => {
      shimmer.wrap(Runnable.prototype, "run", (run) => function() {
        if (!testStartCh.hasSubscribers) {
          return run.apply(this, arguments);
        }
        const isBeforeEach = this.parent._beforeEach.includes(this);
        const isAfterEach = this.parent._afterEach.includes(this);
        const isTestHook = isBeforeEach || isAfterEach;
        if (this.fn.asyncResource) {
          const originalFn = originalFns.get(this.fn);
          this.fn = originalFn;
        }
        if (isTestHook || this.type === "test") {
          const test = isTestHook ? this.ctx.currentTest : this;
          const asyncResource = getTestAsyncResource(test);
          if (asyncResource) {
            const newFn = asyncResource.bind(this.fn);
            originalFns.set(newFn, this.fn);
            this.fn = newFn;
            if (!this.fn.asyncResource) {
              this.fn.asyncResource = asyncResource;
            }
          }
        }
        return run.apply(this, arguments);
      });
      return Runnable;
    });
    addHook({
      name: "mocha-each",
      versions: [">=2.0.1"]
    }, mochaEachHook);
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer/client.js
var require_client11 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer/client.js"() {
    "use strict";
    var { channel, addHook, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startChannel = channel("apm:moleculer:call:start");
    var finishChannel = channel("apm:moleculer:call:finish");
    var errorChannel = channel("apm:moleculer:call:error");
    function wrapCall(call) {
      return function(actionName, params, opts) {
        const callResource = new AsyncResource("bound-anonymous-fn");
        opts = arguments[2] = opts || {};
        opts.meta = opts.meta || {};
        arguments.length = Math.max(3, arguments.length);
        return callResource.runInAsyncScope(() => {
          startChannel.publish({ actionName, params, opts });
          const promise = call.apply(this, arguments);
          const broker = this;
          const ctx = promise.ctx;
          return promise.then(
            (result) => {
              finishChannel.publish({ broker, ctx });
              return result;
            },
            (error) => {
              errorChannel.publish(error);
              finishChannel.publish({ broker, ctx });
              throw error;
            }
          );
        });
      };
    }
    __name(wrapCall, "wrapCall");
    addHook({ name: "moleculer", versions: [">=0.14"] }, (moleculer) => {
      shimmer.wrap(moleculer.ServiceBroker.prototype, "call", wrapCall);
      return moleculer;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer/server.js
var require_server10 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer/server.js"() {
    "use strict";
    var { channel, addHook, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startChannel = channel("apm:moleculer:action:start");
    var finishChannel = channel("apm:moleculer:action:finish");
    var errorChannel = channel("apm:moleculer:action:error");
    function wrapRegisterMiddlewares(registerMiddlewares) {
      return function(userMiddlewares) {
        if (this.middlewares && this.middlewares.add) {
          this.middlewares.add(createMiddleware());
        }
        return registerMiddlewares.apply(this, arguments);
      };
    }
    __name(wrapRegisterMiddlewares, "wrapRegisterMiddlewares");
    function createMiddleware() {
      return {
        name: "Datadog",
        localAction(next, action) {
          const broker = this;
          return /* @__PURE__ */ __name(function datadogMiddleware(ctx) {
            const actionResource = new AsyncResource("bound-anonymous-fn");
            return actionResource.runInAsyncScope(() => {
              startChannel.publish({ action, ctx, broker });
              try {
                return next(ctx).then(
                  (result) => {
                    finishChannel.publish();
                    return result;
                  },
                  (error) => {
                    errorChannel.publish(error);
                    finishChannel.publish();
                    throw error;
                  }
                );
              } catch (e) {
                errorChannel.publish(e);
                finishChannel.publish();
              }
            });
          }, "datadogMiddleware");
        }
      };
    }
    __name(createMiddleware, "createMiddleware");
    addHook({ name: "moleculer", versions: [">=0.14"] }, (moleculer) => {
      shimmer.wrap(moleculer.ServiceBroker.prototype, "registerMiddlewares", wrapRegisterMiddlewares);
      return moleculer;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer.js
var require_moleculer = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/moleculer.js"() {
    "use strict";
    require_client11();
    require_server10();
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb-core.js
var require_mongodb_core = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/mongodb-core.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel(`apm:mongodb:query:start`);
    var finishCh = channel(`apm:mongodb:query:finish`);
    var errorCh = channel(`apm:mongodb:query:error`);
    addHook({ name: "mongodb-core", versions: ["2 - 3.1.9"] }, (Server) => {
      const serverProto = Server.Server.prototype;
      shimmer.wrap(serverProto, "command", (command) => wrapCommand(command, "command"));
      shimmer.wrap(serverProto, "insert", (insert) => wrapCommand(insert, "insert", "insert"));
      shimmer.wrap(serverProto, "update", (update) => wrapCommand(update, "update", "update"));
      shimmer.wrap(serverProto, "remove", (remove) => wrapCommand(remove, "remove", "remove"));
      const cursorProto = Server.Cursor.prototype;
      shimmer.wrap(cursorProto, "_getmore", (_getmore) => wrapCursor(_getmore, "getMore", "getMore"));
      shimmer.wrap(cursorProto, "_find", (_find) => wrapQuery(_find, "_find"));
      shimmer.wrap(cursorProto, "kill", (kill) => wrapCursor(kill, "killCursors", "killCursors"));
      return Server;
    });
    addHook({ name: "mongodb", versions: [">=4"], file: "lib/cmap/connection.js" }, (Connection) => {
      const proto = Connection.Connection.prototype;
      shimmer.wrap(proto, "command", (command) => wrapConnectionCommand(command, "command"));
      shimmer.wrap(proto, "query", (query) => wrapConnectionCommand(query, "query"));
      return Connection;
    });
    addHook({ name: "mongodb", versions: [">=3.3 <4"], file: "lib/core/wireprotocol/index.js" }, (wp) => wrapWp(wp));
    addHook({ name: "mongodb-core", versions: [">=3.2"], file: "lib/wireprotocol/index.js" }, (wp) => wrapWp(wp));
    addHook({ name: "mongodb-core", versions: ["~3.1.10"], file: "lib/wireprotocol/3_2_support.js" }, (WireProtocol) => {
      shimmer.wrap(WireProtocol.prototype, "command", (command) => wrapUnifiedCommand(command, "command"));
      return WireProtocol;
    });
    addHook({ name: "mongodb-core", versions: ["~3.1.10"], file: "lib/wireprotocol/2_6_support.js" }, (WireProtocol) => {
      shimmer.wrap(WireProtocol.prototype, "command", (command) => wrapUnifiedCommand(command, "command"));
      return WireProtocol;
    });
    addHook({ name: "mongodb", versions: [">=3.5.4"], file: "lib/utils.js" }, (util) => {
      shimmer.wrap(util, "maybePromise", (maybePromise) => function(parent, callback, fn) {
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        const callbackIndex = arguments.length - 2;
        callback = arguments[callbackIndex];
        if (typeof callback === "function") {
          arguments[callbackIndex] = asyncResource.bind(callback);
        }
        return maybePromise.apply(this, arguments);
      });
      return util;
    });
    function wrapWp(wp) {
      shimmer.wrap(wp, "command", (command) => wrapUnifiedCommand(command, "command"));
      shimmer.wrap(wp, "insert", (insert) => wrapUnifiedCommand(insert, "insert", "insert"));
      shimmer.wrap(wp, "update", (update) => wrapUnifiedCommand(update, "update", "update"));
      shimmer.wrap(wp, "remove", (remove) => wrapUnifiedCommand(remove, "remove", "remove"));
      shimmer.wrap(wp, "query", (query) => wrapUnifiedCommand(query, "query"));
      shimmer.wrap(wp, "getMore", (getMore) => wrapUnifiedCommand(getMore, "getMore", "getMore"));
      shimmer.wrap(wp, "killCursors", (killCursors) => wrapUnifiedCommand(killCursors, "killCursors", "killCursors"));
      return wp;
    }
    __name(wrapWp, "wrapWp");
    function wrapUnifiedCommand(command, operation, name) {
      const wrapped = /* @__PURE__ */ __name(function(server, ns, ops) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments);
        }
        return instrument(operation, command, this, arguments, server, ns, ops, { name });
      }, "wrapped");
      return shimmer.wrap(command, wrapped);
    }
    __name(wrapUnifiedCommand, "wrapUnifiedCommand");
    function wrapConnectionCommand(command, operation, name) {
      const wrapped = /* @__PURE__ */ __name(function(ns, ops) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments);
        }
        const hostParts = typeof this.address === "string" ? this.address.split(":") : "";
        const options = hostParts.length === 2 ? { host: hostParts[0], port: hostParts[1] } : {};
        const topology = { s: { options } };
        ns = `${ns.db}.${ns.collection}`;
        return instrument(operation, command, this, arguments, topology, ns, ops, { name });
      }, "wrapped");
      return shimmer.wrap(command, wrapped);
    }
    __name(wrapConnectionCommand, "wrapConnectionCommand");
    function wrapQuery(query, operation, name) {
      const wrapped = /* @__PURE__ */ __name(function() {
        if (!startCh.hasSubscribers) {
          return query.apply(this, arguments);
        }
        const pool = this.server.s.pool;
        const ns = this.ns;
        const ops = this.cmd;
        return instrument(operation, query, this, arguments, pool, ns, ops);
      }, "wrapped");
      return shimmer.wrap(query, wrapped);
    }
    __name(wrapQuery, "wrapQuery");
    function wrapCursor(cursor, operation, name) {
      const wrapped = /* @__PURE__ */ __name(function() {
        if (!startCh.hasSubscribers) {
          return cursor.apply(this, arguments);
        }
        const pool = this.server.s.pool;
        const ns = this.ns;
        return instrument(operation, cursor, this, arguments, pool, ns, {}, { name });
      }, "wrapped");
      return shimmer.wrap(cursor, wrapped);
    }
    __name(wrapCursor, "wrapCursor");
    function wrapCommand(command, operation, name) {
      const wrapped = /* @__PURE__ */ __name(function(ns, ops) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments);
        }
        return instrument(operation, command, this, arguments, this, ns, ops, { name });
      }, "wrapped");
      return shimmer.wrap(command, wrapped);
    }
    __name(wrapCommand, "wrapCommand");
    function instrument(operation, command, ctx, args, server, ns, ops, options = {}) {
      const name = options.name || ops && Object.keys(ops)[0];
      const index = args.length - 1;
      let callback = args[index];
      if (typeof callback !== "function")
        return command.apply(ctx, args);
      const serverInfo = server && server.s && server.s.options;
      const callbackResource = new AsyncResource("bound-anonymous-fn");
      const asyncResource = new AsyncResource("bound-anonymous-fn");
      callback = callbackResource.bind(callback);
      return asyncResource.runInAsyncScope(() => {
        startCh.publish({ ns, ops, options: serverInfo, name });
        args[index] = asyncResource.bind(function(err, res) {
          if (err) {
            errorCh.publish(err);
          }
          finishCh.publish();
          if (callback) {
            return callback.apply(this, arguments);
          }
        });
        try {
          return command.apply(ctx, args);
        } catch (err) {
          errorCh.publish(err);
          throw err;
        }
      });
    }
    __name(instrument, "instrument");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/mongoose.js
var require_mongoose = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/mongoose.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise();
    var { AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function wrapAddQueue(addQueue) {
      return /* @__PURE__ */ __name(function addQueueWithTrace(name) {
        if (typeof name === "function") {
          arguments[0] = AsyncResource.bind(name);
        } else if (typeof this[name] === "function") {
          arguments[0] = AsyncResource.bind((...args) => this[name](...args));
        }
        return addQueue.apply(this, arguments);
      }, "addQueueWithTrace");
    }
    __name(wrapAddQueue, "wrapAddQueue");
    addHook({
      name: "mongoose",
      versions: [">=4.6.4"]
    }, (mongoose) => {
      if (mongoose.Promise !== global.Promise) {
        shimmer.wrap(mongoose.Promise.prototype, "then", wrapThen);
      }
      shimmer.wrap(mongoose.Collection.prototype, "addQueue", wrapAddQueue);
      return mongoose;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/mysql.js
var require_mysql = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/mysql.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "mysql", file: "lib/Connection.js", versions: [">=2"] }, (Connection) => {
      const startCh = channel("apm:mysql:query:start");
      const finishCh = channel("apm:mysql:query:finish");
      const errorCh = channel("apm:mysql:query:error");
      shimmer.wrap(Connection.prototype, "query", (query) => function() {
        if (!startCh.hasSubscribers) {
          return query.apply(this, arguments);
        }
        const sql = arguments[0].sql ? arguments[0].sql : arguments[0];
        const conf = this.config;
        const payload2 = { sql, conf };
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          startCh.publish(payload2);
          if (arguments[0].sql) {
            arguments[0].sql = payload2.sql;
          } else {
            arguments[0] = payload2.sql;
          }
          try {
            const res = query.apply(this, arguments);
            if (res._callback) {
              const cb = callbackResource.bind(res._callback);
              res._callback = asyncResource.bind(function(error, result) {
                if (error) {
                  errorCh.publish(error);
                }
                finishCh.publish(result);
                return cb.apply(this, arguments);
              });
            } else {
              const cb = asyncResource.bind(function() {
                finishCh.publish(void 0);
              });
              res.on("end", cb);
            }
            return res;
          } catch (err) {
            err.stack;
            errorCh.publish(err);
            throw err;
          }
        });
      });
      return Connection;
    });
    addHook({ name: "mysql", file: "lib/Pool.js", versions: [">=2"] }, (Pool) => {
      shimmer.wrap(Pool.prototype, "getConnection", (getConnection) => function(cb) {
        arguments[0] = AsyncResource.bind(cb);
        return getConnection.apply(this, arguments);
      });
      return Pool;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/mysql2.js
var require_mysql2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/mysql2.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "mysql2", file: "lib/connection.js", versions: [">=1"] }, (Connection) => {
      const startCh = channel("apm:mysql2:query:start");
      const finishCh = channel("apm:mysql2:query:finish");
      const errorCh = channel("apm:mysql2:query:error");
      shimmer.wrap(Connection.prototype, "addCommand", (addCommand) => function(cmd) {
        if (!startCh.hasSubscribers)
          return addCommand.apply(this, arguments);
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        const name = cmd && cmd.constructor && cmd.constructor.name;
        const isCommand = typeof cmd.execute === "function";
        const isQuery = isCommand && (name === "Execute" || name === "Query");
        cmd.execute = isQuery ? wrapExecute(cmd, cmd.execute, asyncResource, this.config) : bindExecute(cmd, cmd.execute, asyncResource);
        return asyncResource.bind(addCommand, this).apply(this, arguments);
      });
      return Connection;
      function bindExecute(cmd, execute, asyncResource) {
        return asyncResource.bind(/* @__PURE__ */ __name(function executeWithTrace(packet, connection) {
          if (this.onResult) {
            this.onResult = asyncResource.bind(this.onResult);
          }
          return execute.apply(this, arguments);
        }, "executeWithTrace"), cmd);
      }
      __name(bindExecute, "bindExecute");
      function wrapExecute(cmd, execute, asyncResource, config) {
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.bind(/* @__PURE__ */ __name(function executeWithTrace(packet, connection) {
          const sql = cmd.statement ? cmd.statement.query : cmd.sql;
          const payload2 = { sql, conf: config };
          startCh.publish(payload2);
          if (cmd.statement) {
            cmd.statement.query = payload2.sql;
          } else {
            cmd.sql = payload2.sql;
          }
          if (this.onResult) {
            const onResult = callbackResource.bind(this.onResult);
            this.onResult = asyncResource.bind(function(error) {
              if (error) {
                errorCh.publish(error);
              }
              finishCh.publish(void 0);
              onResult.apply(this, arguments);
            }, "bound-anonymous-fn", this);
          } else {
            this.on("error", asyncResource.bind((error) => errorCh.publish(error)));
            this.on("end", asyncResource.bind(() => finishCh.publish(void 0)));
          }
          this.execute = execute;
          try {
            return execute.apply(this, arguments);
          } catch (err) {
            errorCh.publish(err);
          }
        }, "executeWithTrace"), cmd);
      }
      __name(wrapExecute, "wrapExecute");
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/net.js
var require_net = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/net.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startICPCh = channel("apm:net:ipc:start");
    var finishICPCh = channel("apm:net:ipc:finish");
    var errorICPCh = channel("apm:net:ipc:error");
    var startTCPCh = channel("apm:net:tcp:start");
    var finishTCPCh = channel("apm:net:tcp:finish");
    var errorTCPCh = channel("apm:net:tcp:error");
    var connectionCh = channel(`apm:net:tcp:connection`);
    addHook({ name: "net" }, (net) => {
      __require("dns");
      shimmer.wrap(net.Socket.prototype, "connect", (connect) => function() {
        if (!startICPCh.hasSubscribers || !startTCPCh.hasSubscribers) {
          return connect.apply(this, arguments);
        }
        const options = getOptions(arguments);
        const lastIndex = arguments.length - 1;
        const callback = arguments[lastIndex];
        if (!options)
          return connect.apply(this, arguments);
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        if (typeof callback === "function") {
          arguments[lastIndex] = callbackResource.bind(callback);
        }
        const protocol = options.path ? "ipc" : "tcp";
        return asyncResource.runInAsyncScope(() => {
          if (protocol === "ipc") {
            startICPCh.publish({ options });
            setupListeners(this, "ipc", asyncResource);
          } else {
            startTCPCh.publish({ options });
            setupListeners(this, "tcp", asyncResource);
          }
          const emit = this.emit;
          this.emit = function(eventName) {
            switch (eventName) {
              case "ready":
              case "connect":
                return callbackResource.runInAsyncScope(() => {
                  return emit.apply(this, arguments);
                });
              default:
                return emit.apply(this, arguments);
            }
          };
          try {
            return connect.apply(this, arguments);
          } catch (err) {
            protocol === "ipc" ? errorICPCh.publish(err) : errorTCPCh.publish(err);
            throw err;
          }
        });
      });
      return net;
    });
    function getOptions(args) {
      if (!args[0])
        return;
      switch (typeof args[0]) {
        case "object":
          if (Array.isArray(args[0]))
            return getOptions(args[0]);
          return args[0];
        case "string":
          if (isNaN(parseFloat(args[0]))) {
            return {
              path: args[0]
            };
          }
        case "number":
          return {
            port: args[0],
            host: typeof args[1] === "string" ? args[1] : "localhost"
          };
      }
    }
    __name(getOptions, "getOptions");
    function setupListeners(socket, protocol, asyncResource) {
      const events = ["connect", "error", "close", "timeout"];
      const wrapListener = asyncResource.bind(function(error) {
        if (error) {
          protocol === "ipc" ? errorICPCh.publish(error) : errorTCPCh.publish(error);
        }
        protocol === "ipc" ? finishICPCh.publish(void 0) : finishTCPCh.publish(void 0);
      });
      const localListener = asyncResource.bind(function() {
        connectionCh.publish({ socket });
      });
      const cleanupListener = /* @__PURE__ */ __name(function() {
        socket.removeListener("connect", localListener);
        events.forEach((event) => {
          socket.removeListener(event, wrapListener);
          socket.removeListener(event, cleanupListener);
        });
      }, "cleanupListener");
      if (protocol === "tcp") {
        socket.once("connect", localListener);
      }
      events.forEach((event) => {
        socket.once(event, wrapListener);
        socket.once(event, cleanupListener);
      });
    }
    __name(setupListeners, "setupListeners");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/next.js
var require_next = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/next.js"() {
    "use strict";
    var { channel, addHook, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startChannel = channel("apm:next:request:start");
    var finishChannel = channel("apm:next:request:finish");
    var errorChannel = channel("apm:next:request:error");
    var pageLoadChannel = channel("apm:next:page:load");
    var requestResources = /* @__PURE__ */ new WeakMap();
    function wrapHandleRequest(handleRequest) {
      return function(req, res, pathname, query) {
        return instrument(req, res, () => handleRequest.apply(this, arguments));
      };
    }
    __name(wrapHandleRequest, "wrapHandleRequest");
    function wrapHandleApiRequest(handleApiRequest) {
      return function(req, res, pathname, query) {
        return instrument(req, res, () => {
          const promise = handleApiRequest.apply(this, arguments);
          return promise.then((handled) => {
            if (!handled)
              return handled;
            const page = getPageFromPath(pathname, this.dynamicRoutes);
            pageLoadChannel.publish({ page });
            return handled;
          });
        });
      };
    }
    __name(wrapHandleApiRequest, "wrapHandleApiRequest");
    function wrapRenderToResponse(renderToResponse) {
      return function(ctx) {
        return instrument(ctx.req, ctx.res, () => renderToResponse.apply(this, arguments));
      };
    }
    __name(wrapRenderToResponse, "wrapRenderToResponse");
    function wrapRenderErrorToResponse(renderErrorToResponse) {
      return function(ctx) {
        return instrument(ctx.req, ctx.res, () => renderErrorToResponse.apply(this, arguments));
      };
    }
    __name(wrapRenderErrorToResponse, "wrapRenderErrorToResponse");
    function wrapRenderToHTML(renderToHTML) {
      return function(req, res, pathname, query, parsedUrl) {
        return instrument(req, res, () => renderToHTML.apply(this, arguments));
      };
    }
    __name(wrapRenderToHTML, "wrapRenderToHTML");
    function wrapRenderErrorToHTML(renderErrorToHTML) {
      return function(err, req, res, pathname, query) {
        return instrument(req, res, () => renderErrorToHTML.apply(this, arguments));
      };
    }
    __name(wrapRenderErrorToHTML, "wrapRenderErrorToHTML");
    function wrapFindPageComponents(findPageComponents) {
      return function(pathname, query) {
        const result = findPageComponents.apply(this, arguments);
        if (result) {
          pageLoadChannel.publish({ page: getPagePath(pathname) });
        }
        return result;
      };
    }
    __name(wrapFindPageComponents, "wrapFindPageComponents");
    function getPagePath(page) {
      return typeof page === "object" ? page.pathname : page;
    }
    __name(getPagePath, "getPagePath");
    function getPageFromPath(page, dynamicRoutes = []) {
      for (const dynamicRoute of dynamicRoutes) {
        if (dynamicRoute.page.startsWith("/api") && dynamicRoute.match(page)) {
          return getPagePath(dynamicRoute.page);
        }
      }
      return getPagePath(page);
    }
    __name(getPageFromPath, "getPageFromPath");
    function instrument(req, res, handler2) {
      if (requestResources.has(req))
        return handler2();
      const requestResource = new AsyncResource("bound-anonymous-fn");
      requestResources.set(req, requestResource);
      return requestResource.runInAsyncScope(() => {
        startChannel.publish({ req, res });
        try {
          const promise = handler2();
          return promise.then(
            (result) => finish(req, res, result),
            (err) => finish(req, res, null, err)
          );
        } catch (e) {
          return finish(req, res, null, e);
        }
      });
    }
    __name(instrument, "instrument");
    function finish(req, res, result, err) {
      if (err) {
        errorChannel.publish(err);
      }
      finishChannel.publish({ req, res });
      if (err) {
        throw err;
      }
      return result;
    }
    __name(finish, "finish");
    addHook({ name: "next", versions: [">=11.1"], file: "dist/server/next-server.js" }, (nextServer) => {
      const Server = nextServer.default;
      shimmer.wrap(Server.prototype, "handleRequest", wrapHandleRequest);
      shimmer.wrap(Server.prototype, "handleApiRequest", wrapHandleApiRequest);
      shimmer.wrap(Server.prototype, "renderToResponse", wrapRenderToResponse);
      shimmer.wrap(Server.prototype, "renderErrorToResponse", wrapRenderErrorToResponse);
      shimmer.wrap(Server.prototype, "findPageComponents", wrapFindPageComponents);
      return nextServer;
    });
    addHook({ name: "next", versions: [">=9.5 <11.1"], file: "dist/next-server/server/next-server.js" }, (nextServer) => {
      const Server = nextServer.default;
      shimmer.wrap(Server.prototype, "handleRequest", wrapHandleRequest);
      shimmer.wrap(Server.prototype, "handleApiRequest", wrapHandleApiRequest);
      shimmer.wrap(Server.prototype, "renderToHTML", wrapRenderToHTML);
      shimmer.wrap(Server.prototype, "renderErrorToHTML", wrapRenderErrorToHTML);
      shimmer.wrap(Server.prototype, "findPageComponents", wrapFindPageComponents);
      return nextServer;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/oracledb.js
var require_oracledb = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/oracledb.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var connectionAttributes = /* @__PURE__ */ new WeakMap();
    var poolAttributes = /* @__PURE__ */ new WeakMap();
    var startChannel = channel("apm:oracledb:query:start");
    var errorChannel = channel("apm:oracledb:query:error");
    var finishChannel = channel("apm:oracledb:query:finish");
    function finish(err) {
      if (err) {
        errorChannel.publish(err);
      }
      finishChannel.publish(void 0);
    }
    __name(finish, "finish");
    addHook({ name: "oracledb", versions: ["5"] }, (oracledb) => {
      shimmer.wrap(oracledb.Connection.prototype, "execute", (execute) => {
        return /* @__PURE__ */ __name(function wrappedExecute(dbQuery, ...args) {
          if (!startChannel.hasSubscribers) {
            return execute.apply(this, arguments);
          }
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            const cb = arguments[arguments.length - 1];
            const outerAr = new AsyncResource("apm:oracledb:outer-scope");
            arguments[arguments.length - 1] = /* @__PURE__ */ __name(function wrappedCb(err, result) {
              finish(err);
              return outerAr.runInAsyncScope(() => cb.apply(this, arguments));
            }, "wrappedCb");
          }
          return new AsyncResource("apm:oracledb:inner-scope").runInAsyncScope(() => {
            const connAttrs = connectionAttributes.get(this);
            startChannel.publish({ query: dbQuery, connAttrs });
            try {
              let result = execute.apply(this, arguments);
              if (result && typeof result.then === "function") {
                result = result.then(
                  (x) => {
                    finish();
                    return x;
                  },
                  (e) => {
                    finish(e);
                    throw e;
                  }
                );
              }
              return result;
            } catch (err) {
              errorChannel.publish(err);
              throw err;
            }
          });
        }, "wrappedExecute");
      });
      shimmer.wrap(oracledb, "getConnection", (getConnection) => {
        return /* @__PURE__ */ __name(function wrappedGetConnection(connAttrs, callback) {
          if (callback) {
            arguments[1] = (err, connection) => {
              if (connection) {
                connectionAttributes.set(connection, connAttrs);
              }
              callback(err, connection);
            };
            getConnection.apply(this, arguments);
          } else {
            return getConnection.apply(this, arguments).then((connection) => {
              connectionAttributes.set(connection, connAttrs);
              return connection;
            });
          }
        }, "wrappedGetConnection");
      });
      shimmer.wrap(oracledb, "createPool", (createPool) => {
        return /* @__PURE__ */ __name(function wrappedCreatePool(poolAttrs, callback) {
          if (callback) {
            arguments[1] = (err, pool) => {
              if (pool) {
                poolAttributes.set(pool, poolAttrs);
              }
              callback(err, pool);
            };
            createPool.apply(this, arguments);
          } else {
            return createPool.apply(this, arguments).then((pool) => {
              poolAttributes.set(pool, poolAttrs);
              return pool;
            });
          }
        }, "wrappedCreatePool");
      });
      shimmer.wrap(oracledb.Pool.prototype, "getConnection", (getConnection) => {
        return /* @__PURE__ */ __name(function wrappedGetConnection() {
          let callback;
          if (typeof arguments[arguments.length - 1] === "function") {
            callback = arguments[arguments.length - 1];
          }
          if (callback) {
            arguments[arguments.length - 1] = (err, connection) => {
              if (connection) {
                connectionAttributes.set(connection, poolAttributes.get(this));
              }
              callback(err, connection);
            };
            getConnection.apply(this, arguments);
          } else {
            return getConnection.apply(this, arguments).then((connection) => {
              connectionAttributes.set(connection, poolAttributes.get(this));
              return connection;
            });
          }
        }, "wrappedGetConnection");
      });
      return oracledb;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/paperplane.js
var require_paperplane = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/paperplane.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var logChannel = channel("apm:paperplane:log");
    var handleChannel = channel("apm:paperplane:request:handle");
    var routeChannel = channel("apm:paperplane:request:route");
    var nodeMajor = Number(process.versions.node.split(".")[0]);
    var name = "paperplane";
    var versions = nodeMajor <= 12 ? [">=2.3.2"] : nodeMajor <= 14 ? [">=3.1.1"] : [];
    var wrapRoute = /* @__PURE__ */ __name((handler2) => (req) => {
      const { original, route } = req;
      if (routeChannel.hasSubscribers) {
        routeChannel.publish({ req: original, route });
      }
      return handler2(req);
    }, "wrapRoute");
    var wrapLogger = /* @__PURE__ */ __name((logger) => (record) => {
      const event = { message: record };
      logChannel.publish(event);
      return logger(event.message);
    }, "wrapLogger");
    var wrapMount = /* @__PURE__ */ __name((mount) => (opts) => {
      const handler2 = mount(opts);
      return function(req, res) {
        handleChannel.publish(req);
        return handler2.apply(this, arguments);
      };
    }, "wrapMount");
    var wrapRoutes = /* @__PURE__ */ __name((routes) => (handlers) => {
      const traced = {};
      for (const route in handlers) {
        traced[route] = wrapRoute(handlers[route]);
      }
      return routes(traced);
    }, "wrapRoutes");
    addHook({ name, versions, file: "lib/logger.js" }, (exports3) => {
      shimmer.wrap(exports3, "logger", wrapLogger);
      return exports3;
    });
    addHook({ name, versions, file: "lib/mount.js" }, (exports3) => {
      shimmer.wrap(exports3, "mount", wrapMount);
      return exports3;
    });
    addHook({ name, versions, file: "lib/routes.js" }, (exports3) => {
      shimmer.wrap(exports3, "routes", wrapRoutes);
      return exports3;
    });
    if (nodeMajor <= 12) {
      addHook({ name, versions: ["2.3.0 - 2.3.1"] }, (paperplane) => {
        shimmer.wrap(paperplane, "mount", wrapMount);
        shimmer.wrap(paperplane, "routes", wrapRoutes);
        return paperplane;
      });
    }
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/pg.js
var require_pg = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/pg.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:pg:query:start");
    var finishCh = channel("apm:pg:query:finish");
    var errorCh = channel("apm:pg:query:error");
    addHook({ name: "pg", versions: [">=8.0.3"] }, (pg) => {
      shimmer.wrap(pg.Client.prototype, "query", (query) => wrapQuery(query));
      return pg;
    });
    addHook({ name: "pg", file: "lib/native/index.js", versions: [">=8.0.3"] }, (Client) => {
      shimmer.wrap(Client.prototype, "query", (query) => wrapQuery(query));
      return Client;
    });
    function wrapQuery(query) {
      return function() {
        if (!startCh.hasSubscribers) {
          return query.apply(this, arguments);
        }
        const retval = query.apply(this, arguments);
        const queryQueue = this.queryQueue || this._queryQueue;
        const activeQuery = this.activeQuery || this._activeQuery;
        const pgQuery = queryQueue[queryQueue.length - 1] || activeQuery;
        if (!pgQuery) {
          return retval;
        }
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        const processId = this.processID;
        return asyncResource.runInAsyncScope(() => {
          startCh.publish({
            params: this.connectionParameters,
            originalQuery: pgQuery.text,
            query: pgQuery,
            processId
          });
          const finish = asyncResource.bind(function(error) {
            if (error) {
              errorCh.publish(error);
            }
            finishCh.publish();
          });
          if (pgQuery.callback) {
            const originalCallback = callbackResource.bind(pgQuery.callback);
            pgQuery.callback = function(err, res) {
              finish(err);
              return originalCallback.apply(this, arguments);
            };
          } else if (pgQuery.once) {
            pgQuery.once("error", finish).once("end", () => finish());
          } else {
            pgQuery.then(() => finish(), finish);
          }
          try {
            return retval;
          } catch (err) {
            errorCh.publish(err);
          }
        });
      };
    }
    __name(wrapQuery, "wrapQuery");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/pino.js
var require_pino = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/pino.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function wrapPino(symbol, wrapper, pino) {
      return /* @__PURE__ */ __name(function pinoWithTrace() {
        const instance = pino.apply(this, arguments);
        Object.defineProperty(instance, symbol, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: wrapper(instance[symbol])
        });
        return instance;
      }, "pinoWithTrace");
    }
    __name(wrapPino, "wrapPino");
    function wrapAsJson(asJson) {
      const ch = channel("apm:pino:log");
      return /* @__PURE__ */ __name(function asJsonWithTrace(obj, msg, num, time) {
        obj = arguments[0] = obj || {};
        const payload2 = { message: obj };
        ch.publish(payload2);
        arguments[0] = payload2.message;
        return asJson.apply(this, arguments);
      }, "asJsonWithTrace");
    }
    __name(wrapAsJson, "wrapAsJson");
    function wrapMixin(mixin) {
      const ch = channel("apm:pino:log");
      return /* @__PURE__ */ __name(function mixinWithTrace() {
        let obj = {};
        if (mixin) {
          obj = mixin.apply(this, arguments);
        }
        const payload2 = { message: obj };
        ch.publish(payload2);
        return payload2.message;
      }, "mixinWithTrace");
    }
    __name(wrapMixin, "wrapMixin");
    function wrapPrettifyObject(prettifyObject) {
      const ch = channel("apm:pino:log");
      return /* @__PURE__ */ __name(function prettifyObjectWithTrace(input) {
        const payload2 = { message: input.input };
        ch.publish(payload2);
        input.input = payload2.message;
        return prettifyObject.apply(this, arguments);
      }, "prettifyObjectWithTrace");
    }
    __name(wrapPrettifyObject, "wrapPrettifyObject");
    function wrapPrettyFactory(prettyFactory) {
      const ch = channel("apm:pino:log");
      return /* @__PURE__ */ __name(function prettyFactoryWithTrace() {
        const pretty = prettyFactory.apply(this, arguments);
        return /* @__PURE__ */ __name(function prettyWithTrace(obj) {
          const payload2 = { message: obj };
          ch.publish(payload2);
          arguments[0] = payload2.message;
          return pretty.apply(this, arguments);
        }, "prettyWithTrace");
      }, "prettyFactoryWithTrace");
    }
    __name(wrapPrettyFactory, "wrapPrettyFactory");
    addHook({ name: "pino", versions: ["2 - 3", "4", ">=5 <5.14.0"] }, (pino) => {
      const asJsonSym = pino.symbols && pino.symbols.asJsonSym || "asJson";
      return shimmer.wrap(pino, wrapPino(asJsonSym, wrapAsJson, pino));
    });
    addHook({ name: "pino", versions: [">=5.14.0 <6.8.0"] }, (pino) => {
      const mixinSym = pino.symbols.mixinSym;
      return shimmer.wrap(pino, wrapPino(mixinSym, wrapMixin, pino));
    });
    addHook({ name: "pino", versions: [">=6.8.0"] }, (pino) => {
      const mixinSym = pino.symbols.mixinSym;
      const wrapped = shimmer.wrap(pino, wrapPino(mixinSym, wrapMixin, pino));
      wrapped.pino = wrapped;
      wrapped.default = wrapped;
      return wrapped;
    });
    addHook({ name: "pino-pretty", file: "lib/utils.js", versions: [">=3"] }, (utils) => {
      shimmer.wrap(utils, "prettifyObject", wrapPrettifyObject);
      return utils;
    });
    addHook({ name: "pino-pretty", versions: ["1 - 2"] }, (prettyFactory) => {
      return shimmer.wrap(prettyFactory, wrapPrettyFactory(prettyFactory));
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/promise-js.js
var require_promise_js = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/promise-js.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise();
    var shimmer = require_datadog_shimmer();
    addHook({
      name: "promise-js",
      versions: [">=0.0.3"]
    }, (Promise2) => {
      if (Promise2 !== global.Promise) {
        shimmer.wrap(Promise2.prototype, "then", wrapThen);
      }
      return Promise2;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/promise.js
var require_promise2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/promise.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise();
    var shimmer = require_datadog_shimmer();
    addHook({
      name: "promise",
      file: "lib/core.js",
      versions: [">=7"]
    }, (Promise2) => {
      shimmer.wrap(Promise2.prototype, "then", wrapThen);
      return Promise2;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/q.js
var require_q = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/q.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise();
    var shimmer = require_datadog_shimmer();
    addHook({
      name: "q",
      versions: ["1"]
    }, (Q) => {
      shimmer.wrap(Q.makePromise.prototype, "then", wrapThen);
      return Q;
    });
    addHook({
      name: "q",
      versions: [">=2"]
    }, (Q) => {
      shimmer.wrap(Q.Promise.prototype, "then", wrapThen);
      return Q;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/qs.js
var require_qs = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/qs.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var qsParseCh = channel("datadog:qs:parse:finish");
    function wrapParse(originalParse) {
      return function() {
        const qsParsedObj = originalParse.apply(this, arguments);
        if (qsParseCh.hasSubscribers && qsParsedObj) {
          qsParseCh.publish({ qs: qsParsedObj });
        }
        return qsParsedObj;
      };
    }
    __name(wrapParse, "wrapParse");
    addHook({
      name: "qs",
      versions: [">=1"]
    }, (qs) => {
      shimmer.wrap(qs, "parse", wrapParse);
      return qs;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/restify.js
var require_restify = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/restify.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var handlers = ["use", "pre"];
    var methods = ["del", "get", "head", "opts", "post", "put", "patch"];
    var handleChannel = channel("apm:restify:request:handle");
    var errorChannel = channel("apm:restify:middleware:error");
    var enterChannel = channel("apm:restify:middleware:enter");
    var exitChannel = channel("apm:restify:middleware:exit");
    var finishChannel = channel("apm:restify:middleware:finish");
    var nextChannel = channel("apm:restify:middleware:next");
    function wrapSetupRequest(setupRequest) {
      return function(req, res) {
        handleChannel.publish({ req, res });
        return setupRequest.apply(this, arguments);
      };
    }
    __name(wrapSetupRequest, "wrapSetupRequest");
    function wrapMethod(method) {
      return function(path) {
        const middleware = wrapMiddleware(Array.prototype.slice.call(arguments, 1));
        return method.apply(this, [path].concat(middleware));
      };
    }
    __name(wrapMethod, "wrapMethod");
    function wrapHandler(method) {
      return function() {
        return method.apply(this, wrapMiddleware(arguments));
      };
    }
    __name(wrapHandler, "wrapHandler");
    function wrapMiddleware(middleware) {
      return Array.prototype.map.call(middleware, wrapFn);
    }
    __name(wrapMiddleware, "wrapMiddleware");
    function wrapFn(fn) {
      if (Array.isArray(fn))
        return wrapMiddleware(fn);
      return function(req, res, next) {
        if (typeof next === "function") {
          arguments[2] = wrapNext(req, next);
        }
        const route = req.route && req.route.path;
        enterChannel.publish({ req, route });
        try {
          return fn.apply(this, arguments);
        } catch (error) {
          errorChannel.publish({ req, error });
          nextChannel.publish({ req });
          finishChannel.publish({ req });
          throw error;
        } finally {
          exitChannel.publish({ req });
        }
      };
    }
    __name(wrapFn, "wrapFn");
    function wrapNext(req, next) {
      return function() {
        nextChannel.publish({ req });
        finishChannel.publish({ req });
        next.apply(this, arguments);
      };
    }
    __name(wrapNext, "wrapNext");
    addHook({ name: "restify", versions: [">=3"], file: "lib/server.js" }, (Server) => {
      shimmer.wrap(Server.prototype, "_setupRequest", wrapSetupRequest);
      shimmer.massWrap(Server.prototype, handlers, wrapHandler);
      shimmer.massWrap(Server.prototype, methods, wrapMethod);
      return Server;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/rhea.js
var require_rhea = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/rhea.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var circularBufferConstructor = Symbol("circularBufferConstructor");
    var inFlightDeliveries = Symbol("inFlightDeliveries");
    var patched = /* @__PURE__ */ new WeakSet();
    var startSendCh = channel("apm:rhea:send:start");
    var encodeSendCh = channel("apm:rhea:send:encode");
    var errorSendCh = channel("apm:rhea:send:error");
    var finishSendCh = channel("apm:rhea:send:finish");
    var startReceiveCh = channel("apm:rhea:receive:start");
    var dispatchReceiveCh = channel("apm:rhea:receive:dispatch");
    var errorReceiveCh = channel("apm:rhea:receive:error");
    var finishReceiveCh = channel("apm:rhea:receive:finish");
    var contexts = /* @__PURE__ */ new WeakMap();
    addHook({ name: "rhea", versions: [">=1"] }, (rhea) => {
      shimmer.wrap(rhea.message, "encode", (encode) => function(msg) {
        encodeSendCh.publish(msg);
        return encode.apply(this, arguments);
      });
      return rhea;
    });
    addHook({ name: "rhea", versions: [">=1"], file: "lib/link.js" }, (obj) => {
      const Sender = obj.Sender;
      const Receiver = obj.Receiver;
      shimmer.wrap(Sender.prototype, "send", (send) => function(msg, tag, format) {
        if (!canTrace(this)) {
          return send.apply(this, arguments);
        }
        const { host, port } = getHostAndPort(this.connection);
        const targetAddress = this.options && this.options.target && this.options.target.address ? this.options.target.address : void 0;
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        return asyncResource.runInAsyncScope(() => {
          startSendCh.publish({ targetAddress, host, port, msg });
          const delivery = send.apply(this, arguments);
          const context = {
            asyncResource
          };
          contexts.set(delivery, context);
          addToInFlightDeliveries(this.connection, delivery);
          try {
            return delivery;
          } catch (err) {
            errorSendCh.publish(err);
            throw err;
          }
        });
      });
      shimmer.wrap(Receiver.prototype, "dispatch", (dispatch) => function(eventName, msgObj) {
        if (!canTrace(this)) {
          return dispatch.apply(this, arguments);
        }
        if (eventName === "message" && msgObj) {
          const asyncResource = new AsyncResource("bound-anonymous-fn");
          return asyncResource.runInAsyncScope(() => {
            startReceiveCh.publish({ msgObj, connection: this.connection });
            if (msgObj.delivery) {
              const context = {
                asyncResource
              };
              contexts.set(msgObj.delivery, context);
              msgObj.delivery.update = wrapDeliveryUpdate(msgObj.delivery, msgObj.delivery.update);
              addToInFlightDeliveries(this.connection, msgObj.delivery);
            }
            try {
              return dispatch.apply(this, arguments);
            } catch (err) {
              errorReceiveCh.publish(err);
              throw err;
            }
          });
        }
        return dispatch.apply(this, arguments);
      });
      return obj;
    });
    addHook({ name: "rhea", versions: [">=1"], file: "lib/connection.js" }, (Connection) => {
      shimmer.wrap(Connection.prototype, "dispatch", (dispatch) => function(eventName, obj) {
        if (eventName === "disconnected") {
          const error = obj.error || this.saved_error;
          if (this[inFlightDeliveries]) {
            this[inFlightDeliveries].forEach((delivery) => {
              const context = contexts.get(delivery);
              const asyncResource = context && context.asyncResource;
              if (!asyncResource)
                return;
              asyncResource.runInAsyncScope(() => {
                errorReceiveCh.publish(error);
                beforeFinish(delivery, null);
                finishReceiveCh.publish();
              });
            });
          }
        }
        return dispatch.apply(this, arguments);
      });
      return Connection;
    });
    addHook({ name: "rhea", versions: [">=1"], file: "lib/session.js" }, (Session) => {
      patchCircularBuffer(Session.prototype, Session);
      return Session;
    });
    function canTrace(link) {
      return link.connection && link.session && link.session.outgoing;
    }
    __name(canTrace, "canTrace");
    function getHostAndPort(connection) {
      let host;
      let port;
      if (connection && connection.options) {
        host = connection.options.host;
        port = connection.options.port;
      }
      return { host, port };
    }
    __name(getHostAndPort, "getHostAndPort");
    function wrapDeliveryUpdate(obj, update) {
      const context = contexts.get(obj);
      const asyncResource = context.asyncResource;
      if (obj && asyncResource) {
        const cb = asyncResource.bind(update);
        return AsyncResource.bind(/* @__PURE__ */ __name(function wrappedUpdate(settled, stateData) {
          const state = getStateFromData(stateData);
          dispatchReceiveCh.publish({ state });
          return cb.apply(this, arguments);
        }, "wrappedUpdate"));
      }
      return /* @__PURE__ */ __name(function wrappedUpdate(settled, stateData) {
        return update.apply(this, arguments);
      }, "wrappedUpdate");
    }
    __name(wrapDeliveryUpdate, "wrapDeliveryUpdate");
    function patchCircularBuffer(proto, Session) {
      Object.defineProperty(proto, "outgoing", {
        configurable: true,
        get() {
          return void 0;
        },
        set(outgoing) {
          delete proto.outgoing;
          this.outgoing = outgoing;
          if (outgoing) {
            let CircularBuffer;
            if (outgoing.deliveries) {
              CircularBuffer = outgoing.deliveries.constructor;
            }
            if (CircularBuffer && !patched.has(CircularBuffer.prototype)) {
              shimmer.wrap(CircularBuffer.prototype, "pop_if", (popIf) => function(fn) {
                arguments[0] = AsyncResource.bind(function(entry) {
                  const context = contexts.get(entry);
                  const asyncResource = context && context.asyncResource;
                  if (!asyncResource)
                    return fn(entry);
                  const shouldPop = asyncResource.runInAsyncScope(() => fn(entry));
                  if (shouldPop) {
                    const remoteState = entry.remote_state;
                    const state = remoteState && remoteState.constructor ? entry.remote_state.constructor.composite_type : void 0;
                    asyncResource.runInAsyncScope(() => {
                      beforeFinish(entry, state);
                      finishSendCh.publish();
                    });
                  }
                  return shouldPop;
                });
                return popIf.apply(this, arguments);
              });
              patched.add(CircularBuffer.prototype);
              const Session2 = proto.constructor;
              if (Session2) {
                Session2[circularBufferConstructor] = CircularBuffer;
              }
            }
          }
        }
      });
    }
    __name(patchCircularBuffer, "patchCircularBuffer");
    function addToInFlightDeliveries(connection, delivery) {
      let deliveries = connection[inFlightDeliveries];
      if (!deliveries) {
        deliveries = /* @__PURE__ */ new Set();
        connection[inFlightDeliveries] = deliveries;
      }
      deliveries.add(delivery);
    }
    __name(addToInFlightDeliveries, "addToInFlightDeliveries");
    function beforeFinish(delivery, state) {
      const obj = contexts.get(delivery);
      if (obj) {
        if (state) {
          dispatchReceiveCh.publish({ state });
        }
        if (obj.connection && obj.connection[inFlightDeliveries]) {
          obj.connection[inFlightDeliveries].delete(delivery);
        }
      }
    }
    __name(beforeFinish, "beforeFinish");
    function getStateFromData(stateData) {
      if (stateData && stateData.descriptor && stateData.descriptor) {
        switch (stateData.descriptor.value) {
          case 36:
            return "accepted";
          case 37:
            return "rejected";
          case 38:
            return "released";
          case 39:
            return "modified";
        }
      }
    }
    __name(getStateFromData, "getStateFromData");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/sharedb.js
var require_sharedb = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/sharedb.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var READABLE_ACTION_NAMES = {
      hs: "handshake",
      qf: "query-fetch",
      qs: "query-subscribe",
      qu: "query-unsubscribe",
      bf: "bulk-fetch",
      bs: "bulk-subscribe",
      bu: "bulk-unsubscribe",
      f: "fetch",
      s: "subscribe",
      u: "unsubscribe",
      op: "op",
      nf: "snapshot-fetch",
      nt: "snapshot-fetch-by-ts",
      p: "presence-broadcast",
      pr: "presence-request",
      ps: "presence-subscribe",
      pu: "presence-unsubscribe"
    };
    addHook({ name: "sharedb", versions: [">=1"], file: "lib/agent.js" }, (Agent) => {
      const startCh = channel("apm:sharedb:request:start");
      const finishCh = channel("apm:sharedb:request:finish");
      const errorCh = channel("apm:sharedb:request:error");
      shimmer.wrap(Agent.prototype, "_handleMessage", (origHandleMessageFn) => function(request, callback) {
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        const action = request.a;
        const actionName = getReadableActionName(action);
        return asyncResource.runInAsyncScope(() => {
          startCh.publish({ actionName, request });
          callback = callbackResource.bind(callback);
          arguments[1] = asyncResource.bind(function(error, res) {
            if (error) {
              errorCh.publish(error);
            }
            finishCh.publish({ request, res });
            return callback.apply(this, arguments);
          });
          try {
            return origHandleMessageFn.apply(this, arguments);
          } catch (error) {
            errorCh.publish(error);
            throw error;
          }
        });
      });
      return Agent;
    });
    function getReadableActionName(action) {
      const actionName = READABLE_ACTION_NAMES[action];
      if (actionName === void 0) {
        return action;
      }
      return actionName;
    }
    __name(getReadableActionName, "getReadableActionName");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/tedious.js
var require_tedious = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/tedious.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "tedious", versions: [">=1.0.0"] }, (tedious) => {
      const startCh = channel("apm:tedious:request:start");
      const finishCh = channel("apm:tedious:request:finish");
      const errorCh = channel("apm:tedious:request:error");
      shimmer.wrap(tedious.Connection.prototype, "makeRequest", (makeRequest) => function(request) {
        if (!startCh.hasSubscribers) {
          return makeRequest.apply(this, arguments);
        }
        const queryOrProcedure = getQueryOrProcedure(request);
        if (!queryOrProcedure) {
          return makeRequest.apply(this, arguments);
        }
        const callbackResource = new AsyncResource("bound-anonymous-fn");
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        const connectionConfig = this.config;
        return asyncResource.runInAsyncScope(() => {
          startCh.publish({ queryOrProcedure, connectionConfig });
          const cb = callbackResource.bind(request.callback, request);
          request.callback = asyncResource.bind(function(error) {
            if (error) {
              errorCh.publish(error);
            }
            finishCh.publish(void 0);
            return cb.apply(this, arguments);
          }, null, request);
          try {
            return makeRequest.apply(this, arguments);
          } catch (error) {
            errorCh.publish(error);
            throw error;
          }
        });
      });
      return tedious;
    });
    function getQueryOrProcedure(request) {
      if (!request.parameters)
        return;
      const statement = request.parametersByName.statement || request.parametersByName.stmt;
      if (!statement) {
        return request.sqlTextOrProcedure;
      }
      return statement.value;
    }
    __name(getQueryOrProcedure, "getQueryOrProcedure");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/when.js
var require_when = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/when.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise();
    var shimmer = require_datadog_shimmer();
    addHook({
      name: "when",
      file: "lib/Promise.js",
      versions: [">=3"]
    }, (Promise2) => {
      shimmer.wrap(Promise2.prototype, "then", wrapThen);
      return Promise2;
    });
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/winston.js
var require_winston = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/winston.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var patched = /* @__PURE__ */ new WeakSet();
    addHook({ name: "winston", file: "lib/winston/logger.js", versions: [">=3"] }, (Logger) => {
      const logCh = channel("apm:winston:log");
      shimmer.wrap(Logger.prototype, "write", (write) => {
        return /* @__PURE__ */ __name(function wrappedWrite(chunk, enc, cb) {
          if (logCh.hasSubscribers) {
            const payload2 = { message: chunk };
            logCh.publish(payload2);
            arguments[0] = payload2.message;
          }
          return write.apply(this, arguments);
        }, "wrappedWrite");
      });
      return Logger;
    });
    addHook({ name: "winston", file: "lib/winston/logger.js", versions: ["1", "2"] }, (logger) => {
      const logCh = channel("apm:winston:log");
      if (logger.Logger.prototype.configure) {
        shimmer.wrap(logger.Logger.prototype, "configure", (configure) => wrapMethod(configure, logCh));
      }
      shimmer.wrap(logger.Logger.prototype, "add", (configure) => wrapMethod(configure, logCh));
      return logger;
    });
    function wrapMethod(method, logCh) {
      return /* @__PURE__ */ __name(function methodWithTrace() {
        const result = method.apply(this, arguments);
        if (logCh.hasSubscribers) {
          for (const name in this.transports) {
            const transport = this.transports[name];
            if (patched.has(transport) || typeof transport.log !== "function")
              continue;
            const log = transport.log;
            transport.log = /* @__PURE__ */ __name(function wrappedLog(level, msg, meta, callback) {
              const payload2 = { message: meta || {} };
              logCh.publish(payload2);
              arguments[2] = payload2.message;
              log.apply(this, arguments);
            }, "wrappedLog");
            patched.add(transport);
          }
        }
        return result;
      }, "methodWithTrace");
    }
    __name(wrapMethod, "wrapMethod");
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hooks.js
var require_hooks = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/hooks.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "@aws-sdk/smithy-client": () => require_aws_sdk(),
      "@cucumber/cucumber": () => require_cucumber(),
      "@playwright/test": () => require_playwright(),
      "@elastic/elasticsearch": () => require_elasticsearch(),
      "@elastic/transport": () => require_elasticsearch(),
      "@google-cloud/pubsub": () => require_google_cloud_pubsub(),
      "@grpc/grpc-js": () => require_grpc(),
      "@hapi/hapi": () => require_hapi(),
      "@jest/core": () => require_jest(),
      "@jest/reporters": () => require_jest(),
      "@koa/router": () => require_koa(),
      "@node-redis/client": () => require_redis(),
      "@opensearch-project/opensearch": () => require_opensearch(),
      "@redis/client": () => require_redis(),
      "amqp10": () => require_amqp10(),
      "amqplib": () => require_amqplib(),
      "aws-sdk": () => require_aws_sdk(),
      "bluebird": () => require_bluebird(),
      "body-parser": () => require_body_parser(),
      "bunyan": () => require_bunyan(),
      "cassandra-driver": () => require_cassandra_driver(),
      "child_process": () => require_child_process(),
      "node:child_process": () => require_child_process(),
      "connect": () => require_connect(),
      "couchbase": () => require_couchbase(),
      "crypto": () => require_crypto(),
      "cypress": () => require_cypress(),
      "dns": () => require_dns(),
      "elasticsearch": () => require_elasticsearch(),
      "express": () => require_express(),
      "fastify": () => require_fastify(),
      "find-my-way": () => require_find_my_way(),
      "fs": () => require_fs(),
      "node:fs": () => require_fs(),
      "graphql": () => require_graphql(),
      "grpc": () => require_grpc(),
      "hapi": () => require_hapi(),
      "http": () => require_http2(),
      "http2": () => require_http22(),
      "https": () => require_http2(),
      "ioredis": () => require_ioredis(),
      "jest-circus": () => require_jest(),
      "jest-config": () => require_jest(),
      "jest-environment-node": () => require_jest(),
      "jest-environment-jsdom": () => require_jest(),
      "jest-jasmine2": () => require_jest(),
      "koa": () => require_koa(),
      "koa-router": () => require_koa(),
      "kafkajs": () => require_kafkajs(),
      "ldapjs": () => require_ldapjs(),
      "limitd-client": () => require_limitd_client(),
      "mariadb": () => require_mariadb(),
      "memcached": () => require_memcached(),
      "microgateway-core": () => require_microgateway_core(),
      "mocha": () => require_mocha(),
      "mocha-each": () => require_mocha(),
      "moleculer": () => require_moleculer(),
      "mongodb": () => require_mongodb_core(),
      "mongodb-core": () => require_mongodb_core(),
      "mongoose": () => require_mongoose(),
      "mysql": () => require_mysql(),
      "mysql2": () => require_mysql2(),
      "net": () => require_net(),
      "next": () => require_next(),
      "oracledb": () => require_oracledb(),
      "paperplane": () => require_paperplane(),
      "pg": () => require_pg(),
      "pino": () => require_pino(),
      "pino-pretty": () => require_pino(),
      "promise-js": () => require_promise_js(),
      "promise": () => require_promise2(),
      "q": () => require_q(),
      "qs": () => require_qs(),
      "redis": () => require_redis(),
      "restify": () => require_restify(),
      "rhea": () => require_rhea(),
      "router": () => require_router(),
      "sharedb": () => require_sharedb(),
      "tedious": () => require_tedious(),
      "when": () => require_when(),
      "winston": () => require_winston()
    };
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/register.js
var require_register2 = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/register.js"(exports2, module2) {
    "use strict";
    var { channel } = __require("diagnostics_channel");
    var path = __require("path");
    var semver = require_semver();
    var Hook = require_hook();
    var requirePackageJson = require_require_package_json();
    var log = require_log();
    var hooks = require_hooks();
    var instrumentations = require_instrumentations();
    var names = Object.keys(hooks);
    var pathSepExpr = new RegExp(`\\${path.sep}`, "g");
    var loadChannel = channel("dd-trace:instrumentation:load");
    for (const packageName of names) {
      Hook([packageName], (moduleExports, moduleName2, moduleBaseDir) => {
        moduleName2 = moduleName2.replace(pathSepExpr, "/");
        hooks[packageName]();
        for (const { name, file, versions, hook } of instrumentations[packageName]) {
          const fullFilename = filename(name, file);
          if (moduleName2 === fullFilename) {
            const version = getVersion(moduleBaseDir);
            if (matchVersion(version, versions)) {
              try {
                loadChannel.publish({ name, version, file });
                moduleExports = hook(moduleExports, version);
              } catch (e) {
                log.error(e);
              }
            }
          }
        }
        return moduleExports;
      });
    }
    function matchVersion(version, ranges) {
      return !version || ranges && ranges.some((range) => semver.satisfies(semver.coerce(version), range));
    }
    __name(matchVersion, "matchVersion");
    function getVersion(moduleBaseDir) {
      if (moduleBaseDir) {
        return requirePackageJson(moduleBaseDir, module2).version;
      }
    }
    __name(getVersion, "getVersion");
    function filename(name, file) {
      return [name, file].filter((val) => val).join("/");
    }
    __name(filename, "filename");
    module2.exports = {
      filename,
      pathSepExpr
    };
  }
});

// node_modules/dd-trace/packages/datadog-instrumentations/index.js
var require_datadog_instrumentations = __commonJS({
  "node_modules/dd-trace/packages/datadog-instrumentations/index.js"() {
    "use strict";
    require_register2();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/errors.js
var require_errors = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/errors.js"(exports2, module2) {
    "use strict";
    var ExtendedError = class extends Error {
      constructor(reason) {
        super(reason);
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    __name(ExtendedError, "ExtendedError");
    var ImpendingTimeout = class extends ExtendedError {
    };
    __name(ImpendingTimeout, "ImpendingTimeout");
    ImpendingTimeout.prototype.name = "Impending Timeout";
    module2.exports = {
      ImpendingTimeout
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/lambda/handler.js
var require_handler = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/lambda/handler.js"(exports2) {
    "use strict";
    var { channel } = require_instrument();
    var { ERROR_MESSAGE, ERROR_TYPE } = require_constants();
    var { ImpendingTimeout } = require_errors();
    var globalTracer = global._ddtrace;
    var tracer2 = globalTracer._tracer;
    var timeoutChannel = channel("apm:aws:lambda:timeout");
    timeoutChannel.subscribe((_) => {
      crashFlush();
    });
    var __lambdaTimeout;
    function checkTimeout(context) {
      let remainingTimeInMillis = context.getRemainingTimeInMillis();
      const apmFlushDeadline = parseInt(process.env.DD_APM_FLUSH_DEADLINE);
      if (apmFlushDeadline && apmFlushDeadline <= remainingTimeInMillis) {
        remainingTimeInMillis = apmFlushDeadline;
      }
      __lambdaTimeout = setTimeout(() => {
        timeoutChannel.publish(void 0);
      }, remainingTimeInMillis - 50);
    }
    __name(checkTimeout, "checkTimeout");
    function crashFlush() {
      const activeSpan = tracer2.scope().active();
      const error = new ImpendingTimeout("Datadog detected an impending timeout");
      activeSpan.addTags({
        [ERROR_MESSAGE]: error.message,
        [ERROR_TYPE]: error.name
      });
      tracer2._processor.killAll();
      activeSpan.finish();
    }
    __name(crashFlush, "crashFlush");
    exports2.datadog = /* @__PURE__ */ __name(function datadog2(lambdaHandler) {
      return (...args) => {
        const context = args[1];
        const patched = lambdaHandler.apply(this, args);
        checkTimeout(context);
        if (patched) {
          patched.then((_) => clearTimeout(__lambdaTimeout));
        }
        return patched;
      };
    }, "datadog");
  }
});

// node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/patch.js
var require_patch = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/patch.js"() {
    "use strict";
    var path = __require("path");
    var { _extractModuleNameAndHandlerPath, _extractModuleRootAndHandler, _getLambdaFilePath } = require_ritm2();
    var { datadog: datadog2 } = require_handler();
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var patchDatadogLambdaModule = /* @__PURE__ */ __name((datadogLambdaModule) => {
      shimmer.wrap(datadogLambdaModule, "datadog", patchDatadogLambdaHandler);
      return datadogLambdaModule;
    }, "patchDatadogLambdaModule");
    function patchDatadogLambdaHandler(datadogHandler) {
      return (userHandler) => {
        return datadogHandler(datadog2(userHandler));
      };
    }
    __name(patchDatadogLambdaHandler, "patchDatadogLambdaHandler");
    var patchLambdaModule = /* @__PURE__ */ __name((handlerPath) => (lambdaModule) => {
      shimmer.wrap(lambdaModule, handlerPath, patchLambdaHandler);
      return lambdaModule;
    }, "patchLambdaModule");
    function patchLambdaHandler(lambdaHandler) {
      return datadog2(lambdaHandler);
    }
    __name(patchLambdaHandler, "patchLambdaHandler");
    var lambdaTaskRoot = process.env.LAMBDA_TASK_ROOT;
    var originalLambdaHandler = process.env.DD_LAMBDA_HANDLER;
    if (originalLambdaHandler !== void 0) {
      const [moduleRoot, moduleAndHandler] = _extractModuleRootAndHandler(originalLambdaHandler);
      const [_module, handlerPath] = _extractModuleNameAndHandlerPath(moduleAndHandler);
      const lambdaStylePath = path.resolve(lambdaTaskRoot, moduleRoot, _module);
      const lambdaFilePath = _getLambdaFilePath(lambdaStylePath);
      addHook({ name: lambdaFilePath }, patchLambdaModule(handlerPath));
    } else {
      addHook({ name: "datadog-lambda-js" }, patchDatadogLambdaModule);
    }
  }
});

// node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/ritm.js
var require_ritm2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/lambda/runtime/ritm.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    var log = require_log();
    var Hook = require_hook();
    var instrumentations = require_instrumentations();
    var {
      filename,
      pathSepExpr
    } = require_register2();
    function _extractModuleRootAndHandler(fullHandler) {
      const handlerString = path.basename(fullHandler);
      const moduleRoot = fullHandler.substring(0, fullHandler.indexOf(handlerString));
      return [moduleRoot, handlerString];
    }
    __name(_extractModuleRootAndHandler, "_extractModuleRootAndHandler");
    function _extractModuleNameAndHandlerPath(handler2) {
      const FUNCTION_EXPR = /^([^.]*)\.(.*)$/;
      const match = handler2.match(FUNCTION_EXPR);
      if (!match || match.length !== 3) {
        return;
      }
      return [match[1], match[2]];
    }
    __name(_extractModuleNameAndHandlerPath, "_extractModuleNameAndHandlerPath");
    function _getLambdaFilePath(lambdaStylePath) {
      let lambdaFilePath = lambdaStylePath;
      if (fs.existsSync(lambdaStylePath + ".js")) {
        lambdaFilePath += ".js";
      } else if (fs.existsSync(lambdaStylePath + ".mjs")) {
        lambdaFilePath += ".mjs";
      } else if (fs.existsSync(lambdaStylePath + ".cjs")) {
        lambdaFilePath += ".cjs";
      }
      return lambdaFilePath;
    }
    __name(_getLambdaFilePath, "_getLambdaFilePath");
    var registerLambdaHook = /* @__PURE__ */ __name(() => {
      const lambdaTaskRoot = process.env.LAMBDA_TASK_ROOT;
      const originalLambdaHandler = process.env.DD_LAMBDA_HANDLER;
      if (originalLambdaHandler !== void 0) {
        const [moduleRoot, moduleAndHandler] = _extractModuleRootAndHandler(originalLambdaHandler);
        const [_module] = _extractModuleNameAndHandlerPath(moduleAndHandler);
        const lambdaStylePath = path.resolve(lambdaTaskRoot, moduleRoot, _module);
        const lambdaFilePath = _getLambdaFilePath(lambdaStylePath);
        Hook([lambdaFilePath], (moduleExports) => {
          require_patch();
          for (const { hook } of instrumentations[lambdaFilePath]) {
            try {
              moduleExports = hook(moduleExports);
            } catch (e) {
              log.error(e);
            }
          }
          return moduleExports;
        });
      } else {
        const moduleToPatch = "datadog-lambda-js";
        Hook([moduleToPatch], (moduleExports, moduleName2, _) => {
          moduleName2 = moduleName2.replace(pathSepExpr, "/");
          require_patch();
          for (const { name, file, hook } of instrumentations[moduleToPatch]) {
            const fullFilename = filename(name, file);
            if (moduleName2 === fullFilename) {
              try {
                moduleExports = hook(moduleExports);
              } catch (e) {
                log.error(e);
              }
            }
          }
          return moduleExports;
        });
      }
    }, "registerLambdaHook");
    module2.exports = {
      _extractModuleRootAndHandler,
      _extractModuleNameAndHandlerPath,
      _getLambdaFilePath,
      registerLambdaHook
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/lambda/index.js
var require_lambda2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/lambda/index.js"() {
    "use strict";
    var { registerLambdaHook } = require_ritm2();
    registerLambdaHook();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/plugin_manager.js
var require_plugin_manager = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/plugin_manager.js"(exports2, module2) {
    "use strict";
    var { channel } = __require("diagnostics_channel");
    var { isFalse } = require_util();
    var plugins = require_plugins();
    var log = require_log();
    var loadChannel = channel("dd-trace:instrumentation:load");
    require_datadog_instrumentations();
    if (process.env.AWS_LAMBDA_FUNCTION_NAME !== void 0) {
      require_lambda2();
    }
    var { DD_TRACE_DISABLED_PLUGINS } = process.env;
    var disabledPlugins = new Set(
      DD_TRACE_DISABLED_PLUGINS && DD_TRACE_DISABLED_PLUGINS.split(",").map((plugin) => plugin.trim())
    );
    var pluginClasses = {};
    loadChannel.subscribe(({ name }) => {
      const Plugin = plugins[name];
      if (!Plugin || typeof Plugin !== "function")
        return;
      if (!pluginClasses[Plugin.name]) {
        const envName = `DD_TRACE_${Plugin.name.toUpperCase()}_ENABLED`;
        const enabled = process.env[envName.replace(/[^a-z0-9_]/ig, "_")];
        if (isFalse(enabled) || disabledPlugins.has(Plugin.name)) {
          log.debug(`Plugin "${Plugin.name}" was disabled via configuration option.`);
          pluginClasses[Plugin.name] = null;
        } else {
          pluginClasses[Plugin.name] = Plugin;
        }
      }
    });
    module2.exports = /* @__PURE__ */ __name(class PluginManager {
      constructor(tracer2) {
        this._tracer = tracer2;
        this._tracerConfig = null;
        this._pluginsByName = {};
        this._configsByName = {};
        this._loadedSubscriber = ({ name }) => {
          const Plugin = plugins[name];
          if (!Plugin || typeof Plugin !== "function")
            return;
          this.loadPlugin(Plugin.name);
        };
        loadChannel.subscribe(this._loadedSubscriber);
      }
      loadPlugin(name) {
        const Plugin = pluginClasses[name];
        if (!Plugin)
          return;
        if (!this._pluginsByName[name]) {
          this._pluginsByName[name] = new Plugin(this._tracer);
        }
        if (!this._tracerConfig)
          return;
        const pluginConfig = this._configsByName[name] || {
          enabled: this._tracerConfig.plugins !== false
        };
        this._pluginsByName[name].configure({
          ...this._getSharedConfig(name),
          ...pluginConfig
        });
      }
      configurePlugin(name, pluginConfig) {
        const enabled = this._isEnabled(pluginConfig);
        this._configsByName[name] = {
          ...pluginConfig,
          enabled
        };
        this.loadPlugin(name);
      }
      configure(config = {}) {
        this._tracerConfig = config;
        for (const name in pluginClasses) {
          this.loadPlugin(name);
        }
      }
      destroy() {
        for (const name in this._pluginsByName) {
          this._pluginsByName[name].configure({ enabled: false });
        }
        loadChannel.unsubscribe(this._loadedSubscriber);
      }
      _isEnabled(pluginConfig) {
        if (typeof pluginConfig === "boolean")
          return pluginConfig;
        if (!pluginConfig)
          return true;
        return pluginConfig.enabled !== false;
      }
      _getSharedConfig(name) {
        const {
          logInjection,
          serviceMapping,
          queryStringObfuscation,
          site,
          url,
          dbmPropagationMode
        } = this._tracerConfig;
        const sharedConfig = {};
        if (logInjection !== void 0) {
          sharedConfig.logInjection = logInjection;
        }
        if (queryStringObfuscation !== void 0) {
          sharedConfig.queryStringObfuscation = queryStringObfuscation;
        }
        sharedConfig.dbmPropagationMode = dbmPropagationMode;
        if (serviceMapping && serviceMapping[name]) {
          sharedConfig.service = serviceMapping[name];
        }
        sharedConfig.site = site;
        sharedConfig.url = url;
        return sharedConfig;
      }
    }, "PluginManager");
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/remote_config/scheduler.js
var require_scheduler = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/remote_config/scheduler.js"(exports2, module2) {
    "use strict";
    var Scheduler = class {
      constructor(callback, interval) {
        this._timer = null;
        this._callback = callback;
        this._interval = interval;
      }
      start() {
        if (this._timer)
          return;
        this.runAfterDelay(0);
      }
      runAfterDelay(interval = this._interval) {
        this._timer = setTimeout(this._callback, interval, () => this.runAfterDelay());
        this._timer.unref && this._timer.unref();
      }
      stop() {
        clearTimeout(this._timer);
        this._timer = null;
      }
    };
    __name(Scheduler, "Scheduler");
    module2.exports = Scheduler;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/remote_config/manager.js
var require_manager = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/remote_config/manager.js"(exports2, module2) {
    "use strict";
    var uuid = require_crypto_randomuuid();
    var { EventEmitter } = __require("events");
    var Scheduler = require_scheduler();
    var tracerVersion = require_package().version;
    var request = require_request();
    var log = require_log();
    var clientId = uuid();
    var DEFAULT_CAPABILITY = Buffer.alloc(1).toString("base64");
    var RemoteConfigManager = class extends EventEmitter {
      constructor(config) {
        super();
        const pollInterval = config.remoteConfig.pollInterval * 1e3;
        this.scheduler = new Scheduler((cb) => this.poll(cb), pollInterval);
        this.requestOptions = {
          url: config.url,
          hostname: config.hostname,
          port: config.port,
          method: "POST",
          path: "/v0.7/config"
        };
        this.state = {
          client: {
            state: {
              root_version: 1,
              targets_version: 0,
              config_states: [],
              has_error: false,
              error: "",
              backend_client_state: ""
            },
            id: clientId,
            products: [],
            is_tracer: true,
            client_tracer: {
              runtime_id: config.tags["runtime-id"],
              language: "node",
              tracer_version: tracerVersion,
              service: config.service,
              env: config.env,
              app_version: config.version
            },
            capabilities: DEFAULT_CAPABILITY
          },
          cached_target_files: []
        };
        this.appliedConfigs = /* @__PURE__ */ new Map();
      }
      updateCapabilities(mask, value) {
        const hex = Buffer.from(this.state.client.capabilities, "base64").toString("hex");
        let num = BigInt(`0x${hex}`);
        if (value) {
          num |= mask;
        } else {
          num &= ~mask;
        }
        let str = num.toString(16);
        if (str.length % 2)
          str = `0${str}`;
        this.state.client.capabilities = Buffer.from(str, "hex").toString("base64");
      }
      on(event, listener) {
        super.on(event, listener);
        this.state.client.products = this.eventNames();
        this.scheduler.start();
        return this;
      }
      off(event, listener) {
        super.off(event, listener);
        this.state.client.products = this.eventNames();
        if (!this.state.client.products.length) {
          this.scheduler.stop();
        }
        return this;
      }
      poll(cb) {
        request(JSON.stringify(this.state), this.requestOptions, (err, data, statusCode) => {
          if (statusCode === 404)
            return cb();
          if (err) {
            log.error(err);
            return cb();
          }
          if (this.state.client.state.has_error) {
            this.state.client.state.has_error = false;
            this.state.client.state.error = "";
          }
          if (data && data !== "{}") {
            try {
              this.parseConfig(JSON.parse(data));
            } catch (err2) {
              log.error(`Could not parse remote config response: ${err2}`);
              this.state.client.state.has_error = true;
              this.state.client.state.error = err2.toString();
            }
          }
          cb();
        });
      }
      parseConfig({
        client_configs: clientConfigs = [],
        targets,
        target_files: targetFiles = []
      }) {
        const toUnapply = [];
        const toApply = [];
        const toModify = [];
        for (const appliedConfig of this.appliedConfigs.values()) {
          if (!clientConfigs.includes(appliedConfig.path)) {
            toUnapply.push(appliedConfig);
          }
        }
        targets = fromBase64JSON(targets);
        if (targets) {
          for (const path of clientConfigs) {
            const meta = targets.signed.targets[path];
            if (!meta)
              throw new Error(`Unable to find target for path ${path}`);
            const current = this.appliedConfigs.get(path);
            const newConf = {};
            if (current) {
              if (current.hashes.sha256 === meta.hashes.sha256)
                continue;
              toModify.push(newConf);
            } else {
              toApply.push(newConf);
            }
            const file = targetFiles.find((file2) => file2.path === path);
            if (!file)
              throw new Error(`Unable to find file for path ${path}`);
            const { product, id } = parseConfigPath(path);
            Object.assign(newConf, {
              path,
              product,
              id,
              version: meta.custom.v,
              apply_state: 1,
              apply_error: "",
              length: meta.length,
              hashes: meta.hashes,
              file: fromBase64JSON(file.raw)
            });
          }
          this.state.client.state.targets_version = targets.signed.version;
          this.state.client.state.backend_client_state = targets.signed.custom.opaque_backend_state;
        }
        if (toUnapply.length || toApply.length || toModify.length) {
          this.dispatch(toUnapply, "unapply");
          this.dispatch(toApply, "apply");
          this.dispatch(toModify, "modify");
          this.state.client.state.config_states = [];
          this.state.cached_target_files = [];
          for (const conf of this.appliedConfigs.values()) {
            this.state.client.state.config_states.push({
              id: conf.id,
              version: conf.version,
              product: conf.product,
              apply_state: conf.apply_state,
              apply_error: conf.apply_error
            });
            this.state.cached_target_files.push({
              path: conf.path,
              length: conf.length,
              hashes: Object.entries(conf.hashes).map((entry) => ({ algorithm: entry[0], hash: entry[1] }))
            });
          }
        }
      }
      dispatch(list, action) {
        for (const item of list) {
          try {
            this.emit(item.product, action, item.file, item.id);
            item.apply_state = 2;
          } catch (err) {
            item.apply_state = 3;
            item.apply_error = err.toString();
          }
          if (action === "unapply") {
            this.appliedConfigs.delete(item.path);
          } else {
            this.appliedConfigs.set(item.path, item);
          }
        }
      }
    };
    __name(RemoteConfigManager, "RemoteConfigManager");
    function fromBase64JSON(str) {
      if (!str)
        return null;
      return JSON.parse(Buffer.from(str, "base64").toString());
    }
    __name(fromBase64JSON, "fromBase64JSON");
    var configPathRegex = /^(?:datadog\/\d+|employee)\/([^/]+)\/([^/]+)\/[^/]+$/;
    function parseConfigPath(configPath) {
      const match = configPathRegex.exec(configPath);
      if (!match || !match[1] || !match[2]) {
        throw new Error(`Unable to parse path ${configPath}`);
      }
      return {
        product: match[1],
        id: match[2]
      };
    }
    __name(parseConfigPath, "parseConfigPath");
    module2.exports = RemoteConfigManager;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/remote_config/capabilities.js
var require_capabilities = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/remote_config/capabilities.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ASM_ACTIVATION: 1n << 1n,
      ASM_IP_BLOCKING: 1n << 2n,
      ASM_DD_RULES: 1n << 3n
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js
var require_addresses = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/addresses.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      HTTP_INCOMING_BODY: "server.request.body",
      HTTP_INCOMING_QUERY: "server.request.query",
      HTTP_INCOMING_HEADERS: "server.request.headers.no_cookies",
      HTTP_INCOMING_URL: "server.request.uri.raw",
      HTTP_INCOMING_METHOD: "server.request.method",
      HTTP_INCOMING_ENDPOINT: "server.request.framework_endpoint",
      HTTP_INCOMING_PARAMS: "server.request.path_params",
      HTTP_INCOMING_COOKIES: "server.request.cookies",
      HTTP_INCOMING_RESPONSE_CODE: "server.response.status",
      HTTP_INCOMING_RESPONSE_HEADERS: "server.response.headers.no_cookies",
      HTTP_INCOMING_REMOTE_IP: "server.request.client_ip",
      HTTP_INCOMING_REMOTE_PORT: "server.request.client_port",
      HTTP_CLIENT_IP: "http.client_ip"
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/als.js
var require_als = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/als.js"(exports2, module2) {
    "use strict";
    var { AsyncLocalStorage } = __require("async_hooks");
    module2.exports = new AsyncLocalStorage();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/runner.js
var require_runner = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/runner.js"(exports2, module2) {
    "use strict";
    var als = require_als();
    var lock = false;
    function runSubscriptions(subscriptions, params) {
      const results = [];
      if (lock || !subscriptions.size)
        return results;
      lock = true;
      const store = als.getStore();
      const executedCallbacks = /* @__PURE__ */ new Set();
      for (const subscription of subscriptions) {
        if (executedCallbacks.has(subscription.callback))
          continue;
        executedCallbacks.add(subscription.callback);
        let result;
        try {
          result = subscription.callback.method(params, store);
        } catch (err) {
        }
        results.push(result);
      }
      lock = false;
      return results;
    }
    __name(runSubscriptions, "runSubscriptions");
    module2.exports = {
      runSubscriptions
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/engine.js
var require_engine = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/engine.js"(exports2, module2) {
    "use strict";
    var Runner = require_runner();
    var MAX_CONTEXT_SIZE = 1024;
    var SubscriptionManager = class {
      constructor() {
        this.addressToSubscriptions = /* @__PURE__ */ new Map();
        this.addresses = /* @__PURE__ */ new Set();
        this.subscriptions = /* @__PURE__ */ new Set();
      }
      clear() {
        this.addressToSubscriptions = /* @__PURE__ */ new Map();
        this.addresses = /* @__PURE__ */ new Set();
        this.subscriptions = /* @__PURE__ */ new Set();
      }
      addSubscription(subscription) {
        if (!subscription.addresses.length || this.subscriptions.has(subscription))
          return;
        for (let i = 0; i < subscription.addresses.length; ++i) {
          const address = subscription.addresses[i];
          this.addresses.add(address);
          const list = this.addressToSubscriptions.get(address);
          if (list === void 0) {
            this.addressToSubscriptions.set(address, [subscription]);
          } else {
            list.push(subscription);
          }
        }
        this.subscriptions.add(subscription);
      }
      matchSubscriptions(newAddresses, allAddresses) {
        const addresses = /* @__PURE__ */ new Set();
        const subscriptions = /* @__PURE__ */ new Set();
        const knownSubscriptions = /* @__PURE__ */ new Set();
        newAddresses.forEach((newAddress) => {
          const matchedSubscriptions = this.addressToSubscriptions.get(newAddress);
          if (matchedSubscriptions === void 0)
            return;
          for (let j = 0; j < matchedSubscriptions.length; ++j) {
            const subscription = matchedSubscriptions[j];
            if (knownSubscriptions.has(subscription) === true)
              continue;
            knownSubscriptions.add(subscription);
            const isFulfilled = subscription.addresses.every(allAddresses.has, allAddresses);
            if (isFulfilled === true) {
              for (let k = 0; k < subscription.addresses.length; ++k) {
                addresses.add(subscription.addresses[k]);
              }
              subscriptions.add(subscription);
            }
          }
        });
        return { addresses, subscriptions };
      }
      dispatch(newAddresses, allAddresses, context) {
        const matches = this.matchSubscriptions(newAddresses, allAddresses);
        const params = {};
        matches.addresses.forEach((address) => {
          params[address] = context.resolve(address);
        });
        return Runner.runSubscriptions(matches.subscriptions, params);
      }
    };
    __name(SubscriptionManager, "SubscriptionManager");
    var Context = class {
      static setManager(manager) {
        this.manager = manager;
      }
      constructor() {
        this.store = /* @__PURE__ */ new Map();
        this.allAddresses = /* @__PURE__ */ new Set();
        this.newAddresses = /* @__PURE__ */ new Set();
      }
      clear() {
        this.store = /* @__PURE__ */ new Map();
        this.allAddresses = /* @__PURE__ */ new Set();
        this.newAddresses = /* @__PURE__ */ new Set();
      }
      setValue(address, value) {
        if (this.allAddresses.size >= MAX_CONTEXT_SIZE)
          return this;
        if (typeof value !== "object") {
          const oldValue = this.store.get(address);
          if (oldValue === value)
            return this;
        }
        this.store.set(address, value);
        this.allAddresses.add(address);
        this.newAddresses.add(address);
        return this;
      }
      dispatch() {
        if (this.newAddresses.size === 0)
          return [];
        const result = Context.manager.dispatch(this.newAddresses, this.allAddresses, this);
        this.newAddresses.clear();
        return result;
      }
      resolve(address) {
        return this.store.get(address);
      }
    };
    __name(Context, "Context");
    module2.exports = {
      SubscriptionManager,
      Context
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/index.js
var require_engine2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/index.js"(exports2, module2) {
    "use strict";
    var { SubscriptionManager, Context } = require_engine();
    var als = require_als();
    var manager = new SubscriptionManager();
    Context.setManager(manager);
    function startContext() {
      const store = /* @__PURE__ */ new Map();
      store.set("context", new Context());
      als.enterWith(store);
      return store;
    }
    __name(startContext, "startContext");
    function getContext() {
      const store = als.getStore();
      return store && store.get("context");
    }
    __name(getContext, "getContext");
    function needsAddress(address) {
      return manager.addresses.has(address);
    }
    __name(needsAddress, "needsAddress");
    function propagate(data, context = getContext()) {
      if (!context)
        return;
      const keys = Object.keys(data);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (needsAddress(key)) {
          context.setValue(key, data[key]);
        }
      }
      return context.dispatch();
    }
    __name(propagate, "propagate");
    module2.exports = {
      manager,
      startContext,
      getContext,
      needsAddress,
      propagate
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/reporter.js
var require_reporter = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/reporter.js"(exports2, module2) {
    "use strict";
    var addresses = require_addresses();
    var Limiter = require_rate_limiter();
    var web = require_web();
    var limiter = new Limiter(100);
    var REQUEST_HEADERS_PASSLIST = [
      "accept",
      "accept-encoding",
      "accept-language",
      "content-encoding",
      "content-language",
      "content-length",
      "content-type",
      "forwarded",
      "forwarded-for",
      "host",
      "true-client-ip",
      "user-agent",
      "via",
      "x-client-ip",
      "x-cluster-client-ip",
      "x-forwarded",
      "x-forwarded-for",
      "x-real-ip"
    ];
    var RESPONSE_HEADERS_PASSLIST = [
      "content-encoding",
      "content-language",
      "content-length",
      "content-type"
    ];
    var metricsQueue = /* @__PURE__ */ new Map();
    function resolveHTTPRequest(context) {
      if (!context)
        return {};
      const headers = context.resolve(addresses.HTTP_INCOMING_HEADERS);
      return {
        remote_ip: context.resolve(addresses.HTTP_INCOMING_REMOTE_IP),
        headers: filterHeaders(headers, REQUEST_HEADERS_PASSLIST, "http.request.headers.")
      };
    }
    __name(resolveHTTPRequest, "resolveHTTPRequest");
    function resolveHTTPResponse(context) {
      if (!context)
        return {};
      const headers = context.resolve(addresses.HTTP_INCOMING_RESPONSE_HEADERS);
      return {
        endpoint: context.resolve(addresses.HTTP_INCOMING_ENDPOINT),
        headers: filterHeaders(headers, RESPONSE_HEADERS_PASSLIST, "http.response.headers.")
      };
    }
    __name(resolveHTTPResponse, "resolveHTTPResponse");
    function filterHeaders(headers, passlist, prefix) {
      const result = {};
      if (!headers)
        return result;
      for (let i = 0; i < passlist.length; ++i) {
        const headerName = passlist[i];
        if (headers[headerName]) {
          result[`${prefix}${formatHeaderName(headerName)}`] = headers[headerName] + "";
        }
      }
      return result;
    }
    __name(filterHeaders, "filterHeaders");
    function formatHeaderName(name) {
      return name.trim().slice(0, 200).replace(/[^a-zA-Z0-9_\-:/]/g, "_").toLowerCase();
    }
    __name(formatHeaderName, "formatHeaderName");
    function reportMetrics(metrics, store) {
      const req = store && store.get("req");
      const rootSpan = web.root(req);
      if (!rootSpan)
        return false;
      if (metrics.duration) {
        rootSpan.setTag("_dd.appsec.waf.duration", metrics.duration);
      }
      if (metrics.durationExt) {
        rootSpan.setTag("_dd.appsec.waf.duration_ext", metrics.durationExt);
      }
      if (metrics.rulesVersion) {
        rootSpan.setTag("_dd.appsec.event_rules.version", metrics.rulesVersion);
      }
    }
    __name(reportMetrics, "reportMetrics");
    function reportAttack(attackData, store) {
      const req = store && store.get("req");
      const rootSpan = web.root(req);
      if (!rootSpan)
        return false;
      const currentTags = rootSpan.context()._tags;
      const newTags = {
        "appsec.event": "true"
      };
      if (limiter.isAllowed()) {
        newTags["manual.keep"] = "true";
      }
      if (!currentTags["_dd.origin"]) {
        newTags["_dd.origin"] = "appsec";
      }
      const currentJson = currentTags["_dd.appsec.json"];
      if (currentJson) {
        newTags["_dd.appsec.json"] = currentJson.slice(0, -2) + "," + attackData.slice(1, -1) + currentJson.slice(-2);
      } else {
        newTags["_dd.appsec.json"] = '{"triggers":' + attackData + "}";
      }
      const context = store.get("context");
      if (context) {
        const resolvedRequest = resolveHTTPRequest(context);
        Object.assign(newTags, resolvedRequest.headers);
        const ua = resolvedRequest.headers["http.request.headers.user-agent"];
        if (ua) {
          newTags["http.useragent"] = ua;
        }
        newTags["network.client.ip"] = resolvedRequest.remote_ip;
      }
      rootSpan.addTags(newTags);
    }
    __name(reportAttack, "reportAttack");
    function finishRequest(req, context) {
      const rootSpan = web.root(req);
      if (!rootSpan)
        return false;
      if (metricsQueue.size) {
        rootSpan.addTags(Object.fromEntries(metricsQueue));
        metricsQueue.clear();
      }
      if (!context || !rootSpan.context()._tags["appsec.event"])
        return false;
      const resolvedResponse = resolveHTTPResponse(context);
      const newTags = resolvedResponse.headers;
      if (resolvedResponse.endpoint) {
        newTags["http.endpoint"] = resolvedResponse.endpoint;
      }
      rootSpan.addTags(newTags);
    }
    __name(finishRequest, "finishRequest");
    function setRateLimit(rateLimit) {
      limiter = new Limiter(rateLimit);
    }
    __name(setRateLimit, "setRateLimit");
    module2.exports = {
      metricsQueue,
      resolveHTTPRequest,
      resolveHTTPResponse,
      filterHeaders,
      formatHeaderName,
      reportMetrics,
      reportAttack,
      finishRequest,
      setRateLimit
    };
  }
});

// node_modules/@datadog/native-appsec/index.js
var require_native_appsec = __commonJS({
  "node_modules/@datadog/native-appsec/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_node_gyp_build()(__dirname);
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/ddwaf.js
var require_ddwaf = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/ddwaf.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var addresses = require_addresses();
    var Gateway = require_engine2();
    var Reporter = require_reporter();
    var validAddressSet = new Set(Object.values(addresses));
    var WAFCallback = class {
      static loadDDWAF(rules, config) {
        try {
          const { DDWAF } = require_native_appsec();
          return new DDWAF(rules, config);
        } catch (err) {
          log.error("AppSec could not load native package. In-app WAF features will not be available.");
          throw err;
        }
      }
      constructor(rules, config) {
        const { wafTimeout, obfuscatorKeyRegex, obfuscatorValueRegex } = config;
        this.ddwaf = WAFCallback.loadDDWAF(rules, { obfuscatorKeyRegex, obfuscatorValueRegex });
        this.wafTimeout = wafTimeout;
        Reporter.metricsQueue.set("_dd.appsec.waf.version", this.ddwaf.constructor.version());
        const { loaded, failed, errors } = this.ddwaf.rulesInfo;
        Reporter.metricsQueue.set("_dd.appsec.event_rules.loaded", loaded);
        Reporter.metricsQueue.set("_dd.appsec.event_rules.error_count", failed);
        if (failed)
          Reporter.metricsQueue.set("_dd.appsec.event_rules.errors", JSON.stringify(errors));
        Reporter.metricsQueue.set("manual.keep", "true");
        this.wafContextCache = /* @__PURE__ */ new WeakMap();
        const self2 = this;
        const method = /* @__PURE__ */ __name((params, store) => {
          return self2.action(params, store);
        }, "method");
        const callback = { method };
        const subscribedAddresses = /* @__PURE__ */ new Set();
        for (const rule of rules.rules) {
          for (const condition of rule.conditions) {
            for (const input of condition.parameters.inputs) {
              const address = input.address.split(":", 2)[0];
              if (!validAddressSet.has(address) || subscribedAddresses.has(address))
                continue;
              subscribedAddresses.add(address);
              Gateway.manager.addSubscription({ addresses: [address], callback });
            }
          }
        }
      }
      action(params, store) {
        let wafContext;
        if (store) {
          const key = store.get("context");
          if (key) {
            if (this.wafContextCache.has(key)) {
              wafContext = this.wafContextCache.get(key);
            } else {
              wafContext = this.ddwaf.createContext();
              this.wafContextCache.set(key, wafContext);
            }
          }
        }
        if (!wafContext || wafContext.disposed) {
          wafContext = this.ddwaf.createContext();
        }
        if (params[addresses.HTTP_INCOMING_RESPONSE_CODE]) {
          params[addresses.HTTP_INCOMING_RESPONSE_CODE] = params[addresses.HTTP_INCOMING_RESPONSE_CODE] + "";
        }
        try {
          const start = process.hrtime.bigint();
          const result = wafContext.run(params, this.wafTimeout);
          result.durationExt = parseInt(process.hrtime.bigint() - start);
          return this.applyResult(result, store);
        } catch (err) {
          log.error("Error while running the AppSec WAF");
          log.error(err);
        } finally {
          wafContext.dispose();
        }
      }
      applyResult(result, store) {
        Reporter.reportMetrics({
          duration: result.totalRuntime / 1e3,
          durationExt: result.durationExt / 1e3,
          rulesVersion: this.ddwaf.rulesInfo.version
        }, store);
        if (result.data && result.data !== "[]") {
          Reporter.reportAttack(result.data, store);
        }
        return result.actions;
      }
      updateRuleData(ruleData) {
        this.ddwaf.updateRuleData(ruleData);
      }
      clear() {
        this.ddwaf.dispose();
        this.wafContextCache = /* @__PURE__ */ new WeakMap();
      }
    };
    __name(WAFCallback, "WAFCallback");
    module2.exports = WAFCallback;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/index.js
var require_callbacks = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      get DDWAF() {
        return require_ddwaf();
      }
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/rule_manager.js
var require_rule_manager = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/rule_manager.js"(exports2, module2) {
    "use strict";
    var callbacks = require_callbacks();
    var Gateway = require_engine2();
    var appliedCallbacks = /* @__PURE__ */ new Map();
    var appliedAsmData = /* @__PURE__ */ new Map();
    function applyRules(rules, config) {
      if (appliedCallbacks.has(rules))
        return;
      const callback = new callbacks.DDWAF(rules, config);
      appliedCallbacks.set(rules, callback);
    }
    __name(applyRules, "applyRules");
    function updateAsmData(action, asmData, asmDataId) {
      if (action === "unapply") {
        appliedAsmData.delete(asmDataId);
      } else {
        appliedAsmData.set(asmDataId, asmData);
      }
      const mergedRuleData = mergeRuleData(appliedAsmData.values());
      for (const callback of appliedCallbacks.values()) {
        callback.updateRuleData(mergedRuleData);
      }
    }
    __name(updateAsmData, "updateAsmData");
    function mergeRuleData(asmDataValues) {
      const mergedRulesData = /* @__PURE__ */ new Map();
      for (const asmData of asmDataValues) {
        if (!asmData.rules_data)
          continue;
        for (const rulesData of asmData.rules_data) {
          const key = `${rulesData.id}+${rulesData.type}`;
          if (mergedRulesData.has(key)) {
            const existingRulesData = mergedRulesData.get(key);
            rulesData.data.reduce(rulesReducer, existingRulesData.data);
          } else {
            mergedRulesData.set(key, copyRulesData(rulesData));
          }
        }
      }
      return [...mergedRulesData.values()];
    }
    __name(mergeRuleData, "mergeRuleData");
    function rulesReducer(existingEntries, rulesDataEntry) {
      const existingEntry = existingEntries.find((entry) => entry.value === rulesDataEntry.value);
      if (existingEntry && !("expiration" in existingEntry))
        return existingEntries;
      if (existingEntry && "expiration" in rulesDataEntry && rulesDataEntry.expiration > existingEntry.expiration) {
        existingEntry.expiration = rulesDataEntry.expiration;
      } else if (existingEntry && !("expiration" in rulesDataEntry)) {
        delete existingEntry.expiration;
      } else if (!existingEntry) {
        existingEntries.push({ ...rulesDataEntry });
      }
      return existingEntries;
    }
    __name(rulesReducer, "rulesReducer");
    function copyRulesData(rulesData) {
      const copy = { ...rulesData };
      if (copy.data) {
        const data = [];
        copy.data.forEach((item) => {
          data.push({ ...item });
        });
        copy.data = data;
      }
      return copy;
    }
    __name(copyRulesData, "copyRulesData");
    function clearAllRules() {
      Gateway.manager.clear();
      for (const [key, callback] of appliedCallbacks) {
        callback.clear();
        appliedCallbacks.delete(key);
      }
      appliedAsmData.clear();
    }
    __name(clearAllRules, "clearAllRules");
    module2.exports = {
      applyRules,
      clearAllRules,
      updateAsmData
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/blocking.js
var require_blocking = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/blocking.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var templateHtml;
    var templateJson;
    function block(req, res, topSpan, abortController) {
      let type;
      let body;
      const accept = req.headers.accept && req.headers.accept.split(",").map((str) => str.split(";", 1)[0].trim());
      if (accept && accept.includes("text/html") && !accept.includes("application/json")) {
        type = "text/html";
        body = templateHtml;
      } else {
        type = "application/json";
        body = templateJson;
      }
      topSpan.addTags({
        "appsec.blocked": "true"
      });
      res.statusCode = 403;
      res.setHeader("Content-Type", type);
      res.setHeader("Content-Length", Buffer.byteLength(body));
      res.end(body);
      abortController.abort();
    }
    __name(block, "block");
    function loadTemplates(config) {
      templateHtml = fs.readFileSync(config.appsec.blockedTemplateHtml);
      templateJson = fs.readFileSync(config.appsec.blockedTemplateJson);
    }
    __name(loadTemplates, "loadTemplates");
    async function loadTemplatesAsync(config) {
      templateHtml = await fs.promises.readFile(config.appsec.blockedTemplateHtml);
      templateJson = await fs.promises.readFile(config.appsec.blockedTemplateJson);
    }
    __name(loadTemplatesAsync, "loadTemplatesAsync");
    module2.exports = {
      block,
      loadTemplates,
      loadTemplatesAsync
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/index.js
var require_appsec = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/index.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    var log = require_log();
    var RuleManager = require_rule_manager();
    var remoteConfig = require_remote_config();
    var { incomingHttpRequestStart, incomingHttpRequestEnd } = require_channels2();
    var Gateway = require_engine2();
    var addresses = require_addresses();
    var Reporter = require_reporter();
    var web = require_web();
    var { extractIp } = require_ip_extractor();
    var { HTTP_CLIENT_IP } = require_tags();
    var { block, loadTemplates, loadTemplatesAsync } = require_blocking();
    var isEnabled = false;
    var config;
    function enable(_config) {
      if (isEnabled)
        return;
      try {
        loadTemplates(_config);
        const rules = fs.readFileSync(_config.appsec.rules || path.join(__dirname, "recommended.json"));
        enableFromRules(_config, JSON.parse(rules));
      } catch (err) {
        abortEnable(err);
      }
    }
    __name(enable, "enable");
    async function enableAsync(_config) {
      if (isEnabled)
        return;
      try {
        await loadTemplatesAsync(_config);
        const rules = await fs.promises.readFile(_config.appsec.rules || path.join(__dirname, "recommended.json"));
        enableFromRules(_config, JSON.parse(rules));
      } catch (err) {
        abortEnable(err);
      }
    }
    __name(enableAsync, "enableAsync");
    function enableFromRules(_config, rules) {
      RuleManager.applyRules(rules, _config.appsec);
      remoteConfig.enableAsmData(_config.appsec);
      Reporter.setRateLimit(_config.appsec.rateLimit);
      incomingHttpRequestStart.subscribe(incomingHttpStartTranslator);
      incomingHttpRequestEnd.subscribe(incomingHttpEndTranslator);
      Gateway.manager.addresses.add(addresses.HTTP_INCOMING_HEADERS);
      Gateway.manager.addresses.add(addresses.HTTP_INCOMING_ENDPOINT);
      Gateway.manager.addresses.add(addresses.HTTP_INCOMING_RESPONSE_HEADERS);
      Gateway.manager.addresses.add(addresses.HTTP_INCOMING_REMOTE_IP);
      isEnabled = true;
      config = _config;
    }
    __name(enableFromRules, "enableFromRules");
    function abortEnable(err) {
      log.error("Unable to start AppSec");
      log.error(err);
      RuleManager.clearAllRules();
      remoteConfig.disableAsmData();
    }
    __name(abortEnable, "abortEnable");
    function incomingHttpStartTranslator({ req, res, abortController }) {
      const topSpan = web.root(req);
      if (!topSpan)
        return;
      const clientIp = extractIp(config, req);
      topSpan.addTags({
        "_dd.appsec.enabled": 1,
        "_dd.runtime_family": "nodejs",
        [HTTP_CLIENT_IP]: clientIp
      });
      const store = Gateway.startContext();
      store.set("req", req);
      store.set("res", res);
      const context = store.get("context");
      if (clientIp) {
        const results = Gateway.propagate({
          [addresses.HTTP_CLIENT_IP]: clientIp
        }, context);
        if (!results || !abortController)
          return;
        for (const entry of results) {
          if (entry && entry.includes("block")) {
            block(req, res, topSpan, abortController);
            break;
          }
        }
      }
    }
    __name(incomingHttpStartTranslator, "incomingHttpStartTranslator");
    function incomingHttpEndTranslator(data) {
      const context = Gateway.getContext();
      if (!context)
        return;
      const requestHeaders = Object.assign({}, data.req.headers);
      delete requestHeaders.cookie;
      const responseHeaders = Object.assign({}, data.res.getHeaders());
      delete responseHeaders["set-cookie"];
      const payload2 = {
        [addresses.HTTP_INCOMING_URL]: data.req.url,
        [addresses.HTTP_INCOMING_HEADERS]: requestHeaders,
        [addresses.HTTP_INCOMING_METHOD]: data.req.method,
        [addresses.HTTP_INCOMING_REMOTE_IP]: data.req.socket.remoteAddress,
        [addresses.HTTP_INCOMING_REMOTE_PORT]: data.req.socket.remotePort,
        [addresses.HTTP_INCOMING_RESPONSE_CODE]: data.res.statusCode,
        [addresses.HTTP_INCOMING_RESPONSE_HEADERS]: responseHeaders
      };
      if (data.req.body !== void 0 && data.req.body !== null) {
        payload2[addresses.HTTP_INCOMING_BODY] = data.req.body;
      }
      if (data.req.query && typeof data.req.query === "object") {
        payload2[addresses.HTTP_INCOMING_QUERY] = data.req.query;
      }
      if (data.req.route && typeof data.req.route.path === "string") {
        payload2[addresses.HTTP_INCOMING_ENDPOINT] = data.req.route.path;
      }
      if (data.req.params && typeof data.req.params === "object") {
        payload2[addresses.HTTP_INCOMING_PARAMS] = data.req.params;
      }
      if (data.req.cookies && typeof data.req.cookies === "object") {
        payload2[addresses.HTTP_INCOMING_COOKIES] = {};
        for (const k of Object.keys(data.req.cookies)) {
          payload2[addresses.HTTP_INCOMING_COOKIES][k] = [data.req.cookies[k]];
        }
      }
      Gateway.propagate(payload2, context);
      Reporter.finishRequest(data.req, context);
    }
    __name(incomingHttpEndTranslator, "incomingHttpEndTranslator");
    function disable() {
      isEnabled = false;
      config = null;
      RuleManager.clearAllRules();
      remoteConfig.disableAsmData();
      if (incomingHttpRequestStart.hasSubscribers)
        incomingHttpRequestStart.unsubscribe(incomingHttpStartTranslator);
      if (incomingHttpRequestEnd.hasSubscribers)
        incomingHttpRequestEnd.unsubscribe(incomingHttpEndTranslator);
    }
    __name(disable, "disable");
    module2.exports = {
      enable,
      enableAsync,
      disable,
      incomingHttpStartTranslator,
      incomingHttpEndTranslator
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/remote_config/index.js
var require_remote_config = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/remote_config/index.js"(exports2, module2) {
    "use strict";
    var RemoteConfigManager = require_manager();
    var RemoteConfigCapabilities = require_capabilities();
    var RuleManager = require_rule_manager();
    var rc;
    function enable(config) {
      rc = new RemoteConfigManager(config);
      if (config.appsec.enabled === void 0) {
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_ACTIVATION, true);
        rc.on("ASM_FEATURES", (action, conf) => {
          if (conf && conf.asm && typeof conf.asm.enabled === "boolean") {
            let shouldEnable;
            if (action === "apply" || action === "modify") {
              shouldEnable = conf.asm.enabled;
            } else {
              shouldEnable = config.appsec.enabled;
            }
            if (shouldEnable) {
              require_appsec().enableAsync(config).catch(() => {
              });
            } else {
              require_appsec().disable();
            }
          }
        });
      }
    }
    __name(enable, "enable");
    function enableAsmData(appsecConfig) {
      if (rc && appsecConfig && appsecConfig.rules === void 0) {
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_IP_BLOCKING, true);
        rc.on("ASM_DATA", _asmDataListener);
      }
    }
    __name(enableAsmData, "enableAsmData");
    function disableAsmData() {
      if (rc) {
        rc.off("ASM_DATA", _asmDataListener);
      }
    }
    __name(disableAsmData, "disableAsmData");
    function _asmDataListener(action, ruleData, ruleId) {
      RuleManager.updateAsmData(action, ruleData, ruleId);
    }
    __name(_asmDataListener, "_asmDataListener");
    module2.exports = {
      enable,
      enableAsmData,
      disableAsmData
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/utils.js
var require_utils = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/utils.js"(exports2, module2) {
    "use strict";
    function getRootSpan(tracer2) {
      const span = tracer2.scope().active();
      return span && span.context()._trace.started[0];
    }
    __name(getRootSpan, "getRootSpan");
    module2.exports = {
      getRootSpan
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/track_event.js
var require_track_event = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/track_event.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var { getRootSpan } = require_utils();
    var { MANUAL_KEEP } = require_tags();
    function trackUserLoginSuccessEvent(tracer2, user, metadata) {
      if (!user || !user.id) {
        log.warn("Invalid user provided to trackUserLoginSuccessEvent");
        return;
      }
      const rootSpan = getRootSpan(tracer2);
      if (!rootSpan) {
        log.warn("Root span not available in trackUserLoginSuccessEvent");
        return;
      }
      tracer2.setUser(user);
      trackEvent(tracer2, "users.login.success", metadata, "trackUserLoginSuccessEvent", rootSpan);
    }
    __name(trackUserLoginSuccessEvent, "trackUserLoginSuccessEvent");
    function trackUserLoginFailureEvent(tracer2, userId, exists, metadata) {
      if (!userId || typeof userId !== "string") {
        log.warn("Invalid userId provided to trackUserLoginFailureEvent");
        return;
      }
      const fields = {
        "usr.id": userId,
        "usr.exists": exists ? "true" : "false",
        ...metadata
      };
      trackEvent(tracer2, "users.login.failure", fields, "trackUserLoginFailureEvent");
    }
    __name(trackUserLoginFailureEvent, "trackUserLoginFailureEvent");
    function trackCustomEvent(tracer2, eventName, metadata) {
      if (!eventName || typeof eventName !== "string") {
        log.warn("Invalid eventName provided to trackCustomEvent");
        return;
      }
      trackEvent(tracer2, eventName, metadata, "trackCustomEvent");
    }
    __name(trackCustomEvent, "trackCustomEvent");
    function trackEvent(tracer2, eventName, fields, sdkMethodName, rootSpan = getRootSpan(tracer2)) {
      if (!rootSpan) {
        log.warn(`Root span not available in ${sdkMethodName}`);
        return;
      }
      const tags = {
        [`appsec.events.${eventName}.track`]: "true",
        [MANUAL_KEEP]: "true"
      };
      if (fields) {
        for (const metadataKey of Object.keys(fields)) {
          tags[`appsec.events.${eventName}.${metadataKey}`] = "" + fields[metadataKey];
        }
      }
      rootSpan.addTags(tags);
    }
    __name(trackEvent, "trackEvent");
    module2.exports = {
      trackUserLoginSuccessEvent,
      trackUserLoginFailureEvent,
      trackCustomEvent
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/index.js
var require_sdk = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/sdk/index.js"(exports2, module2) {
    "use strict";
    var { trackUserLoginSuccessEvent, trackUserLoginFailureEvent, trackCustomEvent } = require_track_event();
    var AppsecSdk = class {
      constructor(tracer2) {
        this._tracer = tracer2;
      }
      trackUserLoginSuccessEvent(user, metadata) {
        return trackUserLoginSuccessEvent(this._tracer, user, metadata);
      }
      trackUserLoginFailureEvent(userId, exists, metadata) {
        return trackUserLoginFailureEvent(this._tracer, userId, exists, metadata);
      }
      trackCustomEvent(eventName, metadata) {
        return trackCustomEvent(this._tracer, eventName, metadata);
      }
    };
    __name(AppsecSdk, "AppsecSdk");
    module2.exports = AppsecSdk;
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._timeouts = timeouts;
      this._options = options || {};
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    __name(RetryOperation, "RetryOperation");
    module2.exports = RetryOperation;
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (this._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = /* @__PURE__ */ __name(function retryWrapper() {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original.apply(obj, args);
          });
        }, "retryWrapper");
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js
var require_agent2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/agent.js"(exports2, module2) {
    "use strict";
    var retry = require_retry2();
    var { request } = __require("http");
    var docker = require_docker();
    var FormData = require_form_data();
    var { storage } = require_datadog_core();
    var version = require_package().version;
    var containerId = docker.id();
    function sendRequest(options, form, callback) {
      const store = storage.getStore();
      storage.enterWith({ noop: true });
      const req = request(options, (res) => {
        if (res.statusCode >= 400) {
          const error = new Error(`HTTP Error ${res.statusCode}`);
          error.status = res.statusCode;
          callback(error);
        } else {
          callback(null, res);
        }
      });
      req.on("error", callback);
      if (form)
        form.pipe(req);
      storage.enterWith(store);
    }
    __name(sendRequest, "sendRequest");
    function getBody(stream, callback) {
      const chunks = [];
      stream.on("error", callback);
      stream.on("data", (chunk) => chunks.push(chunk));
      stream.on("end", () => {
        callback(null, Buffer.concat(chunks));
      });
    }
    __name(getBody, "getBody");
    function computeRetries(uploadTimeout) {
      let tries = 0;
      while (tries < 2 || uploadTimeout > 1e3) {
        tries++;
        uploadTimeout /= 2;
      }
      return [tries, Math.floor(uploadTimeout)];
    }
    __name(computeRetries, "computeRetries");
    var AgentExporter = class {
      constructor({ url, logger, uploadTimeout } = {}) {
        this._url = url;
        this._logger = logger;
        const [backoffTries, backoffTime] = computeRetries(uploadTimeout);
        this._backoffTime = backoffTime;
        this._backoffTries = backoffTries;
      }
      export({ profiles, start, end, tags }) {
        const types = Object.keys(profiles);
        const fields = [
          ["recording-start", start.toISOString()],
          ["recording-end", end.toISOString()],
          ["language", "javascript"],
          ["runtime", "nodejs"],
          ["runtime_version", process.version],
          ["profiler_version", version],
          ["format", "pprof"],
          ["tags[]", "language:javascript"],
          ["tags[]", "runtime:nodejs"],
          ["tags[]", `runtime_version:${process.version}`],
          ["tags[]", `profiler_version:${version}`],
          ["tags[]", "format:pprof"],
          ...Object.entries(tags).map(([key, value]) => ["tags[]", `${key}:${value}`])
        ];
        this._logger.debug(() => {
          const body = fields.map(([key, value]) => `  ${key}: ${value}`).join("\n");
          return `Building agent export report: ${"\n" + body}`;
        });
        for (let index = 0; index < types.length; index++) {
          const type = types[index];
          const buffer = profiles[type];
          this._logger.debug(() => {
            const bytes = buffer.toString("hex").match(/../g).join(" ");
            return `Adding ${type} profile to agent export: ` + bytes;
          });
          fields.push([`types[${index}]`, type]);
          fields.push([`data[${index}]`, buffer, {
            filename: `${type}.pb.gz`,
            contentType: "application/octet-stream",
            knownLength: buffer.length
          }]);
        }
        return new Promise((resolve, reject) => {
          const operation = retry.operation({
            randomize: true,
            minTimeout: this._backoffTime,
            retries: this._backoffTries
          });
          operation.attempt((attempt) => {
            const form = new FormData();
            for (const [key, value, options2] of fields) {
              form.append(key, value, options2);
            }
            const options = {
              method: "POST",
              path: "/profiling/v1/input",
              headers: form.getHeaders(),
              timeout: this._backoffTime * Math.pow(2, attempt)
            };
            if (containerId) {
              options.headers["Datadog-Container-ID"] = containerId;
            }
            if (this._url.protocol === "unix:") {
              options.socketPath = this._url.pathname;
            } else {
              options.protocol = this._url.protocol;
              options.hostname = this._url.hostname;
              options.port = this._url.port;
            }
            this._logger.debug(() => {
              return `Submitting profiler agent report attempt #${attempt} to: ${JSON.stringify(options)}`;
            });
            sendRequest(options, form, (err, response) => {
              if (operation.retry(err)) {
                this._logger.error(`Error from the agent: ${err.message}`);
                return;
              } else if (err) {
                reject(new Error("Profiler agent export back-off period expired"));
                return;
              }
              getBody(response, (err2, body) => {
                if (err2) {
                  this._logger.error(`Error reading agent response: ${err2.message}`);
                } else {
                  this._logger.debug(() => {
                    const bytes = (body.toString("hex").match(/../g) || []).join(" ");
                    return `Agent export response: ${bytes}`;
                  });
                }
              });
              resolve();
            });
          });
        });
      }
    };
    __name(AgentExporter, "AgentExporter");
    module2.exports = { AgentExporter, computeRetries };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js
var require_file = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiling/exporters/file.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var { promisify } = __require("util");
    var writeFile = promisify(fs.writeFile);
    var FileExporter = class {
      export({ profiles }) {
        const types = Object.keys(profiles);
        const tasks = types.map((type) => {
          return writeFile(`${type}.pb.gz`, profiles[type]);
        });
        return Promise.all(tasks);
      }
    };
    __name(FileExporter, "FileExporter");
    module2.exports = { FileExporter };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js
var require_console = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiling/loggers/console.js"(exports2, module2) {
    "use strict";
    var mapping = {
      error: 3,
      warn: 4,
      info: 6,
      debug: 7
    };
    var ConsoleLogger = class {
      constructor(options = {}) {
        this._level = mapping[options.level] || mapping["error"];
      }
      debug(message) {
        this._log("debug", message);
      }
      info(message) {
        this._log("info", message);
      }
      warn(message) {
        this._log("warn", message);
      }
      error(message) {
        this._log("error", message);
      }
      _log(level, message) {
        if (mapping[level] > this._level)
          return;
        console[level](message);
      }
    };
    __name(ConsoleLogger, "ConsoleLogger");
    module2.exports = { ConsoleLogger };
  }
});

// node_modules/@datadog/pprof/proto/profile.js
var require_profile = __commonJS({
  "node_modules/@datadog/pprof/proto/profile.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.perftools = function() {
      var perftools = {};
      perftools.profiles = function() {
        var profiles = {};
        profiles.Profile = function() {
          function Profile(properties) {
            this.sampleType = [];
            this.sample = [];
            this.mapping = [];
            this.location = [];
            this["function"] = [];
            this.stringTable = [];
            this.comment = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Profile, "Profile");
          Profile.prototype.sampleType = $util.emptyArray;
          Profile.prototype.sample = $util.emptyArray;
          Profile.prototype.mapping = $util.emptyArray;
          Profile.prototype.location = $util.emptyArray;
          Profile.prototype["function"] = $util.emptyArray;
          Profile.prototype.stringTable = $util.emptyArray;
          Profile.prototype.dropFrames = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Profile.prototype.keepFrames = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Profile.prototype.timeNanos = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Profile.prototype.durationNanos = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Profile.prototype.periodType = null;
          Profile.prototype.period = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Profile.prototype.comment = $util.emptyArray;
          Profile.prototype.defaultSampleType = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Profile.create = /* @__PURE__ */ __name(function create(properties) {
            return new Profile(properties);
          }, "create");
          Profile.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.sampleType != null && message.sampleType.length)
              for (var i = 0; i < message.sampleType.length; ++i)
                $root.perftools.profiles.ValueType.encode(message.sampleType[i], writer.uint32(10).fork()).ldelim();
            if (message.sample != null && message.sample.length)
              for (var i = 0; i < message.sample.length; ++i)
                $root.perftools.profiles.Sample.encode(message.sample[i], writer.uint32(18).fork()).ldelim();
            if (message.mapping != null && message.mapping.length)
              for (var i = 0; i < message.mapping.length; ++i)
                $root.perftools.profiles.Mapping.encode(message.mapping[i], writer.uint32(26).fork()).ldelim();
            if (message.location != null && message.location.length)
              for (var i = 0; i < message.location.length; ++i)
                $root.perftools.profiles.Location.encode(message.location[i], writer.uint32(34).fork()).ldelim();
            if (message["function"] != null && message["function"].length)
              for (var i = 0; i < message["function"].length; ++i)
                $root.perftools.profiles.Function.encode(message["function"][i], writer.uint32(42).fork()).ldelim();
            if (message.stringTable != null && message.stringTable.length)
              for (var i = 0; i < message.stringTable.length; ++i)
                writer.uint32(50).string(message.stringTable[i]);
            if (message.dropFrames != null && Object.hasOwnProperty.call(message, "dropFrames"))
              writer.uint32(56).int64(message.dropFrames);
            if (message.keepFrames != null && Object.hasOwnProperty.call(message, "keepFrames"))
              writer.uint32(64).int64(message.keepFrames);
            if (message.timeNanos != null && Object.hasOwnProperty.call(message, "timeNanos"))
              writer.uint32(72).int64(message.timeNanos);
            if (message.durationNanos != null && Object.hasOwnProperty.call(message, "durationNanos"))
              writer.uint32(80).int64(message.durationNanos);
            if (message.periodType != null && Object.hasOwnProperty.call(message, "periodType"))
              $root.perftools.profiles.ValueType.encode(message.periodType, writer.uint32(90).fork()).ldelim();
            if (message.period != null && Object.hasOwnProperty.call(message, "period"))
              writer.uint32(96).int64(message.period);
            if (message.comment != null && message.comment.length) {
              writer.uint32(106).fork();
              for (var i = 0; i < message.comment.length; ++i)
                writer.int64(message.comment[i]);
              writer.ldelim();
            }
            if (message.defaultSampleType != null && Object.hasOwnProperty.call(message, "defaultSampleType"))
              writer.uint32(112).int64(message.defaultSampleType);
            return writer;
          }, "encode");
          Profile.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Profile.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Profile();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (!(message.sampleType && message.sampleType.length))
                    message.sampleType = [];
                  message.sampleType.push($root.perftools.profiles.ValueType.decode(reader, reader.uint32()));
                  break;
                }
                case 2: {
                  if (!(message.sample && message.sample.length))
                    message.sample = [];
                  message.sample.push($root.perftools.profiles.Sample.decode(reader, reader.uint32()));
                  break;
                }
                case 3: {
                  if (!(message.mapping && message.mapping.length))
                    message.mapping = [];
                  message.mapping.push($root.perftools.profiles.Mapping.decode(reader, reader.uint32()));
                  break;
                }
                case 4: {
                  if (!(message.location && message.location.length))
                    message.location = [];
                  message.location.push($root.perftools.profiles.Location.decode(reader, reader.uint32()));
                  break;
                }
                case 5: {
                  if (!(message["function"] && message["function"].length))
                    message["function"] = [];
                  message["function"].push($root.perftools.profiles.Function.decode(reader, reader.uint32()));
                  break;
                }
                case 6: {
                  if (!(message.stringTable && message.stringTable.length))
                    message.stringTable = [];
                  message.stringTable.push(reader.string());
                  break;
                }
                case 7: {
                  message.dropFrames = reader.int64();
                  break;
                }
                case 8: {
                  message.keepFrames = reader.int64();
                  break;
                }
                case 9: {
                  message.timeNanos = reader.int64();
                  break;
                }
                case 10: {
                  message.durationNanos = reader.int64();
                  break;
                }
                case 11: {
                  message.periodType = $root.perftools.profiles.ValueType.decode(reader, reader.uint32());
                  break;
                }
                case 12: {
                  message.period = reader.int64();
                  break;
                }
                case 13: {
                  if (!(message.comment && message.comment.length))
                    message.comment = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.comment.push(reader.int64());
                  } else
                    message.comment.push(reader.int64());
                  break;
                }
                case 14: {
                  message.defaultSampleType = reader.int64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Profile.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Profile.verify = /* @__PURE__ */ __name(function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.sampleType != null && message.hasOwnProperty("sampleType")) {
              if (!Array.isArray(message.sampleType))
                return "sampleType: array expected";
              for (var i = 0; i < message.sampleType.length; ++i) {
                var error = $root.perftools.profiles.ValueType.verify(message.sampleType[i]);
                if (error)
                  return "sampleType." + error;
              }
            }
            if (message.sample != null && message.hasOwnProperty("sample")) {
              if (!Array.isArray(message.sample))
                return "sample: array expected";
              for (var i = 0; i < message.sample.length; ++i) {
                var error = $root.perftools.profiles.Sample.verify(message.sample[i]);
                if (error)
                  return "sample." + error;
              }
            }
            if (message.mapping != null && message.hasOwnProperty("mapping")) {
              if (!Array.isArray(message.mapping))
                return "mapping: array expected";
              for (var i = 0; i < message.mapping.length; ++i) {
                var error = $root.perftools.profiles.Mapping.verify(message.mapping[i]);
                if (error)
                  return "mapping." + error;
              }
            }
            if (message.location != null && message.hasOwnProperty("location")) {
              if (!Array.isArray(message.location))
                return "location: array expected";
              for (var i = 0; i < message.location.length; ++i) {
                var error = $root.perftools.profiles.Location.verify(message.location[i]);
                if (error)
                  return "location." + error;
              }
            }
            if (message["function"] != null && message.hasOwnProperty("function")) {
              if (!Array.isArray(message["function"]))
                return "function: array expected";
              for (var i = 0; i < message["function"].length; ++i) {
                var error = $root.perftools.profiles.Function.verify(message["function"][i]);
                if (error)
                  return "function." + error;
              }
            }
            if (message.stringTable != null && message.hasOwnProperty("stringTable")) {
              if (!Array.isArray(message.stringTable))
                return "stringTable: array expected";
              for (var i = 0; i < message.stringTable.length; ++i)
                if (!$util.isString(message.stringTable[i]))
                  return "stringTable: string[] expected";
            }
            if (message.dropFrames != null && message.hasOwnProperty("dropFrames")) {
              if (!$util.isInteger(message.dropFrames) && !(message.dropFrames && $util.isInteger(message.dropFrames.low) && $util.isInteger(message.dropFrames.high)))
                return "dropFrames: integer|Long expected";
            }
            if (message.keepFrames != null && message.hasOwnProperty("keepFrames")) {
              if (!$util.isInteger(message.keepFrames) && !(message.keepFrames && $util.isInteger(message.keepFrames.low) && $util.isInteger(message.keepFrames.high)))
                return "keepFrames: integer|Long expected";
            }
            if (message.timeNanos != null && message.hasOwnProperty("timeNanos")) {
              if (!$util.isInteger(message.timeNanos) && !(message.timeNanos && $util.isInteger(message.timeNanos.low) && $util.isInteger(message.timeNanos.high)))
                return "timeNanos: integer|Long expected";
            }
            if (message.durationNanos != null && message.hasOwnProperty("durationNanos")) {
              if (!$util.isInteger(message.durationNanos) && !(message.durationNanos && $util.isInteger(message.durationNanos.low) && $util.isInteger(message.durationNanos.high)))
                return "durationNanos: integer|Long expected";
            }
            if (message.periodType != null && message.hasOwnProperty("periodType")) {
              var error = $root.perftools.profiles.ValueType.verify(message.periodType);
              if (error)
                return "periodType." + error;
            }
            if (message.period != null && message.hasOwnProperty("period")) {
              if (!$util.isInteger(message.period) && !(message.period && $util.isInteger(message.period.low) && $util.isInteger(message.period.high)))
                return "period: integer|Long expected";
            }
            if (message.comment != null && message.hasOwnProperty("comment")) {
              if (!Array.isArray(message.comment))
                return "comment: array expected";
              for (var i = 0; i < message.comment.length; ++i)
                if (!$util.isInteger(message.comment[i]) && !(message.comment[i] && $util.isInteger(message.comment[i].low) && $util.isInteger(message.comment[i].high)))
                  return "comment: integer|Long[] expected";
            }
            if (message.defaultSampleType != null && message.hasOwnProperty("defaultSampleType")) {
              if (!$util.isInteger(message.defaultSampleType) && !(message.defaultSampleType && $util.isInteger(message.defaultSampleType.low) && $util.isInteger(message.defaultSampleType.high)))
                return "defaultSampleType: integer|Long expected";
            }
            return null;
          }, "verify");
          Profile.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
            if (object instanceof $root.perftools.profiles.Profile)
              return object;
            var message = new $root.perftools.profiles.Profile();
            if (object.sampleType) {
              if (!Array.isArray(object.sampleType))
                throw TypeError(".perftools.profiles.Profile.sampleType: array expected");
              message.sampleType = [];
              for (var i = 0; i < object.sampleType.length; ++i) {
                if (typeof object.sampleType[i] !== "object")
                  throw TypeError(".perftools.profiles.Profile.sampleType: object expected");
                message.sampleType[i] = $root.perftools.profiles.ValueType.fromObject(object.sampleType[i]);
              }
            }
            if (object.sample) {
              if (!Array.isArray(object.sample))
                throw TypeError(".perftools.profiles.Profile.sample: array expected");
              message.sample = [];
              for (var i = 0; i < object.sample.length; ++i) {
                if (typeof object.sample[i] !== "object")
                  throw TypeError(".perftools.profiles.Profile.sample: object expected");
                message.sample[i] = $root.perftools.profiles.Sample.fromObject(object.sample[i]);
              }
            }
            if (object.mapping) {
              if (!Array.isArray(object.mapping))
                throw TypeError(".perftools.profiles.Profile.mapping: array expected");
              message.mapping = [];
              for (var i = 0; i < object.mapping.length; ++i) {
                if (typeof object.mapping[i] !== "object")
                  throw TypeError(".perftools.profiles.Profile.mapping: object expected");
                message.mapping[i] = $root.perftools.profiles.Mapping.fromObject(object.mapping[i]);
              }
            }
            if (object.location) {
              if (!Array.isArray(object.location))
                throw TypeError(".perftools.profiles.Profile.location: array expected");
              message.location = [];
              for (var i = 0; i < object.location.length; ++i) {
                if (typeof object.location[i] !== "object")
                  throw TypeError(".perftools.profiles.Profile.location: object expected");
                message.location[i] = $root.perftools.profiles.Location.fromObject(object.location[i]);
              }
            }
            if (object["function"]) {
              if (!Array.isArray(object["function"]))
                throw TypeError(".perftools.profiles.Profile.function: array expected");
              message["function"] = [];
              for (var i = 0; i < object["function"].length; ++i) {
                if (typeof object["function"][i] !== "object")
                  throw TypeError(".perftools.profiles.Profile.function: object expected");
                message["function"][i] = $root.perftools.profiles.Function.fromObject(object["function"][i]);
              }
            }
            if (object.stringTable) {
              if (!Array.isArray(object.stringTable))
                throw TypeError(".perftools.profiles.Profile.stringTable: array expected");
              message.stringTable = [];
              for (var i = 0; i < object.stringTable.length; ++i)
                message.stringTable[i] = String(object.stringTable[i]);
            }
            if (object.dropFrames != null) {
              if ($util.Long)
                (message.dropFrames = $util.Long.fromValue(object.dropFrames)).unsigned = false;
              else if (typeof object.dropFrames === "string")
                message.dropFrames = parseInt(object.dropFrames, 10);
              else if (typeof object.dropFrames === "number")
                message.dropFrames = object.dropFrames;
              else if (typeof object.dropFrames === "object")
                message.dropFrames = new $util.LongBits(object.dropFrames.low >>> 0, object.dropFrames.high >>> 0).toNumber();
            }
            if (object.keepFrames != null) {
              if ($util.Long)
                (message.keepFrames = $util.Long.fromValue(object.keepFrames)).unsigned = false;
              else if (typeof object.keepFrames === "string")
                message.keepFrames = parseInt(object.keepFrames, 10);
              else if (typeof object.keepFrames === "number")
                message.keepFrames = object.keepFrames;
              else if (typeof object.keepFrames === "object")
                message.keepFrames = new $util.LongBits(object.keepFrames.low >>> 0, object.keepFrames.high >>> 0).toNumber();
            }
            if (object.timeNanos != null) {
              if ($util.Long)
                (message.timeNanos = $util.Long.fromValue(object.timeNanos)).unsigned = false;
              else if (typeof object.timeNanos === "string")
                message.timeNanos = parseInt(object.timeNanos, 10);
              else if (typeof object.timeNanos === "number")
                message.timeNanos = object.timeNanos;
              else if (typeof object.timeNanos === "object")
                message.timeNanos = new $util.LongBits(object.timeNanos.low >>> 0, object.timeNanos.high >>> 0).toNumber();
            }
            if (object.durationNanos != null) {
              if ($util.Long)
                (message.durationNanos = $util.Long.fromValue(object.durationNanos)).unsigned = false;
              else if (typeof object.durationNanos === "string")
                message.durationNanos = parseInt(object.durationNanos, 10);
              else if (typeof object.durationNanos === "number")
                message.durationNanos = object.durationNanos;
              else if (typeof object.durationNanos === "object")
                message.durationNanos = new $util.LongBits(object.durationNanos.low >>> 0, object.durationNanos.high >>> 0).toNumber();
            }
            if (object.periodType != null) {
              if (typeof object.periodType !== "object")
                throw TypeError(".perftools.profiles.Profile.periodType: object expected");
              message.periodType = $root.perftools.profiles.ValueType.fromObject(object.periodType);
            }
            if (object.period != null) {
              if ($util.Long)
                (message.period = $util.Long.fromValue(object.period)).unsigned = false;
              else if (typeof object.period === "string")
                message.period = parseInt(object.period, 10);
              else if (typeof object.period === "number")
                message.period = object.period;
              else if (typeof object.period === "object")
                message.period = new $util.LongBits(object.period.low >>> 0, object.period.high >>> 0).toNumber();
            }
            if (object.comment) {
              if (!Array.isArray(object.comment))
                throw TypeError(".perftools.profiles.Profile.comment: array expected");
              message.comment = [];
              for (var i = 0; i < object.comment.length; ++i)
                if ($util.Long)
                  (message.comment[i] = $util.Long.fromValue(object.comment[i])).unsigned = false;
                else if (typeof object.comment[i] === "string")
                  message.comment[i] = parseInt(object.comment[i], 10);
                else if (typeof object.comment[i] === "number")
                  message.comment[i] = object.comment[i];
                else if (typeof object.comment[i] === "object")
                  message.comment[i] = new $util.LongBits(object.comment[i].low >>> 0, object.comment[i].high >>> 0).toNumber();
            }
            if (object.defaultSampleType != null) {
              if ($util.Long)
                (message.defaultSampleType = $util.Long.fromValue(object.defaultSampleType)).unsigned = false;
              else if (typeof object.defaultSampleType === "string")
                message.defaultSampleType = parseInt(object.defaultSampleType, 10);
              else if (typeof object.defaultSampleType === "number")
                message.defaultSampleType = object.defaultSampleType;
              else if (typeof object.defaultSampleType === "object")
                message.defaultSampleType = new $util.LongBits(object.defaultSampleType.low >>> 0, object.defaultSampleType.high >>> 0).toNumber();
            }
            return message;
          }, "fromObject");
          Profile.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.sampleType = [];
              object.sample = [];
              object.mapping = [];
              object.location = [];
              object["function"] = [];
              object.stringTable = [];
              object.comment = [];
            }
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.dropFrames = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.dropFrames = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.keepFrames = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.keepFrames = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.timeNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.timeNanos = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.durationNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.durationNanos = options.longs === String ? "0" : 0;
              object.periodType = null;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.period = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.period = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.defaultSampleType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.defaultSampleType = options.longs === String ? "0" : 0;
            }
            if (message.sampleType && message.sampleType.length) {
              object.sampleType = [];
              for (var j = 0; j < message.sampleType.length; ++j)
                object.sampleType[j] = $root.perftools.profiles.ValueType.toObject(message.sampleType[j], options);
            }
            if (message.sample && message.sample.length) {
              object.sample = [];
              for (var j = 0; j < message.sample.length; ++j)
                object.sample[j] = $root.perftools.profiles.Sample.toObject(message.sample[j], options);
            }
            if (message.mapping && message.mapping.length) {
              object.mapping = [];
              for (var j = 0; j < message.mapping.length; ++j)
                object.mapping[j] = $root.perftools.profiles.Mapping.toObject(message.mapping[j], options);
            }
            if (message.location && message.location.length) {
              object.location = [];
              for (var j = 0; j < message.location.length; ++j)
                object.location[j] = $root.perftools.profiles.Location.toObject(message.location[j], options);
            }
            if (message["function"] && message["function"].length) {
              object["function"] = [];
              for (var j = 0; j < message["function"].length; ++j)
                object["function"][j] = $root.perftools.profiles.Function.toObject(message["function"][j], options);
            }
            if (message.stringTable && message.stringTable.length) {
              object.stringTable = [];
              for (var j = 0; j < message.stringTable.length; ++j)
                object.stringTable[j] = message.stringTable[j];
            }
            if (message.dropFrames != null && message.hasOwnProperty("dropFrames"))
              if (typeof message.dropFrames === "number")
                object.dropFrames = options.longs === String ? String(message.dropFrames) : message.dropFrames;
              else
                object.dropFrames = options.longs === String ? $util.Long.prototype.toString.call(message.dropFrames) : options.longs === Number ? new $util.LongBits(message.dropFrames.low >>> 0, message.dropFrames.high >>> 0).toNumber() : message.dropFrames;
            if (message.keepFrames != null && message.hasOwnProperty("keepFrames"))
              if (typeof message.keepFrames === "number")
                object.keepFrames = options.longs === String ? String(message.keepFrames) : message.keepFrames;
              else
                object.keepFrames = options.longs === String ? $util.Long.prototype.toString.call(message.keepFrames) : options.longs === Number ? new $util.LongBits(message.keepFrames.low >>> 0, message.keepFrames.high >>> 0).toNumber() : message.keepFrames;
            if (message.timeNanos != null && message.hasOwnProperty("timeNanos"))
              if (typeof message.timeNanos === "number")
                object.timeNanos = options.longs === String ? String(message.timeNanos) : message.timeNanos;
              else
                object.timeNanos = options.longs === String ? $util.Long.prototype.toString.call(message.timeNanos) : options.longs === Number ? new $util.LongBits(message.timeNanos.low >>> 0, message.timeNanos.high >>> 0).toNumber() : message.timeNanos;
            if (message.durationNanos != null && message.hasOwnProperty("durationNanos"))
              if (typeof message.durationNanos === "number")
                object.durationNanos = options.longs === String ? String(message.durationNanos) : message.durationNanos;
              else
                object.durationNanos = options.longs === String ? $util.Long.prototype.toString.call(message.durationNanos) : options.longs === Number ? new $util.LongBits(message.durationNanos.low >>> 0, message.durationNanos.high >>> 0).toNumber() : message.durationNanos;
            if (message.periodType != null && message.hasOwnProperty("periodType"))
              object.periodType = $root.perftools.profiles.ValueType.toObject(message.periodType, options);
            if (message.period != null && message.hasOwnProperty("period"))
              if (typeof message.period === "number")
                object.period = options.longs === String ? String(message.period) : message.period;
              else
                object.period = options.longs === String ? $util.Long.prototype.toString.call(message.period) : options.longs === Number ? new $util.LongBits(message.period.low >>> 0, message.period.high >>> 0).toNumber() : message.period;
            if (message.comment && message.comment.length) {
              object.comment = [];
              for (var j = 0; j < message.comment.length; ++j)
                if (typeof message.comment[j] === "number")
                  object.comment[j] = options.longs === String ? String(message.comment[j]) : message.comment[j];
                else
                  object.comment[j] = options.longs === String ? $util.Long.prototype.toString.call(message.comment[j]) : options.longs === Number ? new $util.LongBits(message.comment[j].low >>> 0, message.comment[j].high >>> 0).toNumber() : message.comment[j];
            }
            if (message.defaultSampleType != null && message.hasOwnProperty("defaultSampleType"))
              if (typeof message.defaultSampleType === "number")
                object.defaultSampleType = options.longs === String ? String(message.defaultSampleType) : message.defaultSampleType;
              else
                object.defaultSampleType = options.longs === String ? $util.Long.prototype.toString.call(message.defaultSampleType) : options.longs === Number ? new $util.LongBits(message.defaultSampleType.low >>> 0, message.defaultSampleType.high >>> 0).toNumber() : message.defaultSampleType;
            return object;
          }, "toObject");
          Profile.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          Profile.getTypeUrl = /* @__PURE__ */ __name(function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/perftools.profiles.Profile";
          }, "getTypeUrl");
          return Profile;
        }();
        profiles.ValueType = function() {
          function ValueType(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ValueType, "ValueType");
          ValueType.prototype.type = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          ValueType.prototype.unit = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          ValueType.create = /* @__PURE__ */ __name(function create(properties) {
            return new ValueType(properties);
          }, "create");
          ValueType.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
              writer.uint32(8).int64(message.type);
            if (message.unit != null && Object.hasOwnProperty.call(message, "unit"))
              writer.uint32(16).int64(message.unit);
            return writer;
          }, "encode");
          ValueType.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ValueType.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.perftools.profiles.ValueType();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.type = reader.int64();
                  break;
                }
                case 2: {
                  message.unit = reader.int64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ValueType.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ValueType.verify = /* @__PURE__ */ __name(function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.type != null && message.hasOwnProperty("type")) {
              if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                return "type: integer|Long expected";
            }
            if (message.unit != null && message.hasOwnProperty("unit")) {
              if (!$util.isInteger(message.unit) && !(message.unit && $util.isInteger(message.unit.low) && $util.isInteger(message.unit.high)))
                return "unit: integer|Long expected";
            }
            return null;
          }, "verify");
          ValueType.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
            if (object instanceof $root.perftools.profiles.ValueType)
              return object;
            var message = new $root.perftools.profiles.ValueType();
            if (object.type != null) {
              if ($util.Long)
                (message.type = $util.Long.fromValue(object.type)).unsigned = false;
              else if (typeof object.type === "string")
                message.type = parseInt(object.type, 10);
              else if (typeof object.type === "number")
                message.type = object.type;
              else if (typeof object.type === "object")
                message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber();
            }
            if (object.unit != null) {
              if ($util.Long)
                (message.unit = $util.Long.fromValue(object.unit)).unsigned = false;
              else if (typeof object.unit === "string")
                message.unit = parseInt(object.unit, 10);
              else if (typeof object.unit === "number")
                message.unit = object.unit;
              else if (typeof object.unit === "object")
                message.unit = new $util.LongBits(object.unit.low >>> 0, object.unit.high >>> 0).toNumber();
            }
            return message;
          }, "fromObject");
          ValueType.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.type = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.unit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.unit = options.longs === String ? "0" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
              if (typeof message.type === "number")
                object.type = options.longs === String ? String(message.type) : message.type;
              else
                object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber() : message.type;
            if (message.unit != null && message.hasOwnProperty("unit"))
              if (typeof message.unit === "number")
                object.unit = options.longs === String ? String(message.unit) : message.unit;
              else
                object.unit = options.longs === String ? $util.Long.prototype.toString.call(message.unit) : options.longs === Number ? new $util.LongBits(message.unit.low >>> 0, message.unit.high >>> 0).toNumber() : message.unit;
            return object;
          }, "toObject");
          ValueType.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          ValueType.getTypeUrl = /* @__PURE__ */ __name(function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/perftools.profiles.ValueType";
          }, "getTypeUrl");
          return ValueType;
        }();
        profiles.Sample = function() {
          function Sample(properties) {
            this.locationId = [];
            this.value = [];
            this.label = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Sample, "Sample");
          Sample.prototype.locationId = $util.emptyArray;
          Sample.prototype.value = $util.emptyArray;
          Sample.prototype.label = $util.emptyArray;
          Sample.create = /* @__PURE__ */ __name(function create(properties) {
            return new Sample(properties);
          }, "create");
          Sample.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.locationId != null && message.locationId.length) {
              writer.uint32(10).fork();
              for (var i = 0; i < message.locationId.length; ++i)
                writer.uint64(message.locationId[i]);
              writer.ldelim();
            }
            if (message.value != null && message.value.length) {
              writer.uint32(18).fork();
              for (var i = 0; i < message.value.length; ++i)
                writer.int64(message.value[i]);
              writer.ldelim();
            }
            if (message.label != null && message.label.length)
              for (var i = 0; i < message.label.length; ++i)
                $root.perftools.profiles.Label.encode(message.label[i], writer.uint32(26).fork()).ldelim();
            return writer;
          }, "encode");
          Sample.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Sample.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Sample();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (!(message.locationId && message.locationId.length))
                    message.locationId = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.locationId.push(reader.uint64());
                  } else
                    message.locationId.push(reader.uint64());
                  break;
                }
                case 2: {
                  if (!(message.value && message.value.length))
                    message.value = [];
                  if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                      message.value.push(reader.int64());
                  } else
                    message.value.push(reader.int64());
                  break;
                }
                case 3: {
                  if (!(message.label && message.label.length))
                    message.label = [];
                  message.label.push($root.perftools.profiles.Label.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Sample.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Sample.verify = /* @__PURE__ */ __name(function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.locationId != null && message.hasOwnProperty("locationId")) {
              if (!Array.isArray(message.locationId))
                return "locationId: array expected";
              for (var i = 0; i < message.locationId.length; ++i)
                if (!$util.isInteger(message.locationId[i]) && !(message.locationId[i] && $util.isInteger(message.locationId[i].low) && $util.isInteger(message.locationId[i].high)))
                  return "locationId: integer|Long[] expected";
            }
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!Array.isArray(message.value))
                return "value: array expected";
              for (var i = 0; i < message.value.length; ++i)
                if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))
                  return "value: integer|Long[] expected";
            }
            if (message.label != null && message.hasOwnProperty("label")) {
              if (!Array.isArray(message.label))
                return "label: array expected";
              for (var i = 0; i < message.label.length; ++i) {
                var error = $root.perftools.profiles.Label.verify(message.label[i]);
                if (error)
                  return "label." + error;
              }
            }
            return null;
          }, "verify");
          Sample.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
            if (object instanceof $root.perftools.profiles.Sample)
              return object;
            var message = new $root.perftools.profiles.Sample();
            if (object.locationId) {
              if (!Array.isArray(object.locationId))
                throw TypeError(".perftools.profiles.Sample.locationId: array expected");
              message.locationId = [];
              for (var i = 0; i < object.locationId.length; ++i)
                if ($util.Long)
                  (message.locationId[i] = $util.Long.fromValue(object.locationId[i])).unsigned = true;
                else if (typeof object.locationId[i] === "string")
                  message.locationId[i] = parseInt(object.locationId[i], 10);
                else if (typeof object.locationId[i] === "number")
                  message.locationId[i] = object.locationId[i];
                else if (typeof object.locationId[i] === "object")
                  message.locationId[i] = new $util.LongBits(object.locationId[i].low >>> 0, object.locationId[i].high >>> 0).toNumber(true);
            }
            if (object.value) {
              if (!Array.isArray(object.value))
                throw TypeError(".perftools.profiles.Sample.value: array expected");
              message.value = [];
              for (var i = 0; i < object.value.length; ++i)
                if ($util.Long)
                  (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = false;
                else if (typeof object.value[i] === "string")
                  message.value[i] = parseInt(object.value[i], 10);
                else if (typeof object.value[i] === "number")
                  message.value[i] = object.value[i];
                else if (typeof object.value[i] === "object")
                  message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber();
            }
            if (object.label) {
              if (!Array.isArray(object.label))
                throw TypeError(".perftools.profiles.Sample.label: array expected");
              message.label = [];
              for (var i = 0; i < object.label.length; ++i) {
                if (typeof object.label[i] !== "object")
                  throw TypeError(".perftools.profiles.Sample.label: object expected");
                message.label[i] = $root.perftools.profiles.Label.fromObject(object.label[i]);
              }
            }
            return message;
          }, "fromObject");
          Sample.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.locationId = [];
              object.value = [];
              object.label = [];
            }
            if (message.locationId && message.locationId.length) {
              object.locationId = [];
              for (var j = 0; j < message.locationId.length; ++j)
                if (typeof message.locationId[j] === "number")
                  object.locationId[j] = options.longs === String ? String(message.locationId[j]) : message.locationId[j];
                else
                  object.locationId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.locationId[j]) : options.longs === Number ? new $util.LongBits(message.locationId[j].low >>> 0, message.locationId[j].high >>> 0).toNumber(true) : message.locationId[j];
            }
            if (message.value && message.value.length) {
              object.value = [];
              for (var j = 0; j < message.value.length; ++j)
                if (typeof message.value[j] === "number")
                  object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];
                else
                  object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber() : message.value[j];
            }
            if (message.label && message.label.length) {
              object.label = [];
              for (var j = 0; j < message.label.length; ++j)
                object.label[j] = $root.perftools.profiles.Label.toObject(message.label[j], options);
            }
            return object;
          }, "toObject");
          Sample.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          Sample.getTypeUrl = /* @__PURE__ */ __name(function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/perftools.profiles.Sample";
          }, "getTypeUrl");
          return Sample;
        }();
        profiles.Label = function() {
          function Label(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Label, "Label");
          Label.prototype.key = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Label.prototype.str = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Label.prototype.num = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Label.prototype.numUnit = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Label.create = /* @__PURE__ */ __name(function create(properties) {
            return new Label(properties);
          }, "create");
          Label.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
              writer.uint32(8).int64(message.key);
            if (message.str != null && Object.hasOwnProperty.call(message, "str"))
              writer.uint32(16).int64(message.str);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
              writer.uint32(24).int64(message.num);
            if (message.numUnit != null && Object.hasOwnProperty.call(message, "numUnit"))
              writer.uint32(32).int64(message.numUnit);
            return writer;
          }, "encode");
          Label.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Label.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Label();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.key = reader.int64();
                  break;
                }
                case 2: {
                  message.str = reader.int64();
                  break;
                }
                case 3: {
                  message.num = reader.int64();
                  break;
                }
                case 4: {
                  message.numUnit = reader.int64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Label.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Label.verify = /* @__PURE__ */ __name(function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
              if (!$util.isInteger(message.key) && !(message.key && $util.isInteger(message.key.low) && $util.isInteger(message.key.high)))
                return "key: integer|Long expected";
            }
            if (message.str != null && message.hasOwnProperty("str")) {
              if (!$util.isInteger(message.str) && !(message.str && $util.isInteger(message.str.low) && $util.isInteger(message.str.high)))
                return "str: integer|Long expected";
            }
            if (message.num != null && message.hasOwnProperty("num")) {
              if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))
                return "num: integer|Long expected";
            }
            if (message.numUnit != null && message.hasOwnProperty("numUnit")) {
              if (!$util.isInteger(message.numUnit) && !(message.numUnit && $util.isInteger(message.numUnit.low) && $util.isInteger(message.numUnit.high)))
                return "numUnit: integer|Long expected";
            }
            return null;
          }, "verify");
          Label.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
            if (object instanceof $root.perftools.profiles.Label)
              return object;
            var message = new $root.perftools.profiles.Label();
            if (object.key != null) {
              if ($util.Long)
                (message.key = $util.Long.fromValue(object.key)).unsigned = false;
              else if (typeof object.key === "string")
                message.key = parseInt(object.key, 10);
              else if (typeof object.key === "number")
                message.key = object.key;
              else if (typeof object.key === "object")
                message.key = new $util.LongBits(object.key.low >>> 0, object.key.high >>> 0).toNumber();
            }
            if (object.str != null) {
              if ($util.Long)
                (message.str = $util.Long.fromValue(object.str)).unsigned = false;
              else if (typeof object.str === "string")
                message.str = parseInt(object.str, 10);
              else if (typeof object.str === "number")
                message.str = object.str;
              else if (typeof object.str === "object")
                message.str = new $util.LongBits(object.str.low >>> 0, object.str.high >>> 0).toNumber();
            }
            if (object.num != null) {
              if ($util.Long)
                (message.num = $util.Long.fromValue(object.num)).unsigned = false;
              else if (typeof object.num === "string")
                message.num = parseInt(object.num, 10);
              else if (typeof object.num === "number")
                message.num = object.num;
              else if (typeof object.num === "object")
                message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();
            }
            if (object.numUnit != null) {
              if ($util.Long)
                (message.numUnit = $util.Long.fromValue(object.numUnit)).unsigned = false;
              else if (typeof object.numUnit === "string")
                message.numUnit = parseInt(object.numUnit, 10);
              else if (typeof object.numUnit === "number")
                message.numUnit = object.numUnit;
              else if (typeof object.numUnit === "object")
                message.numUnit = new $util.LongBits(object.numUnit.low >>> 0, object.numUnit.high >>> 0).toNumber();
            }
            return message;
          }, "fromObject");
          Label.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.key = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.str = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.str = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.num = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.numUnit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.numUnit = options.longs === String ? "0" : 0;
            }
            if (message.key != null && message.hasOwnProperty("key"))
              if (typeof message.key === "number")
                object.key = options.longs === String ? String(message.key) : message.key;
              else
                object.key = options.longs === String ? $util.Long.prototype.toString.call(message.key) : options.longs === Number ? new $util.LongBits(message.key.low >>> 0, message.key.high >>> 0).toNumber() : message.key;
            if (message.str != null && message.hasOwnProperty("str"))
              if (typeof message.str === "number")
                object.str = options.longs === String ? String(message.str) : message.str;
              else
                object.str = options.longs === String ? $util.Long.prototype.toString.call(message.str) : options.longs === Number ? new $util.LongBits(message.str.low >>> 0, message.str.high >>> 0).toNumber() : message.str;
            if (message.num != null && message.hasOwnProperty("num"))
              if (typeof message.num === "number")
                object.num = options.longs === String ? String(message.num) : message.num;
              else
                object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;
            if (message.numUnit != null && message.hasOwnProperty("numUnit"))
              if (typeof message.numUnit === "number")
                object.numUnit = options.longs === String ? String(message.numUnit) : message.numUnit;
              else
                object.numUnit = options.longs === String ? $util.Long.prototype.toString.call(message.numUnit) : options.longs === Number ? new $util.LongBits(message.numUnit.low >>> 0, message.numUnit.high >>> 0).toNumber() : message.numUnit;
            return object;
          }, "toObject");
          Label.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          Label.getTypeUrl = /* @__PURE__ */ __name(function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/perftools.profiles.Label";
          }, "getTypeUrl");
          return Label;
        }();
        profiles.Mapping = function() {
          function Mapping(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Mapping, "Mapping");
          Mapping.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Mapping.prototype.memoryStart = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Mapping.prototype.memoryLimit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Mapping.prototype.fileOffset = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Mapping.prototype.filename = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Mapping.prototype.buildId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Mapping.prototype.hasFunctions = false;
          Mapping.prototype.hasFilenames = false;
          Mapping.prototype.hasLineNumbers = false;
          Mapping.prototype.hasInlineFrames = false;
          Mapping.create = /* @__PURE__ */ __name(function create(properties) {
            return new Mapping(properties);
          }, "create");
          Mapping.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(8).uint64(message.id);
            if (message.memoryStart != null && Object.hasOwnProperty.call(message, "memoryStart"))
              writer.uint32(16).uint64(message.memoryStart);
            if (message.memoryLimit != null && Object.hasOwnProperty.call(message, "memoryLimit"))
              writer.uint32(24).uint64(message.memoryLimit);
            if (message.fileOffset != null && Object.hasOwnProperty.call(message, "fileOffset"))
              writer.uint32(32).uint64(message.fileOffset);
            if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
              writer.uint32(40).int64(message.filename);
            if (message.buildId != null && Object.hasOwnProperty.call(message, "buildId"))
              writer.uint32(48).int64(message.buildId);
            if (message.hasFunctions != null && Object.hasOwnProperty.call(message, "hasFunctions"))
              writer.uint32(56).bool(message.hasFunctions);
            if (message.hasFilenames != null && Object.hasOwnProperty.call(message, "hasFilenames"))
              writer.uint32(64).bool(message.hasFilenames);
            if (message.hasLineNumbers != null && Object.hasOwnProperty.call(message, "hasLineNumbers"))
              writer.uint32(72).bool(message.hasLineNumbers);
            if (message.hasInlineFrames != null && Object.hasOwnProperty.call(message, "hasInlineFrames"))
              writer.uint32(80).bool(message.hasInlineFrames);
            return writer;
          }, "encode");
          Mapping.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Mapping.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Mapping();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.id = reader.uint64();
                  break;
                }
                case 2: {
                  message.memoryStart = reader.uint64();
                  break;
                }
                case 3: {
                  message.memoryLimit = reader.uint64();
                  break;
                }
                case 4: {
                  message.fileOffset = reader.uint64();
                  break;
                }
                case 5: {
                  message.filename = reader.int64();
                  break;
                }
                case 6: {
                  message.buildId = reader.int64();
                  break;
                }
                case 7: {
                  message.hasFunctions = reader.bool();
                  break;
                }
                case 8: {
                  message.hasFilenames = reader.bool();
                  break;
                }
                case 9: {
                  message.hasLineNumbers = reader.bool();
                  break;
                }
                case 10: {
                  message.hasInlineFrames = reader.bool();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Mapping.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Mapping.verify = /* @__PURE__ */ __name(function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
            }
            if (message.memoryStart != null && message.hasOwnProperty("memoryStart")) {
              if (!$util.isInteger(message.memoryStart) && !(message.memoryStart && $util.isInteger(message.memoryStart.low) && $util.isInteger(message.memoryStart.high)))
                return "memoryStart: integer|Long expected";
            }
            if (message.memoryLimit != null && message.hasOwnProperty("memoryLimit")) {
              if (!$util.isInteger(message.memoryLimit) && !(message.memoryLimit && $util.isInteger(message.memoryLimit.low) && $util.isInteger(message.memoryLimit.high)))
                return "memoryLimit: integer|Long expected";
            }
            if (message.fileOffset != null && message.hasOwnProperty("fileOffset")) {
              if (!$util.isInteger(message.fileOffset) && !(message.fileOffset && $util.isInteger(message.fileOffset.low) && $util.isInteger(message.fileOffset.high)))
                return "fileOffset: integer|Long expected";
            }
            if (message.filename != null && message.hasOwnProperty("filename")) {
              if (!$util.isInteger(message.filename) && !(message.filename && $util.isInteger(message.filename.low) && $util.isInteger(message.filename.high)))
                return "filename: integer|Long expected";
            }
            if (message.buildId != null && message.hasOwnProperty("buildId")) {
              if (!$util.isInteger(message.buildId) && !(message.buildId && $util.isInteger(message.buildId.low) && $util.isInteger(message.buildId.high)))
                return "buildId: integer|Long expected";
            }
            if (message.hasFunctions != null && message.hasOwnProperty("hasFunctions")) {
              if (typeof message.hasFunctions !== "boolean")
                return "hasFunctions: boolean expected";
            }
            if (message.hasFilenames != null && message.hasOwnProperty("hasFilenames")) {
              if (typeof message.hasFilenames !== "boolean")
                return "hasFilenames: boolean expected";
            }
            if (message.hasLineNumbers != null && message.hasOwnProperty("hasLineNumbers")) {
              if (typeof message.hasLineNumbers !== "boolean")
                return "hasLineNumbers: boolean expected";
            }
            if (message.hasInlineFrames != null && message.hasOwnProperty("hasInlineFrames")) {
              if (typeof message.hasInlineFrames !== "boolean")
                return "hasInlineFrames: boolean expected";
            }
            return null;
          }, "verify");
          Mapping.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
            if (object instanceof $root.perftools.profiles.Mapping)
              return object;
            var message = new $root.perftools.profiles.Mapping();
            if (object.id != null) {
              if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
              else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
              else if (typeof object.id === "number")
                message.id = object.id;
              else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            }
            if (object.memoryStart != null) {
              if ($util.Long)
                (message.memoryStart = $util.Long.fromValue(object.memoryStart)).unsigned = true;
              else if (typeof object.memoryStart === "string")
                message.memoryStart = parseInt(object.memoryStart, 10);
              else if (typeof object.memoryStart === "number")
                message.memoryStart = object.memoryStart;
              else if (typeof object.memoryStart === "object")
                message.memoryStart = new $util.LongBits(object.memoryStart.low >>> 0, object.memoryStart.high >>> 0).toNumber(true);
            }
            if (object.memoryLimit != null) {
              if ($util.Long)
                (message.memoryLimit = $util.Long.fromValue(object.memoryLimit)).unsigned = true;
              else if (typeof object.memoryLimit === "string")
                message.memoryLimit = parseInt(object.memoryLimit, 10);
              else if (typeof object.memoryLimit === "number")
                message.memoryLimit = object.memoryLimit;
              else if (typeof object.memoryLimit === "object")
                message.memoryLimit = new $util.LongBits(object.memoryLimit.low >>> 0, object.memoryLimit.high >>> 0).toNumber(true);
            }
            if (object.fileOffset != null) {
              if ($util.Long)
                (message.fileOffset = $util.Long.fromValue(object.fileOffset)).unsigned = true;
              else if (typeof object.fileOffset === "string")
                message.fileOffset = parseInt(object.fileOffset, 10);
              else if (typeof object.fileOffset === "number")
                message.fileOffset = object.fileOffset;
              else if (typeof object.fileOffset === "object")
                message.fileOffset = new $util.LongBits(object.fileOffset.low >>> 0, object.fileOffset.high >>> 0).toNumber(true);
            }
            if (object.filename != null) {
              if ($util.Long)
                (message.filename = $util.Long.fromValue(object.filename)).unsigned = false;
              else if (typeof object.filename === "string")
                message.filename = parseInt(object.filename, 10);
              else if (typeof object.filename === "number")
                message.filename = object.filename;
              else if (typeof object.filename === "object")
                message.filename = new $util.LongBits(object.filename.low >>> 0, object.filename.high >>> 0).toNumber();
            }
            if (object.buildId != null) {
              if ($util.Long)
                (message.buildId = $util.Long.fromValue(object.buildId)).unsigned = false;
              else if (typeof object.buildId === "string")
                message.buildId = parseInt(object.buildId, 10);
              else if (typeof object.buildId === "number")
                message.buildId = object.buildId;
              else if (typeof object.buildId === "object")
                message.buildId = new $util.LongBits(object.buildId.low >>> 0, object.buildId.high >>> 0).toNumber();
            }
            if (object.hasFunctions != null)
              message.hasFunctions = Boolean(object.hasFunctions);
            if (object.hasFilenames != null)
              message.hasFilenames = Boolean(object.hasFilenames);
            if (object.hasLineNumbers != null)
              message.hasLineNumbers = Boolean(object.hasLineNumbers);
            if (object.hasInlineFrames != null)
              message.hasInlineFrames = Boolean(object.hasInlineFrames);
            return message;
          }, "fromObject");
          Mapping.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.id = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.memoryStart = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.memoryStart = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.memoryLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.memoryLimit = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.fileOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.fileOffset = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.filename = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.filename = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.buildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.buildId = options.longs === String ? "0" : 0;
              object.hasFunctions = false;
              object.hasFilenames = false;
              object.hasLineNumbers = false;
              object.hasInlineFrames = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
              if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
              else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.memoryStart != null && message.hasOwnProperty("memoryStart"))
              if (typeof message.memoryStart === "number")
                object.memoryStart = options.longs === String ? String(message.memoryStart) : message.memoryStart;
              else
                object.memoryStart = options.longs === String ? $util.Long.prototype.toString.call(message.memoryStart) : options.longs === Number ? new $util.LongBits(message.memoryStart.low >>> 0, message.memoryStart.high >>> 0).toNumber(true) : message.memoryStart;
            if (message.memoryLimit != null && message.hasOwnProperty("memoryLimit"))
              if (typeof message.memoryLimit === "number")
                object.memoryLimit = options.longs === String ? String(message.memoryLimit) : message.memoryLimit;
              else
                object.memoryLimit = options.longs === String ? $util.Long.prototype.toString.call(message.memoryLimit) : options.longs === Number ? new $util.LongBits(message.memoryLimit.low >>> 0, message.memoryLimit.high >>> 0).toNumber(true) : message.memoryLimit;
            if (message.fileOffset != null && message.hasOwnProperty("fileOffset"))
              if (typeof message.fileOffset === "number")
                object.fileOffset = options.longs === String ? String(message.fileOffset) : message.fileOffset;
              else
                object.fileOffset = options.longs === String ? $util.Long.prototype.toString.call(message.fileOffset) : options.longs === Number ? new $util.LongBits(message.fileOffset.low >>> 0, message.fileOffset.high >>> 0).toNumber(true) : message.fileOffset;
            if (message.filename != null && message.hasOwnProperty("filename"))
              if (typeof message.filename === "number")
                object.filename = options.longs === String ? String(message.filename) : message.filename;
              else
                object.filename = options.longs === String ? $util.Long.prototype.toString.call(message.filename) : options.longs === Number ? new $util.LongBits(message.filename.low >>> 0, message.filename.high >>> 0).toNumber() : message.filename;
            if (message.buildId != null && message.hasOwnProperty("buildId"))
              if (typeof message.buildId === "number")
                object.buildId = options.longs === String ? String(message.buildId) : message.buildId;
              else
                object.buildId = options.longs === String ? $util.Long.prototype.toString.call(message.buildId) : options.longs === Number ? new $util.LongBits(message.buildId.low >>> 0, message.buildId.high >>> 0).toNumber() : message.buildId;
            if (message.hasFunctions != null && message.hasOwnProperty("hasFunctions"))
              object.hasFunctions = message.hasFunctions;
            if (message.hasFilenames != null && message.hasOwnProperty("hasFilenames"))
              object.hasFilenames = message.hasFilenames;
            if (message.hasLineNumbers != null && message.hasOwnProperty("hasLineNumbers"))
              object.hasLineNumbers = message.hasLineNumbers;
            if (message.hasInlineFrames != null && message.hasOwnProperty("hasInlineFrames"))
              object.hasInlineFrames = message.hasInlineFrames;
            return object;
          }, "toObject");
          Mapping.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          Mapping.getTypeUrl = /* @__PURE__ */ __name(function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/perftools.profiles.Mapping";
          }, "getTypeUrl");
          return Mapping;
        }();
        profiles.Location = function() {
          function Location(properties) {
            this.line = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Location, "Location");
          Location.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Location.prototype.mappingId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Location.prototype.address = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Location.prototype.line = $util.emptyArray;
          Location.create = /* @__PURE__ */ __name(function create(properties) {
            return new Location(properties);
          }, "create");
          Location.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(8).uint64(message.id);
            if (message.mappingId != null && Object.hasOwnProperty.call(message, "mappingId"))
              writer.uint32(16).uint64(message.mappingId);
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
              writer.uint32(24).uint64(message.address);
            if (message.line != null && message.line.length)
              for (var i = 0; i < message.line.length; ++i)
                $root.perftools.profiles.Line.encode(message.line[i], writer.uint32(34).fork()).ldelim();
            return writer;
          }, "encode");
          Location.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Location.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Location();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.id = reader.uint64();
                  break;
                }
                case 2: {
                  message.mappingId = reader.uint64();
                  break;
                }
                case 3: {
                  message.address = reader.uint64();
                  break;
                }
                case 4: {
                  if (!(message.line && message.line.length))
                    message.line = [];
                  message.line.push($root.perftools.profiles.Line.decode(reader, reader.uint32()));
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Location.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Location.verify = /* @__PURE__ */ __name(function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
            }
            if (message.mappingId != null && message.hasOwnProperty("mappingId")) {
              if (!$util.isInteger(message.mappingId) && !(message.mappingId && $util.isInteger(message.mappingId.low) && $util.isInteger(message.mappingId.high)))
                return "mappingId: integer|Long expected";
            }
            if (message.address != null && message.hasOwnProperty("address")) {
              if (!$util.isInteger(message.address) && !(message.address && $util.isInteger(message.address.low) && $util.isInteger(message.address.high)))
                return "address: integer|Long expected";
            }
            if (message.line != null && message.hasOwnProperty("line")) {
              if (!Array.isArray(message.line))
                return "line: array expected";
              for (var i = 0; i < message.line.length; ++i) {
                var error = $root.perftools.profiles.Line.verify(message.line[i]);
                if (error)
                  return "line." + error;
              }
            }
            return null;
          }, "verify");
          Location.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
            if (object instanceof $root.perftools.profiles.Location)
              return object;
            var message = new $root.perftools.profiles.Location();
            if (object.id != null) {
              if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
              else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
              else if (typeof object.id === "number")
                message.id = object.id;
              else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            }
            if (object.mappingId != null) {
              if ($util.Long)
                (message.mappingId = $util.Long.fromValue(object.mappingId)).unsigned = true;
              else if (typeof object.mappingId === "string")
                message.mappingId = parseInt(object.mappingId, 10);
              else if (typeof object.mappingId === "number")
                message.mappingId = object.mappingId;
              else if (typeof object.mappingId === "object")
                message.mappingId = new $util.LongBits(object.mappingId.low >>> 0, object.mappingId.high >>> 0).toNumber(true);
            }
            if (object.address != null) {
              if ($util.Long)
                (message.address = $util.Long.fromValue(object.address)).unsigned = true;
              else if (typeof object.address === "string")
                message.address = parseInt(object.address, 10);
              else if (typeof object.address === "number")
                message.address = object.address;
              else if (typeof object.address === "object")
                message.address = new $util.LongBits(object.address.low >>> 0, object.address.high >>> 0).toNumber(true);
            }
            if (object.line) {
              if (!Array.isArray(object.line))
                throw TypeError(".perftools.profiles.Location.line: array expected");
              message.line = [];
              for (var i = 0; i < object.line.length; ++i) {
                if (typeof object.line[i] !== "object")
                  throw TypeError(".perftools.profiles.Location.line: object expected");
                message.line[i] = $root.perftools.profiles.Line.fromObject(object.line[i]);
              }
            }
            return message;
          }, "fromObject");
          Location.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.line = [];
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.id = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.mappingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.mappingId = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.address = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.address = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
              if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
              else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.mappingId != null && message.hasOwnProperty("mappingId"))
              if (typeof message.mappingId === "number")
                object.mappingId = options.longs === String ? String(message.mappingId) : message.mappingId;
              else
                object.mappingId = options.longs === String ? $util.Long.prototype.toString.call(message.mappingId) : options.longs === Number ? new $util.LongBits(message.mappingId.low >>> 0, message.mappingId.high >>> 0).toNumber(true) : message.mappingId;
            if (message.address != null && message.hasOwnProperty("address"))
              if (typeof message.address === "number")
                object.address = options.longs === String ? String(message.address) : message.address;
              else
                object.address = options.longs === String ? $util.Long.prototype.toString.call(message.address) : options.longs === Number ? new $util.LongBits(message.address.low >>> 0, message.address.high >>> 0).toNumber(true) : message.address;
            if (message.line && message.line.length) {
              object.line = [];
              for (var j = 0; j < message.line.length; ++j)
                object.line[j] = $root.perftools.profiles.Line.toObject(message.line[j], options);
            }
            return object;
          }, "toObject");
          Location.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          Location.getTypeUrl = /* @__PURE__ */ __name(function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/perftools.profiles.Location";
          }, "getTypeUrl");
          return Location;
        }();
        profiles.Line = function() {
          function Line(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Line, "Line");
          Line.prototype.functionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Line.prototype.line = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Line.create = /* @__PURE__ */ __name(function create(properties) {
            return new Line(properties);
          }, "create");
          Line.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.functionId != null && Object.hasOwnProperty.call(message, "functionId"))
              writer.uint32(8).uint64(message.functionId);
            if (message.line != null && Object.hasOwnProperty.call(message, "line"))
              writer.uint32(16).int64(message.line);
            return writer;
          }, "encode");
          Line.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Line.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Line();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.functionId = reader.uint64();
                  break;
                }
                case 2: {
                  message.line = reader.int64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Line.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Line.verify = /* @__PURE__ */ __name(function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.functionId != null && message.hasOwnProperty("functionId")) {
              if (!$util.isInteger(message.functionId) && !(message.functionId && $util.isInteger(message.functionId.low) && $util.isInteger(message.functionId.high)))
                return "functionId: integer|Long expected";
            }
            if (message.line != null && message.hasOwnProperty("line")) {
              if (!$util.isInteger(message.line) && !(message.line && $util.isInteger(message.line.low) && $util.isInteger(message.line.high)))
                return "line: integer|Long expected";
            }
            return null;
          }, "verify");
          Line.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
            if (object instanceof $root.perftools.profiles.Line)
              return object;
            var message = new $root.perftools.profiles.Line();
            if (object.functionId != null) {
              if ($util.Long)
                (message.functionId = $util.Long.fromValue(object.functionId)).unsigned = true;
              else if (typeof object.functionId === "string")
                message.functionId = parseInt(object.functionId, 10);
              else if (typeof object.functionId === "number")
                message.functionId = object.functionId;
              else if (typeof object.functionId === "object")
                message.functionId = new $util.LongBits(object.functionId.low >>> 0, object.functionId.high >>> 0).toNumber(true);
            }
            if (object.line != null) {
              if ($util.Long)
                (message.line = $util.Long.fromValue(object.line)).unsigned = false;
              else if (typeof object.line === "string")
                message.line = parseInt(object.line, 10);
              else if (typeof object.line === "number")
                message.line = object.line;
              else if (typeof object.line === "object")
                message.line = new $util.LongBits(object.line.low >>> 0, object.line.high >>> 0).toNumber();
            }
            return message;
          }, "fromObject");
          Line.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.functionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.functionId = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.line = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.line = options.longs === String ? "0" : 0;
            }
            if (message.functionId != null && message.hasOwnProperty("functionId"))
              if (typeof message.functionId === "number")
                object.functionId = options.longs === String ? String(message.functionId) : message.functionId;
              else
                object.functionId = options.longs === String ? $util.Long.prototype.toString.call(message.functionId) : options.longs === Number ? new $util.LongBits(message.functionId.low >>> 0, message.functionId.high >>> 0).toNumber(true) : message.functionId;
            if (message.line != null && message.hasOwnProperty("line"))
              if (typeof message.line === "number")
                object.line = options.longs === String ? String(message.line) : message.line;
              else
                object.line = options.longs === String ? $util.Long.prototype.toString.call(message.line) : options.longs === Number ? new $util.LongBits(message.line.low >>> 0, message.line.high >>> 0).toNumber() : message.line;
            return object;
          }, "toObject");
          Line.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          Line.getTypeUrl = /* @__PURE__ */ __name(function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/perftools.profiles.Line";
          }, "getTypeUrl");
          return Line;
        }();
        profiles.Function = function() {
          function Function2(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Function2, "Function");
          Function2.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Function2.prototype.name = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Function2.prototype.systemName = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Function2.prototype.filename = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Function2.prototype.startLine = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Function2.create = /* @__PURE__ */ __name(function create(properties) {
            return new Function2(properties);
          }, "create");
          Function2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(8).uint64(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
              writer.uint32(16).int64(message.name);
            if (message.systemName != null && Object.hasOwnProperty.call(message, "systemName"))
              writer.uint32(24).int64(message.systemName);
            if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
              writer.uint32(32).int64(message.filename);
            if (message.startLine != null && Object.hasOwnProperty.call(message, "startLine"))
              writer.uint32(40).int64(message.startLine);
            return writer;
          }, "encode");
          Function2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Function2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.perftools.profiles.Function();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.id = reader.uint64();
                  break;
                }
                case 2: {
                  message.name = reader.int64();
                  break;
                }
                case 3: {
                  message.systemName = reader.int64();
                  break;
                }
                case 4: {
                  message.filename = reader.int64();
                  break;
                }
                case 5: {
                  message.startLine = reader.int64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Function2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Function2.verify = /* @__PURE__ */ __name(function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
            }
            if (message.name != null && message.hasOwnProperty("name")) {
              if (!$util.isInteger(message.name) && !(message.name && $util.isInteger(message.name.low) && $util.isInteger(message.name.high)))
                return "name: integer|Long expected";
            }
            if (message.systemName != null && message.hasOwnProperty("systemName")) {
              if (!$util.isInteger(message.systemName) && !(message.systemName && $util.isInteger(message.systemName.low) && $util.isInteger(message.systemName.high)))
                return "systemName: integer|Long expected";
            }
            if (message.filename != null && message.hasOwnProperty("filename")) {
              if (!$util.isInteger(message.filename) && !(message.filename && $util.isInteger(message.filename.low) && $util.isInteger(message.filename.high)))
                return "filename: integer|Long expected";
            }
            if (message.startLine != null && message.hasOwnProperty("startLine")) {
              if (!$util.isInteger(message.startLine) && !(message.startLine && $util.isInteger(message.startLine.low) && $util.isInteger(message.startLine.high)))
                return "startLine: integer|Long expected";
            }
            return null;
          }, "verify");
          Function2.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
            if (object instanceof $root.perftools.profiles.Function)
              return object;
            var message = new $root.perftools.profiles.Function();
            if (object.id != null) {
              if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
              else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
              else if (typeof object.id === "number")
                message.id = object.id;
              else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
            }
            if (object.name != null) {
              if ($util.Long)
                (message.name = $util.Long.fromValue(object.name)).unsigned = false;
              else if (typeof object.name === "string")
                message.name = parseInt(object.name, 10);
              else if (typeof object.name === "number")
                message.name = object.name;
              else if (typeof object.name === "object")
                message.name = new $util.LongBits(object.name.low >>> 0, object.name.high >>> 0).toNumber();
            }
            if (object.systemName != null) {
              if ($util.Long)
                (message.systemName = $util.Long.fromValue(object.systemName)).unsigned = false;
              else if (typeof object.systemName === "string")
                message.systemName = parseInt(object.systemName, 10);
              else if (typeof object.systemName === "number")
                message.systemName = object.systemName;
              else if (typeof object.systemName === "object")
                message.systemName = new $util.LongBits(object.systemName.low >>> 0, object.systemName.high >>> 0).toNumber();
            }
            if (object.filename != null) {
              if ($util.Long)
                (message.filename = $util.Long.fromValue(object.filename)).unsigned = false;
              else if (typeof object.filename === "string")
                message.filename = parseInt(object.filename, 10);
              else if (typeof object.filename === "number")
                message.filename = object.filename;
              else if (typeof object.filename === "object")
                message.filename = new $util.LongBits(object.filename.low >>> 0, object.filename.high >>> 0).toNumber();
            }
            if (object.startLine != null) {
              if ($util.Long)
                (message.startLine = $util.Long.fromValue(object.startLine)).unsigned = false;
              else if (typeof object.startLine === "string")
                message.startLine = parseInt(object.startLine, 10);
              else if (typeof object.startLine === "number")
                message.startLine = object.startLine;
              else if (typeof object.startLine === "object")
                message.startLine = new $util.LongBits(object.startLine.low >>> 0, object.startLine.high >>> 0).toNumber();
            }
            return message;
          }, "fromObject");
          Function2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.id = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.name = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.name = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.systemName = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.systemName = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.filename = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.filename = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.startLine = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.startLine = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
              if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
              else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
              if (typeof message.name === "number")
                object.name = options.longs === String ? String(message.name) : message.name;
              else
                object.name = options.longs === String ? $util.Long.prototype.toString.call(message.name) : options.longs === Number ? new $util.LongBits(message.name.low >>> 0, message.name.high >>> 0).toNumber() : message.name;
            if (message.systemName != null && message.hasOwnProperty("systemName"))
              if (typeof message.systemName === "number")
                object.systemName = options.longs === String ? String(message.systemName) : message.systemName;
              else
                object.systemName = options.longs === String ? $util.Long.prototype.toString.call(message.systemName) : options.longs === Number ? new $util.LongBits(message.systemName.low >>> 0, message.systemName.high >>> 0).toNumber() : message.systemName;
            if (message.filename != null && message.hasOwnProperty("filename"))
              if (typeof message.filename === "number")
                object.filename = options.longs === String ? String(message.filename) : message.filename;
              else
                object.filename = options.longs === String ? $util.Long.prototype.toString.call(message.filename) : options.longs === Number ? new $util.LongBits(message.filename.low >>> 0, message.filename.high >>> 0).toNumber() : message.filename;
            if (message.startLine != null && message.hasOwnProperty("startLine"))
              if (typeof message.startLine === "number")
                object.startLine = options.longs === String ? String(message.startLine) : message.startLine;
              else
                object.startLine = options.longs === String ? $util.Long.prototype.toString.call(message.startLine) : options.longs === Number ? new $util.LongBits(message.startLine.low >>> 0, message.startLine.high >>> 0).toNumber() : message.startLine;
            return object;
          }, "toObject");
          Function2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          Function2.getTypeUrl = /* @__PURE__ */ __name(function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/perftools.profiles.Function";
          }, "getTypeUrl");
          return Function2;
        }();
        return profiles;
      }();
      return perftools;
    }();
    module2.exports = $root;
  }
});

// node_modules/@datadog/pprof/out/src/profile-serializer.js
var require_profile_serializer = __commonJS({
  "node_modules/@datadog/pprof/out/src/profile-serializer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeHeapProfile = exports2.serializeCpuProfile = exports2.serializeTimeProfile = void 0;
    var profile_1 = require_profile();
    function isGeneratedLocation(location) {
      return location.column !== void 0 && location.line !== void 0 && location.line > 0;
    }
    __name(isGeneratedLocation, "isGeneratedLocation");
    var StringTable = class {
      constructor() {
        this.strings = [];
        this.stringsMap = /* @__PURE__ */ new Map();
        this.getIndexOrAdd("");
      }
      getIndexOrAdd(str) {
        let idx = this.stringsMap.get(str);
        if (idx !== void 0) {
          return idx;
        }
        idx = this.strings.push(str) - 1;
        this.stringsMap.set(str, idx);
        return idx;
      }
    };
    __name(StringTable, "StringTable");
    function serialize(profile, root, appendToSamples, stringTable, ignoreSamplesPath, sourceMapper) {
      const samples = [];
      const locations = [];
      const functions = [];
      const functionIdMap = /* @__PURE__ */ new Map();
      const locationIdMap = /* @__PURE__ */ new Map();
      const entries = root.children.map((n) => ({
        node: n,
        stack: []
      }));
      while (entries.length > 0) {
        const entry = entries.pop();
        const node = entry.node;
        if (ignoreSamplesPath && node.scriptName.indexOf(ignoreSamplesPath) > -1) {
          continue;
        }
        if (node.name === "(idle)" || node.name === "(program)")
          continue;
        const stack = entry.stack;
        const location = getLocation(node, sourceMapper);
        stack.unshift(location.id);
        appendToSamples(entry, samples);
        for (const child of node.children) {
          entries.push({ node: child, stack: stack.slice() });
        }
      }
      profile.sample = samples;
      profile.location = locations;
      profile.function = functions;
      profile.stringTable = stringTable.strings;
      function getLocation(node, sourceMapper2) {
        let profLoc = {
          file: node.scriptName || "",
          line: node.lineNumber,
          column: node.columnNumber,
          name: node.name
        };
        if (profLoc.line) {
          if (sourceMapper2 && isGeneratedLocation(profLoc)) {
            profLoc = sourceMapper2.mappingInfo(profLoc);
          }
        }
        const keyStr = `${node.scriptId}:${profLoc.line}:${profLoc.column}:${profLoc.name}`;
        let id = locationIdMap.get(keyStr);
        if (id !== void 0) {
          return locations[id - 1];
        }
        id = locations.length + 1;
        locationIdMap.set(keyStr, id);
        const line = getLine(node.scriptId, profLoc.file, profLoc.name, profLoc.line);
        const location = new profile_1.perftools.profiles.Location({ id, line: [line] });
        locations.push(location);
        return location;
      }
      __name(getLocation, "getLocation");
      function getLine(scriptId, scriptName, name, line) {
        return new profile_1.perftools.profiles.Line({
          functionId: getFunction(scriptId, scriptName, name).id,
          line
        });
      }
      __name(getLine, "getLine");
      function getFunction(scriptId, scriptName, name) {
        const keyStr = `${scriptId}:${name}`;
        let id = functionIdMap.get(keyStr);
        if (id !== void 0) {
          return functions[id - 1];
        }
        id = functions.length + 1;
        functionIdMap.set(keyStr, id);
        const nameId = stringTable.getIndexOrAdd(name || "(anonymous)");
        const f = new profile_1.perftools.profiles.Function({
          id,
          name: nameId,
          systemName: nameId,
          filename: stringTable.getIndexOrAdd(scriptName || "")
        });
        functions.push(f);
        return f;
      }
      __name(getFunction, "getFunction");
    }
    __name(serialize, "serialize");
    function createSampleCountValueType(table) {
      return new profile_1.perftools.profiles.ValueType({
        type: table.getIndexOrAdd("sample"),
        unit: table.getIndexOrAdd("count")
      });
    }
    __name(createSampleCountValueType, "createSampleCountValueType");
    function createTimeValueType(table) {
      return new profile_1.perftools.profiles.ValueType({
        type: table.getIndexOrAdd("wall"),
        unit: table.getIndexOrAdd("nanoseconds")
      });
    }
    __name(createTimeValueType, "createTimeValueType");
    function createCpuValueType(table) {
      return new profile_1.perftools.profiles.ValueType({
        type: table.getIndexOrAdd("cpu"),
        unit: table.getIndexOrAdd("nanoseconds")
      });
    }
    __name(createCpuValueType, "createCpuValueType");
    function createObjectCountValueType(table) {
      return new profile_1.perftools.profiles.ValueType({
        type: table.getIndexOrAdd("objects"),
        unit: table.getIndexOrAdd("count")
      });
    }
    __name(createObjectCountValueType, "createObjectCountValueType");
    function createAllocationValueType(table) {
      return new profile_1.perftools.profiles.ValueType({
        type: table.getIndexOrAdd("space"),
        unit: table.getIndexOrAdd("bytes")
      });
    }
    __name(createAllocationValueType, "createAllocationValueType");
    function serializeTimeProfile(prof, intervalMicros, sourceMapper) {
      const intervalNanos = intervalMicros * 1e3;
      const appendTimeEntryToSamples = /* @__PURE__ */ __name((entry, samples) => {
        if (entry.node.hitCount > 0) {
          const sample = new profile_1.perftools.profiles.Sample({
            locationId: entry.stack,
            value: [entry.node.hitCount, entry.node.hitCount * intervalNanos]
          });
          samples.push(sample);
        }
      }, "appendTimeEntryToSamples");
      const stringTable = new StringTable();
      const sampleValueType = createSampleCountValueType(stringTable);
      const timeValueType = createTimeValueType(stringTable);
      const profile = {
        sampleType: [sampleValueType, timeValueType],
        timeNanos: Date.now() * 1e3 * 1e3,
        durationNanos: (prof.endTime - prof.startTime) * 1e3,
        periodType: timeValueType,
        period: intervalMicros
      };
      serialize(profile, prof.topDownRoot, appendTimeEntryToSamples, stringTable, void 0, sourceMapper);
      return profile;
    }
    __name(serializeTimeProfile, "serializeTimeProfile");
    exports2.serializeTimeProfile = serializeTimeProfile;
    function buildLabels(labelSet, stringTable) {
      const labels = [];
      for (const [key, value] of Object.entries(labelSet)) {
        if (typeof value === "number" || typeof value === "string") {
          const label = new profile_1.perftools.profiles.Label({
            key: stringTable.getIndexOrAdd(key),
            num: typeof value === "number" ? value : void 0,
            str: typeof value === "string" ? stringTable.getIndexOrAdd(value) : void 0
          });
          labels.push(label);
        }
      }
      return labels;
    }
    __name(buildLabels, "buildLabels");
    function serializeCpuProfile(prof, intervalMicros, sourceMapper) {
      const intervalNanos = intervalMicros * 1e3;
      const appendCpuEntryToSamples = /* @__PURE__ */ __name((entry, samples) => {
        for (const labelSet of entry.node.labelSets) {
          const sample = new profile_1.perftools.profiles.Sample({
            locationId: entry.stack,
            value: [1, intervalNanos],
            label: buildLabels(labelSet, stringTable)
          });
          samples.push(sample);
        }
        const unknownEntryCount = entry.node.hitCount - entry.node.labelSets.length;
        if (unknownEntryCount > 0) {
          const sample = new profile_1.perftools.profiles.Sample({
            locationId: entry.stack,
            value: [
              unknownEntryCount,
              entry.node.cpuTime
            ]
          });
          samples.push(sample);
        }
      }, "appendCpuEntryToSamples");
      const stringTable = new StringTable();
      const sampleValueType = createSampleCountValueType(stringTable);
      const cpuValueType = createCpuValueType(stringTable);
      const profile = {
        sampleType: [sampleValueType, cpuValueType],
        timeNanos: Date.now() * 1e3 * 1e3,
        durationNanos: prof.endTime - prof.startTime,
        periodType: cpuValueType,
        period: intervalMicros
      };
      serialize(profile, prof.topDownRoot, appendCpuEntryToSamples, stringTable, void 0, sourceMapper);
      return profile;
    }
    __name(serializeCpuProfile, "serializeCpuProfile");
    exports2.serializeCpuProfile = serializeCpuProfile;
    function serializeHeapProfile(prof, startTimeNanos, intervalBytes, ignoreSamplesPath, sourceMapper) {
      const appendHeapEntryToSamples = /* @__PURE__ */ __name((entry, samples) => {
        if (entry.node.allocations.length > 0) {
          for (const alloc of entry.node.allocations) {
            const sample = new profile_1.perftools.profiles.Sample({
              locationId: entry.stack,
              value: [alloc.count, alloc.sizeBytes * alloc.count]
            });
            samples.push(sample);
          }
        }
      }, "appendHeapEntryToSamples");
      const stringTable = new StringTable();
      const sampleValueType = createObjectCountValueType(stringTable);
      const allocationValueType = createAllocationValueType(stringTable);
      const profile = {
        sampleType: [sampleValueType, allocationValueType],
        timeNanos: startTimeNanos,
        periodType: allocationValueType,
        period: intervalBytes
      };
      serialize(profile, prof, appendHeapEntryToSamples, stringTable, ignoreSamplesPath, sourceMapper);
      return profile;
    }
    __name(serializeHeapProfile, "serializeHeapProfile");
    exports2.serializeHeapProfile = serializeHeapProfile;
  }
});

// node_modules/@datadog/pprof/out/src/cpu-profiler-bindings.js
var require_cpu_profiler_bindings = __commonJS({
  "node_modules/@datadog/pprof/out/src/cpu-profiler-bindings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CpuProfiler = void 0;
    var path_1 = __require("path");
    var findBinding = require_node_gyp_build();
    var profiler = findBinding((0, path_1.join)(__dirname, "..", ".."));
    exports2.CpuProfiler = profiler.CpuProfiler;
  }
});

// node_modules/@datadog/pprof/out/src/cpu-profiler.js
var require_cpu_profiler = __commonJS({
  "node_modules/@datadog/pprof/out/src/cpu-profiler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var profile_serializer_1 = require_profile_serializer();
    var cpu_profiler_bindings_1 = require_cpu_profiler_bindings();
    function isNodeEqual(a, b) {
      if (a.name !== b.name)
        return false;
      if (a.scriptName !== b.scriptName)
        return false;
      if (a.scriptId !== b.scriptId)
        return false;
      if (a.lineNumber !== b.lineNumber)
        return false;
      if (a.columnNumber !== b.columnNumber)
        return false;
      return true;
    }
    __name(isNodeEqual, "isNodeEqual");
    function makeNode(location) {
      return {
        name: location.comment || location.functionName,
        scriptName: location.scriptName || "",
        scriptId: location.scriptId,
        lineNumber: location.line,
        columnNumber: location.column,
        hitCount: 0,
        cpuTime: 0,
        labelSets: [],
        children: []
      };
    }
    __name(makeNode, "makeNode");
    var CpuProfiler = class extends cpu_profiler_bindings_1.CpuProfiler {
      profile() {
        if (this.frequency === 0)
          return;
        const profile = super.profile();
        const timeProfile = {
          startTime: profile.startTime,
          endTime: profile.endTime,
          topDownRoot: {
            name: "(root)",
            scriptName: "",
            scriptId: 0,
            lineNumber: 0,
            columnNumber: 0,
            hitCount: 0,
            cpuTime: 0,
            labelSets: [],
            children: []
          }
        };
        let targetNode = timeProfile.topDownRoot;
        for (const sample of profile.samples) {
          if (!sample)
            continue;
          locations:
            for (const location of sample.locations) {
              const node = makeNode(location);
              for (const found of targetNode.children) {
                const foundNode = found;
                if (isNodeEqual(node, foundNode)) {
                  targetNode = foundNode;
                  continue locations;
                }
              }
              targetNode.children.push(node);
              targetNode = node;
            }
          targetNode.cpuTime += sample.cpuTime;
          targetNode.hitCount++;
          if (sample.labels) {
            targetNode.labelSets.push(sample.labels);
          }
          targetNode = timeProfile.topDownRoot;
        }
        const intervalMicros = 1e3 / this.frequency;
        return (0, profile_serializer_1.serializeCpuProfile)(timeProfile, intervalMicros);
      }
    };
    __name(CpuProfiler, "CpuProfiler");
    exports2.default = CpuProfiler;
  }
});

// node_modules/@datadog/pprof/out/src/heap-profiler-bindings.js
var require_heap_profiler_bindings = __commonJS({
  "node_modules/@datadog/pprof/out/src/heap-profiler-bindings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAllocationProfile = exports2.stopSamplingHeapProfiler = exports2.startSamplingHeapProfiler = void 0;
    var path = __require("path");
    var findBinding = require_node_gyp_build();
    var profiler = findBinding(path.join(__dirname, "..", ".."));
    function startSamplingHeapProfiler(heapIntervalBytes, heapStackDepth) {
      profiler.heapProfiler.startSamplingHeapProfiler(heapIntervalBytes, heapStackDepth);
    }
    __name(startSamplingHeapProfiler, "startSamplingHeapProfiler");
    exports2.startSamplingHeapProfiler = startSamplingHeapProfiler;
    function stopSamplingHeapProfiler() {
      profiler.heapProfiler.stopSamplingHeapProfiler();
    }
    __name(stopSamplingHeapProfiler, "stopSamplingHeapProfiler");
    exports2.stopSamplingHeapProfiler = stopSamplingHeapProfiler;
    function getAllocationProfile() {
      return profiler.heapProfiler.getAllocationProfile();
    }
    __name(getAllocationProfile, "getAllocationProfile");
    exports2.getAllocationProfile = getAllocationProfile;
  }
});

// node_modules/@datadog/pprof/out/src/heap-profiler.js
var require_heap_profiler = __commonJS({
  "node_modules/@datadog/pprof/out/src/heap-profiler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stop = exports2.start = exports2.profile = exports2.v8Profile = void 0;
    var heap_profiler_bindings_1 = require_heap_profiler_bindings();
    var profile_serializer_1 = require_profile_serializer();
    var enabled = false;
    var heapIntervalBytes = 0;
    var heapStackDepth = 0;
    function v8Profile() {
      if (!enabled) {
        throw new Error("Heap profiler is not enabled.");
      }
      return (0, heap_profiler_bindings_1.getAllocationProfile)();
    }
    __name(v8Profile, "v8Profile");
    exports2.v8Profile = v8Profile;
    function profile(ignoreSamplePath, sourceMapper) {
      const startTimeNanos = Date.now() * 1e3 * 1e3;
      const result = v8Profile();
      const { external } = process.memoryUsage();
      if (external > 0) {
        const externalNode = {
          name: "(external)",
          scriptName: "",
          children: [],
          allocations: [{ sizeBytes: external, count: 1 }]
        };
        result.children.push(externalNode);
      }
      return (0, profile_serializer_1.serializeHeapProfile)(result, startTimeNanos, heapIntervalBytes, ignoreSamplePath, sourceMapper);
    }
    __name(profile, "profile");
    exports2.profile = profile;
    function start(intervalBytes, stackDepth) {
      if (enabled) {
        throw new Error(`Heap profiler is already started  with intervalBytes ${heapIntervalBytes} and stackDepth ${stackDepth}`);
      }
      heapIntervalBytes = intervalBytes;
      heapStackDepth = stackDepth;
      (0, heap_profiler_bindings_1.startSamplingHeapProfiler)(heapIntervalBytes, heapStackDepth);
      enabled = true;
    }
    __name(start, "start");
    exports2.start = start;
    function stop() {
      if (enabled) {
        enabled = false;
        (0, heap_profiler_bindings_1.stopSamplingHeapProfiler)();
      }
    }
    __name(stop, "stop");
    exports2.stop = stop;
  }
});

// node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = /* @__PURE__ */ __name((fn, options, proxy, unwrapped) => function(...arguments_) {
      const P = options.promiseModule;
      return new P((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self2 = this === proxy ? unwrapped : this;
        Reflect.apply(fn, self2, arguments_);
      });
    }, "processFn");
    var filterCache = /* @__PURE__ */ new WeakMap();
    module2.exports = (input, options) => {
      options = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise,
        ...options
      };
      const objectType = typeof input;
      if (!(input !== null && (objectType === "object" || objectType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
      }
      const filter = /* @__PURE__ */ __name((target, key) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key in cached) {
          return cached[key];
        }
        const match = /* @__PURE__ */ __name((pattern) => typeof pattern === "string" || typeof key === "symbol" ? key === pattern : pattern.test(key), "match");
        const desc = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
      }, "filter");
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key) {
          const property = target[key];
          if (!filter(target, key) || property === Function.prototype[key]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        }
      });
      return proxy;
    };
  }
});

// node_modules/@datadog/pprof/out/src/profile-encoder.js
var require_profile_encoder = __commonJS({
  "node_modules/@datadog/pprof/out/src/profile-encoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeSync = exports2.encode = void 0;
    var pify = require_pify();
    var zlib_1 = __require("zlib");
    var profile_1 = require_profile();
    var gzipPromise = pify(zlib_1.gzip);
    async function encode(profile) {
      const buffer = profile_1.perftools.profiles.Profile.encode(profile).finish();
      return gzipPromise(buffer);
    }
    __name(encode, "encode");
    exports2.encode = encode;
    function encodeSync(profile) {
      const buffer = profile_1.perftools.profiles.Profile.encode(profile).finish();
      return (0, zlib_1.gzipSync)(buffer);
    }
    __name(encodeSync, "encodeSync");
    exports2.encodeSync = encodeSync;
  }
});

// node_modules/delay/index.js
var require_delay = __commonJS({
  "node_modules/delay/index.js"(exports2, module2) {
    "use strict";
    var randomInteger = /* @__PURE__ */ __name((minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum), "randomInteger");
    var createAbortError = /* @__PURE__ */ __name(() => {
      const error = new Error("Delay aborted");
      error.name = "AbortError";
      return error;
    }, "createAbortError");
    var createDelay = /* @__PURE__ */ __name(({ clearTimeout: defaultClear, setTimeout: set, willResolve }) => (ms, { value, signal } = {}) => {
      if (signal && signal.aborted) {
        return Promise.reject(createAbortError());
      }
      let timeoutId;
      let settle;
      let rejectFn;
      const clear = defaultClear || clearTimeout;
      const signalListener = /* @__PURE__ */ __name(() => {
        clear(timeoutId);
        rejectFn(createAbortError());
      }, "signalListener");
      const cleanup = /* @__PURE__ */ __name(() => {
        if (signal) {
          signal.removeEventListener("abort", signalListener);
        }
      }, "cleanup");
      const delayPromise = new Promise((resolve, reject) => {
        settle = /* @__PURE__ */ __name(() => {
          cleanup();
          if (willResolve) {
            resolve(value);
          } else {
            reject(value);
          }
        }, "settle");
        rejectFn = reject;
        timeoutId = (set || setTimeout)(settle, ms);
      });
      if (signal) {
        signal.addEventListener("abort", signalListener, { once: true });
      }
      delayPromise.clear = () => {
        clear(timeoutId);
        timeoutId = null;
        settle();
      };
      return delayPromise;
    }, "createDelay");
    var createWithTimers = /* @__PURE__ */ __name((clearAndSet) => {
      const delay2 = createDelay({ ...clearAndSet, willResolve: true });
      delay2.reject = createDelay({ ...clearAndSet, willResolve: false });
      delay2.range = (minimum, maximum, options) => delay2(randomInteger(minimum, maximum), options);
      return delay2;
    }, "createWithTimers");
    var delay = createWithTimers();
    delay.createWithTimers = createWithTimers;
    module2.exports = delay;
    module2.exports.default = delay;
  }
});

// node_modules/@datadog/pprof/out/src/time-profiler-bindings.js
var require_time_profiler_bindings = __commonJS({
  "node_modules/@datadog/pprof/out/src/time-profiler-bindings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeProfiler = void 0;
    var path_1 = __require("path");
    var findBinding = require_node_gyp_build();
    var profiler = findBinding((0, path_1.join)(__dirname, "..", ".."));
    exports2.TimeProfiler = profiler.TimeProfiler;
  }
});

// node_modules/@datadog/pprof/out/src/time-profiler.js
var require_time_profiler = __commonJS({
  "node_modules/@datadog/pprof/out/src/time-profiler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.start = exports2.profile = void 0;
    var delay_1 = require_delay();
    var profile_serializer_1 = require_profile_serializer();
    var time_profiler_bindings_1 = require_time_profiler_bindings();
    var DEFAULT_INTERVAL_MICROS = 1e3;
    var majorVersion = process.version.slice(1).split(".").map(Number)[0];
    async function profile(options) {
      const stop = start(options.intervalMicros || DEFAULT_INTERVAL_MICROS, options.name, options.sourceMapper, options.lineNumbers);
      await (0, delay_1.default)(options.durationMillis);
      return stop();
    }
    __name(profile, "profile");
    exports2.profile = profile;
    function ensureRunName(name) {
      return name || `pprof-${Date.now()}-${Math.random()}`;
    }
    __name(ensureRunName, "ensureRunName");
    function start(intervalMicros = DEFAULT_INTERVAL_MICROS, name, sourceMapper, lineNumbers = true) {
      const profiler = new time_profiler_bindings_1.TimeProfiler(intervalMicros);
      let runName = start2();
      return majorVersion < 16 ? stopOld : stop;
      function start2() {
        const runName2 = ensureRunName(name);
        profiler.start(runName2, lineNumbers);
        return runName2;
      }
      __name(start2, "start");
      function stopOld(restart = false) {
        const result = profiler.stop(runName, lineNumbers);
        profiler.dispose();
        if (restart) {
          runName = start2();
        }
        return (0, profile_serializer_1.serializeTimeProfile)(result, intervalMicros, sourceMapper);
      }
      __name(stopOld, "stopOld");
      function stop(restart = false) {
        let nextRunName;
        if (restart) {
          nextRunName = start2();
        }
        const result = profiler.stop(runName, lineNumbers);
        if (nextRunName) {
          runName = nextRunName;
        }
        if (!restart)
          profiler.dispose();
        return (0, profile_serializer_1.serializeTimeProfile)(result, intervalMicros, sourceMapper);
      }
      __name(stop, "stop");
    }
    __name(start, "start");
    exports2.start = start;
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/base64.js
var require_base642 = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/base64-vlq.js"(exports2) {
    var base64 = require_base642();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    __name(toVLQSigned, "toVLQSigned");
    exports2.encode = /* @__PURE__ */ __name(function base64VLQ_encode(aValue) {
      let encoded = "";
      let digit;
      let vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    }, "base64VLQ_encode");
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/util.js
var require_util8 = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      }
      throw new Error('"' + aName + '" is a required argument.');
    }
    __name(getArg, "getArg");
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      const match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    __name(urlParse, "urlParse");
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      let url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    __name(urlGenerate, "urlGenerate");
    exports2.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      const cache = [];
      return function(input) {
        for (let i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            const temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        const result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    __name(lruMemoize, "lruMemoize");
    var normalize = lruMemoize(/* @__PURE__ */ __name(function normalize2(aPath) {
      let path = aPath;
      const url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      const isAbsolute = exports2.isAbsolute(path);
      const parts = [];
      let start = 0;
      let i = 0;
      while (true) {
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
          parts.push(path.slice(start));
          break;
        } else {
          parts.push(path.slice(start, i));
          while (i < path.length && path[i] === "/") {
            i++;
          }
        }
      }
      let up = 0;
      for (i = parts.length - 1; i >= 0; i--) {
        const part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }, "normalize"));
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      const aPathUrl = urlParse(aPath);
      const aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      const joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    __name(join, "join");
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      let level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        const index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    __name(relative, "relative");
    exports2.relative = relative;
    var supportsNullProto = function() {
      const obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    __name(identity, "identity");
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    __name(toSetString, "toSetString");
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    __name(fromSetString, "fromSetString");
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      const length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (let i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    __name(isProtoString, "isProtoString");
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      let cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    __name(compareByOriginalPositions, "compareByOriginalPositions");
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      let cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    __name(compareByGeneratedPositionsDeflated, "compareByGeneratedPositionsDeflated");
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    __name(strcmp, "strcmp");
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      let cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    __name(compareByGeneratedPositionsInflated, "compareByGeneratedPositionsInflated");
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    __name(parseSourceMapInput, "parseSourceMapInput");
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        const parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          const index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    __name(computeSourceURL, "computeSourceURL");
    exports2.computeSourceURL = computeSourceURL;
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/array-set.js"(exports2) {
    var ArraySet = class {
      constructor() {
        this._array = [];
        this._set = /* @__PURE__ */ new Map();
      }
      static fromArray(aArray, aAllowDuplicates) {
        const set = new ArraySet();
        for (let i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      }
      size() {
        return this._set.size;
      }
      add(aStr, aAllowDuplicates) {
        const isDuplicate = this.has(aStr);
        const idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set.set(aStr, idx);
        }
      }
      has(aStr) {
        return this._set.has(aStr);
      }
      indexOf(aStr) {
        const idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
        throw new Error('"' + aStr + '" is not in the set.');
      }
      at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      }
      toArray() {
        return this._array.slice();
      }
    };
    __name(ArraySet, "ArraySet");
    exports2.ArraySet = ArraySet;
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/mapping-list.js"(exports2) {
    var util = require_util8();
    function generatedPositionAfter(mappingA, mappingB) {
      const lineA = mappingA.generatedLine;
      const lineB = mappingB.generatedLine;
      const columnA = mappingA.generatedColumn;
      const columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    __name(generatedPositionAfter, "generatedPositionAfter");
    var MappingList = class {
      constructor() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      unsortedForEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      }
      add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      }
      toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      }
    };
    __name(MappingList, "MappingList");
    exports2.MappingList = MappingList;
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util = require_util8();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    var SourceMapGenerator = class {
      constructor(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      static fromSourceMap(aSourceMapConsumer) {
        const sourceRoot = aSourceMapConsumer.sourceRoot;
        const generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          const newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          let sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          const content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      }
      addMapping(aArgs) {
        const generated = util.getArg(aArgs, "generated");
        const original = util.getArg(aArgs, "original", null);
        let source = util.getArg(aArgs, "source", null);
        let name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      }
      setSourceContent(aSourceFile, aSourceContent) {
        let source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      }
      applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        let sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        const sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        const newSources = this._mappings.toArray().length > 0 ? new ArraySet() : this._sources;
        const newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            const original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          const source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          const name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(srcFile) {
          const content = aSourceMapConsumer.sourceContentFor(srcFile);
          if (content != null) {
            if (aSourceMapPath != null) {
              srcFile = util.join(aSourceMapPath, srcFile);
            }
            if (sourceRoot != null) {
              srcFile = util.relative(sourceRoot, srcFile);
            }
            this.setSourceContent(srcFile, content);
          }
        }, this);
      }
      _validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      }
      _serializeMappings() {
        let previousGeneratedColumn = 0;
        let previousGeneratedLine = 1;
        let previousOriginalColumn = 0;
        let previousOriginalLine = 0;
        let previousName = 0;
        let previousSource = 0;
        let result = "";
        let next;
        let mapping;
        let nameIdx;
        let sourceIdx;
        const mappings = this._mappings.toArray();
        for (let i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      }
      _generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          const key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      }
      toJSON() {
        const map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      }
      toString() {
        return JSON.stringify(this.toJSON());
      }
    };
    __name(SourceMapGenerator, "SourceMapGenerator");
    SourceMapGenerator.prototype._version = 3;
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      const mid = Math.floor((aHigh - aLow) / 2) + aLow;
      const cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        }
        return mid;
      }
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return mid;
      }
      return aLow < 0 ? -1 : aLow;
    }
    __name(recursiveSearch, "recursiveSearch");
    exports2.search = /* @__PURE__ */ __name(function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      let index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports2.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    }, "search");
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/read-wasm.js
var require_read_wasm = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/read-wasm.js"(exports2, module2) {
    var isBrowserEnvironment = function() {
      return typeof window !== "undefined" && this === window;
    }.call();
    if (isBrowserEnvironment) {
      let mappingsWasm = null;
      module2.exports = /* @__PURE__ */ __name(function readWasm() {
        if (typeof mappingsWasm === "string") {
          return fetch(mappingsWasm).then((response) => response.arrayBuffer());
        }
        if (mappingsWasm instanceof ArrayBuffer) {
          return Promise.resolve(mappingsWasm);
        }
        throw new Error("You must provide the string URL or ArrayBuffer contents of lib/mappings.wasm by calling SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) before using SourceMapConsumer");
      }, "readWasm");
      module2.exports.initialize = (input) => mappingsWasm = input;
    } else {
      const fs = __require("fs");
      const path = __require("path");
      module2.exports = /* @__PURE__ */ __name(function readWasm() {
        return new Promise((resolve, reject) => {
          const wasmPath = path.join(__dirname, "mappings.wasm");
          fs.readFile(wasmPath, null, (error, data) => {
            if (error) {
              reject(error);
              return;
            }
            resolve(data.buffer);
          });
        });
      }, "readWasm");
      module2.exports.initialize = (_) => {
        console.debug("SourceMapConsumer.initialize is a no-op when running in node.js");
      };
    }
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/wasm.js
var require_wasm = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/wasm.js"(exports2, module2) {
    var readWasm = require_read_wasm();
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.lastGeneratedColumn = null;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    __name(Mapping, "Mapping");
    var cachedWasm = null;
    module2.exports = /* @__PURE__ */ __name(function wasm() {
      if (cachedWasm) {
        return cachedWasm;
      }
      const callbackStack = [];
      cachedWasm = readWasm().then((buffer) => {
        return WebAssembly.instantiate(buffer, {
          env: {
            mapping_callback(generatedLine, generatedColumn, hasLastGeneratedColumn, lastGeneratedColumn, hasOriginal, source, originalLine, originalColumn, hasName, name) {
              const mapping = new Mapping();
              mapping.generatedLine = generatedLine + 1;
              mapping.generatedColumn = generatedColumn;
              if (hasLastGeneratedColumn) {
                mapping.lastGeneratedColumn = lastGeneratedColumn - 1;
              }
              if (hasOriginal) {
                mapping.source = source;
                mapping.originalLine = originalLine + 1;
                mapping.originalColumn = originalColumn;
                if (hasName) {
                  mapping.name = name;
                }
              }
              callbackStack[callbackStack.length - 1](mapping);
            },
            start_all_generated_locations_for() {
              console.time("all_generated_locations_for");
            },
            end_all_generated_locations_for() {
              console.timeEnd("all_generated_locations_for");
            },
            start_compute_column_spans() {
              console.time("compute_column_spans");
            },
            end_compute_column_spans() {
              console.timeEnd("compute_column_spans");
            },
            start_generated_location_for() {
              console.time("generated_location_for");
            },
            end_generated_location_for() {
              console.timeEnd("generated_location_for");
            },
            start_original_location_for() {
              console.time("original_location_for");
            },
            end_original_location_for() {
              console.timeEnd("original_location_for");
            },
            start_parse_mappings() {
              console.time("parse_mappings");
            },
            end_parse_mappings() {
              console.timeEnd("parse_mappings");
            },
            start_sort_by_generated_location() {
              console.time("sort_by_generated_location");
            },
            end_sort_by_generated_location() {
              console.timeEnd("sort_by_generated_location");
            },
            start_sort_by_original_location() {
              console.time("sort_by_original_location");
            },
            end_sort_by_original_location() {
              console.timeEnd("sort_by_original_location");
            }
          }
        });
      }).then((Wasm) => {
        return {
          exports: Wasm.instance.exports,
          withMappingCallback: (mappingCallback, f) => {
            callbackStack.push(mappingCallback);
            try {
              f();
            } finally {
              callbackStack.pop();
            }
          }
        };
      }).then(null, (e) => {
        cachedWasm = null;
        throw e;
      });
      return cachedWasm;
    }, "wasm");
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/source-map-consumer.js"(exports2) {
    var util = require_util8();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var readWasm = require_read_wasm();
    var wasm = require_wasm();
    var INTERNAL = Symbol("smcInternal");
    var SourceMapConsumer = class {
      constructor(aSourceMap, aSourceMapURL) {
        if (aSourceMap == INTERNAL) {
          return Promise.resolve(this);
        }
        return _factory(aSourceMap, aSourceMapURL);
      }
      static initialize(opts) {
        readWasm.initialize(opts["lib/mappings.wasm"]);
      }
      static fromSourceMap(aSourceMap, aSourceMapURL) {
        return _factoryBSM(aSourceMap, aSourceMapURL);
      }
      static async with(rawSourceMap, sourceMapUrl, f) {
        const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);
        try {
          return await f(consumer);
        } finally {
          consumer.destroy();
        }
      }
      _parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      }
      eachMapping(aCallback, aContext, aOrder) {
        throw new Error("Subclasses must implement eachMapping");
      }
      allGeneratedPositionsFor(aArgs) {
        throw new Error("Subclasses must implement allGeneratedPositionsFor");
      }
      destroy() {
        throw new Error("Subclasses must implement destroy");
      }
    };
    __name(SourceMapConsumer, "SourceMapConsumer");
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    exports2.SourceMapConsumer = SourceMapConsumer;
    var BasicSourceMapConsumer = class extends SourceMapConsumer {
      constructor(aSourceMap, aSourceMapURL) {
        return super(INTERNAL).then((that) => {
          let sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          const version = util.getArg(sourceMap, "version");
          let sources = util.getArg(sourceMap, "sources");
          const names = util.getArg(sourceMap, "names", []);
          let sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
          const sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
          const mappings = util.getArg(sourceMap, "mappings");
          const file = util.getArg(sourceMap, "file", null);
          if (version != that._version) {
            throw new Error("Unsupported version: " + version);
          }
          if (sourceRoot) {
            sourceRoot = util.normalize(sourceRoot);
          }
          sources = sources.map(String).map(util.normalize).map(function(source) {
            return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
          });
          that._names = ArraySet.fromArray(names.map(String), true);
          that._sources = ArraySet.fromArray(sources, true);
          that._absoluteSources = that._sources.toArray().map(function(s) {
            return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
          });
          that.sourceRoot = sourceRoot;
          that.sourcesContent = sourcesContent;
          that._mappings = mappings;
          that._sourceMapURL = aSourceMapURL;
          that.file = file;
          that._computedColumnSpans = false;
          that._mappingsPtr = 0;
          that._wasm = null;
          return wasm().then((w) => {
            that._wasm = w;
            return that;
          });
        });
      }
      _findSourceIndex(aSource) {
        let relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        for (let i = 0; i < this._absoluteSources.length; ++i) {
          if (this._absoluteSources[i] == aSource) {
            return i;
          }
        }
        return -1;
      }
      static fromSourceMap(aSourceMap, aSourceMapURL) {
        return new BasicSourceMapConsumer(aSourceMap.toString());
      }
      get sources() {
        return this._absoluteSources.slice();
      }
      _getMappingsPtr() {
        if (this._mappingsPtr === 0) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this._mappingsPtr;
      }
      _parseMappings(aStr, aSourceRoot) {
        const size = aStr.length;
        const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);
        const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);
        for (let i = 0; i < size; i++) {
          mappingsBuf[i] = aStr.charCodeAt(i);
        }
        const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);
        if (!mappingsPtr) {
          const error = this._wasm.exports.get_last_error();
          let msg = `Error parsing mappings (code ${error}): `;
          switch (error) {
            case 1:
              msg += "the mappings contained a negative line, column, source index, or name index";
              break;
            case 2:
              msg += "the mappings contained a number larger than 2**32";
              break;
            case 3:
              msg += "reached EOF while in the middle of parsing a VLQ";
              break;
            case 4:
              msg += "invalid base 64 character while parsing a VLQ";
              break;
            default:
              msg += "unknown error code";
              break;
          }
          throw new Error(msg);
        }
        this._mappingsPtr = mappingsPtr;
      }
      eachMapping(aCallback, aContext, aOrder) {
        const context = aContext || null;
        const order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        const sourceRoot = this.sourceRoot;
        this._wasm.withMappingCallback(
          (mapping) => {
            if (mapping.source !== null) {
              mapping.source = this._sources.at(mapping.source);
              mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);
              if (mapping.name !== null) {
                mapping.name = this._names.at(mapping.name);
              }
            }
            aCallback.call(context, mapping);
          },
          () => {
            switch (order) {
              case SourceMapConsumer.GENERATED_ORDER:
                this._wasm.exports.by_generated_location(this._getMappingsPtr());
                break;
              case SourceMapConsumer.ORIGINAL_ORDER:
                this._wasm.exports.by_original_location(this._getMappingsPtr());
                break;
              default:
                throw new Error("Unknown order of iteration.");
            }
          }
        );
      }
      allGeneratedPositionsFor(aArgs) {
        let source = util.getArg(aArgs, "source");
        const originalLine = util.getArg(aArgs, "line");
        const originalColumn = aArgs.column || 0;
        source = this._findSourceIndex(source);
        if (source < 0) {
          return [];
        }
        if (originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        const mappings = [];
        this._wasm.withMappingCallback(
          (m) => {
            let lastColumn = m.lastGeneratedColumn;
            if (this._computedColumnSpans && lastColumn === null) {
              lastColumn = Infinity;
            }
            mappings.push({
              line: m.generatedLine,
              column: m.generatedColumn,
              lastColumn
            });
          },
          () => {
            this._wasm.exports.all_generated_locations_for(
              this._getMappingsPtr(),
              source,
              originalLine - 1,
              "column" in aArgs,
              originalColumn
            );
          }
        );
        return mappings;
      }
      destroy() {
        if (this._mappingsPtr !== 0) {
          this._wasm.exports.free_mappings(this._mappingsPtr);
          this._mappingsPtr = 0;
        }
      }
      computeColumnSpans() {
        if (this._computedColumnSpans) {
          return;
        }
        this._wasm.exports.compute_column_spans(this._getMappingsPtr());
        this._computedColumnSpans = true;
      }
      originalPositionFor(aArgs) {
        const needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        if (needle.generatedLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.generatedColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
        if (bias == null) {
          bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
        }
        let mapping;
        this._wasm.withMappingCallback((m) => mapping = m, () => {
          this._wasm.exports.original_location_for(
            this._getMappingsPtr(),
            needle.generatedLine - 1,
            needle.generatedColumn,
            bias
          );
        });
        if (mapping) {
          if (mapping.generatedLine === needle.generatedLine) {
            let source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            let name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      }
      sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        const index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        let relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        let url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          const fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        }
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
      generatedPositionFor(aArgs) {
        let source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        const needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        if (needle.originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
        if (bias == null) {
          bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
        }
        let mapping;
        this._wasm.withMappingCallback((m) => mapping = m, () => {
          this._wasm.exports.generated_location_for(
            this._getMappingsPtr(),
            needle.source,
            needle.originalLine - 1,
            needle.originalColumn,
            bias
          );
        });
        if (mapping) {
          if (mapping.source === needle.source) {
            let lastColumn = mapping.lastGeneratedColumn;
            if (this._computedColumnSpans && lastColumn === null) {
              lastColumn = Infinity;
            }
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
    };
    __name(BasicSourceMapConsumer, "BasicSourceMapConsumer");
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    var IndexedSourceMapConsumer = class extends SourceMapConsumer {
      constructor(aSourceMap, aSourceMapURL) {
        return super(INTERNAL).then((that) => {
          let sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          const version = util.getArg(sourceMap, "version");
          const sections = util.getArg(sourceMap, "sections");
          if (version != that._version) {
            throw new Error("Unsupported version: " + version);
          }
          that._sources = new ArraySet();
          that._names = new ArraySet();
          that.__generatedMappings = null;
          that.__originalMappings = null;
          that.__generatedMappingsUnsorted = null;
          that.__originalMappingsUnsorted = null;
          let lastOffset = {
            line: -1,
            column: 0
          };
          return Promise.all(sections.map((s) => {
            if (s.url) {
              throw new Error("Support for url field in sections not implemented.");
            }
            const offset = util.getArg(s, "offset");
            const offsetLine = util.getArg(offset, "line");
            const offsetColumn = util.getArg(offset, "column");
            if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
              throw new Error("Section offsets must be ordered and non-overlapping.");
            }
            lastOffset = offset;
            const cons = new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL);
            return cons.then((consumer) => {
              return {
                generatedOffset: {
                  generatedLine: offsetLine + 1,
                  generatedColumn: offsetColumn + 1
                },
                consumer
              };
            });
          })).then((s) => {
            that._sections = s;
            return that;
          });
        });
      }
      get _generatedMappings() {
        if (!this.__generatedMappings) {
          this._sortGeneratedMappings();
        }
        return this.__generatedMappings;
      }
      get _originalMappings() {
        if (!this.__originalMappings) {
          this._sortOriginalMappings();
        }
        return this.__originalMappings;
      }
      get _generatedMappingsUnsorted() {
        if (!this.__generatedMappingsUnsorted) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappingsUnsorted;
      }
      get _originalMappingsUnsorted() {
        if (!this.__originalMappingsUnsorted) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappingsUnsorted;
      }
      _sortGeneratedMappings() {
        const mappings = this._generatedMappingsUnsorted;
        mappings.sort(util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = mappings;
      }
      _sortOriginalMappings() {
        const mappings = this._originalMappingsUnsorted;
        mappings.sort(util.compareByOriginalPositions);
        this.__originalMappings = mappings;
      }
      get sources() {
        const sources = [];
        for (let i = 0; i < this._sections.length; i++) {
          for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
      originalPositionFor(aArgs) {
        const needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        const sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(aNeedle, section2) {
            const cmp = aNeedle.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return aNeedle.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        const section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      }
      hasContentsOfAllSources() {
        return this._sections.every(function(s) {
          return s.consumer.hasContentsOfAllSources();
        });
      }
      sourceContentFor(aSource, nullOnMissing) {
        for (let i = 0; i < this._sections.length; i++) {
          const section = this._sections[i];
          const content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        }
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
      generatedPositionFor(aArgs) {
        for (let i = 0; i < this._sections.length; i++) {
          const section = this._sections[i];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
            continue;
          }
          const generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            const ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
        return {
          line: null,
          column: null
        };
      }
      _parseMappings(aStr, aSourceRoot) {
        const generatedMappings = this.__generatedMappingsUnsorted = [];
        const originalMappings = this.__originalMappingsUnsorted = [];
        for (let i = 0; i < this._sections.length; i++) {
          const section = this._sections[i];
          const sectionMappings = [];
          section.consumer.eachMapping((m) => sectionMappings.push(m));
          for (let j = 0; j < sectionMappings.length; j++) {
            const mapping = sectionMappings[j];
            let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            let name = null;
            if (mapping.name) {
              this._names.add(mapping.name);
              name = this._names.indexOf(mapping.name);
            }
            const adjustedMapping = {
              source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name
            };
            generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              originalMappings.push(adjustedMapping);
            }
          }
        }
      }
      eachMapping(aCallback, aContext, aOrder) {
        const context = aContext || null;
        const order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        let mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        const sourceRoot = this.sourceRoot;
        mappings.map(function(mapping) {
          let source = null;
          if (mapping.source !== null) {
            source = this._sources.at(mapping.source);
            source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          }
          return {
            source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context);
      }
      _findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      }
      allGeneratedPositionsFor(aArgs) {
        const line = util.getArg(aArgs, "line");
        const needle = {
          source: util.getArg(aArgs, "source"),
          originalLine: line,
          originalColumn: util.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        if (needle.originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        const mappings = [];
        let index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index >= 0) {
          let mapping = this._originalMappings[index];
          if (aArgs.column === void 0) {
            const originalLine = mapping.originalLine;
            while (mapping && mapping.originalLine === originalLine) {
              let lastColumn = mapping.lastGeneratedColumn;
              if (this._computedColumnSpans && lastColumn === null) {
                lastColumn = Infinity;
              }
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn
              });
              mapping = this._originalMappings[++index];
            }
          } else {
            const originalColumn = mapping.originalColumn;
            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
              let lastColumn = mapping.lastGeneratedColumn;
              if (this._computedColumnSpans && lastColumn === null) {
                lastColumn = Infinity;
              }
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn
              });
              mapping = this._originalMappings[++index];
            }
          }
        }
        return mappings;
      }
      destroy() {
        for (let i = 0; i < this._sections.length; i++) {
          this._sections[i].consumer.destroy();
        }
      }
    };
    __name(IndexedSourceMapConsumer, "IndexedSourceMapConsumer");
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    function _factory(aSourceMap, aSourceMapURL) {
      let sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      const consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      return Promise.resolve(consumer);
    }
    __name(_factory, "_factory");
    function _factoryBSM(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    }
    __name(_factoryBSM, "_factoryBSM");
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/lib/source-node.js"(exports2) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util8();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    var SourceNode = class {
      constructor(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null)
          this.add(aChunks);
      }
      static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        const node = new SourceNode();
        const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        let remainingLinesIndex = 0;
        const shiftNextLine = /* @__PURE__ */ __name(function() {
          const lineContents = getNextLine();
          const newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
          __name(getNextLine, "getNextLine");
        }, "shiftNextLine");
        let lastGeneratedLine = 1, lastGeneratedColumn = 0;
        let lastMapping = null;
        let nextLine;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              nextLine = remainingLines[remainingLinesIndex] || "";
              const code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            nextLine = remainingLines[remainingLinesIndex] || "";
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          const content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node.add(code);
          } else {
            const source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
        __name(addMappingWithCode, "addMappingWithCode");
      }
      add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      }
      prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (let i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      }
      walk(aFn) {
        let chunk;
        for (let i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
      join(aSep) {
        let newChildren;
        let i;
        const len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      }
      replaceRight(aPattern, aReplacement) {
        const lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      }
      setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      }
      walkSourceContents(aFn) {
        for (let i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        const sources = Object.keys(this.sourceContents);
        for (let i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      }
      toString() {
        let str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      }
      toStringWithSourceMap(aArgs) {
        const generated = {
          code: "",
          line: 1,
          column: 0
        };
        const map = new SourceMapGenerator(aArgs);
        let sourceMappingActive = false;
        let lastOriginalSource = null;
        let lastOriginalLine = null;
        let lastOriginalColumn = null;
        let lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (let idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map };
      }
    };
    __name(SourceNode, "SourceNode");
    exports2.SourceNode = SourceNode;
  }
});

// node_modules/@datadog/pprof/node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/@datadog/pprof/node_modules/source-map/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/findit2/index.js
var require_findit2 = __commonJS({
  "node_modules/findit2/index.js"(exports2, module2) {
    var EventEmitter = __require("events").EventEmitter;
    var fs = __require("fs");
    var path = __require("path");
    module2.exports = findit;
    function findit(basedir, opts) {
      opts = opts || {};
      var followSymlinks = !!opts.followSymlinks;
      var myFs = opts.fs || fs;
      var emitter = new EventEmitter();
      var stopped = false;
      var pending = 0;
      var seen = {};
      emitter.stop = stop;
      walkPath(basedir);
      return emitter;
      function recursiveReadDir(basedir2, linkPath) {
        pendStart();
        myFs.readdir(basedir2, function(err, entries) {
          if (stopped)
            return;
          if (err) {
            handleError(err, basedir2);
            pendEnd();
            return;
          }
          entries.forEach(function(entry) {
            var fullPath = path.join(basedir2, entry);
            var fullLinkPath = linkPath && path.join(linkPath, entry);
            walkPath(fullPath, fullLinkPath);
          });
          pendEnd();
        });
      }
      __name(recursiveReadDir, "recursiveReadDir");
      function walkPath(fullPath, linkPath) {
        pendStart();
        myFs.lstat(fullPath, function(err, stats) {
          if (stopped)
            return;
          if (err) {
            handleError(err, fullPath);
            pendEnd();
            return;
          }
          emitter.emit("path", fullPath, stats, linkPath);
          var dirStopped = false;
          if (stats.isDirectory()) {
            if (seen[fullPath]) {
              err = new Error("file system loop detected");
              err.code = "ELOOP";
              handleError(err, fullPath);
              pendEnd();
              return;
            }
            seen[fullPath] = true;
            emitter.emit("directory", fullPath, stats, stopDir, linkPath);
            if (!dirStopped)
              recursiveReadDir(fullPath, linkPath);
          } else if (stats.isFile()) {
            if (!seen[fullPath]) {
              seen[fullPath] = true;
              emitter.emit("file", fullPath, stats, linkPath);
            }
          } else if (stats.isSymbolicLink()) {
            emitter.emit("link", fullPath, stats, linkPath);
            if (followSymlinks)
              recursiveReadLink(fullPath);
          }
          pendEnd();
          function stopDir() {
            dirStopped = true;
          }
          __name(stopDir, "stopDir");
        });
      }
      __name(walkPath, "walkPath");
      function recursiveReadLink(linkPath) {
        pendStart();
        myFs.readlink(linkPath, function(err, linkString) {
          if (stopped)
            return;
          if (err) {
            handleError(err, linkPath);
            pendEnd();
            return;
          }
          var fullPath = path.resolve(path.dirname(linkPath), linkString);
          emitter.emit("readlink", linkPath, fullPath);
          walkPath(fullPath, linkPath);
          pendEnd();
        });
      }
      __name(recursiveReadLink, "recursiveReadLink");
      function stop() {
        if (stopped)
          return;
        stopped = true;
        emitter.emit("stop");
      }
      __name(stop, "stop");
      function handleError(err, errPath) {
        if (!err || stopped)
          return;
        err.path = errPath;
        emitter.emit("error", err);
      }
      __name(handleError, "handleError");
      function pendStart() {
        pending += 1;
      }
      __name(pendStart, "pendStart");
      function pendEnd() {
        if (stopped)
          return;
        pending -= 1;
        if (pending === 0) {
          emitter.emit("end");
        } else if (pending < 0) {
          throw new Error("pendEnd called too many times");
        }
      }
      __name(pendEnd, "pendEnd");
    }
    __name(findit, "findit");
  }
});

// node_modules/through/index.js
var require_through = __commonJS({
  "node_modules/through/index.js"(exports2, module2) {
    var Stream = __require("stream");
    exports2 = module2.exports = through;
    through.through = through;
    function through(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      };
      end = end || function() {
        this.queue(null);
      };
      var ended = false, destroyed = false, buffer = [], _ended = false;
      var stream = new Stream();
      stream.readable = stream.writable = true;
      stream.paused = false;
      stream.autoDestroy = !(opts && opts.autoDestroy === false);
      stream.write = function(data) {
        write.call(this, data);
        return !stream.paused;
      };
      function drain() {
        while (buffer.length && !stream.paused) {
          var data = buffer.shift();
          if (null === data)
            return stream.emit("end");
          else
            stream.emit("data", data);
        }
      }
      __name(drain, "drain");
      stream.queue = stream.push = function(data) {
        if (_ended)
          return stream;
        if (data === null)
          _ended = true;
        buffer.push(data);
        drain();
        return stream;
      };
      stream.on("end", function() {
        stream.readable = false;
        if (!stream.writable && stream.autoDestroy)
          process.nextTick(function() {
            stream.destroy();
          });
      });
      function _end() {
        stream.writable = false;
        end.call(stream);
        if (!stream.readable && stream.autoDestroy)
          stream.destroy();
      }
      __name(_end, "_end");
      stream.end = function(data) {
        if (ended)
          return;
        ended = true;
        if (arguments.length)
          stream.write(data);
        _end();
        return stream;
      };
      stream.destroy = function() {
        if (destroyed)
          return;
        destroyed = true;
        ended = true;
        buffer.length = 0;
        stream.writable = stream.readable = false;
        stream.emit("close");
        return stream;
      };
      stream.pause = function() {
        if (stream.paused)
          return;
        stream.paused = true;
        return stream;
      };
      stream.resume = function() {
        if (stream.paused) {
          stream.paused = false;
          stream.emit("resume");
        }
        drain();
        if (!stream.paused)
          stream.emit("drain");
        return stream;
      };
      return stream;
    }
    __name(through, "through");
  }
});

// node_modules/split/index.js
var require_split = __commonJS({
  "node_modules/split/index.js"(exports2, module2) {
    var through = require_through();
    var Decoder = __require("string_decoder").StringDecoder;
    module2.exports = split;
    function split(matcher, mapper, options) {
      var decoder = new Decoder();
      var soFar = "";
      var maxLength = options && options.maxLength;
      var trailing = options && options.trailing === false ? false : true;
      if ("function" === typeof matcher)
        mapper = matcher, matcher = null;
      if (!matcher)
        matcher = /\r?\n/;
      function emit(stream, piece) {
        if (mapper) {
          try {
            piece = mapper(piece);
          } catch (err) {
            return stream.emit("error", err);
          }
          if ("undefined" !== typeof piece)
            stream.queue(piece);
        } else
          stream.queue(piece);
      }
      __name(emit, "emit");
      function next(stream, buffer) {
        var pieces = ((soFar != null ? soFar : "") + buffer).split(matcher);
        soFar = pieces.pop();
        if (maxLength && soFar.length > maxLength)
          return stream.emit("error", new Error("maximum buffer reached"));
        for (var i = 0; i < pieces.length; i++) {
          var piece = pieces[i];
          emit(stream, piece);
        }
      }
      __name(next, "next");
      return through(
        function(b) {
          next(this, decoder.write(b));
        },
        function() {
          if (decoder.end)
            next(this, decoder.end());
          if (trailing && soFar != null)
            emit(this, soFar);
          this.queue(null);
        }
      );
    }
    __name(split, "split");
  }
});

// node_modules/@datadog/pprof/out/third_party/cloud-debug-nodejs/src/agent/io/scanner.js
var require_scanner = __commonJS({
  "node_modules/@datadog/pprof/out/third_party/cloud-debug-nodejs/src/agent/io/scanner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scan = void 0;
    var crypto2 = __require("crypto");
    var fs = __require("fs");
    var path = __require("path");
    var findit = require_findit2();
    var split = require_split();
    var ScanResultsImpl = class {
      constructor(stats, errorMap, hash) {
        this.stats = stats;
        this.errorMap = errorMap;
        this.hash = hash;
      }
      errors() {
        return this.errorMap;
      }
      all() {
        return this.stats;
      }
      selectFiles(regex, baseDir) {
        baseDir = path.normalize(baseDir + path.sep);
        return Object.keys(this.stats).filter((file) => {
          return file && regex.test(file);
        }).map((file) => {
          return path.normalize(file).replace(baseDir, "");
        });
      }
    };
    __name(ScanResultsImpl, "ScanResultsImpl");
    async function scan(shouldHash, baseDir, regex) {
      const fileList = await findFiles(baseDir, regex);
      return computeStats(fileList, shouldHash);
    }
    __name(scan, "scan");
    exports2.scan = scan;
    function computeStats(fileList, shouldHash) {
      return new Promise(async (resolve) => {
        if (fileList.length === 0) {
          resolve(new ScanResultsImpl({}, /* @__PURE__ */ new Map(), "EMPTY-no-js-files"));
          return;
        }
        const hashes = [];
        const statistics = {};
        const errors = /* @__PURE__ */ new Map();
        for (const filename of fileList) {
          try {
            const fileStats = await statsForFile(filename, shouldHash);
            if (shouldHash) {
              hashes.push(fileStats.hash);
            }
            statistics[filename] = fileStats;
          } catch (err) {
            errors.set(filename, err);
          }
        }
        let hash;
        if (shouldHash) {
          const buffer = hashes.sort().join();
          const sha1 = crypto2.createHash("sha1").update(buffer).digest("hex");
          hash = "SHA1-" + sha1;
        }
        resolve(new ScanResultsImpl(statistics, errors, hash));
      });
    }
    __name(computeStats, "computeStats");
    function findFiles(baseDir, regex) {
      return new Promise((resolve, reject) => {
        let error;
        if (!baseDir) {
          reject(new Error("hasher.findJSFiles requires a baseDir argument"));
          return;
        }
        const find = findit(baseDir);
        const fileList = [];
        find.on("error", (err) => {
          error = err;
          return;
        });
        find.on("directory", (dir, ignore, stop) => {
          const base = path.basename(dir);
          if (base === ".git" || base === "node_modules") {
            stop();
          }
        });
        find.on("file", (file) => {
          if (regex.test(file)) {
            fileList.push(file);
          }
        });
        find.on("end", () => {
          if (error) {
            reject(error);
          } else {
            resolve(fileList);
          }
        });
      });
    }
    __name(findFiles, "findFiles");
    function statsForFile(filename, shouldHash) {
      return new Promise((resolve, reject) => {
        const reader = fs.createReadStream(filename);
        reader.on("error", (err) => {
          reject(err);
        });
        reader.on("open", () => {
          let shasum;
          if (shouldHash) {
            shasum = crypto2.createHash("sha1");
          }
          let lines = 0;
          let error;
          const byLine = reader.pipe(split());
          byLine.on("error", (e) => {
            error = e;
          });
          byLine.on("data", (d) => {
            if (shouldHash) {
              shasum.update(d);
            }
            lines++;
          });
          byLine.on("end", () => {
            if (error) {
              reject(error);
            } else {
              const hash = shouldHash ? shasum.digest("hex") : void 0;
              resolve({ hash, lines });
            }
          });
        });
      });
    }
    __name(statsForFile, "statsForFile");
  }
});

// node_modules/@datadog/pprof/node_modules/yocto-queue/index.js
var require_yocto_queue = __commonJS({
  "node_modules/@datadog/pprof/node_modules/yocto-queue/index.js"(exports2, module2) {
    var Node = class {
      constructor(value) {
        this.value = value;
        this.next = void 0;
      }
    };
    __name(Node, "Node");
    var Queue = class {
      constructor() {
        this.clear();
      }
      enqueue(value) {
        const node = new Node(value);
        if (this._head) {
          this._tail.next = node;
          this._tail = node;
        } else {
          this._head = node;
          this._tail = node;
        }
        this._size++;
      }
      dequeue() {
        const current = this._head;
        if (!current) {
          return;
        }
        this._head = this._head.next;
        this._size--;
        return current.value;
      }
      clear() {
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      get size() {
        return this._size;
      }
      *[Symbol.iterator]() {
        let current = this._head;
        while (current) {
          yield current.value;
          current = current.next;
        }
      }
    };
    __name(Queue, "Queue");
    module2.exports = Queue;
  }
});

// node_modules/@datadog/pprof/node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "node_modules/@datadog/pprof/node_modules/p-limit/index.js"(exports2, module2) {
    "use strict";
    var Queue = require_yocto_queue();
    var pLimit = /* @__PURE__ */ __name((concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      }
      const queue = new Queue();
      let activeCount = 0;
      const next = /* @__PURE__ */ __name(() => {
        activeCount--;
        if (queue.size > 0) {
          queue.dequeue()();
        }
      }, "next");
      const run = /* @__PURE__ */ __name(async (fn, resolve, ...args) => {
        activeCount++;
        const result = (async () => fn(...args))();
        resolve(result);
        try {
          await result;
        } catch {
        }
        next();
      }, "run");
      const enqueue = /* @__PURE__ */ __name((fn, resolve, ...args) => {
        queue.enqueue(run.bind(null, fn, resolve, ...args));
        (async () => {
          await Promise.resolve();
          if (activeCount < concurrency && queue.size > 0) {
            queue.dequeue()();
          }
        })();
      }, "enqueue");
      const generator = /* @__PURE__ */ __name((fn, ...args) => new Promise((resolve) => {
        enqueue(fn, resolve, ...args);
      }), "generator");
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.size
        },
        clearQueue: {
          value: () => {
            queue.clear();
          }
        }
      });
      return generator;
    }, "pLimit");
    module2.exports = pLimit;
  }
});

// node_modules/@datadog/pprof/out/src/sourcemapper/sourcemapper.js
var require_sourcemapper = __commonJS({
  "node_modules/@datadog/pprof/out/src/sourcemapper/sourcemapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SourceMapper = void 0;
    var fs = __require("fs");
    var path = __require("path");
    var desc = Object.getOwnPropertyDescriptor(globalThis, "fetch");
    delete globalThis.fetch;
    var sourceMap = require_source_map();
    if (desc) {
      Object.defineProperty(globalThis, "fetch", desc);
    }
    var scanner = require_scanner();
    var pify = require_pify();
    var pLimit = require_p_limit();
    var readFile = pify(fs.readFile);
    var CONCURRENCY = 10;
    var MAP_EXT = ".map";
    async function processSourceMap(infoMap, mapPath) {
      if (!mapPath || !mapPath.endsWith(MAP_EXT)) {
        throw new Error(`The path "${mapPath}" does not specify a source map file`);
      }
      mapPath = path.normalize(mapPath);
      let contents;
      try {
        contents = await readFile(mapPath, "utf8");
      } catch (e) {
        throw new Error("Could not read source map file " + mapPath + ": " + e);
      }
      let consumer;
      try {
        consumer = await new sourceMap.SourceMapConsumer(contents);
      } catch (e) {
        throw new Error("An error occurred while reading the sourceMap file " + mapPath + ": " + e);
      }
      const dir = path.dirname(mapPath);
      const generatedBase = consumer.file ? consumer.file : path.basename(mapPath, MAP_EXT);
      const generatedPath = path.resolve(dir, generatedBase);
      infoMap.set(generatedPath, { mapFileDir: dir, mapConsumer: consumer });
    }
    __name(processSourceMap, "processSourceMap");
    var SourceMapper = class {
      constructor() {
        this.infoMap = /* @__PURE__ */ new Map();
      }
      static async create(searchDirs) {
        const mapFiles = [];
        for (const dir of searchDirs) {
          try {
            const mf = await getMapFiles(dir);
            mf.forEach((mapFile) => {
              mapFiles.push(path.resolve(dir, mapFile));
            });
          } catch (e) {
            throw new Error(`failed to get source maps from ${dir}: ${e}`);
          }
        }
        return createFromMapFiles(mapFiles);
      }
      getMappingInfo(inputPath) {
        if (this.infoMap.has(path.normalize(inputPath))) {
          return this.infoMap.get(inputPath);
        }
        return null;
      }
      hasMappingInfo(inputPath) {
        return this.getMappingInfo(inputPath) !== null;
      }
      mappingInfo(location) {
        const inputPath = path.normalize(location.file);
        const entry = this.getMappingInfo(inputPath);
        if (entry === null) {
          return location;
        }
        const generatedPos = { line: location.line, column: location.column };
        const consumer = entry.mapConsumer;
        const pos = consumer.originalPositionFor(generatedPos);
        if (pos.source === null) {
          return location;
        }
        return {
          file: path.resolve(entry.mapFileDir, pos.source),
          line: pos.line || void 0,
          name: pos.name || location.name,
          column: pos.column || void 0
        };
      }
    };
    __name(SourceMapper, "SourceMapper");
    exports2.SourceMapper = SourceMapper;
    async function createFromMapFiles(mapFiles) {
      const limit = pLimit(CONCURRENCY);
      const mapper = new SourceMapper();
      const promises = mapFiles.map((mapPath) => limit(() => processSourceMap(mapper.infoMap, mapPath)));
      try {
        await Promise.all(promises);
      } catch (err) {
        throw new Error("An error occurred while processing the source map files" + err);
      }
      return mapper;
    }
    __name(createFromMapFiles, "createFromMapFiles");
    async function getMapFiles(baseDir) {
      const fileStats = await scanner.scan(false, baseDir, /.js.map$/);
      const mapFiles = fileStats.selectFiles(/.js.map$/, process.cwd());
      return mapFiles;
    }
    __name(getMapFiles, "getMapFiles");
  }
});

// node_modules/@datadog/pprof/out/src/index.js
var require_src49 = __commonJS({
  "node_modules/@datadog/pprof/out/src/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.heap = exports2.time = exports2.CpuProfiler = exports2.SourceMapper = exports2.encodeSync = exports2.encode = void 0;
    var fs_1 = __require("fs");
    var cpu_profiler_1 = require_cpu_profiler();
    var heapProfiler = require_heap_profiler();
    var profile_encoder_1 = require_profile_encoder();
    var timeProfiler = require_time_profiler();
    var profile_encoder_2 = require_profile_encoder();
    Object.defineProperty(exports2, "encode", { enumerable: true, get: function() {
      return profile_encoder_2.encode;
    } });
    Object.defineProperty(exports2, "encodeSync", { enumerable: true, get: function() {
      return profile_encoder_2.encodeSync;
    } });
    var sourcemapper_1 = require_sourcemapper();
    Object.defineProperty(exports2, "SourceMapper", { enumerable: true, get: function() {
      return sourcemapper_1.SourceMapper;
    } });
    exports2.CpuProfiler = cpu_profiler_1.default;
    exports2.time = {
      profile: timeProfiler.profile,
      start: timeProfiler.start
    };
    exports2.heap = {
      start: heapProfiler.start,
      stop: heapProfiler.stop,
      profile: heapProfiler.profile,
      v8Profile: heapProfiler.v8Profile
    };
    if (module2.parent && module2.parent.id === "internal/preload") {
      const stop = exports2.time.start();
      process.on("exit", () => {
        const profile = stop();
        const buffer = (0, profile_encoder_1.encodeSync)(profile);
        (0, fs_1.writeFileSync)(`pprof-profile-${process.pid}.pb.gz`, buffer);
      });
    }
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/cpu.js
var require_cpu = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/cpu.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var dc = __require("diagnostics_channel");
    var beforeCh = dc.channel("dd-trace:storage:before");
    var afterCh = dc.channel("dd-trace:storage:after");
    function getActiveSpan() {
      const store = storage.getStore();
      if (!store)
        return;
      return store.span;
    }
    __name(getActiveSpan, "getActiveSpan");
    function getStartedSpans(activeSpan) {
      const context = activeSpan.context();
      if (!context)
        return;
      return context._trace.started;
    }
    __name(getStartedSpans, "getStartedSpans");
    function getSpanContextTags(span) {
      return span.context()._tags;
    }
    __name(getSpanContextTags, "getSpanContextTags");
    function isWebServerSpan(tags) {
      return tags["span.type"] === "web";
    }
    __name(isWebServerSpan, "isWebServerSpan");
    function endpointNameFromTags(tags) {
      return tags["resource.name"] || [
        tags["http.method"],
        tags["http.route"]
      ].filter((v) => v).join(" ");
    }
    __name(endpointNameFromTags, "endpointNameFromTags");
    var NativeCpuProfiler = class {
      constructor(options = {}) {
        this.type = "cpu";
        this._frequency = options.frequency || 99;
        this._mapper = void 0;
        this._pprof = void 0;
        this._started = false;
        this._cpuProfiler = void 0;
        this._endpointCollection = options.endpointCollection;
        this._enter = this._enter.bind(this);
        this._exit = this._exit.bind(this);
      }
      _enter() {
        if (!this._cpuProfiler)
          return;
        const active = getActiveSpan();
        if (!active)
          return;
        const activeCtx = active.context();
        if (!activeCtx)
          return;
        const spans = getStartedSpans(active);
        if (!spans || !spans.length)
          return;
        const firstCtx = spans[0].context();
        if (!firstCtx)
          return;
        const labels = {
          "local root span id": firstCtx.toSpanId(),
          "span id": activeCtx.toSpanId()
        };
        if (this._endpointCollection) {
          const webServerTags = spans.map(getSpanContextTags).filter(isWebServerSpan)[0];
          if (webServerTags) {
            labels["trace endpoint"] = endpointNameFromTags(webServerTags);
          }
        }
        this._cpuProfiler.labels = labels;
      }
      _exit() {
        if (!this._cpuProfiler)
          return;
        this._cpuProfiler.labels = {};
      }
      start({ mapper } = {}) {
        if (this._started)
          return;
        this._started = true;
        this._mapper = mapper;
        if (!this._pprof) {
          this._pprof = require_src49();
          this._cpuProfiler = new this._pprof.CpuProfiler();
        }
        this._cpuProfiler.start(this._frequency);
        this._enter();
        beforeCh.subscribe(this._enter);
        afterCh.subscribe(this._exit);
      }
      profile() {
        if (!this._started)
          return;
        return this._cpuProfiler.profile();
      }
      encode(profile) {
        return this._pprof.encode(profile);
      }
      stop() {
        if (!this._started)
          return;
        this._started = false;
        this._cpuProfiler.stop();
        beforeCh.unsubscribe(this._enter);
        afterCh.unsubscribe(this._exit);
      }
    };
    __name(NativeCpuProfiler, "NativeCpuProfiler");
    module2.exports = NativeCpuProfiler;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/wall.js
var require_wall = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/wall.js"(exports2, module2) {
    "use strict";
    var NativeWallProfiler = class {
      constructor(options = {}) {
        this.type = "wall";
        this._samplingInterval = options.samplingInterval || 1e6 / 99;
        this._mapper = void 0;
        this._pprof = void 0;
      }
      start({ mapper } = {}) {
        this._mapper = mapper;
        this._pprof = require_src49();
        if (!process._startProfilerIdleNotifier) {
          process._startProfilerIdleNotifier = () => {
          };
        }
        if (!process._stopProfilerIdleNotifier) {
          process._stopProfilerIdleNotifier = () => {
          };
        }
        this._record();
      }
      profile() {
        if (!this._stop)
          return;
        return this._stop(true);
      }
      encode(profile) {
        return this._pprof.encode(profile);
      }
      stop() {
        if (!this._stop)
          return;
        this._stop();
      }
      _record() {
        this._stop = this._pprof.time.start(
          this._samplingInterval,
          null,
          this._mapper,
          false
        );
      }
    };
    __name(NativeWallProfiler, "NativeWallProfiler");
    module2.exports = NativeWallProfiler;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/space.js
var require_space = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiling/profilers/space.js"(exports2, module2) {
    "use strict";
    var NativeSpaceProfiler = class {
      constructor(options = {}) {
        this.type = "space";
        this._samplingInterval = options.samplingInterval || 512 * 1024;
        this._stackDepth = options.stackDepth || 64;
        this._pprof = void 0;
      }
      start({ mapper } = {}) {
        this._mapper = mapper;
        this._pprof = require_src49();
        this._pprof.heap.start(this._samplingInterval, this._stackDepth);
      }
      profile() {
        return this._pprof.heap.profile(void 0, this._mapper);
      }
      encode(profile) {
        return this._pprof.encode(profile);
      }
      stop() {
        this._pprof.heap.stop();
      }
    };
    __name(NativeSpaceProfiler, "NativeSpaceProfiler");
    module2.exports = NativeSpaceProfiler;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js
var require_tagger2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiling/tagger.js"(exports2, module2) {
    "use strict";
    var tagger = {
      parse(tags) {
        if (!tags)
          return {};
        switch (typeof tags) {
          case "object":
            if (Array.isArray(tags)) {
              return tags.reduce((prev, next) => {
                const parts = next.split(":");
                const key = parts.shift().trim();
                const value = parts.join(":").trim();
                if (!key || !value)
                  return prev;
                return Object.assign(prev, { [key]: value });
              }, {});
            } else {
              return tagger.parse(Object.keys(tags).filter((key) => tags[key] !== void 0 && tags[key] !== null).map((key) => `${key}:${tags[key]}`));
            }
          case "string":
            return tagger.parse(tags.split(","));
          default:
            return {};
        }
      }
    };
    module2.exports = { tagger };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiling/config.js
var require_config2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiling/config.js"(exports2, module2) {
    "use strict";
    var coalesce = require_koalas();
    var os = __require("os");
    var { URL: URL2, format } = __require("url");
    var { AgentExporter } = require_agent2();
    var { FileExporter } = require_file();
    var { ConsoleLogger } = require_console();
    var CpuProfiler = require_cpu();
    var WallProfiler = require_wall();
    var SpaceProfiler = require_space();
    var { tagger } = require_tagger2();
    var {
      DD_PROFILING_ENABLED,
      DD_PROFILING_PROFILERS,
      DD_PROFILING_ENDPOINT_COLLECTION_ENABLED,
      DD_ENV,
      DD_TAGS,
      DD_SERVICE,
      DD_VERSION,
      DD_TRACE_AGENT_URL,
      DD_AGENT_HOST,
      DD_TRACE_AGENT_PORT,
      DD_PROFILING_UPLOAD_TIMEOUT,
      DD_PROFILING_SOURCE_MAP
    } = process.env;
    var Config = class {
      constructor(options = {}) {
        const enabled = coalesce(options.enabled, DD_PROFILING_ENABLED, true);
        const env = coalesce(options.env, DD_ENV);
        const service = options.service || DD_SERVICE || "node";
        const host = os.hostname();
        const version = coalesce(options.version, DD_VERSION);
        const functionname = process.env.AWS_LAMBDA_FUNCTION_NAME;
        const flushInterval = coalesce(options.interval, 65 * 1e3);
        const uploadTimeout = coalesce(
          options.uploadTimeout,
          DD_PROFILING_UPLOAD_TIMEOUT,
          60 * 1e3
        );
        const sourceMap = coalesce(
          options.sourceMap,
          DD_PROFILING_SOURCE_MAP,
          true
        );
        const endpointCollection = coalesce(
          options.endpointCollection,
          DD_PROFILING_ENDPOINT_COLLECTION_ENABLED,
          false
        );
        this.enabled = String(enabled) !== "false";
        this.service = service;
        this.env = env;
        this.host = host;
        this.functionname = functionname;
        this.version = version;
        this.tags = Object.assign(
          tagger.parse(DD_TAGS),
          tagger.parse(options.tags),
          tagger.parse({ env, host, service, version, functionname })
        );
        this.logger = ensureLogger(options.logger);
        this.flushInterval = flushInterval;
        this.uploadTimeout = uploadTimeout;
        this.sourceMap = sourceMap;
        this.endpointCollection = endpointCollection;
        const hostname = coalesce(options.hostname, DD_AGENT_HOST) || "localhost";
        const port = coalesce(options.port, DD_TRACE_AGENT_PORT) || 8126;
        this.url = new URL2(coalesce(options.url, DD_TRACE_AGENT_URL, format({
          protocol: "http:",
          hostname,
          port
        })));
        this.exporters = ensureExporters(options.exporters || [
          new AgentExporter(this)
        ], this);
        const profilers = coalesce(options.profilers, DD_PROFILING_PROFILERS, [
          new WallProfiler(this),
          new SpaceProfiler(this)
        ]);
        this.profilers = ensureProfilers(profilers, this);
      }
    };
    __name(Config, "Config");
    module2.exports = { Config };
    function getExporter(name, options) {
      switch (name) {
        case "agent":
          return new AgentExporter(options);
        case "file":
          return new FileExporter(options);
      }
    }
    __name(getExporter, "getExporter");
    function ensureExporters(exporters, options) {
      if (typeof exporters === "string") {
        exporters = exporters.split(",");
      }
      for (let i = 0; i < exporters.length; i++) {
        const exporter = exporters[i];
        if (typeof exporter === "string") {
          exporters[i] = getExporter(exporter, options);
        }
      }
      return exporters;
    }
    __name(ensureExporters, "ensureExporters");
    function getProfiler(name, options) {
      switch (name) {
        case "cpu":
        case "wall":
          return new WallProfiler(options);
        case "space":
          return new SpaceProfiler(options);
        case "cpu-experimental":
          return new CpuProfiler(options);
        default:
          options.logger.error(`Unknown profiler "${name}"`);
      }
    }
    __name(getProfiler, "getProfiler");
    function ensureProfilers(profilers, options) {
      if (typeof profilers === "string") {
        profilers = profilers.split(",");
      }
      for (let i = 0; i < profilers.length; i++) {
        const profiler = profilers[i];
        if (typeof profiler === "string") {
          profilers[i] = getProfiler(profiler, options);
        }
      }
      return profilers.filter((v) => v);
    }
    __name(ensureProfilers, "ensureProfilers");
    function ensureLogger(logger) {
      if (typeof logger !== "object" || typeof logger.debug !== "function" || typeof logger.info !== "function" || typeof logger.warn !== "function" || typeof logger.error !== "function") {
        return new ConsoleLogger();
      }
      return logger;
    }
    __name(ensureLogger, "ensureLogger");
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js
var require_profiler = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = __require("events");
    var { Config } = require_config2();
    function maybeSourceMap(sourceMap) {
      if (!sourceMap)
        return;
      const { SourceMapper } = require_src49();
      return SourceMapper.create([
        process.cwd()
      ]);
    }
    __name(maybeSourceMap, "maybeSourceMap");
    var Profiler = class extends EventEmitter {
      constructor() {
        super();
        this._enabled = false;
        this._logger = void 0;
        this._config = void 0;
        this._timer = void 0;
        this._lastStart = void 0;
        this._timeoutInterval = void 0;
      }
      start(options) {
        this._start(options).catch(() => {
        });
        return this;
      }
      async _start(options) {
        if (this._enabled)
          return;
        const config = this._config = new Config(options);
        if (!config.enabled)
          return;
        this._logger = config.logger;
        this._enabled = true;
        this._setInterval();
        let mapper;
        try {
          mapper = await maybeSourceMap(config.sourceMap);
        } catch (err) {
          this._logger.error(err);
        }
        try {
          for (const profiler of config.profilers) {
            profiler.start({ mapper });
            this._logger.debug(`Started ${profiler.type} profiler`);
          }
          this._capture(this._timeoutInterval);
        } catch (e) {
          this._logger.error(e);
          this.stop();
        }
      }
      _setInterval() {
        this._timeoutInterval = this._config.flushInterval;
      }
      stop() {
        if (!this._enabled)
          return;
        this._enabled = false;
        for (const profiler of this._config.profilers) {
          profiler.stop();
          this._logger.debug(`Stopped ${profiler.type} profiler`);
        }
        clearTimeout(this._timer);
        this._timer = void 0;
        return this;
      }
      _capture(timeout) {
        if (!this._enabled)
          return;
        this._lastStart = new Date();
        if (!this._timer || timeout !== this._timeoutInterval) {
          this._timer = setTimeout(() => this._collect(), timeout);
          this._timer.unref();
        } else {
          this._timer.refresh();
        }
      }
      async _collect() {
        const start = this._lastStart;
        const end = new Date();
        const profiles = {};
        try {
          for (const profiler of this._config.profilers) {
            const profile = profiler.profile();
            if (!profile)
              continue;
            profiles[profiler.type] = await profiler.encode(profile);
            this._logger.debug(() => {
              const profileJson = JSON.stringify(profile, (key, value) => {
                return typeof value === "bigint" ? value.toString() : value;
              });
              return `Collected ${profiler.type} profile: ` + profileJson;
            });
          }
          this._capture(this._timeoutInterval);
          await this._submit(profiles, start, end);
          this._logger.debug("Submitted profiles");
        } catch (err) {
          this._logger.error(err);
          this.stop();
        }
      }
      _submit(profiles, start, end) {
        if (!Object.keys(profiles).length) {
          return Promise.reject(new Error("No profiles to submit"));
        }
        const { tags } = this._config;
        const tasks = [];
        for (const exporter of this._config.exporters) {
          const task = exporter.export({ profiles, start, end, tags }).catch((err) => this._logger.error(err));
          tasks.push(task);
        }
        return Promise.all(tasks);
      }
    };
    __name(Profiler, "Profiler");
    var ServerlessProfiler = class extends Profiler {
      constructor() {
        super();
        this._profiledIntervals = 0;
        this._interval = 1;
        this._flushAfterIntervals = void 0;
      }
      _setInterval() {
        this._timeoutInterval = this._interval * 1e3;
        this._flushAfterIntervals = this._config.flushInterval / 1e3;
      }
      async _collect() {
        if (this._profiledIntervals >= this._flushAfterIntervals) {
          this._profiledIntervals = 0;
          await super._collect();
        } else {
          this._profiledIntervals += 1;
          this._capture(this._timeoutInterval);
        }
      }
    };
    __name(ServerlessProfiler, "ServerlessProfiler");
    module2.exports = { Profiler, ServerlessProfiler };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiling/index.js
var require_profiling = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiling/index.js"(exports2, module2) {
    "use strict";
    var { Profiler, ServerlessProfiler } = require_profiler();
    var CpuProfiler = require_cpu();
    var WallProfiler = require_wall();
    var SpaceProfiler = require_space();
    var { AgentExporter } = require_agent2();
    var { FileExporter } = require_file();
    var { ConsoleLogger } = require_console();
    var profiler = process.env.AWS_LAMBDA_FUNCTION_NAME ? new ServerlessProfiler() : new Profiler();
    module2.exports = {
      profiler,
      AgentExporter,
      FileExporter,
      CpuProfiler,
      WallProfiler,
      SpaceProfiler,
      ConsoleLogger
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/profiler.js
var require_profiler2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/profiler.js"(exports2, module2) {
    "use strict";
    var log = require_log();
    var { profiler } = require_profiling();
    module2.exports = {
      start: (config) => {
        const { service, version, env, url, hostname, port, tags } = config;
        const { enabled, sourceMap, exporters } = config.profiling;
        const logger = {
          debug: (message) => log.debug(message),
          info: (message) => log.info(message),
          warn: (message) => log.warn(message),
          error: (message) => log.error(message)
        };
        profiler.start({
          enabled,
          service,
          version,
          env,
          logger,
          sourceMap,
          exporters,
          url,
          hostname,
          port,
          tags
        });
      },
      stop: () => {
        profiler.stop();
      }
    };
  }
});

// node_modules/dd-trace/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/dd-trace/node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : /* @__PURE__ */ __name(class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort(reason = new Error("This operation was aborted")) {
        this.signal.reason = reason;
        this.signal.dispatchEvent({
          type: "abort",
          target: this.signal
        });
      }
    }, "AbortController");
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : /* @__PURE__ */ __name(class AbortSignal {
      constructor() {
        this.reason = void 0;
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(e) {
        if (e.type === "abort") {
          this.aborted = true;
          this.onabort(e);
          this._listeners.forEach((f) => f(e), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    }, "AbortSignal");
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = /* @__PURE__ */ __name((opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn(code, `${opt} option`, `options.${instead}`, LRUCache);
      }
    }, "deprecatedOption");
    var deprecatedMethod = /* @__PURE__ */ __name((method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
      }
    }, "deprecatedMethod");
    var deprecatedProperty = /* @__PURE__ */ __name((field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
      }
    }, "deprecatedProperty");
    var emitWarning = /* @__PURE__ */ __name((...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    }, "emitWarning");
    var shouldWarn = /* @__PURE__ */ __name((code) => !warned.has(code), "shouldWarn");
    var warn = /* @__PURE__ */ __name((code, what, instead, fn) => {
      warned.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code, fn);
    }, "warn");
    var isPosInt = /* @__PURE__ */ __name((n) => n && n === Math.floor(n) && n > 0 && isFinite(n), "isPosInt");
    var getUintArray = /* @__PURE__ */ __name((max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null, "getUintArray");
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    __name(ZeroArray, "ZeroArray");
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    __name(Stack, "Stack");
    var LRUCache = class {
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          maxEntrySize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort
        } = options;
        const { length, maxAge, stale } = options instanceof LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize && !this.maxEntrySize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize or maxEntrySize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.maxSize !== 0) {
            if (!isPosInt(this.maxSize)) {
              throw new TypeError(
                "maxSize must be a positive integer if specified"
              );
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError(
              "maxEntrySize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = /* @__PURE__ */ __name(() => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        }, "getNow");
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(_index) {
      }
      setItemTTL(_index, _ttl, _start) {
      }
      isStale(_index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (this.isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set."
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, size) => {
          this.sizes[index] = size;
          if (this.maxSize) {
            const maxSize = this.maxSize - this.sizes[index];
            while (this.calculatedSize > maxSize) {
              this.evict(true);
            }
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(_index) {
      }
      addItemSize(_index, _size) {
      }
      requireSize(_k, _v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize or maxEntrySize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          if (!this.isBackgroundFetch(this.valList[i])) {
            yield [this.keyList[i], this.valList[i]];
          }
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          if (!this.isBackgroundFetch(this.valList[i])) {
            yield [this.keyList[i], this.valList[i]];
          }
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          if (!this.isBackgroundFetch(this.valList[i])) {
            yield this.keyList[i];
          }
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          if (!this.isBackgroundFetch(this.valList[i])) {
            yield this.keyList[i];
          }
        }
      }
      *values() {
        for (const i of this.indexes()) {
          if (!this.isBackgroundFetch(this.valList[i])) {
            yield this.valList[i];
          }
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          if (!this.isBackgroundFetch(this.valList[i])) {
            yield this.valList[i];
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of this.indexes()) {
          if (fn(this.valList[i], this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes({ allowStale: true })) {
          const key = this.keyList[i];
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
            const age = perf.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(_v, _k, _reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          this.delete(k);
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size);
          noUpdateTTL = false;
        } else {
          this.moveToTail(index);
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, size);
          }
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v = this.valList[index];
          return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
      }
      backgroundFetch(k, index, options, context) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        if (options.signal) {
          options.signal.addEventListener(
            "abort",
            () => ac.abort(options.signal.reason)
          );
        }
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = /* @__PURE__ */ __name((v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (aborted && !ignoreAbort && !updateCache) {
            return eb(ac.signal.reason);
          }
          if (this.valList[index] === p) {
            if (v2 === void 0) {
              if (p.__staleWhileFetching) {
                this.valList[index] = p.__staleWhileFetching;
              } else {
                this.delete(k);
              }
            } else {
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        }, "cb");
        const eb = /* @__PURE__ */ __name((er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          if (this.valList[index] === p) {
            const del = !noDelete || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else if (!allowStaleAborted) {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (allowStale) {
            return p.__staleWhileFetching;
          } else if (p.__returned === p) {
            throw er;
          }
        }, "eb");
        const pcall = /* @__PURE__ */ __name((res, rej) => {
          this.fetchMethod(k, v, fetchOpts).then((v2) => res(v2), rej);
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res();
              if (options.allowStaleOnFetchAbort) {
                res = /* @__PURE__ */ __name((v2) => cb(v2, true), "res");
              }
            }
          });
        }, "pcall");
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      async fetch(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        fetchContext = this.fetchContext,
        forceRefresh = false,
        signal
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          signal
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return p.__returned = p;
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v.__returned = v;
          }
          if (!forceRefresh && !this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v;
          }
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    __name(LRUCache, "LRUCache");
    module2.exports = LRUCache;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerability-reporter.js
var require_vulnerability_reporter = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerability-reporter.js"(exports2, module2) {
    var { MANUAL_KEEP } = require_tags();
    var LRU = require_lru_cache();
    var VULNERABILITIES_KEY = "vulnerabilities";
    var IAST_JSON_TAG_KEY = "_dd.iast.json";
    var VULNERABILITY_HASHES_MAX_SIZE = 1e3;
    var VULNERABILITY_HASHES = new LRU({ max: VULNERABILITY_HASHES_MAX_SIZE });
    var tracer2;
    function createVulnerability(type, evidence, spanId, location) {
      if (type && evidence) {
        const _spanId = spanId || 0;
        return {
          type,
          evidence,
          location: {
            spanId: _spanId,
            ...location
          },
          hash: createHash(type, location)
        };
      }
      return null;
    }
    __name(createVulnerability, "createVulnerability");
    function createHash(type, location) {
      let hashSource;
      if (location) {
        hashSource = `${type}:${location.path}:${location.line}`;
      } else {
        hashSource = type;
      }
      let hash = 0;
      let offset = 0;
      const size = hashSource.length;
      for (let i = 0; i < size; i++) {
        hash = (hash << 5) - hash + hashSource.charCodeAt(offset++);
      }
      return hash;
    }
    __name(createHash, "createHash");
    function addVulnerability(iastContext, vulnerability) {
      if (vulnerability && vulnerability.evidence && vulnerability.type && vulnerability.location) {
        if (iastContext && iastContext.rootSpan) {
          iastContext[VULNERABILITIES_KEY] = iastContext[VULNERABILITIES_KEY] || [];
          iastContext[VULNERABILITIES_KEY].push(vulnerability);
        } else {
          sendVulnerabilities([vulnerability]);
        }
      }
    }
    __name(addVulnerability, "addVulnerability");
    function isValidVulnerability(vulnerability) {
      return vulnerability && vulnerability.type && vulnerability.evidence && vulnerability.evidence.value && vulnerability.location && vulnerability.location.spanId;
    }
    __name(isValidVulnerability, "isValidVulnerability");
    function formatEvidence(evidence, sourcesIndexes) {
      if (!evidence.ranges) {
        return { value: evidence.value };
      }
      const valueParts = [];
      let fromIndex = 0;
      evidence.ranges.forEach((range, rangeIndex) => {
        if (fromIndex < range.start) {
          valueParts.push({ value: evidence.value.substring(fromIndex, range.start) });
        }
        valueParts.push({ value: evidence.value.substring(range.start, range.end), source: sourcesIndexes[rangeIndex] });
        fromIndex = range.end;
      });
      if (fromIndex < evidence.value.length) {
        valueParts.push({ value: evidence.value.substring(fromIndex) });
      }
      return { valueParts };
    }
    __name(formatEvidence, "formatEvidence");
    function extractSourcesFromVulnerability(vulnerability) {
      if (!vulnerability.evidence.ranges) {
        return [];
      }
      return vulnerability.evidence.ranges.map((range) => ({
        origin: range.iinfo.type,
        name: range.iinfo.parameterName,
        value: range.iinfo.parameterValue
      }));
    }
    __name(extractSourcesFromVulnerability, "extractSourcesFromVulnerability");
    function jsonVulnerabilityFromVulnerability(vulnerability, sourcesIndexes) {
      const jsonVulnerability = {
        type: vulnerability.type,
        hash: vulnerability.hash,
        evidence: formatEvidence(vulnerability.evidence, sourcesIndexes),
        location: {
          spanId: vulnerability.location.spanId
        }
      };
      if (vulnerability.location.path) {
        jsonVulnerability.location.path = vulnerability.location.path;
      }
      if (vulnerability.location.line) {
        jsonVulnerability.location.line = vulnerability.location.line;
      }
      return jsonVulnerability;
    }
    __name(jsonVulnerabilityFromVulnerability, "jsonVulnerabilityFromVulnerability");
    function sendVulnerabilities(vulnerabilities, rootSpan) {
      if (vulnerabilities && vulnerabilities.length) {
        let span = rootSpan;
        if (!span && tracer2) {
          span = tracer2.startSpan("vulnerability", {
            type: "vulnerability"
          });
          vulnerabilities.forEach((vulnerability) => {
            vulnerability.location.spanId = span.context().toSpanId();
          });
        }
        if (span && span.addTags) {
          const jsonToSend = {
            sources: [],
            vulnerabilities: []
          };
          deduplicateVulnerabilities(vulnerabilities).forEach((vulnerability) => {
            if (isValidVulnerability(vulnerability)) {
              const sourcesIndexes = [];
              const vulnerabilitySources = extractSourcesFromVulnerability(vulnerability);
              vulnerabilitySources.forEach((source) => {
                let sourceIndex = jsonToSend.sources.findIndex(
                  (existingSource) => existingSource.origin === source.origin && existingSource.name === source.name && existingSource.value === source.value
                );
                if (sourceIndex === -1) {
                  sourceIndex = jsonToSend.sources.length;
                  jsonToSend.sources.push(source);
                }
                sourcesIndexes.push(sourceIndex);
              });
              jsonToSend.vulnerabilities.push(jsonVulnerabilityFromVulnerability(vulnerability, sourcesIndexes));
            }
          });
          if (jsonToSend.vulnerabilities.length > 0) {
            const tags = {};
            tags[IAST_JSON_TAG_KEY] = JSON.stringify(jsonToSend);
            tags[MANUAL_KEEP] = "true";
            span.addTags(tags);
            if (!rootSpan)
              span.finish();
          }
        }
      }
      return IAST_JSON_TAG_KEY;
    }
    __name(sendVulnerabilities, "sendVulnerabilities");
    function clearCache() {
      VULNERABILITY_HASHES.clear();
    }
    __name(clearCache, "clearCache");
    function deduplicateVulnerabilities(vulnerabilities) {
      const deduplicated = vulnerabilities.filter((vulnerability) => {
        const key = `${vulnerability.type}${vulnerability.hash}`;
        if (!VULNERABILITY_HASHES.get(key)) {
          VULNERABILITY_HASHES.set(key, true);
          return true;
        }
        return false;
      });
      return deduplicated;
    }
    __name(deduplicateVulnerabilities, "deduplicateVulnerabilities");
    function setTracer(_tracer) {
      tracer2 = _tracer;
    }
    __name(setTracer, "setTracer");
    module2.exports = {
      createVulnerability,
      addVulnerability,
      sendVulnerabilities,
      clearCache,
      setTracer
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/path-line.js
var require_path_line = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/path-line.js"(exports2, module2) {
    var path = __require("path");
    var process2 = __require("process");
    var pathLine = {
      getFirstNonDDPathAndLine,
      getFirstNonDDPathAndLineFromCallsites,
      calculateDDBasePath,
      ddBasePath: calculateDDBasePath(__dirname)
    };
    var EXCLUDED_PATHS = [
      path.join(path.sep, "node_modules", "diagnostics_channel")
    ];
    var EXCLUDED_PATH_PREFIXES = [
      "node:diagnostics_channel",
      "diagnostics_channel",
      "node:child_process",
      "child_process",
      "node:async_hooks",
      "async_hooks"
    ];
    function calculateDDBasePath(dirname) {
      const dirSteps = dirname.split(path.sep);
      const packagesIndex = dirSteps.lastIndexOf("packages");
      return dirSteps.slice(0, packagesIndex).join(path.sep) + path.sep;
    }
    __name(calculateDDBasePath, "calculateDDBasePath");
    function getCallSiteInfo() {
      const previousPrepareStackTrace = Error.prepareStackTrace;
      const previousStackTraceLimit = Error.stackTraceLimit;
      let callsiteList;
      Error.stackTraceLimit = 100;
      Error.prepareStackTrace = function(_, callsites) {
        callsiteList = callsites;
      };
      const e = new Error();
      e.stack;
      Error.prepareStackTrace = previousPrepareStackTrace;
      Error.stackTraceLimit = previousStackTraceLimit;
      return callsiteList;
    }
    __name(getCallSiteInfo, "getCallSiteInfo");
    function getFirstNonDDPathAndLineFromCallsites(callsites) {
      if (callsites) {
        for (let i = 0; i < callsites.length; i++) {
          const callsite = callsites[i];
          const filepath = callsite.getFileName();
          if (!isExcluded(callsite) && filepath.indexOf(pathLine.ddBasePath) === -1) {
            return {
              path: path.relative(process2.cwd(), filepath),
              line: callsite.getLineNumber()
            };
          }
        }
      }
      return null;
    }
    __name(getFirstNonDDPathAndLineFromCallsites, "getFirstNonDDPathAndLineFromCallsites");
    function isExcluded(callsite) {
      if (callsite.isNative())
        return true;
      const filename = callsite.getFileName();
      if (!filename) {
        return true;
      }
      for (let i = 0; i < EXCLUDED_PATHS.length; i++) {
        if (filename.indexOf(EXCLUDED_PATHS[i]) > -1) {
          return true;
        }
      }
      for (let i = 0; i < EXCLUDED_PATH_PREFIXES.length; i++) {
        if (filename.indexOf(EXCLUDED_PATH_PREFIXES[i]) === 0) {
          return true;
        }
      }
      return false;
    }
    __name(isExcluded, "isExcluded");
    function getFirstNonDDPathAndLine() {
      return getFirstNonDDPathAndLineFromCallsites(getCallSiteInfo());
    }
    __name(getFirstNonDDPathAndLine, "getFirstNonDDPathAndLine");
    module2.exports = pathLine;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/iast-context.js
var require_iast_context = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/iast-context.js"(exports2, module2) {
    var IAST_CONTEXT_KEY = Symbol("_dd.iast.context");
    var IAST_TRANSACTION_ID = Symbol("_dd.iast.transactionId");
    function getIastContext(store) {
      return store && store[IAST_CONTEXT_KEY];
    }
    __name(getIastContext, "getIastContext");
    function saveIastContext(store, topContext, context) {
      if (store && topContext) {
        store[IAST_CONTEXT_KEY] = context;
        topContext[IAST_CONTEXT_KEY] = context;
        return store[IAST_CONTEXT_KEY];
      }
    }
    __name(saveIastContext, "saveIastContext");
    function cleanIastContext(store, context, iastContext) {
      if (store) {
        if (!iastContext) {
          iastContext = store[IAST_CONTEXT_KEY];
        }
        store[IAST_CONTEXT_KEY] = null;
      }
      if (context) {
        if (!iastContext) {
          iastContext = context[IAST_CONTEXT_KEY];
        }
        context[IAST_CONTEXT_KEY] = null;
      }
      if (iastContext) {
        Object.keys(iastContext).forEach((key) => delete iastContext[key]);
        return true;
      }
      return false;
    }
    __name(cleanIastContext, "cleanIastContext");
    module2.exports = {
      getIastContext,
      saveIastContext,
      cleanIastContext,
      IAST_CONTEXT_KEY,
      IAST_TRANSACTION_ID
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/overhead-controller.js
var require_overhead_controller = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/overhead-controller.js"(exports2, module2) {
    "use strict";
    var OVERHEAD_CONTROLLER_CONTEXT_KEY = "oce";
    var REPORT_VULNERABILITY = "REPORT_VULNERABILITY";
    var INTERVAL_RESET_GLOBAL_CONTEXT = 60 * 1e3;
    var GLOBAL_OCE_CONTEXT = {};
    var resetGlobalContextInterval;
    var config = {};
    var availableRequest = 0;
    var OPERATIONS = {
      REPORT_VULNERABILITY: {
        hasQuota: (context) => {
          const reserved = context && context.tokens && context.tokens[REPORT_VULNERABILITY] > 0;
          if (reserved) {
            context.tokens[REPORT_VULNERABILITY]--;
          }
          return reserved;
        },
        name: REPORT_VULNERABILITY,
        initialTokenBucketSize() {
          return typeof config.maxContextOperations === "number" ? config.maxContextOperations : 2;
        },
        initContext: function(context) {
          context.tokens[REPORT_VULNERABILITY] = this.initialTokenBucketSize();
        }
      }
    };
    function _getNewContext() {
      const oceContext = {
        tokens: {}
      };
      for (const operation in OPERATIONS) {
        OPERATIONS[operation].initContext(oceContext);
      }
      return oceContext;
    }
    __name(_getNewContext, "_getNewContext");
    function _getContext(iastContext) {
      if (iastContext && iastContext[OVERHEAD_CONTROLLER_CONTEXT_KEY]) {
        return iastContext[OVERHEAD_CONTROLLER_CONTEXT_KEY];
      }
      return GLOBAL_OCE_CONTEXT;
    }
    __name(_getContext, "_getContext");
    function _resetGlobalContext() {
      Object.assign(GLOBAL_OCE_CONTEXT, _getNewContext());
    }
    __name(_resetGlobalContext, "_resetGlobalContext");
    function acquireRequest(rootSpan) {
      if (availableRequest > 0) {
        const sampling = config && typeof config.requestSampling === "number" ? config.requestSampling : 30;
        if (rootSpan.context().toSpanId().slice(-2) <= sampling) {
          availableRequest--;
          return true;
        }
      }
      return false;
    }
    __name(acquireRequest, "acquireRequest");
    function releaseRequest() {
      if (availableRequest < config.maxConcurrentRequests) {
        availableRequest++;
      }
    }
    __name(releaseRequest, "releaseRequest");
    function hasQuota(operation, iastContext) {
      const oceContext = _getContext(iastContext);
      return operation.hasQuota(oceContext);
    }
    __name(hasQuota, "hasQuota");
    function initializeRequestContext(iastContext) {
      if (iastContext)
        iastContext[OVERHEAD_CONTROLLER_CONTEXT_KEY] = _getNewContext();
    }
    __name(initializeRequestContext, "initializeRequestContext");
    function configure(cfg) {
      config = cfg;
      availableRequest = config.maxConcurrentRequests;
    }
    __name(configure, "configure");
    function startGlobalContext() {
      if (resetGlobalContextInterval)
        return;
      _resetGlobalContext();
      resetGlobalContextInterval = setInterval(() => {
        _resetGlobalContext();
      }, INTERVAL_RESET_GLOBAL_CONTEXT);
      resetGlobalContextInterval.unref && resetGlobalContextInterval.unref();
    }
    __name(startGlobalContext, "startGlobalContext");
    function finishGlobalContext() {
      if (resetGlobalContextInterval) {
        clearInterval(resetGlobalContextInterval);
        resetGlobalContextInterval = null;
      }
    }
    __name(finishGlobalContext, "finishGlobalContext");
    module2.exports = {
      OVERHEAD_CONTROLLER_CONTEXT_KEY,
      OPERATIONS,
      startGlobalContext,
      finishGlobalContext,
      _resetGlobalContext,
      initializeRequestContext,
      hasQuota,
      acquireRequest,
      releaseRequest,
      configure
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/vulnerability-analyzer.js
var require_vulnerability_analyzer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/vulnerability-analyzer.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var log = require_log();
    var { getFirstNonDDPathAndLine } = require_path_line();
    var { createVulnerability, addVulnerability } = require_vulnerability_reporter();
    var { getIastContext } = require_iast_context();
    var overheadController = require_overhead_controller();
    var Analyzer = class extends Plugin {
      constructor(type) {
        super();
        this._type = type;
      }
      _wrapHandler(handler2) {
        return (message, name) => {
          try {
            handler2(message, name);
          } catch (e) {
            log.debug(e);
          }
        };
      }
      addSub(channelName, handler2) {
        super.addSub(channelName, this._wrapHandler(handler2));
      }
      _isVulnerable(value, context) {
        return false;
      }
      _report(value, context) {
        const evidence = this._getEvidence(value, context);
        const location = this._getLocation();
        const spanId = context && context.rootSpan && context.rootSpan.context().toSpanId();
        const vulnerability = createVulnerability(this._type, evidence, spanId, location);
        addVulnerability(context, vulnerability);
      }
      _reportIfVulnerable(value, context) {
        if (this._isVulnerable(value, context) && this._checkOCE(context)) {
          this._report(value, context);
          return true;
        }
        return false;
      }
      _getEvidence(value) {
        return { value };
      }
      _getLocation() {
        return getFirstNonDDPathAndLine();
      }
      analyze(value) {
        const store = storage.getStore();
        const iastContext = getIastContext(store);
        if (store && !iastContext)
          return;
        this._reportIfVulnerable(value, iastContext);
      }
      analyzeAll(...values) {
        const store = storage.getStore();
        const iastContext = getIastContext(store);
        if (store && !iastContext)
          return;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (this._isVulnerable(value, iastContext)) {
            if (this._checkOCE(iastContext)) {
              this._report(value, iastContext);
            }
            break;
          }
        }
      }
      _checkOCE(context) {
        return overheadController.hasQuota(overheadController.OPERATIONS.REPORT_VULNERABILITY, context);
      }
    };
    __name(Analyzer, "Analyzer");
    module2.exports = Analyzer;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/weak-cipher-analyzer.js
var require_weak_cipher_analyzer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/weak-cipher-analyzer.js"(exports2, module2) {
    "use strict";
    var Analyzer = require_vulnerability_analyzer();
    var INSECURE_CIPHERS = new Set([
      "des",
      "des-cbc",
      "des-cfb",
      "des-cfb1",
      "des-cfb8",
      "des-ecb",
      "des-ede",
      "des-ede-cbc",
      "des-ede-cfb",
      "des-ede-ecb",
      "des-ede-ofb",
      "des-ede3",
      "des-ede3-cbc",
      "des-ede3-cfb",
      "des-ede3-cfb1",
      "des-ede3-cfb8",
      "des-ede3-ecb",
      "des-ede3-ofb",
      "des-ofb",
      "des3",
      "des3-wrap",
      "rc2",
      "rc2-128",
      "rc2-40",
      "rc2-40-cbc",
      "rc2-64",
      "rc2-64-cbc",
      "rc2-cbc",
      "rc2-cfb",
      "rc2-ecb",
      "rc2-ofb",
      "blowfish",
      "rc4",
      "rc4-40",
      "rc4-hmac-md5"
    ].map((algorithm) => algorithm.toLowerCase()));
    var WeakCipherAnalyzer = class extends Analyzer {
      constructor() {
        super("WEAK_CIPHER");
        this.addSub("datadog:crypto:cipher:start", ({ algorithm }) => this.analyze(algorithm));
      }
      _isVulnerable(algorithm) {
        if (algorithm && typeof algorithm === "string") {
          return INSECURE_CIPHERS.has(algorithm.toLowerCase());
        }
        return false;
      }
    };
    __name(WeakCipherAnalyzer, "WeakCipherAnalyzer");
    module2.exports = new WeakCipherAnalyzer();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/weak-hash-analyzer.js
var require_weak_hash_analyzer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/weak-hash-analyzer.js"(exports2, module2) {
    "use strict";
    var Analyzer = require_vulnerability_analyzer();
    var INSECURE_HASH_ALGORITHMS = new Set([
      "md4",
      "md4WithRSAEncryption",
      "RSA-MD4",
      "RSA-MD5",
      "md5",
      "md5-sha1",
      "ssl3-md5",
      "md5WithRSAEncryption",
      "RSA-SHA1",
      "RSA-SHA1-2",
      "sha1",
      "md5-sha1",
      "sha1WithRSAEncryption",
      "ssl3-sha1"
    ].map((algorithm) => algorithm.toLowerCase()));
    var WeakHashAnalyzer = class extends Analyzer {
      constructor() {
        super("WEAK_HASH");
        this.addSub("datadog:crypto:hashing:start", ({ algorithm }) => this.analyze(algorithm));
      }
      _isVulnerable(algorithm) {
        if (typeof algorithm === "string") {
          return INSECURE_HASH_ALGORITHMS.has(algorithm.toLowerCase());
        }
        return false;
      }
    };
    __name(WeakHashAnalyzer, "WeakHashAnalyzer");
    module2.exports = new WeakHashAnalyzer();
  }
});

// node_modules/@datadog/native-iast-taint-tracking/replace.js
var require_replace = __commonJS({
  "node_modules/@datadog/native-iast-taint-tracking/replace.js"(exports2, module2) {
    var isSpecialRegex = /(\$\$)|(\$&)|(\$`)|(\$')|(\$\d)/;
    function getReplace(addon) {
      function isSpecialReplacement(replacer) {
        return replacer.indexOf("$") > -1 && !!replacer.match(isSpecialRegex);
      }
      __name(isSpecialReplacement, "isSpecialReplacement");
      function shouldBePropagated(transactionId, thisArg, replacer) {
        return addon.isTainted(transactionId, thisArg, replacer) && !isSpecialReplacement(replacer);
      }
      __name(shouldBePropagated, "shouldBePropagated");
      if (addon.replace) {
        return addon.replace;
      }
      return /* @__PURE__ */ __name(function replace(transactionId, result, thisArg, matcher, replacer) {
        if (transactionId && typeof thisArg === "string" && typeof replacer === "string") {
          if (typeof matcher === "string") {
            if (shouldBePropagated(transactionId, thisArg, replacer)) {
              const index = thisArg.indexOf(matcher);
              if (index > -1) {
                return addon.replaceStringByString(transactionId, result, thisArg, matcher, replacer, index);
              }
            }
          } else if (matcher instanceof RegExp) {
            if (shouldBePropagated(transactionId, thisArg, replacer)) {
              const replacements = [];
              let lastIndex = -1;
              for (let match = matcher.exec(thisArg), i = 0; match != null; match = matcher.exec(thisArg), i++) {
                const index = match.index;
                if (index !== lastIndex) {
                  replacements.push([index, match[0]]);
                  lastIndex = index;
                } else {
                  break;
                }
              }
              return addon.replaceStringByStringUsingRegex(
                transactionId,
                result,
                thisArg,
                matcher,
                replacer,
                replacements
              );
            }
          }
        }
        return result;
      }, "replace");
    }
    __name(getReplace, "getReplace");
    module2.exports = getReplace;
  }
});

// node_modules/@datadog/native-iast-taint-tracking/index.js
var require_native_iast_taint_tracking = __commonJS({
  "node_modules/@datadog/native-iast-taint-tracking/index.js"(exports2, module2) {
    "use strict";
    var addon;
    try {
      addon = require_node_gyp_build()(__dirname);
    } catch (e) {
      addon = {
        createTransaction(transactionId) {
          return transactionId;
        },
        newTaintedString(transactionId, original) {
          return original;
        },
        isTainted() {
          return false;
        },
        getRanges() {
          return void 0;
        },
        removeTransaction() {
        },
        replace(transactionId, result) {
          return result;
        },
        concat(transactionId, result) {
          return result;
        },
        trim(transaction, result) {
          return result;
        },
        trimEnd(transaction, result) {
          return result;
        },
        slice(transaction, result) {
          return result;
        },
        substring(transaction, result) {
          return result;
        },
        substr(transaction, result) {
          return result;
        }
      };
    }
    var iastNativeMethods = {
      newTaintedString: addon.newTaintedString,
      isTainted: addon.isTainted,
      getRanges: addon.getRanges,
      createTransaction: addon.createTransaction,
      removeTransaction: addon.removeTransaction,
      replace: require_replace()(addon),
      concat: addon.concat,
      trim: addon.trim,
      trimEnd: addon.trimEnd,
      slice: addon.slice,
      substring: addon.substring,
      substr: addon.substr
    };
    module2.exports = iastNativeMethods;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/taint-tracking-impl.js
var require_taint_tracking_impl = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/taint-tracking-impl.js"(exports2, module2) {
    "use strict";
    var TaintedUtils = require_native_iast_taint_tracking();
    var { storage } = require_datadog_core();
    var iastContextFunctions = require_iast_context();
    var log = require_log();
    function noop(res) {
      return res;
    }
    __name(noop, "noop");
    var TaintTrackingDummy = {
      plusOperator: noop,
      trim: noop,
      trimEnd: noop,
      concat: noop,
      substring: noop,
      substr: noop,
      slice: noop,
      replace: noop
    };
    function getTransactionId() {
      const store = storage.getStore();
      const iastContext = iastContextFunctions.getIastContext(store);
      return iastContext && iastContext[iastContextFunctions.IAST_TRANSACTION_ID];
    }
    __name(getTransactionId, "getTransactionId");
    function getFilteredCsiFn(cb, filter) {
      return /* @__PURE__ */ __name(function csiCall(res, fn, target, ...rest) {
        try {
          if (filter(res, fn, target)) {
            return res;
          }
          const transactionId = getTransactionId();
          if (transactionId) {
            return cb(transactionId, res, target, ...rest);
          }
        } catch (e) {
          log.debug(e);
        }
        return res;
      }, "csiCall");
    }
    __name(getFilteredCsiFn, "getFilteredCsiFn");
    function notString() {
      return Array.prototype.some.call(arguments, (p) => typeof p !== "string");
    }
    __name(notString, "notString");
    function isValidCsiMethod(fn, protos) {
      return protos.some((proto) => fn === proto);
    }
    __name(isValidCsiMethod, "isValidCsiMethod");
    function getCsiFn(cb, ...protos) {
      let filter;
      if (!protos || protos.length === 0) {
        filter = /* @__PURE__ */ __name((res, fn, target) => notString(res, target), "filter");
      } else if (protos.length === 1) {
        const protoFn = protos[0];
        filter = /* @__PURE__ */ __name((res, fn, target) => notString(res, target) || fn !== protoFn, "filter");
      } else {
        filter = /* @__PURE__ */ __name((res, fn, target) => notString(res, target) || !isValidCsiMethod(fn, protos), "filter");
      }
      return getFilteredCsiFn(cb, filter);
    }
    __name(getCsiFn, "getCsiFn");
    function csiMethodsDefaults(names, excluded) {
      const impl = {};
      names.forEach((name) => {
        if (excluded.indexOf(name) !== -1)
          return;
        impl[name] = getCsiFn(
          (transactionId, res, target, ...rest) => TaintedUtils[name](transactionId, res, target, ...rest),
          String.prototype[name]
        );
      });
      return impl;
    }
    __name(csiMethodsDefaults, "csiMethodsDefaults");
    var csiMethodsOverrides = {
      plusOperator: function(res, op1, op2) {
        try {
          if (notString(res) || notString(op1) && notString(op2)) {
            return res;
          }
          const transactionId = getTransactionId();
          if (transactionId) {
            return TaintedUtils.concat(transactionId, res, op1, op2);
          }
        } catch (e) {
          log.debug(e);
        }
        return res;
      },
      trim: getCsiFn(
        (transactionId, res, target) => TaintedUtils.trim(transactionId, res, target),
        String.prototype.trim,
        String.prototype.trimStart
      )
    };
    var TaintTracking = {
      ...csiMethodsDefaults(Object.keys(TaintTrackingDummy), Object.keys(csiMethodsOverrides)),
      ...csiMethodsOverrides
    };
    module2.exports = {
      TaintTracking,
      TaintTrackingDummy
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/operations.js
var require_operations = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/operations.js"(exports2, module2) {
    var TaintedUtils = require_native_iast_taint_tracking();
    var { IAST_TRANSACTION_ID } = require_iast_context();
    var { TaintTracking, TaintTrackingDummy } = require_taint_tracking_impl();
    function createTransaction(id, iastContext) {
      if (id && iastContext) {
        iastContext[IAST_TRANSACTION_ID] = TaintedUtils.createTransaction(id);
      }
    }
    __name(createTransaction, "createTransaction");
    function removeTransaction(iastContext) {
      if (iastContext && iastContext[IAST_TRANSACTION_ID]) {
        const transactionId = iastContext[IAST_TRANSACTION_ID];
        TaintedUtils.removeTransaction(transactionId);
        delete iastContext[IAST_TRANSACTION_ID];
      }
    }
    __name(removeTransaction, "removeTransaction");
    function newTaintedString(iastContext, string, name, type) {
      let result = string;
      if (iastContext && iastContext[IAST_TRANSACTION_ID]) {
        const transactionId = iastContext[IAST_TRANSACTION_ID];
        result = TaintedUtils.newTaintedString(transactionId, string, name, type);
      } else {
        result = string;
      }
      return result;
    }
    __name(newTaintedString, "newTaintedString");
    function taintObject(iastContext, object, type) {
      let result = object;
      if (iastContext && iastContext[IAST_TRANSACTION_ID]) {
        const transactionId = iastContext[IAST_TRANSACTION_ID];
        const queue = [{ parent: null, property: null, value: object }];
        const visited = /* @__PURE__ */ new WeakSet();
        while (queue.length > 0) {
          const { parent, property, value } = queue.pop();
          if (typeof value === "string") {
            const tainted = TaintedUtils.newTaintedString(transactionId, value, property, type);
            if (!parent) {
              result = tainted;
            } else {
              parent[property] = tainted;
            }
          } else if (typeof value === "object" && !visited.has(value)) {
            visited.add(value);
            const keys = Object.keys(value);
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              queue.push({ parent: value, property: property ? `${property}.${key}` : key, value: value[key] });
            }
          }
        }
      }
      return result;
    }
    __name(taintObject, "taintObject");
    function isTainted(iastContext, string) {
      let result = false;
      if (iastContext && iastContext[IAST_TRANSACTION_ID]) {
        const transactionId = iastContext[IAST_TRANSACTION_ID];
        result = TaintedUtils.isTainted(transactionId, string);
      } else {
        result = false;
      }
      return result;
    }
    __name(isTainted, "isTainted");
    function getRanges(iastContext, string) {
      let result = [];
      if (iastContext && iastContext[IAST_TRANSACTION_ID]) {
        const transactionId = iastContext[IAST_TRANSACTION_ID];
        result = TaintedUtils.getRanges(transactionId, string);
      } else {
        result = [];
      }
      return result;
    }
    __name(getRanges, "getRanges");
    function enableTaintOperations() {
      global._ddiast = TaintTracking;
    }
    __name(enableTaintOperations, "enableTaintOperations");
    function disableTaintOperations() {
      global._ddiast = TaintTrackingDummy;
    }
    __name(disableTaintOperations, "disableTaintOperations");
    module2.exports = {
      createTransaction,
      removeTransaction,
      newTaintedString,
      taintObject,
      isTainted,
      getRanges,
      enableTaintOperations,
      disableTaintOperations,
      IAST_TRANSACTION_ID
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/injection-analyzer.js
var require_injection_analyzer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/injection-analyzer.js"(exports2, module2) {
    "use strict";
    var Analyzer = require_vulnerability_analyzer();
    var { isTainted, getRanges } = require_operations();
    var InjectionAnalyzer = class extends Analyzer {
      _isVulnerable(value, iastContext) {
        if (value) {
          return isTainted(iastContext, value);
        }
        return false;
      }
      _getEvidence(value, iastContext) {
        const ranges = getRanges(iastContext, value);
        return { value, ranges };
      }
    };
    __name(InjectionAnalyzer, "InjectionAnalyzer");
    module2.exports = InjectionAnalyzer;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/sql-injection-analyzer.js
var require_sql_injection_analyzer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/sql-injection-analyzer.js"(exports2, module2) {
    "use strict";
    var InjectionAnalyzer = require_injection_analyzer();
    var SqlInjectionAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super("SQL_INJECTION");
        this.addSub("apm:mysql:query:start", ({ sql }) => this.analyze(sql));
        this.addSub("apm:mysql2:query:start", ({ sql }) => this.analyze(sql));
        this.addSub("apm:pg:query:start", ({ originalQuery }) => this.analyze(originalQuery));
      }
    };
    __name(SqlInjectionAnalyzer, "SqlInjectionAnalyzer");
    module2.exports = new SqlInjectionAnalyzer();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/path-traversal-analyzer.js
var require_path_traversal_analyzer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/path-traversal-analyzer.js"(exports2, module2) {
    "use strict";
    var { getIastContext } = require_iast_context();
    var { storage } = require_datadog_core();
    var InjectionAnalyzer = require_injection_analyzer();
    var PathTraversalAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super("PATH_TRAVERSAL");
        this.addSub("apm:fs:operation:start", (obj) => {
          const pathArguments = [];
          if (obj.dest) {
            pathArguments.push(obj.dest);
          }
          if (obj.existingPath) {
            pathArguments.push(obj.existingPath);
          }
          if (obj.file) {
            pathArguments.push(obj.file);
          }
          if (obj.newPath) {
            pathArguments.push(obj.newPath);
          }
          if (obj.oldPath) {
            pathArguments.push(obj.oldPath);
          }
          if (obj.path) {
            pathArguments.push(obj.path);
          }
          if (obj.prefix) {
            pathArguments.push(obj.prefix);
          }
          if (obj.src) {
            pathArguments.push(obj.src);
          }
          if (obj.target) {
            pathArguments.push(obj.target);
          }
          this.analyze(pathArguments);
        });
      }
      analyze(value) {
        const iastContext = getIastContext(storage.getStore());
        if (!iastContext) {
          return;
        }
        if (value && value.constructor === Array) {
          for (const val of value) {
            if (this._isVulnerable(val, iastContext)) {
              this._report(val, iastContext);
              break;
            }
          }
        }
      }
    };
    __name(PathTraversalAnalyzer, "PathTraversalAnalyzer");
    module2.exports = new PathTraversalAnalyzer();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/command-injection-analyzer.js
var require_command_injection_analyzer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/command-injection-analyzer.js"(exports2, module2) {
    "use strict";
    var InjectionAnalyzer = require_injection_analyzer();
    var CommandInjectionAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super("COMMAND_INJECTION");
        this.addSub("datadog:child_process:execution:start", ({ command }) => this.analyze(command));
      }
    };
    __name(CommandInjectionAnalyzer, "CommandInjectionAnalyzer");
    module2.exports = new CommandInjectionAnalyzer();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/ldap-injection-analyzer.js
var require_ldap_injection_analyzer = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/ldap-injection-analyzer.js"(exports2, module2) {
    "use strict";
    var InjectionAnalyzer = require_injection_analyzer();
    var LdapInjectionAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super("LDAP_INJECTION");
        this.addSub("datadog:ldapjs:client:search", ({ base, filter }) => this.analyzeAll(base, filter));
      }
    };
    __name(LdapInjectionAnalyzer, "LdapInjectionAnalyzer");
    module2.exports = new LdapInjectionAnalyzer();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/analyzers.js
var require_analyzers = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/analyzers.js"(exports2, module2) {
    module2.exports = {
      "WEAK_CIPHER_ANALYZER": require_weak_cipher_analyzer(),
      "WEAK_HASH_ANALYZER": require_weak_hash_analyzer(),
      "SQL_INJECTION_ANALYZER": require_sql_injection_analyzer(),
      "PATH_TRAVERSAL_ANALYZER": require_path_traversal_analyzer(),
      "COMMAND_INJECTION_ANALYZER": require_command_injection_analyzer(),
      "LDAP_ANALYZER": require_ldap_injection_analyzer()
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/index.js
var require_analyzers2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/analyzers/index.js"(exports2, module2) {
    "use strict";
    var analyzers = require_analyzers();
    function enableAllAnalyzers() {
      for (const analyzer in analyzers) {
        analyzers[analyzer].configure(true);
      }
    }
    __name(enableAllAnalyzers, "enableAllAnalyzers");
    function disableAllAnalyzers() {
      for (const analyzer in analyzers) {
        analyzers[analyzer].configure(false);
      }
    }
    __name(disableAllAnalyzers, "disableAllAnalyzers");
    module2.exports = {
      enableAllAnalyzers,
      disableAllAnalyzers
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/filter.js
var require_filter = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/filter.js"(exports2, module2) {
    "use strict";
    var NODE_MODULES = "node_modules";
    var isPrivateModule = /* @__PURE__ */ __name(function(file) {
      return file && file.indexOf(NODE_MODULES) === -1;
    }, "isPrivateModule");
    var isNotLibraryFile = /* @__PURE__ */ __name(function(file) {
      return file && file.indexOf("dd-trace-js") === -1 && file.indexOf("dd-trace") === -1;
    }, "isNotLibraryFile");
    module2.exports = {
      isPrivateModule,
      isNotLibraryFile
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/csi-methods.js
var require_csi_methods = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/csi-methods.js"(exports2, module2) {
    "use strict";
    var csiMethods = [
      { src: "plusOperator", operator: true },
      { src: "trim" },
      { src: "trimStart", dst: "trim" },
      { src: "trimEnd" },
      { src: "concat" },
      { src: "substring" },
      { src: "substr" },
      { src: "slice" },
      { src: "replace" }
    ];
    module2.exports = {
      csiMethods
    };
  }
});

// node_modules/@datadog/native-iast-rewriter/js/source-map/primordials.js
var require_primordials = __commonJS({
  "node_modules/@datadog/native-iast-rewriter/js/source-map/primordials.js"(exports2, module2) {
    "use strict";
    function generateCaller(method) {
      return function(self2, ...args) {
        return method.apply(self2, args);
      };
    }
    __name(generateCaller, "generateCaller");
    var primordials = {
      ArrayPrototypePush: generateCaller(Array.prototype.push),
      ArrayPrototypeSlice: generateCaller(Array.prototype.slice),
      ArrayPrototypeSort: generateCaller(Array.prototype.sort),
      ArrayIsArray: Array.isArray,
      ObjectPrototypeHasOwnProperty: generateCaller(Object.prototype.hasOwnProperty),
      StringPrototypeCharAt: generateCaller(String.prototype.charAt)
    };
    module2.exports = primordials;
  }
});

// node_modules/@datadog/native-iast-rewriter/js/source-map/node_source_map.js
var require_node_source_map = __commonJS({
  "node_modules/@datadog/native-iast-rewriter/js/source-map/node_source_map.js"(exports2, module2) {
    "use strict";
    var {
      ArrayPrototypePush,
      ArrayPrototypeSlice,
      ArrayPrototypeSort,
      ArrayIsArray,
      ObjectPrototypeHasOwnProperty,
      StringPrototypeCharAt
    } = require_primordials();
    var validateObject = /* @__PURE__ */ __name(function() {
    }, "validateObject");
    var base64Map;
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE_MASK = (1 << 5) - 1;
    var VLQ_CONTINUATION_MASK = 1 << 5;
    var StringCharIterator = class {
      constructor(string) {
        this._string = string;
        this._position = 0;
      }
      next() {
        return StringPrototypeCharAt(this._string, this._position++);
      }
      peek() {
        return StringPrototypeCharAt(this._string, this._position);
      }
      hasNext() {
        return this._position < this._string.length;
      }
    };
    __name(StringCharIterator, "StringCharIterator");
    var SourceMap = class {
      constructor(payload2) {
        this._mappings = [];
        this._sources = {};
        this._sources = {};
        if (!base64Map) {
          const base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          base64Map = {};
          for (let i = 0; i < base64Digits.length; ++i) {
            base64Map[base64Digits[i]] = i;
          }
        }
        this._payload = cloneSourceMapV3(payload2);
        this._parseMappingPayload();
      }
      _parseMappingPayload() {
        if (this._payload.sections) {
          this._parseSections(this._payload.sections);
        } else {
          this._parseMap(this._payload, 0, 0);
        }
        ArrayPrototypeSort(this._mappings, compareSourceMapEntry);
      }
      _parseSections(sections) {
        for (let i = 0; i < sections.length; ++i) {
          const section = sections[i];
          this._parseMap(section.map, section.offset.line, section.offset.column);
        }
      }
      findEntry(lineNumber, columnNumber) {
        let first = 0;
        let count = this._mappings.length;
        while (count > 1) {
          const step = count >> 1;
          const middle = first + step;
          const mapping = this._mappings[middle];
          if (lineNumber < mapping[0] || lineNumber === mapping[0] && columnNumber < mapping[1]) {
            count = step;
          } else {
            first = middle;
            count -= step;
          }
        }
        const entry = this._mappings[first];
        if (!first && entry && (lineNumber < entry[0] || lineNumber === entry[0] && columnNumber < entry[1])) {
          return {};
        } else if (!entry) {
          return {};
        }
        return {
          generatedLine: entry[0],
          generatedColumn: entry[1],
          originalSource: entry[2],
          originalLine: entry[3],
          originalColumn: entry[4],
          name: entry[5]
        };
      }
      _parseMap(map, lineNumber, columnNumber) {
        let sourceIndex = 0;
        let sourceLineNumber = 0;
        let sourceColumnNumber = 0;
        let nameIndex = 0;
        const sources = [];
        const originalToCanonicalURLMap = {};
        for (let i = 0; i < map.sources.length; ++i) {
          const url = map.sources[i];
          originalToCanonicalURLMap[url] = url;
          ArrayPrototypePush(sources, url);
          this._sources[url] = true;
          if (map.sourcesContent && map.sourcesContent[i]) {
            this._sources[url] = map.sourcesContent[i];
          }
        }
        const stringCharIterator = new StringCharIterator(map.mappings);
        let sourceURL = sources[sourceIndex];
        while (true) {
          if (stringCharIterator.peek() === ",") {
            stringCharIterator.next();
          } else {
            while (stringCharIterator.peek() === ";") {
              lineNumber += 1;
              columnNumber = 0;
              stringCharIterator.next();
            }
            if (!stringCharIterator.hasNext()) {
              break;
            }
          }
          columnNumber += decodeVLQ(stringCharIterator);
          if (isSeparator(stringCharIterator.peek())) {
            ArrayPrototypePush(this._mappings, [lineNumber, columnNumber]);
            continue;
          }
          const sourceIndexDelta = decodeVLQ(stringCharIterator);
          if (sourceIndexDelta) {
            sourceIndex += sourceIndexDelta;
            sourceURL = sources[sourceIndex];
          }
          sourceLineNumber += decodeVLQ(stringCharIterator);
          sourceColumnNumber += decodeVLQ(stringCharIterator);
          let name;
          if (!isSeparator(stringCharIterator.peek())) {
            nameIndex += decodeVLQ(stringCharIterator);
            name = map.names ? map.names[nameIndex] : void 0;
          }
          ArrayPrototypePush(this._mappings, [
            lineNumber,
            columnNumber,
            sourceURL,
            sourceLineNumber,
            sourceColumnNumber,
            name
          ]);
        }
      }
    };
    __name(SourceMap, "SourceMap");
    function isSeparator(char) {
      return char === "," || char === ";";
    }
    __name(isSeparator, "isSeparator");
    function decodeVLQ(stringCharIterator) {
      let result = 0;
      let shift = 0;
      let digit;
      do {
        digit = base64Map[stringCharIterator.next()];
        result += (digit & VLQ_BASE_MASK) << shift;
        shift += VLQ_BASE_SHIFT;
      } while (digit & VLQ_CONTINUATION_MASK);
      const negative = result & 1;
      result >>>= 1;
      if (!negative) {
        return result;
      }
      return -result | 1 << 31;
    }
    __name(decodeVLQ, "decodeVLQ");
    function cloneSourceMapV3(payload2) {
      validateObject(payload2, "payload");
      payload2 = { ...payload2 };
      for (const key in payload2) {
        if (ObjectPrototypeHasOwnProperty(payload2, key) && ArrayIsArray(payload2[key])) {
          payload2[key] = ArrayPrototypeSlice(payload2[key]);
        }
      }
      return payload2;
    }
    __name(cloneSourceMapV3, "cloneSourceMapV3");
    function compareSourceMapEntry(entry1, entry2) {
      const { 0: lineNumber1, 1: columnNumber1 } = entry1;
      const { 0: lineNumber2, 1: columnNumber2 } = entry2;
      if (lineNumber1 !== lineNumber2) {
        return lineNumber1 - lineNumber2;
      }
      return columnNumber1 - columnNumber2;
    }
    __name(compareSourceMapEntry, "compareSourceMapEntry");
    module2.exports = {
      SourceMap
    };
  }
});

// node_modules/@datadog/native-iast-rewriter/js/source-map/index.js
var require_source_map2 = __commonJS({
  "node_modules/@datadog/native-iast-rewriter/js/source-map/index.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var fs = __require("fs");
    var { SourceMap } = require_node_source_map();
    var SOURCE_MAP_LINE_START = "//# sourceMappingURL=";
    var SOURCE_MAP_INLINE_LINE_START = "//# sourceMappingURL=data:application/json;base64,";
    var rewrittenSourceMapsCache = /* @__PURE__ */ new Map();
    function generateSourceMapFromFileContent(fileContent, filePath) {
      const fileLines = fileContent.trim().split("\n");
      const lastLine = fileLines[fileLines.length - 1];
      let rawSourceMap;
      if (lastLine.indexOf(SOURCE_MAP_INLINE_LINE_START) === 0) {
        const sourceMapInBase64 = lastLine.substring(SOURCE_MAP_INLINE_LINE_START.length);
        rawSourceMap = Buffer.from(sourceMapInBase64, "base64").toString("utf8");
      } else if (lastLine.indexOf(SOURCE_MAP_LINE_START) === 0) {
        let sourceMappingURL = lastLine.substring(SOURCE_MAP_LINE_START.length);
        if (sourceMappingURL) {
          sourceMappingURL = path.join(filePath, sourceMappingURL);
          rawSourceMap = fs.readFileSync(sourceMappingURL).toString();
        }
      }
      if (rawSourceMap) {
        return new SourceMap(JSON.parse(rawSourceMap));
      }
    }
    __name(generateSourceMapFromFileContent, "generateSourceMapFromFileContent");
    function cacheRewrittenSourceMap(filename, fileContent) {
      const sm = generateSourceMapFromFileContent(fileContent, getFilePathFromName(filename));
      rewrittenSourceMapsCache.set(filename, sm);
    }
    __name(cacheRewrittenSourceMap, "cacheRewrittenSourceMap");
    function getFilePathFromName(filename) {
      const filenameParts = filename.split(path.sep);
      filenameParts.pop();
      return filenameParts.join(path.sep);
    }
    __name(getFilePathFromName, "getFilePathFromName");
    function getSourcePathAndLineFromSourceMaps(filename, line, column = 0) {
      try {
        const sourceMap = rewrittenSourceMapsCache.get(filename);
        if (sourceMap) {
          const filePath = getFilePathFromName(filename);
          const { originalSource, originalLine, originalColumn } = sourceMap.findEntry(line - 1, column - 1);
          return {
            path: path.join(filePath, originalSource),
            line: originalLine + 1,
            column: originalColumn + 1
          };
        }
      } catch (e) {
      }
      return { path: filename, line, column };
    }
    __name(getSourcePathAndLineFromSourceMaps, "getSourcePathAndLineFromSourceMaps");
    module2.exports = {
      getSourcePathAndLineFromSourceMaps,
      cacheRewrittenSourceMap
    };
  }
});

// node_modules/@datadog/native-iast-rewriter/js/stack-trace/index.js
var require_stack_trace = __commonJS({
  "node_modules/@datadog/native-iast-rewriter/js/stack-trace/index.js"(exports2, module2) {
    var { getSourcePathAndLineFromSourceMaps } = require_source_map2();
    var kSymbolPrepareStackTrace = Symbol("_ddiastPrepareStackTrace");
    var WrappedCallSite = class {
      constructor(callSite) {
        const { path, line, column } = getSourcePathAndLineFromSourceMaps(
          callSite.getFileName(),
          callSite.getLineNumber(),
          callSite.getColumnNumber()
        );
        this.source = path;
        this.lineNumber = line;
        this.columnNumber = column;
        this.callSite = callSite;
      }
      getThis() {
        return this.callSite;
      }
      getTypeName() {
        return this.callSite.getTypeName();
      }
      getFunction() {
        return this.callSite.getFunction();
      }
      getFunctionName() {
        return this.callSite.getFunctionName();
      }
      getMethodName() {
        return this.callSite.getMethodName();
      }
      getFileName() {
        return this.source;
      }
      getScriptNameOrSourceURL() {
        return null;
      }
      getLineNumber() {
        return this.lineNumber;
      }
      getColumnNumber() {
        return this.columnNumber;
      }
      getEvalOrigin() {
        return this.callSite.getEvalOrigin();
      }
      isToplevel() {
        return this.callSite.isToplevel();
      }
      isEval() {
        return this.callSite.isEval();
      }
      isNative() {
        return this.callSite.isNative();
      }
      isConstructor() {
        return this.callSite.isConstructor();
      }
    };
    __name(WrappedCallSite, "WrappedCallSite");
    function getPrepareStackTrace(originalPrepareStackTrace) {
      if (originalPrepareStackTrace && originalPrepareStackTrace[kSymbolPrepareStackTrace]) {
        return originalPrepareStackTrace;
      }
      const wrappedPrepareStackTrace = /* @__PURE__ */ __name((error, structuredStackTrace) => {
        if (originalPrepareStackTrace) {
          const parsedCallSites = structuredStackTrace.map((callSite) => new WrappedCallSite(callSite));
          return originalPrepareStackTrace(error, parsedCallSites);
        }
        const stackLines = error.stack.split("\n");
        let firstIndex = -1;
        for (let i = 0; i < stackLines.length; i++) {
          if (stackLines[i].match(/^\s*at/gm)) {
            firstIndex = i;
            break;
          }
        }
        return stackLines.map((stackFrame, index) => {
          if (index < firstIndex) {
            return stackFrame;
          }
          index = index - firstIndex;
          const stackTraceItem = structuredStackTrace[index];
          if (!stackTraceItem) {
            return stackFrame;
          }
          let filename = stackTraceItem.getFileName();
          let originalLine = stackTraceItem.getLineNumber();
          let originalColumn = stackTraceItem.getColumnNumber();
          if (stackTraceItem.isEval()) {
            const evalOrigin = stackTraceItem.getEvalOrigin();
            const evalRegex = /.*\(((?:.:[/\\]?)?[/\\].*):(\d*):(\d*)\)/g;
            const evalData = evalRegex.exec(evalOrigin);
            if (evalData) {
              filename = evalData[1];
              originalLine = evalData[2];
              originalColumn = evalData[3];
            } else {
              return stackFrame;
            }
          }
          const { path, line, column } = getSourcePathAndLineFromSourceMaps(filename, originalLine, originalColumn);
          if (path !== filename || line !== originalLine || column !== originalColumn) {
            return stackFrame.replace(`${filename}:${originalLine}:${originalColumn}`, `${path}:${line}:${column}`);
          }
          return stackFrame;
        }).join("\n");
      }, "wrappedPrepareStackTrace");
      Object.defineProperty(wrappedPrepareStackTrace, kSymbolPrepareStackTrace, {
        value: true
      });
      return wrappedPrepareStackTrace;
    }
    __name(getPrepareStackTrace, "getPrepareStackTrace");
    module2.exports = {
      getPrepareStackTrace
    };
  }
});

// node_modules/@datadog/native-iast-rewriter/wasm/wasm_iast_rewriter.js
var require_wasm_iast_rewriter = __commonJS({
  "node_modules/@datadog/native-iast-rewriter/wasm/wasm_iast_rewriter.js"(exports2, module2) {
    var imports = {};
    imports["__wbindgen_placeholder__"] = module2.exports;
    var wasm;
    var { TextEncoder, TextDecoder } = __require("util");
    var heap = new Array(32).fill(void 0);
    heap.push(void 0, null, true, false);
    function getObject(idx) {
      return heap[idx];
    }
    __name(getObject, "getObject");
    var heap_next = heap.length;
    function dropObject(idx) {
      if (idx < 36)
        return;
      heap[idx] = heap_next;
      heap_next = idx;
    }
    __name(dropObject, "dropObject");
    function takeObject(idx) {
      const ret = getObject(idx);
      dropObject(idx);
      return ret;
    }
    __name(takeObject, "takeObject");
    var WASM_VECTOR_LEN = 0;
    var cachedUint8Memory0 = new Uint8Array();
    function getUint8Memory0() {
      if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
      }
      return cachedUint8Memory0;
    }
    __name(getUint8Memory0, "getUint8Memory0");
    var cachedTextEncoder = new TextEncoder("utf-8");
    var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    function passStringToWasm0(arg, malloc, realloc) {
      if (realloc === void 0) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr2 = malloc(buf.length);
        getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr2;
      }
      let len = arg.length;
      let ptr = malloc(len);
      const mem = getUint8Memory0();
      let offset = 0;
      for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 127)
          break;
        mem[ptr + offset] = code;
      }
      if (offset !== len) {
        if (offset !== 0) {
          arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
      }
      WASM_VECTOR_LEN = offset;
      return ptr;
    }
    __name(passStringToWasm0, "passStringToWasm0");
    function isLikeNone(x) {
      return x === void 0 || x === null;
    }
    __name(isLikeNone, "isLikeNone");
    var cachedInt32Memory0 = new Int32Array();
    function getInt32Memory0() {
      if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
      }
      return cachedInt32Memory0;
    }
    __name(getInt32Memory0, "getInt32Memory0");
    var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    function getStringFromWasm0(ptr, len) {
      return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
    }
    __name(getStringFromWasm0, "getStringFromWasm0");
    function addHeapObject(obj) {
      if (heap_next === heap.length)
        heap.push(heap.length + 1);
      const idx = heap_next;
      heap_next = heap[idx];
      heap[idx] = obj;
      return idx;
    }
    __name(addHeapObject, "addHeapObject");
    var cachedFloat64Memory0 = new Float64Array();
    function getFloat64Memory0() {
      if (cachedFloat64Memory0.byteLength === 0) {
        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
      }
      return cachedFloat64Memory0;
    }
    __name(getFloat64Memory0, "getFloat64Memory0");
    function debugString(val) {
      const type = typeof val;
      if (type == "number" || type == "boolean" || val == null) {
        return `${val}`;
      }
      if (type == "string") {
        return `"${val}"`;
      }
      if (type == "symbol") {
        const description = val.description;
        if (description == null) {
          return "Symbol";
        } else {
          return `Symbol(${description})`;
        }
      }
      if (type == "function") {
        const name = val.name;
        if (typeof name == "string" && name.length > 0) {
          return `Function(${name})`;
        } else {
          return "Function";
        }
      }
      if (Array.isArray(val)) {
        const length = val.length;
        let debug = "[";
        if (length > 0) {
          debug += debugString(val[0]);
        }
        for (let i = 1; i < length; i++) {
          debug += ", " + debugString(val[i]);
        }
        debug += "]";
        return debug;
      }
      const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
      let className;
      if (builtInMatches.length > 1) {
        className = builtInMatches[1];
      } else {
        return toString.call(val);
      }
      if (className == "Object") {
        try {
          return "Object(" + JSON.stringify(val) + ")";
        } catch (_) {
          return "Object";
        }
      }
      if (val instanceof Error) {
        return `${val.name}: ${val.message}
${val.stack}`;
      }
      return className;
    }
    __name(debugString, "debugString");
    function handleError(f, args) {
      try {
        return f.apply(this, args);
      } catch (e) {
        wasm.__wbindgen_exn_store(addHeapObject(e));
      }
    }
    __name(handleError, "handleError");
    var Rewriter = class {
      static __wrap(ptr) {
        const obj = Object.create(Rewriter.prototype);
        obj.ptr = ptr;
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rewriter_free(ptr);
      }
      constructor(config_js) {
        const ret = wasm.rewriter_new(addHeapObject(config_js));
        return Rewriter.__wrap(ret);
      }
      rewrite(code, file) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          const ptr1 = passStringToWasm0(file, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len1 = WASM_VECTOR_LEN;
          wasm.rewriter_rewrite(retptr, this.ptr, ptr0, len0, ptr1, len1);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          var r3 = getInt32Memory0()[retptr / 4 + 3];
          var ptr2 = r0;
          var len2 = r1;
          if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject(r2);
          }
          return getStringFromWasm0(ptr2, len2);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_free(ptr2, len2);
        }
      }
      csiMethods() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rewriter_csiMethods(retptr, this.ptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    __name(Rewriter, "Rewriter");
    module2.exports.Rewriter = Rewriter;
    module2.exports.__wbindgen_object_drop_ref = function(arg0) {
      takeObject(arg0);
    };
    module2.exports.__wbindgen_string_get = function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof obj === "string" ? obj : void 0;
      var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len0 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len0;
      getInt32Memory0()[arg0 / 4 + 0] = ptr0;
    };
    module2.exports.__wbindgen_boolean_get = function(arg0) {
      const v = getObject(arg0);
      const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
      return ret;
    };
    module2.exports.__wbindgen_is_object = function(arg0) {
      const val = getObject(arg0);
      const ret = typeof val === "object" && val !== null;
      return ret;
    };
    module2.exports.__wbindgen_is_undefined = function(arg0) {
      const ret = getObject(arg0) === void 0;
      return ret;
    };
    module2.exports.__wbindgen_in = function(arg0, arg1) {
      const ret = getObject(arg0) in getObject(arg1);
      return ret;
    };
    module2.exports.__wbindgen_error_new = function(arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_object_clone_ref = function(arg0) {
      const ret = getObject(arg0);
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_string_new = function(arg0, arg1) {
      const ret = getStringFromWasm0(arg0, arg1);
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
      const ret = getObject(arg0) == getObject(arg1);
      return ret;
    };
    module2.exports.__wbindgen_number_get = function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof obj === "number" ? obj : void 0;
      getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
      getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
    };
    module2.exports.__wbg_String_91fba7ded13ba54c = function(arg0, arg1) {
      const ret = String(getObject(arg1));
      const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len0;
      getInt32Memory0()[arg0 / 4 + 0] = ptr0;
    };
    module2.exports.__wbg_getwithrefkey_15c62c2b8546208d = function(arg0, arg1) {
      const ret = getObject(arg0)[getObject(arg1)];
      return addHeapObject(ret);
    };
    module2.exports.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) {
      const ret = getObject(arg0)[arg1 >>> 0];
      return addHeapObject(ret);
    };
    module2.exports.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    };
    module2.exports.__wbg_new_1d9a920c6bfc44a8 = function() {
      const ret = new Array();
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_is_function = function(arg0) {
      const ret = typeof getObject(arg0) === "function";
      return ret;
    };
    module2.exports.__wbg_next_579e583d33566a86 = function(arg0) {
      const ret = getObject(arg0).next;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_next_aaef7c8aa5e212ac = function() {
      return handleError(function(arg0) {
        const ret = getObject(arg0).next();
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_done_1b73b0672e15f234 = function(arg0) {
      const ret = getObject(arg0).done;
      return ret;
    };
    module2.exports.__wbg_value_1ccc36bc03462d71 = function(arg0) {
      const ret = getObject(arg0).value;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_iterator_6f9d4f28845f426c = function() {
      const ret = Symbol.iterator;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_get_765201544a2b6869 = function() {
      return handleError(function(arg0, arg1) {
        const ret = Reflect.get(getObject(arg0), getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_call_97ae9d8645dc388b = function() {
      return handleError(function(arg0, arg1) {
        const ret = getObject(arg0).call(getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_set_a68214f35c417fa9 = function(arg0, arg1, arg2) {
      getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
    };
    module2.exports.__wbg_isArray_27c46c67f498e15d = function(arg0) {
      const ret = Array.isArray(getObject(arg0));
      return ret;
    };
    module2.exports.__wbg_instanceof_ArrayBuffer_e5e48f4762c5610b = function(arg0) {
      let result;
      try {
        result = getObject(arg0) instanceof ArrayBuffer;
      } catch {
        result = false;
      }
      const ret = result;
      return ret;
    };
    module2.exports.__wbg_now_58886682b7e790d7 = function() {
      const ret = Date.now();
      return ret;
    };
    module2.exports.__wbg_buffer_3f3d764d4747d564 = function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_new_8c3f0052272a457a = function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    };
    module2.exports.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    };
    module2.exports.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    };
    module2.exports.__wbg_instanceof_Uint8Array_971eeda69eb75003 = function(arg0) {
      let result;
      try {
        result = getObject(arg0) instanceof Uint8Array;
      } catch {
        result = false;
      }
      const ret = result;
      return ret;
    };
    module2.exports.__wbindgen_debug_string = function(arg0, arg1) {
      const ret = debugString(getObject(arg1));
      const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len0;
      getInt32Memory0()[arg0 / 4 + 0] = ptr0;
    };
    module2.exports.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    module2.exports.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    };
    var path = __require("path").join(__dirname, "wasm_iast_rewriter_bg.wasm");
    var bytes = __require("fs").readFileSync(path);
    var wasmModule = new WebAssembly.Module(bytes);
    var wasmInstance = new WebAssembly.Instance(wasmModule, imports);
    wasm = wasmInstance.exports;
    module2.exports.__wasm = wasm;
  }
});

// node_modules/@datadog/native-iast-rewriter/main.js
var require_main = __commonJS({
  "node_modules/@datadog/native-iast-rewriter/main.js"(exports2, module2) {
    "use strict";
    var { getPrepareStackTrace } = require_stack_trace();
    var { cacheRewrittenSourceMap } = require_source_map2();
    var DummyRewriter = class {
      rewrite(code, file) {
        return code;
      }
      csiMethods() {
        return [];
      }
    };
    __name(DummyRewriter, "DummyRewriter");
    var NativeRewriter;
    var CacheRewriter = class {
      constructor(config) {
        if (NativeRewriter) {
          this.nativeRewriter = new NativeRewriter(config);
        } else {
          this.nativeRewriter = new DummyRewriter();
        }
      }
      rewrite(code, file) {
        const content = this.nativeRewriter.rewrite(code, file);
        cacheRewrittenSourceMap(file, content);
        return content;
      }
      csiMethods() {
        return this.nativeRewriter.csiMethods();
      }
    };
    __name(CacheRewriter, "CacheRewriter");
    function getRewriter() {
      try {
        const iastRewriter = require_wasm_iast_rewriter();
        NativeRewriter = iastRewriter.Rewriter;
        return CacheRewriter;
      } catch (e) {
        return DummyRewriter;
      }
    }
    __name(getRewriter, "getRewriter");
    module2.exports = {
      Rewriter: getRewriter(),
      getPrepareStackTrace
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/rewriter.js
var require_rewriter = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/rewriter.js"(exports2, module2) {
    "use strict";
    var Module = __require("module");
    var shimmer = require_datadog_shimmer();
    var log = require_log();
    var { isPrivateModule, isNotLibraryFile } = require_filter();
    var { csiMethods } = require_csi_methods();
    var rewriter;
    var getPrepareStackTrace;
    function getRewriter() {
      if (!rewriter) {
        try {
          const iastRewriter = require_main();
          const Rewriter = iastRewriter.Rewriter;
          getPrepareStackTrace = iastRewriter.getPrepareStackTrace;
          rewriter = new Rewriter({ csiMethods });
        } catch (e) {
          log.warn(`Unable to initialize TaintTracking Rewriter: ${e.message}`);
        }
      }
      return rewriter;
    }
    __name(getRewriter, "getRewriter");
    var originalPrepareStackTrace = Error.prepareStackTrace;
    function getPrepareStackTraceAccessor() {
      let actual = getPrepareStackTrace(originalPrepareStackTrace);
      return {
        get() {
          return actual;
        },
        set(value) {
          actual = getPrepareStackTrace(value);
          originalPrepareStackTrace = value;
        }
      };
    }
    __name(getPrepareStackTraceAccessor, "getPrepareStackTraceAccessor");
    function getCompileMethodFn(compileMethod) {
      return function(content, filename) {
        try {
          if (isPrivateModule(filename) && isNotLibraryFile(filename)) {
            content = rewriter.rewrite(content, filename);
          }
        } catch (e) {
          log.debug(e);
        }
        return compileMethod.apply(this, [content, filename]);
      };
    }
    __name(getCompileMethodFn, "getCompileMethodFn");
    function enableRewriter() {
      const rewriter2 = getRewriter();
      if (rewriter2) {
        Object.defineProperty(global.Error, "prepareStackTrace", getPrepareStackTraceAccessor());
        shimmer.wrap(Module.prototype, "_compile", (compileMethod) => getCompileMethodFn(compileMethod));
      }
    }
    __name(enableRewriter, "enableRewriter");
    function disableRewriter() {
      shimmer.unwrap(Module.prototype, "_compile");
      Error.prepareStackTrace = originalPrepareStackTrace;
    }
    __name(disableRewriter, "disableRewriter");
    module2.exports = {
      enableRewriter,
      disableRewriter
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/origin-types.js
var require_origin_types = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/origin-types.js"(exports2, module2) {
    module2.exports = {
      HTTP_REQUEST_BODY: "http.request.body",
      HTTP_REQUEST_PARAMETER: "http.request.parameter"
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/plugin.js
var require_plugin2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/plugin.js"(exports2, module2) {
    var Plugin = require_plugin();
    var { getIastContext } = require_iast_context();
    var { storage } = require_datadog_core();
    var { HTTP_REQUEST_PARAMETER, HTTP_REQUEST_BODY } = require_origin_types();
    var { taintObject } = require_operations();
    var TaintTrackingPlugin = class extends Plugin {
      constructor() {
        super();
        this._type = "taint-tracking";
        this.addSub(
          "datadog:body-parser:read:finish",
          ({ request }) => this._taintTrackingHandler(HTTP_REQUEST_BODY, request, "body")
        );
        this.addSub(
          "datadog:qs:parse:finish",
          ({ qs }) => this._taintTrackingHandler(HTTP_REQUEST_PARAMETER, qs)
        );
      }
      _taintTrackingHandler(type, target, property) {
        const iastContext = getIastContext(storage.getStore());
        if (!property) {
          target = taintObject(iastContext, target, type);
        } else {
          target[property] = taintObject(iastContext, target[property], type);
        }
      }
      enable() {
        this.configure(true);
      }
      disable() {
        this.configure(false);
      }
    };
    __name(TaintTrackingPlugin, "TaintTrackingPlugin");
    module2.exports = new TaintTrackingPlugin();
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/index.js
var require_taint_tracking = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/taint-tracking/index.js"(exports2, module2) {
    var { enableRewriter, disableRewriter } = require_rewriter();
    var { createTransaction, removeTransaction, enableTaintOperations, disableTaintOperations } = require_operations();
    var taintTrackingPlugin = require_plugin2();
    module2.exports = {
      enableTaintTracking() {
        enableRewriter();
        enableTaintOperations();
        taintTrackingPlugin.enable();
      },
      disableTaintTracking() {
        disableRewriter();
        disableTaintOperations();
        taintTrackingPlugin.disable();
      },
      createTransaction,
      removeTransaction
    };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/appsec/iast/index.js
var require_iast = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/appsec/iast/index.js"(exports2, module2) {
    var { sendVulnerabilities, setTracer } = require_vulnerability_reporter();
    var { enableAllAnalyzers, disableAllAnalyzers } = require_analyzers2();
    var web = require_web();
    var { storage } = require_datadog_core();
    var overheadController = require_overhead_controller();
    var dc = __require("diagnostics_channel");
    var iastContextFunctions = require_iast_context();
    var { enableTaintTracking, disableTaintTracking, createTransaction, removeTransaction } = require_taint_tracking();
    var IAST_ENABLED_TAG_KEY = "_dd.iast.enabled";
    var requestStart = dc.channel("dd-trace:incomingHttpRequestStart");
    var requestClose = dc.channel("dd-trace:incomingHttpRequestEnd");
    function enable(config, _tracer) {
      enableAllAnalyzers();
      enableTaintTracking();
      requestStart.subscribe(onIncomingHttpRequestStart);
      requestClose.subscribe(onIncomingHttpRequestEnd);
      overheadController.configure(config.iast);
      overheadController.startGlobalContext();
      setTracer(_tracer);
    }
    __name(enable, "enable");
    function disable() {
      disableAllAnalyzers();
      disableTaintTracking();
      overheadController.finishGlobalContext();
      if (requestStart.hasSubscribers)
        requestStart.unsubscribe(onIncomingHttpRequestStart);
      if (requestClose.hasSubscribers)
        requestClose.unsubscribe(onIncomingHttpRequestEnd);
    }
    __name(disable, "disable");
    function onIncomingHttpRequestStart(data) {
      if (data && data.req) {
        const store = storage.getStore();
        if (store) {
          const topContext = web.getContext(data.req);
          if (topContext) {
            const rootSpan = topContext.span;
            const isRequestAcquired = overheadController.acquireRequest(rootSpan);
            if (isRequestAcquired) {
              const iastContext = iastContextFunctions.saveIastContext(store, topContext, { rootSpan, req: data.req });
              createTransaction(rootSpan.context().toSpanId(), iastContext);
              overheadController.initializeRequestContext(iastContext);
            }
            if (rootSpan.addTags) {
              rootSpan.addTags({
                [IAST_ENABLED_TAG_KEY]: isRequestAcquired ? "1" : "0"
              });
            }
          }
        }
      }
    }
    __name(onIncomingHttpRequestStart, "onIncomingHttpRequestStart");
    function onIncomingHttpRequestEnd(data) {
      if (data && data.req) {
        const store = storage.getStore();
        const iastContext = iastContextFunctions.getIastContext(storage.getStore());
        if (iastContext && iastContext.rootSpan) {
          const vulnerabilities = iastContext.vulnerabilities;
          const rootSpan = iastContext.rootSpan;
          sendVulnerabilities(vulnerabilities, rootSpan);
          removeTransaction(iastContext);
        }
        if (iastContextFunctions.cleanIastContext(store, web.getContext(data.req), iastContext)) {
          overheadController.releaseRequest();
        }
      }
    }
    __name(onIncomingHttpRequestEnd, "onIncomingHttpRequestEnd");
    module2.exports = { enable, disable, onIncomingHttpRequestEnd, onIncomingHttpRequestStart };
  }
});

// node_modules/dd-trace/packages/dd-trace/src/proxy.js
var require_proxy2 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/proxy.js"(exports2, module2) {
    "use strict";
    var NoopProxy = require_proxy();
    var DatadogTracer = require_tracer3();
    var Config = require_config();
    var metrics = require_metrics();
    var log = require_log();
    var { setStartupLogPluginManager } = require_startup_log();
    var telemetry = require_telemetry();
    var PluginManager = require_plugin_manager();
    var remoteConfig = require_remote_config();
    var AppsecSdk = require_sdk();
    var Tracer = class extends NoopProxy {
      constructor() {
        super();
        this._initialized = false;
        this._pluginManager = new PluginManager(this);
      }
      init(options) {
        if (this._initialized)
          return this;
        this._initialized = true;
        try {
          const config = new Config(options);
          if (config.remoteConfig.enabled && !config.isCiVisibility) {
            remoteConfig.enable(config);
          }
          if (config.profiling.enabled) {
            try {
              const profiler = require_profiler2();
              profiler.start(config);
            } catch (e) {
              log.error(e);
            }
          }
          if (config.runtimeMetrics) {
            metrics.start(config);
          }
          if (config.tracing) {
            if (config.appsec.enabled) {
              require_appsec().enable(config);
            }
            this._tracer = new DatadogTracer(config);
            this.appsec = new AppsecSdk(this._tracer);
            if (config.iast.enabled) {
              require_iast().enable(config, this._tracer);
            }
            this._pluginManager.configure(config);
            setStartupLogPluginManager(this._pluginManager);
            telemetry.start(config, this._pluginManager);
          }
        } catch (e) {
          log.error(e);
        }
        return this;
      }
      use() {
        this._pluginManager.configurePlugin(...arguments);
        return this;
      }
    };
    __name(Tracer, "Tracer");
    module2.exports = Tracer;
  }
});

// node_modules/dd-trace/packages/dd-trace/src/index.js
var require_src50 = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/src/index.js"(exports2, module2) {
    "use strict";
    var { isFalse } = require_util();
    var inJestWorker = typeof jest !== "undefined";
    module2.exports = isFalse(process.env.DD_TRACE_ENABLED) || inJestWorker ? require_proxy() : require_proxy2();
  }
});

// node_modules/dd-trace/packages/dd-trace/index.js
var require_dd_trace = __commonJS({
  "node_modules/dd-trace/packages/dd-trace/index.js"(exports2, module2) {
    "use strict";
    if (!global._ddtrace) {
      const TracerProxy = require_src50();
      Object.defineProperty(global, "_ddtrace", {
        value: new TracerProxy(),
        enumerable: false,
        configurable: true,
        writable: true
      });
      global._ddtrace.default = global._ddtrace;
      global._ddtrace.tracer = global._ddtrace;
    }
    module2.exports = global._ddtrace;
  }
});

// node_modules/dd-trace/index.js
var require_dd_trace2 = __commonJS({
  "node_modules/dd-trace/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_dd_trace();
  }
});

// node_modules/hot-shots/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/hot-shots/lib/helpers.js"(exports2, module2) {
    var fs = __require("fs");
    function sanitizeTags(value, telegraf) {
      const blacklist = telegraf ? /:|\||,/g : /:|\||@|,/g;
      return String(value).replace(blacklist, "_");
    }
    __name(sanitizeTags, "sanitizeTags");
    function formatTags(tags, telegraf) {
      if (Array.isArray(tags)) {
        return tags;
      } else {
        return Object.keys(tags).map((key) => {
          return `${sanitizeTags(key, telegraf)}:${sanitizeTags(tags[key], telegraf)}`;
        });
      }
    }
    __name(formatTags, "formatTags");
    function overrideTags(parent, child, telegraf) {
      const childCopy = {};
      const toAppend = [];
      formatTags(child, telegraf).forEach((tag) => {
        const idx = typeof tag === "string" ? tag.indexOf(":") : -1;
        if (idx < 1) {
          toAppend.push(tag);
        } else {
          const key = tag.substring(0, idx);
          const value = tag.substring(idx + 1);
          childCopy[key] = childCopy[key] || [];
          childCopy[key].push(value);
        }
      });
      const result = parent.filter((tag) => {
        const idx = typeof tag === "string" ? tag.indexOf(":") : -1;
        if (idx < 1) {
          return true;
        }
        const key = tag.substring(0, idx);
        return !childCopy.hasOwnProperty(key);
      });
      Object.keys(childCopy).forEach((key) => {
        for (const value of childCopy[key]) {
          result.push(`${key}:${value}`);
        }
      });
      return result.concat(toAppend);
    }
    __name(overrideTags, "overrideTags");
    function formatDate(date) {
      let timestamp;
      if (date instanceof Date) {
        timestamp = Math.round(date.getTime() / 1e3);
      } else if (date instanceof Number || typeof date === "number") {
        timestamp = Math.round(date);
      }
      return timestamp;
    }
    __name(formatDate, "formatDate");
    function intToIP(int) {
      const part1 = int & 255;
      const part2 = int >> 8 & 255;
      const part3 = int >> 16 & 255;
      const part4 = int >> 24 & 255;
      return `${part4}.${part3}.${part2}.${part1}`;
    }
    __name(intToIP, "intToIP");
    function getDefaultRoute() {
      try {
        const fileContents = fs.readFileSync("/proc/net/route", "utf8");
        const routes = fileContents.split("\n");
        for (const routeIdx in routes) {
          const fields = routes[routeIdx].trim().split("	");
          if (fields[1] === "00000000") {
            const address = fields[2];
            const littleEndianAddress = address.match(/.{2}/g).reverse().join("");
            return intToIP(parseInt(littleEndianAddress, 16));
          }
        }
      } catch (e) {
        console.error("Could not get default route from /proc/net/route");
      }
      return null;
    }
    __name(getDefaultRoute, "getDefaultRoute");
    module2.exports = {
      formatTags,
      overrideTags,
      formatDate,
      getDefaultRoute,
      sanitizeTags
    };
  }
});

// node_modules/hot-shots/lib/statsFunctions.js
var require_statsFunctions = __commonJS({
  "node_modules/hot-shots/lib/statsFunctions.js"(exports2, module2) {
    var helpers = require_helpers();
    function applyStatsFns(Client) {
      Client.prototype.timing = function(stat, time, sampleRate, tags, callback) {
        const t = time instanceof Date ? new Date() - time : time;
        this.sendAll(stat, t, "ms", sampleRate, tags, callback);
      };
      Client.prototype.timer = function(func, stat, sampleRate, tags, callback) {
        const _this = this;
        return (...args) => {
          const start = process.hrtime();
          try {
            return func(...args);
          } finally {
            const durationComponents = process.hrtime(start);
            const seconds = durationComponents[0];
            const nanoseconds = durationComponents[1];
            const duration = seconds * 1e3 + nanoseconds / 1e6;
            _this.timing(
              stat,
              duration,
              sampleRate,
              tags,
              callback
            );
          }
        };
      };
      Client.prototype.asyncTimer = function(func, stat, sampleRate, tags, callback) {
        const self2 = this;
        return (...args) => {
          const end = hrtimer();
          const p = func(...args);
          const recordStat = /* @__PURE__ */ __name(() => {
            self2.timing(stat, end(), sampleRate, tags, callback);
          }, "recordStat");
          p.then(recordStat, recordStat);
          return p;
        };
      };
      Client.prototype.asyncDistTimer = function(func, stat, sampleRate, tags, callback) {
        const self2 = this;
        return (...args) => {
          const end = hrtimer();
          const p = func(...args);
          const recordStat = /* @__PURE__ */ __name(() => self2.distribution(stat, end(), sampleRate, tags, callback), "recordStat");
          p.then(recordStat, recordStat);
          return p;
        };
      };
      function hrtimer() {
        const start = process.hrtime();
        return () => {
          const durationComponents = process.hrtime(start);
          const seconds = durationComponents[0];
          const nanoseconds = durationComponents[1];
          const duration = seconds * 1e3 + nanoseconds / 1e6;
          return duration;
        };
      }
      __name(hrtimer, "hrtimer");
      Client.prototype.increment = function(stat, value, sampleRate, tags, callback) {
        if (arguments.length < 3) {
          if (typeof value !== "number") {
            tags = value;
            value = void 0;
          }
        }
        if (value === void 0 || value === null) {
          value = 1;
        }
        this.sendAll(stat, value, "c", sampleRate, tags, callback);
      };
      Client.prototype.decrement = function(stat, value, sampleRate, tags, callback) {
        if (arguments.length < 3) {
          if (typeof value !== "number") {
            tags = value;
            value = void 0;
          }
        }
        if (value === void 0 || value === null) {
          value = 1;
        }
        this.sendAll(stat, -value, "c", sampleRate, tags, callback);
      };
      Client.prototype.histogram = function(stat, value, sampleRate, tags, callback) {
        this.sendAll(stat, value, "h", sampleRate, tags, callback);
      };
      Client.prototype.distribution = function(stat, value, sampleRate, tags, callback) {
        this.sendAll(stat, value, "d", sampleRate, tags, callback);
      };
      Client.prototype.gauge = function(stat, value, sampleRate, tags, callback) {
        this.sendAll(stat, value, "g", sampleRate, tags, callback);
      };
      Client.prototype.unique = Client.prototype.set = function(stat, value, sampleRate, tags, callback) {
        this.sendAll(stat, value, "s", sampleRate, tags, callback);
      };
      Client.prototype.check = function(name, status, options, tags, callback) {
        if (this.telegraf) {
          const err = new Error("Not supported by Telegraf / InfluxDB");
          if (callback) {
            return callback(err);
          } else if (this.errorHandler) {
            return this.errorHandler(err);
          }
          throw err;
        }
        const check = ["_sc", this.prefix + name + this.suffix, status], metadata = options || {};
        if (metadata.date_happened) {
          const timestamp = helpers.formatDate(metadata.date_happened);
          if (timestamp) {
            check.push(`d:${timestamp}`);
          }
        }
        if (metadata.hostname) {
          check.push(`h:${metadata.hostname}`);
        }
        let mergedTags = this.globalTags;
        if (tags && typeof tags === "object") {
          mergedTags = helpers.overrideTags(mergedTags, tags, this.telegraf);
        }
        if (mergedTags.length > 0) {
          check.push(`#${mergedTags.join(",")}`);
        }
        if (metadata.message) {
          check.push(`m:${metadata.message}`);
        }
        if (typeof tags === "function" && callback === void 0) {
          callback = tags;
        }
        const message = check.join("|");
        this._send(message, callback);
      };
      Client.prototype.event = function(title, text, options, tags, callback) {
        if (this.telegraf) {
          const err = new Error("Not supported by Telegraf / InfluxDB");
          if (callback) {
            return callback(err);
          } else if (this.errorHandler) {
            return this.errorHandler(err);
          }
          throw err;
        }
        let message;
        const msgTitle = String(title ? title : "");
        let msgText = String(text ? text : msgTitle);
        msgText = msgText.replace(/\n/g, "\\n");
        message = `_e{${msgTitle.length},${msgText.length}}:${msgTitle}|${msgText}`;
        if (options) {
          if (options.date_happened) {
            const timestamp = helpers.formatDate(options.date_happened);
            if (timestamp) {
              message += `|d:${timestamp}`;
            }
          }
          if (options.hostname) {
            message += `|h:${options.hostname}`;
          }
          if (options.aggregation_key) {
            message += `|k:${options.aggregation_key}`;
          }
          if (options.priority) {
            message += `|p:${options.priority}`;
          }
          if (options.source_type_name) {
            message += `|s:${options.source_type_name}`;
          }
          if (options.alert_type) {
            message += `|t:${options.alert_type}`;
          }
        }
        if (typeof tags === "function" && callback === void 0) {
          callback = tags;
        }
        this.send(message, tags, callback);
      };
    }
    __name(applyStatsFns, "applyStatsFns");
    module2.exports = applyStatsFns;
  }
});

// node_modules/hot-shots/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/hot-shots/lib/constants.js"(exports2) {
    var os = __require("os");
    var process2 = __require("process");
    exports2.PROTOCOL = {
      TCP: "tcp",
      UDS: "uds",
      UDP: "udp",
      STREAM: "stream"
    };
    function udsErrors() {
      if (process2.platform === "linux") {
        return [
          os.constants.errno.ENOTCONN,
          os.constants.errno.ECONNREFUSED
        ];
      }
      if (process2.platform === "darwin") {
        return [
          os.constants.errno.EDESTADDRREQ,
          os.constants.errno.ECONNRESET
        ];
      }
      return [];
    }
    __name(udsErrors, "udsErrors");
    exports2.udsErrors = udsErrors;
  }
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "node_modules/file-uri-to-path/index.js"(exports2, module2) {
    var sep = __require("path").sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if ("string" != typeof uri || uri.length <= 7 || "file://" != uri.substring(0, 7)) {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if ("localhost" == host)
        host = "";
      if (host) {
        host = sep + sep + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host + path;
    }
    __name(fileUriToPath, "fileUriToPath");
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "node_modules/bindings/bindings.js"(exports2, module2) {
    var fs = __require("fs");
    var path = __require("path");
    var fileURLToPath = require_file_uri_to_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        ["module_root", "build", "bindings"],
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        ["module_root", "build", "default", "bindings"],
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i2) {
        if (!(i2 in opts))
          opts[i2] = defaults[i2];
      });
      if (!opts.module_root) {
        opts.module_root = exports2.getRoot(exports2.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join.apply(
          null,
          opts.try[i].map(function(p) {
            return opts[p] || p;
          })
        );
        tries.push(n);
        try {
          b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error(
        "Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
          return opts.arrow + a;
        }).join("\n")
      );
      err.tries = tries;
      throw err;
    }
    __name(bindings, "bindings");
    module2.exports = exports2 = bindings;
    exports2.getFileName = /* @__PURE__ */ __name(function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    }, "getFileName");
    exports2.getRoot = /* @__PURE__ */ __name(function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error(
            'Could not find module root given file: "' + file + '". Do you have a `package.json` file? '
          );
        }
        prev = dir;
        dir = join(dir, "..");
      }
    }, "getRoot");
  }
});

// node_modules/unix-dgram/lib/unix_dgram.js
var require_unix_dgram = __commonJS({
  "node_modules/unix-dgram/lib/unix_dgram.js"(exports2) {
    var events = __require("events");
    var dgram = __require("dgram");
    var util = __require("util");
    var binding = require_bindings()("unix_dgram.node");
    var SOCK_DGRAM = binding.SOCK_DGRAM;
    var AF_UNIX = binding.AF_UNIX;
    var socket = binding.socket || unsupported;
    var bind = binding.bind || unsupported;
    var connect = binding.connect || unsupported;
    var sendto = binding.sendto || unsupported;
    var send = binding.send || unsupported;
    var close = binding.close || unsupported;
    function unsupported() {
      throw new Error("Unix datagrams not available on this platform");
    }
    __name(unsupported, "unsupported");
    function errnoException(errorno, syscall) {
      var e = new Error(syscall + " " + errorno);
      e.errno = e.code = errorno;
      e.syscall = syscall;
      return e;
    }
    __name(errnoException, "errnoException");
    function internalError(code, msg) {
      var e = new Error(msg);
      e.code = code;
      return e;
    }
    __name(internalError, "internalError");
    function recv(status, buf, path) {
      var rinfo = {
        size: buf.length,
        address: {},
        path
      };
      this.emit("message", buf, rinfo);
    }
    __name(recv, "recv");
    function writable() {
      this.emit("writable");
    }
    __name(writable, "writable");
    exports2.createSocket = function(type, listener) {
      if (type == "udp4" || type == "udp6")
        return dgram.createSocket(type, listener);
      return new Socket(type, listener);
    };
    function Socket(type, listener) {
      if (type != "unix_dgram")
        throw new Error("Unsupported socket type: " + type);
      var err = socket(AF_UNIX, SOCK_DGRAM, 0, recv.bind(this), writable.bind(this));
      if (err < 0)
        throw errnoException(err, "socket");
      this.fd = err;
      this.type = type;
      if (typeof listener === "function")
        this.on("message", listener);
    }
    __name(Socket, "Socket");
    util.inherits(Socket, events.EventEmitter);
    Socket.prototype.bind = function(path) {
      var err = bind(this.fd, path);
      if (err < 0)
        this.emit("error", errnoException(err, "bind"));
      else
        this.emit("listening");
    };
    Socket.prototype.connect = function(path) {
      var err = connect(this.fd, path);
      if (err < 0) {
        this.emit("error", errnoException(err, "connect"));
      } else {
        this.connected = true;
        this.emit("connect");
      }
    };
    Socket.prototype.send = function(buf, offset, length, path, callback) {
      var err;
      if (this.connected) {
        err = send(this.fd, buf);
        callback = offset;
      } else {
        err = sendto(this.fd, buf, offset, length, path);
      }
      if (typeof callback === "function") {
        if (err < 0) {
          callback(errnoException(err, "send"));
        } else if (err === 1) {
          callback(internalError(err, "congestion"));
        } else {
          callback();
        }
      } else {
        if (err < 0) {
          this.emit("error", errnoException(err, "send"));
        } else if (err === 1) {
          this.emit("congestion", buf);
        }
      }
    };
    Socket.prototype.sendto = function(buf, offset, length, path, callback) {
      return this.send(buf, offset, length, path, callback);
    };
    Socket.prototype.close = function() {
      var err = close(this.fd);
      if (err < 0)
        throw new errnoException(err, "close");
      this.fd = -1;
    };
    Socket.prototype.address = function() {
      throw new Error("not implemented");
    };
    Socket.prototype.setTTL = function(ttl) {
      throw new Error("not implemented");
    };
    Socket.prototype.setBroadcast = function(flag) {
      throw new Error("not implemented");
    };
    Socket.prototype.setMulticastTTL = function(ttl) {
      throw new Error("not implemented");
    };
    Socket.prototype.setMulticastLoopback = function(flag) {
      throw new Error("not implemented");
    };
    Socket.prototype.addMembership = function(multicastAddress, multicastInterface) {
      throw new Error("not implemented");
    };
    Socket.prototype.dropMembership = function(multicastAddress, multicastInterface) {
      throw new Error("not implemented");
    };
  }
});

// node_modules/hot-shots/lib/transport.js
var require_transport = __commonJS({
  "node_modules/hot-shots/lib/transport.js"(exports2, module2) {
    var assert = __require("assert");
    var dgram = __require("dgram");
    var net = __require("net");
    var dns = __require("dns");
    var { PROTOCOL } = require_constants2();
    var unixDgram;
    var UDS_PATH_DEFAULT = "/var/run/datadog/dsd.socket";
    var addEol = /* @__PURE__ */ __name((buf) => {
      let msg = buf.toString();
      if (msg.length > 0 && msg[msg.length - 1] !== "\n") {
        msg += "\n";
      }
      return msg;
    }, "addEol");
    var createTcpTransport = /* @__PURE__ */ __name((args) => {
      const socket = net.connect(args.port, args.host);
      socket.setKeepAlive(true);
      socket.unref();
      return {
        emit: socket.emit.bind(socket),
        on: socket.on.bind(socket),
        removeListener: socket.removeListener.bind(socket),
        send: (buf, callback) => {
          socket.write(addEol(buf), "ascii", callback);
        },
        close: () => socket.destroy(),
        unref: socket.unref.bind(socket)
      };
    }, "createTcpTransport");
    var createUdpTransport = /* @__PURE__ */ __name((args) => {
      const socket = dgram.createSocket("udp4");
      socket.unref();
      const dnsResolutionData = {
        timestamp: new Date(0),
        resolvedAddress: void 0
      };
      const sendUsingDnsCache = /* @__PURE__ */ __name((callback, buf) => {
        const now = Date.now();
        if (dnsResolutionData.resolvedAddress === void 0 || now - dnsResolutionData.timestamp > args.cacheDnsTtl) {
          dns.lookup(args.host, (error, address) => {
            if (error) {
              callback(error);
              return;
            }
            dnsResolutionData.resolvedAddress = address;
            dnsResolutionData.timestamp = now;
            socket.send(buf, 0, buf.length, args.port, dnsResolutionData.resolvedAddress, callback);
          });
        } else {
          socket.send(buf, 0, buf.length, args.port, dnsResolutionData.resolvedAddress, callback);
        }
      }, "sendUsingDnsCache");
      return {
        emit: socket.emit.bind(socket),
        on: socket.on.bind(socket),
        removeListener: socket.removeListener.bind(socket),
        send: function(buf, callback) {
          if (args.cacheDns) {
            sendUsingDnsCache(callback, buf);
          } else {
            socket.send(buf, 0, buf.length, args.port, args.host, callback);
          }
        },
        close: socket.close.bind(socket),
        unref: socket.unref.bind(socket)
      };
    }, "createUdpTransport");
    var createUdsTransport = /* @__PURE__ */ __name((args) => {
      try {
        unixDgram = require_unix_dgram();
      } catch (err) {
        throw new Error(
          "The library `unix_dgram`, needed for the uds protocol to work, is not installed. You need to pick another protocol to use hot-shots. See the hot-shots README for additional details."
        );
      }
      const udsPath = args.path ? args.path : UDS_PATH_DEFAULT;
      const socket = unixDgram.createSocket("unix_dgram");
      try {
        socket.connect(udsPath);
      } catch (err) {
        socket.close();
        throw err;
      }
      return {
        emit: socket.emit.bind(socket),
        on: socket.on.bind(socket),
        removeListener: socket.removeListener.bind(socket),
        send: socket.send.bind(socket),
        close: () => {
          socket.close();
          socket.emit("close");
        },
        unref: () => {
          throw new Error("unix-dgram does not implement unref for sockets");
        }
      };
    }, "createUdsTransport");
    var createStreamTransport = /* @__PURE__ */ __name((args) => {
      const stream = args.stream;
      assert(stream, "`stream` option required");
      return {
        emit: stream.emit.bind(stream),
        on: stream.on.bind(stream),
        removeListener: stream.removeListener.bind(stream),
        send: (buf, callback) => stream.write(addEol(buf), callback),
        close: () => {
          stream.destroy();
          if (process.version.split(".").shift() === "v8") {
            stream.emit("close");
          }
        },
        unref: () => {
          throw new Error("stream transport does not support unref");
        }
      };
    }, "createStreamTransport");
    module2.exports = (instance, args) => {
      let transport = null;
      const protocol = args.protocol || PROTOCOL.UDP;
      try {
        if (protocol === PROTOCOL.TCP) {
          transport = createTcpTransport(args);
        } else if (protocol === PROTOCOL.UDS) {
          transport = createUdsTransport(args);
        } else if (protocol === PROTOCOL.UDP) {
          transport = createUdpTransport(args);
        } else if (protocol === PROTOCOL.STREAM) {
          transport = createStreamTransport(args);
        } else {
          throw new Error(`Unsupported protocol '${protocol}'`);
        }
        transport.type = protocol;
        transport.createdAt = Date.now();
      } catch (e) {
        if (instance.errorHandler) {
          instance.errorHandler(e);
        } else {
          console.error(e);
        }
      }
      return transport;
    };
  }
});

// node_modules/hot-shots/lib/statsd.js
var require_statsd = __commonJS({
  "node_modules/hot-shots/lib/statsd.js"(exports2, module2) {
    var process2 = __require("process");
    var util = __require("util");
    var helpers = require_helpers();
    var applyStatsFns = require_statsFunctions();
    var constants = require_constants2();
    var createTransport = require_transport();
    var PROTOCOL = constants.PROTOCOL;
    var UDS_ERROR_CODES = constants.udsErrors();
    var UDS_DEFAULT_GRACEFUL_RESTART_LIMIT = 1e3;
    var CACHE_DNS_TTL_DEFAULT = 6e4;
    var Client = /* @__PURE__ */ __name(function(host, port, prefix, suffix, globalize, cacheDns, mock, globalTags, maxBufferSize, bufferFlushInterval, telegraf, sampleRate, protocol) {
      let options = host || {};
      if (arguments.length > 1 || typeof host === "string") {
        options = {
          host,
          port,
          prefix,
          suffix,
          globalize,
          cacheDns,
          mock: mock === true,
          globalTags,
          maxBufferSize,
          bufferFlushInterval,
          telegraf,
          sampleRate,
          protocol
        };
      }
      options.globalTags = options.globalTags || options.global_tags;
      this.protocol = options.protocol && options.protocol.toLowerCase();
      if (!this.protocol) {
        this.protocol = PROTOCOL.UDP;
      }
      this.cacheDns = options.cacheDns === true;
      this.cacheDnsTtl = options.cacheDnsTtl || CACHE_DNS_TTL_DEFAULT;
      this.host = options.host || process2.env.DD_AGENT_HOST;
      this.port = options.port || parseInt(process2.env.DD_DOGSTATSD_PORT, 10) || 8125;
      this.path = options.path;
      this.stream = options.stream;
      this.prefix = options.prefix || "";
      this.suffix = options.suffix || "";
      this.tagPrefix = options.tagPrefix || "#";
      this.tagSeparator = options.tagSeparator || ",";
      this.mock = options.mock;
      this.globalTags = typeof options.globalTags === "object" ? helpers.formatTags(options.globalTags, options.telegraf) : [];
      if (process2.env.DD_ENTITY_ID) {
        this.globalTags = this.globalTags.filter((item) => {
          return item.indexOf("dd.internal.entity_id:") !== 0;
        });
        this.globalTags.push("dd.internal.entity_id:".concat(helpers.sanitizeTags(process2.env.DD_ENTITY_ID)));
      }
      this.telegraf = options.telegraf || false;
      this.maxBufferSize = options.maxBufferSize || 0;
      this.sampleRate = options.sampleRate || 1;
      this.bufferFlushInterval = options.bufferFlushInterval || 1e3;
      this.bufferHolder = options.isChild ? options.bufferHolder : { buffer: "" };
      this.errorHandler = options.errorHandler;
      this.udsGracefulErrorHandling = "udsGracefulErrorHandling" in options ? options.udsGracefulErrorHandling : true;
      this.udsGracefulRestartRateLimit = options.udsGracefulRestartRateLimit || UDS_DEFAULT_GRACEFUL_RESTART_LIMIT;
      this.isChild = options.isChild;
      this.closingFlushInterval = options.closingFlushInterval || 50;
      if (this.mock) {
        this.mockBuffer = [];
      }
      if (!options.isChild && this.maxBufferSize > 0) {
        this.intervalHandle = setInterval(this.onBufferFlushInterval.bind(this), this.bufferFlushInterval);
        this.intervalHandle.unref();
      }
      if (options.isChild) {
        if (options.dnsError) {
          this.dnsError = options.dnsError;
        }
        this.socket = options.socket;
      } else if (options.useDefaultRoute) {
        const defaultRoute = helpers.getDefaultRoute();
        if (defaultRoute) {
          console.log(`Got ${defaultRoute} for the system's default route`);
          this.host = defaultRoute;
        }
      }
      if (!this.socket) {
        trySetNewSocket(this);
      }
      if (this.socket && !options.isChild && options.errorHandler) {
        this.socket.on("error", options.errorHandler);
      }
      if (options.globalize) {
        global.statsd = this;
      }
      if (this.socket && options.protocol === PROTOCOL.UDS) {
        maybeAddUDSErrorHandler(this);
      }
      this.messagesInFlight = 0;
      this.CHECKS = {
        OK: 0,
        WARNING: 1,
        CRITICAL: 2,
        UNKNOWN: 3
      };
    }, "Client");
    applyStatsFns(Client);
    Client.prototype.sendAll = function(stat, value, type, sampleRate, tags, callback) {
      let completed = 0;
      let calledback = false;
      let sentBytes = 0;
      const self2 = this;
      if (sampleRate && typeof sampleRate !== "number") {
        callback = tags;
        tags = sampleRate;
        sampleRate = void 0;
      }
      if (tags && typeof tags !== "object") {
        callback = tags;
        tags = void 0;
      }
      function onSend(error, bytes) {
        completed += 1;
        if (calledback) {
          return;
        }
        if (error) {
          if (typeof callback === "function") {
            calledback = true;
            callback(error);
          } else if (self2.errorHandler) {
            calledback = true;
            self2.errorHandler(error);
          }
          return;
        }
        if (bytes) {
          sentBytes += bytes;
        }
        if (completed === stat.length && typeof callback === "function") {
          callback(null, sentBytes);
        }
      }
      __name(onSend, "onSend");
      if (Array.isArray(stat)) {
        stat.forEach((item) => {
          self2.sendStat(item, value, type, sampleRate, tags, onSend);
        });
      } else {
        this.sendStat(stat, value, type, sampleRate, tags, callback);
      }
    };
    Client.prototype.sendStat = function(stat, value, type, sampleRate, tags, callback) {
      let message = `${this.prefix + stat + this.suffix}:${value}|${type}`;
      sampleRate = sampleRate || this.sampleRate;
      if (sampleRate && sampleRate < 1) {
        if (Math.random() < sampleRate) {
          message += `|@${sampleRate}`;
        } else {
          return callback ? callback() : void 0;
        }
      }
      this.send(message, tags, callback);
    };
    Client.prototype.send = function(message, tags, callback) {
      let mergedTags = this.globalTags;
      if (tags && typeof tags === "object") {
        mergedTags = helpers.overrideTags(mergedTags, tags, this.telegraf);
      }
      if (mergedTags.length > 0) {
        if (this.telegraf) {
          message = message.split(":");
          message = `${message[0]},${mergedTags.join(",").replace(/:/g, "=")}:${message.slice(1).join(":")}`;
        } else {
          message += `|${this.tagPrefix}${mergedTags.join(this.tagSeparator)}`;
        }
      }
      this._send(message, callback);
    };
    Client.prototype._send = function(message, callback) {
      if (this.dnsError) {
        if (callback) {
          return callback(this.dnsError);
        } else if (this.errorHandler) {
          return this.errorHandler(this.dnsError);
        }
        throw this.dnsError;
      }
      if (!this.mock) {
        if (this.maxBufferSize === 0) {
          this.sendMessage(message, callback);
        } else {
          this.enqueue(message, callback);
        }
      } else {
        this.mockBuffer.push(message);
        if (typeof callback === "function") {
          callback(null, 0);
        }
      }
    };
    Client.prototype.enqueue = function(message, callback) {
      message += "\n";
      if (this.bufferHolder.buffer.length + message.length > this.maxBufferSize) {
        this.flushQueue(callback);
        this.bufferHolder.buffer += message;
      } else {
        this.bufferHolder.buffer += message;
        if (callback) {
          callback(null);
        }
      }
    };
    Client.prototype.flushQueue = function(callback) {
      this.sendMessage(this.bufferHolder.buffer, callback);
      this.bufferHolder.buffer = "";
    };
    Client.prototype.sendMessage = function(message, callback) {
      if (message === "") {
        if (callback) {
          callback(null);
        }
        return;
      }
      const socketWasMissing = !this.socket;
      if (socketWasMissing && this.protocol === PROTOCOL.UDS) {
        trySetNewSocket(this);
        if (this.socket) {
          maybeAddUDSErrorHandler(this, Date.now());
        }
      }
      if (socketWasMissing) {
        const error = new Error("Socket not created properly. Check previous errors for details.");
        if (callback) {
          return callback(error);
        } else if (this.errorHandler) {
          return this.errorHandler(error);
        } else {
          return console.error(String(error));
        }
      }
      const handleCallback = /* @__PURE__ */ __name((err, bytes) => {
        this.messagesInFlight--;
        const errFormatted = err ? new Error(`Error sending hot-shots message: ${err}`) : null;
        if (errFormatted) {
          errFormatted.code = err.code;
          if (this.protocol === PROTOCOL.UDS && (callback || this.errorHandler)) {
            udsErrorHandler(this, err);
          }
        }
        if (callback) {
          callback(errFormatted, bytes);
        } else if (errFormatted) {
          if (this.errorHandler) {
            this.errorHandler(errFormatted);
          } else {
            console.error(String(errFormatted));
            this.socket.emit("error", errFormatted);
          }
        }
      }, "handleCallback");
      try {
        this.messagesInFlight++;
        this.socket.send(Buffer.from(message), handleCallback);
      } catch (err) {
        handleCallback(err);
      }
    };
    Client.prototype.onBufferFlushInterval = function() {
      this.flushQueue();
    };
    Client.prototype.close = function(callback) {
      if (this.intervalHandle) {
        clearInterval(this.intervalHandle);
      }
      this.flushQueue((err) => {
        if (err) {
          if (callback) {
            return callback(err);
          } else {
            return console.error(err);
          }
        }
        let intervalAttempts = 0;
        const waitForMessages = setInterval(() => {
          intervalAttempts++;
          if (intervalAttempts > 10) {
            console.log("hot-shots could not clear out messages in flight but closing anyways");
            this.messagesInFlight = 0;
          }
          if (this.messagesInFlight <= 0) {
            clearInterval(waitForMessages);
            this._close(callback);
          }
        }, this.closingFlushInterval);
      });
    };
    Client.prototype._close = function(callback) {
      let handledError = false;
      const handleErr = /* @__PURE__ */ __name((err) => {
        const errMessage = `Error closing hot-shots socket: ${err}`;
        if (handledError) {
          console.error(errMessage);
        } else {
          handledError = true;
          if (callback) {
            callback(new Error(errMessage));
          } else if (this.errorHandler) {
            this.errorHandler(new Error(errMessage));
          } else {
            console.error(errMessage);
          }
        }
      }, "handleErr");
      if (this.errorHandler) {
        this.socket.removeListener("error", this.errorHandler);
      }
      this.socket.on("error", handleErr);
      if (callback) {
        this.socket.on("close", (err) => {
          if (!handledError && callback) {
            callback(err);
          }
        });
      }
      try {
        this.socket.close();
      } catch (err) {
        handleErr(err);
      }
    };
    var ChildClient = /* @__PURE__ */ __name(function(parent, options) {
      options = options || {};
      Client.call(this, {
        isChild: true,
        socket: parent.socket,
        bufferHolder: parent.bufferHolder,
        dnsError: parent.dnsError,
        errorHandler: options.errorHandler || parent.errorHandler,
        host: parent.host,
        port: parent.port,
        tagPrefix: parent.tagPrefix,
        tagSeparator: parent.tagSeparator,
        prefix: (options.prefix || "") + parent.prefix,
        suffix: parent.suffix + (options.suffix || ""),
        globalize: false,
        mock: parent.mock,
        globalTags: typeof options.globalTags === "object" ? helpers.overrideTags(parent.globalTags, options.globalTags, parent.telegraf) : parent.globalTags,
        maxBufferSize: parent.maxBufferSize,
        bufferFlushInterval: parent.bufferFlushInterval,
        telegraf: parent.telegraf,
        protocol: parent.protocol,
        closingFlushInterval: parent.closingFlushInterval
      });
    }, "ChildClient");
    util.inherits(ChildClient, Client);
    Client.prototype.childClient = function(options) {
      return new ChildClient(this, options);
    };
    exports2 = module2.exports = Client;
    exports2.StatsD = Client;
    function udsErrorHandler(client, err) {
      if (!err || !UDS_ERROR_CODES.includes(-err.code)) {
        return;
      }
      if (!client.socket.createdAt || Date.now() - client.socket.createdAt < client.udsGracefulRestartRateLimit) {
        return;
      }
      if (client.errorHandler) {
        client.socket.removeListener("error", client.errorHandler);
      }
      const newSocket = createTransport(client, {
        host: client.host,
        path: client.path,
        port: client.port,
        protocol: client.protocol
      });
      if (newSocket) {
        client.socket.close();
        client.socket = newSocket;
        maybeAddUDSErrorHandler(client);
      } else {
        const errorMessage = "Could not replace UDS connection with new socket";
        if (client.errorHandler) {
          client.errorHandler(new Error(errorMessage));
        } else {
          console.error(errorMessage);
        }
        return;
      }
      if (client.errorHandler) {
        client.socket.on("error", client.errorHandler);
      } else {
        client.socket.on("error", (error) => console.error(`hot-shots UDS error: ${error}`));
      }
    }
    __name(udsErrorHandler, "udsErrorHandler");
    function maybeAddUDSErrorHandler(client) {
      if (client.isChild || !client.udsGracefulErrorHandling) {
        return;
      }
      client.socket.on("error", (err) => {
        udsErrorHandler(client, err);
      });
    }
    __name(maybeAddUDSErrorHandler, "maybeAddUDSErrorHandler");
    function trySetNewSocket(client) {
      client.socket = createTransport(client, {
        host: client.host,
        cacheDns: client.cacheDns,
        cacheDnsTtl: client.cacheDnsTtl,
        path: client.path,
        port: client.port,
        protocol: client.protocol,
        stream: client.stream
      });
    }
    __name(trySetNewSocket, "trySetNewSocket");
  }
});

// node_modules/hot-shots/index.js
var require_hot_shots = __commonJS({
  "node_modules/hot-shots/index.js"(exports2, module2) {
    module2.exports = require_statsd();
  }
});

// node_modules/datadog-lambda-js/dist/utils/cold-start.js
var require_cold_start = __commonJS({
  "node_modules/datadog-lambda-js/dist/utils/cold-start.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._resetColdStart = exports2.getColdStartTag = exports2.didFunctionColdStart = exports2.setColdStart = void 0;
    var functionDidColdStart = true;
    var isColdStartSet = false;
    function setColdStart() {
      functionDidColdStart = !isColdStartSet;
      isColdStartSet = true;
    }
    __name(setColdStart, "setColdStart");
    exports2.setColdStart = setColdStart;
    function didFunctionColdStart() {
      return functionDidColdStart;
    }
    __name(didFunctionColdStart, "didFunctionColdStart");
    exports2.didFunctionColdStart = didFunctionColdStart;
    function getColdStartTag() {
      return "cold_start:".concat(didFunctionColdStart());
    }
    __name(getColdStartTag, "getColdStartTag");
    exports2.getColdStartTag = getColdStartTag;
    function _resetColdStart() {
      functionDidColdStart = true;
      isColdStartSet = false;
    }
    __name(_resetColdStart, "_resetColdStart");
    exports2._resetColdStart = _resetColdStart;
  }
});

// node_modules/serialize-error/index.js
var require_serialize_error = __commonJS({
  "node_modules/serialize-error/index.js"(exports2, module2) {
    "use strict";
    var NonError = class extends Error {
      constructor(message) {
        super(NonError._prepareSuperMessage(message));
        Object.defineProperty(this, "name", {
          value: "NonError",
          configurable: true,
          writable: true
        });
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, NonError);
        }
      }
      static _prepareSuperMessage(message) {
        try {
          return JSON.stringify(message);
        } catch {
          return String(message);
        }
      }
    };
    __name(NonError, "NonError");
    var commonProperties = [
      { property: "name", enumerable: false },
      { property: "message", enumerable: false },
      { property: "stack", enumerable: false },
      { property: "code", enumerable: true }
    ];
    var isCalled = Symbol(".toJSON called");
    var toJSON = /* @__PURE__ */ __name((from) => {
      from[isCalled] = true;
      const json = from.toJSON();
      delete from[isCalled];
      return json;
    }, "toJSON");
    var destroyCircular = /* @__PURE__ */ __name(({
      from,
      seen,
      to_,
      forceEnumerable,
      maxDepth,
      depth
    }) => {
      const to = to_ || (Array.isArray(from) ? [] : {});
      seen.push(from);
      if (depth >= maxDepth) {
        return to;
      }
      if (typeof from.toJSON === "function" && from[isCalled] !== true) {
        return toJSON(from);
      }
      for (const [key, value] of Object.entries(from)) {
        if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
          to[key] = "[object Buffer]";
          continue;
        }
        if (typeof value === "function") {
          continue;
        }
        if (!value || typeof value !== "object") {
          to[key] = value;
          continue;
        }
        if (!seen.includes(from[key])) {
          depth++;
          to[key] = destroyCircular({
            from: from[key],
            seen: seen.slice(),
            forceEnumerable,
            maxDepth,
            depth
          });
          continue;
        }
        to[key] = "[Circular]";
      }
      for (const { property, enumerable } of commonProperties) {
        if (typeof from[property] === "string") {
          Object.defineProperty(to, property, {
            value: from[property],
            enumerable: forceEnumerable ? true : enumerable,
            configurable: true,
            writable: true
          });
        }
      }
      return to;
    }, "destroyCircular");
    var serializeError = /* @__PURE__ */ __name((value, options = {}) => {
      const { maxDepth = Number.POSITIVE_INFINITY } = options;
      if (typeof value === "object" && value !== null) {
        return destroyCircular({
          from: value,
          seen: [],
          forceEnumerable: true,
          maxDepth,
          depth: 0
        });
      }
      if (typeof value === "function") {
        return `[Function: ${value.name || "anonymous"}]`;
      }
      return value;
    }, "serializeError");
    var deserializeError = /* @__PURE__ */ __name((value, options = {}) => {
      const { maxDepth = Number.POSITIVE_INFINITY } = options;
      if (value instanceof Error) {
        return value;
      }
      if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        const newError = new Error();
        destroyCircular({
          from: value,
          seen: [],
          to_: newError,
          maxDepth,
          depth: 0
        });
        return newError;
      }
      return new NonError(value);
    }, "deserializeError");
    module2.exports = {
      serializeError,
      deserializeError
    };
  }
});

// node_modules/datadog-lambda-js/dist/utils/log.js
var require_log4 = __commonJS({
  "node_modules/datadog-lambda-js/dist/utils/log.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logError = exports2.logDebug = exports2.getLogLevel = exports2.setLogLevel = exports2.setLogger = exports2.LogLevel = void 0;
    var serialize_error_1 = require_serialize_error();
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
      LogLevel2[LogLevel2["ERROR"] = 1] = "ERROR";
      LogLevel2[LogLevel2["NONE"] = 2] = "NONE";
    })(LogLevel = exports2.LogLevel || (exports2.LogLevel = {}));
    var logger = console;
    var logLevel = LogLevel.ERROR;
    function setLogger(customLogger) {
      logger = customLogger;
    }
    __name(setLogger, "setLogger");
    exports2.setLogger = setLogger;
    function setLogLevel(level) {
      logLevel = level;
    }
    __name(setLogLevel, "setLogLevel");
    exports2.setLogLevel = setLogLevel;
    function getLogLevel() {
      return logLevel;
    }
    __name(getLogLevel, "getLogLevel");
    exports2.getLogLevel = getLogLevel;
    function logDebug(message, metadata, error) {
      if (logLevel > LogLevel.DEBUG) {
        return;
      }
      emitLog(logger.debug, "debug", message, metadata, error);
    }
    __name(logDebug, "logDebug");
    exports2.logDebug = logDebug;
    function logError(message, metadata, error) {
      if (logLevel > LogLevel.ERROR) {
        return;
      }
      emitLog(logger.error, "error", message, metadata, error);
    }
    __name(logError, "logError");
    exports2.logError = logError;
    function emitLog(outputter, status, message, metadata, error) {
      message = "datadog:".concat(message);
      var output = { status, message };
      if (metadata instanceof Error && error === void 0) {
        error = metadata;
        metadata = void 0;
      }
      if (metadata !== void 0) {
        output = __assign(__assign({}, output), metadata);
      }
      if (error !== void 0) {
        var errorInfo = (0, serialize_error_1.serializeError)(error);
        output = __assign(__assign({}, output), errorInfo);
      }
      outputter(JSON.stringify(output));
    }
    __name(emitLog, "emitLog");
  }
});

// node_modules/datadog-lambda-js/dist/utils/handler.js
var require_handler2 = __commonJS({
  "node_modules/datadog-lambda-js/dist/utils/handler.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.promisifiedHandler = exports2.wrap = void 0;
    var log_1 = require_log4();
    function wrap(handler2, onStart, onComplete, onWrap) {
      var _this = this;
      var promHandler = promisifiedHandler(handler2);
      return function(event, context) {
        return __awaiter(_this, void 0, void 0, function() {
          var error_1, result, handlerError, wrappedHandler, error_2, error_3;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, onStart(event, context)];
              case 1:
                _a.sent();
                return [3, 3];
              case 2:
                error_1 = _a.sent();
                if (error_1 instanceof Error) {
                  (0, log_1.logError)("Pre-lambda hook threw error", error_1);
                }
                return [3, 3];
              case 3:
                wrappedHandler = promHandler;
                try {
                  wrappedHandler = onWrap !== void 0 ? onWrap(promHandler) : promHandler;
                } catch (error) {
                  if (error instanceof Error) {
                    (0, log_1.logError)("Failed to apply wrap to handler function", error);
                  }
                }
                _a.label = 4;
              case 4:
                _a.trys.push([4, 6, 7, 14]);
                return [4, wrappedHandler(event, context)];
              case 5:
                result = _a.sent();
                return [3, 14];
              case 6:
                error_2 = _a.sent();
                if (error_2 instanceof Error) {
                  handlerError = error_2;
                }
                throw error_2;
              case 7:
                _a.trys.push([7, 12, , 13]);
                if (!handlerError)
                  return [3, 9];
                return [4, onComplete(event, context, handlerError)];
              case 8:
                _a.sent();
                return [3, 11];
              case 9:
                return [4, onComplete(event, context)];
              case 10:
                _a.sent();
                _a.label = 11;
              case 11:
                return [3, 13];
              case 12:
                error_3 = _a.sent();
                if (error_3 instanceof Error) {
                  (0, log_1.logError)("Post-lambda hook threw error", error_3);
                }
                return [3, 13];
              case 13:
                return [7];
              case 14:
                return [2, result];
            }
          });
        });
      };
    }
    __name(wrap, "wrap");
    exports2.wrap = wrap;
    function promisifiedHandler(handler2) {
      return function(event, context) {
        var modifiedCallback = /* @__PURE__ */ __name(function() {
        }, "modifiedCallback");
        var modifiedLegacyDoneCallback = /* @__PURE__ */ __name(function() {
        }, "modifiedLegacyDoneCallback");
        var modifiedLegacySucceedCallback = /* @__PURE__ */ __name(function() {
        }, "modifiedLegacySucceedCallback");
        var modifiedLegacyFailCallback = /* @__PURE__ */ __name(function() {
        }, "modifiedLegacyFailCallback");
        var callbackProm = new Promise(function(resolve, reject) {
          modifiedCallback = /* @__PURE__ */ __name(function(err, result) {
            if (err !== void 0 && err !== null) {
              reject(err);
            } else {
              resolve(result);
            }
          }, "modifiedCallback");
          modifiedLegacyDoneCallback = /* @__PURE__ */ __name(function(err, result) {
            context.callbackWaitsForEmptyEventLoop = false;
            if (err !== void 0 && err !== null) {
              reject(err);
            } else {
              resolve(result);
            }
          }, "modifiedLegacyDoneCallback");
          modifiedLegacySucceedCallback = /* @__PURE__ */ __name(function(result) {
            context.callbackWaitsForEmptyEventLoop = false;
            resolve(result);
          }, "modifiedLegacySucceedCallback");
          modifiedLegacyFailCallback = /* @__PURE__ */ __name(function(err) {
            context.callbackWaitsForEmptyEventLoop = false;
            reject(err);
          }, "modifiedLegacyFailCallback");
        });
        context.done = modifiedLegacyDoneCallback;
        context.succeed = modifiedLegacySucceedCallback;
        context.fail = modifiedLegacyFailCallback;
        var asyncProm = handler2(event, context, modifiedCallback);
        var promise = callbackProm;
        if (asyncProm !== void 0 && typeof asyncProm.then === "function") {
          promise = Promise.race([callbackProm, asyncProm]);
        }
        return promise;
      };
    }
    __name(promisifiedHandler, "promisifiedHandler");
    exports2.promisifiedHandler = promisifiedHandler;
  }
});

// node_modules/datadog-lambda-js/dist/utils/timer.js
var require_timer = __commonJS({
  "node_modules/datadog-lambda-js/dist/utils/timer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timer = void 0;
    var Timer = function() {
      function Timer2(intervalMS) {
        this.intervalMS = intervalMS;
        this.isCompleted = false;
      }
      __name(Timer2, "Timer");
      Object.defineProperty(Timer2.prototype, "completed", {
        get: function() {
          return this.isCompleted;
        },
        enumerable: false,
        configurable: true
      });
      Timer2.prototype.start = function() {
        var _this = this;
        if (this.timer !== void 0) {
          return;
        }
        this.timer = setInterval(function() {
          if (_this.currentResolver !== void 0) {
            _this.currentResolver(false);
            _this.currentResolver = void 0;
            _this.currentPromise = void 0;
          }
        }, this.intervalMS);
      };
      Timer2.prototype.nextTimeout = function() {
        var _this = this;
        if (this.isCompleted) {
          return new Promise(function(resolve) {
            return resolve(true);
          });
        }
        if (this.currentPromise === void 0) {
          this.currentPromise = new Promise(function(resolver) {
            _this.currentResolver = resolver;
          });
        }
        return this.currentPromise;
      };
      Timer2.prototype.complete = function() {
        this.isCompleted = true;
        if (this.timer !== void 0) {
          clearInterval(this.timer);
          this.timer = void 0;
        }
        var currentResolver = this.currentResolver;
        this.currentResolver = void 0;
        this.currentPromise = void 0;
        if (currentResolver !== void 0) {
          currentResolver(true);
        }
      };
      return Timer2;
    }();
    exports2.Timer = Timer;
  }
});

// node_modules/datadog-lambda-js/dist/utils/request.js
var require_request2 = __commonJS({
  "node_modules/datadog-lambda-js/dist/utils/request.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.get = exports2.post = void 0;
    var https_1 = __importDefault(__require("https"));
    var http_1 = __importDefault(__require("http"));
    var log_1 = require_log4();
    function post(url, body, options) {
      var bodyJSON = JSON.stringify(body);
      var buffer = Buffer.from(bodyJSON);
      (0, log_1.logDebug)("sending payload with body ".concat(bodyJSON));
      var requestOptions = __assign({ headers: { "content-type": "application/json" }, host: url.host, hostname: url.hostname, method: "POST", path: "".concat(url.pathname).concat(url.search), port: url.port, protocol: url.protocol }, options);
      return sendRequest(url, requestOptions, buffer);
    }
    __name(post, "post");
    exports2.post = post;
    function get(url, options) {
      var requestOptions = __assign({ headers: { "content-type": "application/json" }, host: url.host, hostname: url.hostname, method: "GET", path: "".concat(url.pathname).concat(url.search), port: url.port, protocol: url.protocol }, options);
      return sendRequest(url, requestOptions);
    }
    __name(get, "get");
    exports2.get = get;
    function sendRequest(url, options, buffer) {
      return new Promise(function(resolve) {
        var requestMethod = url.protocol === "https:" ? https_1.default.request : http_1.default.request;
        var request = requestMethod(options, function(response) {
          var statusCode = response.statusCode;
          if (statusCode === void 0 || statusCode < 200 || statusCode > 299) {
            return resolve({
              success: false,
              statusCode,
              errorMessage: "HTTP error code: ".concat(response.statusCode)
            });
          }
          return resolve({
            success: true,
            statusCode
          });
        });
        request.on("error", function(error) {
          resolve({
            success: false,
            errorMessage: error.message
          });
        });
        if (buffer) {
          request.write(buffer);
        }
        request.end();
      });
    }
    __name(sendRequest, "sendRequest");
  }
});

// node_modules/datadog-lambda-js/dist/utils/tag-object.js
var require_tag_object = __commonJS({
  "node_modules/datadog-lambda-js/dist/utils/tag-object.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tagObject = void 0;
    var redactableKeys = ["authorization", "x-authorization", "password", "token"];
    var maxDepth = 10;
    function tagObject(currentSpan, key, obj, depth) {
      var e_1, _a;
      if (depth === void 0) {
        depth = 0;
      }
      if (depth >= maxDepth) {
        return;
      } else {
        depth += 1;
      }
      if (obj === null) {
        return currentSpan.setTag(key, obj);
      }
      if (typeof obj === "string") {
        var parsed = void 0;
        try {
          parsed = JSON.parse(obj);
        } catch (e) {
          var redacted = redactVal(key, obj.substring(0, 5e3));
          return currentSpan.setTag(key, redacted);
        }
        return tagObject(currentSpan, key, parsed, depth);
      }
      if (typeof obj === "number") {
        return currentSpan.setTag(key, obj);
      }
      if (typeof obj === "object") {
        try {
          for (var _b = __values(Object.entries(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), k = _d[0], v = _d[1];
            tagObject(currentSpan, "".concat(key, ".").concat(k), v, depth);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return;
      }
    }
    __name(tagObject, "tagObject");
    exports2.tagObject = tagObject;
    function redactVal(k, v) {
      var splitKey = k.split(".").pop() || k;
      if (redactableKeys.includes(splitKey)) {
        return "redacted";
      }
      return v;
    }
    __name(redactVal, "redactVal");
  }
});

// node_modules/datadog-lambda-js/dist/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/datadog-lambda-js/dist/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tagObject = exports2.post = exports2.get = exports2.LogLevel = exports2.setLogger = exports2.setLogLevel = exports2.logDebug = exports2.logError = exports2.Timer = exports2.promisifiedHandler = exports2.wrap = exports2.setColdStart = exports2.getColdStartTag = exports2.didFunctionColdStart = void 0;
    var cold_start_1 = require_cold_start();
    Object.defineProperty(exports2, "didFunctionColdStart", { enumerable: true, get: function() {
      return cold_start_1.didFunctionColdStart;
    } });
    Object.defineProperty(exports2, "getColdStartTag", { enumerable: true, get: function() {
      return cold_start_1.getColdStartTag;
    } });
    Object.defineProperty(exports2, "setColdStart", { enumerable: true, get: function() {
      return cold_start_1.setColdStart;
    } });
    var handler_1 = require_handler2();
    Object.defineProperty(exports2, "wrap", { enumerable: true, get: function() {
      return handler_1.wrap;
    } });
    Object.defineProperty(exports2, "promisifiedHandler", { enumerable: true, get: function() {
      return handler_1.promisifiedHandler;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports2, "Timer", { enumerable: true, get: function() {
      return timer_1.Timer;
    } });
    var log_1 = require_log4();
    Object.defineProperty(exports2, "logError", { enumerable: true, get: function() {
      return log_1.logError;
    } });
    Object.defineProperty(exports2, "logDebug", { enumerable: true, get: function() {
      return log_1.logDebug;
    } });
    Object.defineProperty(exports2, "setLogLevel", { enumerable: true, get: function() {
      return log_1.setLogLevel;
    } });
    Object.defineProperty(exports2, "setLogger", { enumerable: true, get: function() {
      return log_1.setLogger;
    } });
    Object.defineProperty(exports2, "LogLevel", { enumerable: true, get: function() {
      return log_1.LogLevel;
    } });
    var request_1 = require_request2();
    Object.defineProperty(exports2, "get", { enumerable: true, get: function() {
      return request_1.get;
    } });
    Object.defineProperty(exports2, "post", { enumerable: true, get: function() {
      return request_1.post;
    } });
    var tag_object_1 = require_tag_object();
    Object.defineProperty(exports2, "tagObject", { enumerable: true, get: function() {
      return tag_object_1.tagObject;
    } });
  }
});

// node_modules/datadog-lambda-js/dist/metrics/api.js
var require_api = __commonJS({
  "node_modules/datadog-lambda-js/dist/metrics/api.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.APIClient = void 0;
    var querystring_1 = __importDefault(__require("querystring"));
    var url_1 = __require("url");
    var utils_1 = require_utils2();
    var API_KEY_QUERY_PARAM = "api_key";
    var FORBIDDEN_HTTP_STATUS_CODE = 403;
    var APIClient = function() {
      function APIClient2(apiKey, baseAPIURL) {
        this.apiKey = apiKey;
        this.baseAPIURL = baseAPIURL;
      }
      __name(APIClient2, "APIClient");
      APIClient2.prototype.sendMetrics = function(metrics) {
        return __awaiter(this, void 0, void 0, function() {
          var result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, (0, utils_1.post)(this.getUrl("api/v1/distribution_points"), { series: metrics })];
              case 1:
                result = _a.sent();
                if (result.success) {
                  return [2];
                }
                if (result.statusCode === FORBIDDEN_HTTP_STATUS_CODE) {
                  (0, utils_1.logDebug)("authorization failed when sending metrics, please check validity of API key");
                }
                (0, utils_1.logDebug)("failed attempt to send metrics to Datadog. ".concat(result.errorMessage, " "));
                throw result.errorMessage;
            }
          });
        });
      };
      APIClient2.prototype.getUrl = function(path) {
        var _a;
        var url = new url_1.URL(path, this.baseAPIURL);
        (0, utils_1.logDebug)("sending metadata to api endpoint ".concat(url.toString()));
        url.search = querystring_1.default.stringify((_a = {}, _a[API_KEY_QUERY_PARAM] = this.apiKey, _a));
        return url;
      };
      return APIClient2;
    }();
    exports2.APIClient = APIClient;
  }
});

// node_modules/datadog-lambda-js/dist/metrics/extension.js
var require_extension = __commonJS({
  "node_modules/datadog-lambda-js/dist/metrics/extension.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flushExtension = exports2.isAgentRunning = exports2.AGENT_URL = void 0;
    var url_1 = __require("url");
    var utils_1 = require_utils2();
    var fs_1 = __importDefault(__require("fs"));
    exports2.AGENT_URL = "http://127.0.0.1:8124";
    var HELLO_PATH = "/lambda/hello";
    var FLUSH_PATH = "/lambda/flush";
    var EXTENSION_PATH = "/opt/extensions/datadog-agent";
    var AGENT_TIMEOUT_MS = 100;
    function isAgentRunning() {
      return __awaiter(this, void 0, void 0, function() {
        var extensionExists, url, result;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, fileExists(EXTENSION_PATH)];
            case 1:
              extensionExists = _a.sent();
              if (!extensionExists) {
                (0, utils_1.logDebug)("Agent isn't present in sandbox");
                return [2, false];
              }
              url = new url_1.URL(HELLO_PATH, exports2.AGENT_URL);
              return [4, (0, utils_1.get)(url, { timeout: AGENT_TIMEOUT_MS })];
            case 2:
              result = _a.sent();
              if (!result.success) {
                (0, utils_1.logDebug)("Could not connect to agent. ".concat(result.errorMessage));
                return [2, false];
              }
              return [2, true];
          }
        });
      });
    }
    __name(isAgentRunning, "isAgentRunning");
    exports2.isAgentRunning = isAgentRunning;
    function flushExtension() {
      return __awaiter(this, void 0, void 0, function() {
        var url, result;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              url = new url_1.URL(FLUSH_PATH, exports2.AGENT_URL);
              return [4, (0, utils_1.post)(url, {}, { timeout: AGENT_TIMEOUT_MS })];
            case 1:
              result = _a.sent();
              if (!result.success) {
                (0, utils_1.logError)("Failed to flush extension. ".concat(result.errorMessage));
                return [2, false];
              }
              return [2, true];
          }
        });
      });
    }
    __name(flushExtension, "flushExtension");
    exports2.flushExtension = flushExtension;
    function fileExists(filename) {
      return fs_1.default.promises.access(filename, fs_1.default.constants.F_OK).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
    }
    __name(fileExists, "fileExists");
  }
});

// node_modules/datadog-lambda-js/dist/metrics/metric-log.js
var require_metric_log = __commonJS({
  "node_modules/datadog-lambda-js/dist/metrics/metric-log.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.writeMetricToStdout = exports2.buildMetricLog = void 0;
    function buildMetricLog(name, value, metricTime, tags) {
      return "".concat(JSON.stringify({
        e: metricTime.getTime() / 1e3,
        m: name,
        t: tags,
        v: value
      }), "\n");
    }
    __name(buildMetricLog, "buildMetricLog");
    exports2.buildMetricLog = buildMetricLog;
    function writeMetricToStdout(name, value, metricTime, tags) {
      process.stdout.write(buildMetricLog(name, value, metricTime, tags));
    }
    __name(writeMetricToStdout, "writeMetricToStdout");
    exports2.writeMetricToStdout = writeMetricToStdout;
  }
});

// node_modules/datadog-lambda-js/dist/metrics/model.js
var require_model = __commonJS({
  "node_modules/datadog-lambda-js/dist/metrics/model.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDistribution = exports2.Distribution = void 0;
    var Distribution = function() {
      function Distribution2(name, points) {
        var tags = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          tags[_i - 2] = arguments[_i];
        }
        this.name = name;
        this.points = points;
        this.metricType = "distribution";
        this.tags = tags;
      }
      __name(Distribution2, "Distribution");
      Distribution2.prototype.toAPIMetrics = function() {
        var points = this.points.map(function(point) {
          var unixSeconds = Math.floor(point.timestamp.getTime() / 1e3);
          return [unixSeconds, [point.value]];
        });
        return [
          {
            metric: this.name,
            points,
            tags: this.tags,
            type: this.metricType
          }
        ];
      };
      Distribution2.prototype.union = function(metric) {
        if (!isDistribution(metric)) {
          return this;
        }
        var distribution = new Distribution2(this.name, this.points);
        Object.assign(distribution, __assign(__assign({}, this), { points: __spreadArray(__spreadArray([], __read(this.points), false), __read(metric.points), false) }));
        return distribution;
      };
      return Distribution2;
    }();
    exports2.Distribution = Distribution;
    function isDistribution(metric) {
      return metric.metricType === "distribution";
    }
    __name(isDistribution, "isDistribution");
    exports2.isDistribution = isDistribution;
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    __name(assign, "assign");
    function createError(err, code, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code === "object") {
        props = code;
        code = void 0;
      }
      if (code != null) {
        props.code = code;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = /* @__PURE__ */ __name(function() {
        }, "ErrClass");
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        return assign(new ErrClass(), props);
      }
    }
    __name(createError, "createError");
    module2.exports = createError;
  }
});

// node_modules/promise-retry/node_modules/retry/lib/retry_operation.js
var require_retry_operation2 = __commonJS({
  "node_modules/promise-retry/node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    __name(RetryOperation, "RetryOperation");
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/promise-retry/node_modules/retry/lib/retry.js
var require_retry3 = __commonJS({
  "node_modules/promise-retry/node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation2();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }, "retryWrapper")).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/promise-retry/node_modules/retry/index.js
var require_retry4 = __commonJS({
  "node_modules/promise-retry/node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry3();
  }
});

// node_modules/promise-retry/index.js
var require_promise_retry = __commonJS({
  "node_modules/promise-retry/index.js"(exports2, module2) {
    "use strict";
    var errcode = require_err_code();
    var retry = require_retry4();
    var hasOwn = Object.prototype.hasOwnProperty;
    function isRetryError(err) {
      return err && err.code === "EPROMISERETRY" && hasOwn.call(err, "retried");
    }
    __name(isRetryError, "isRetryError");
    function promiseRetry(fn, options) {
      var temp;
      var operation;
      if (typeof fn === "object" && typeof options === "function") {
        temp = options;
        options = fn;
        fn = temp;
      }
      operation = retry.operation(options);
      return new Promise(function(resolve, reject) {
        operation.attempt(function(number) {
          Promise.resolve().then(function() {
            return fn(function(err) {
              if (isRetryError(err)) {
                err = err.retried;
              }
              throw errcode(new Error("Retrying"), "EPROMISERETRY", { retried: err });
            }, number);
          }).then(resolve, function(err) {
            if (isRetryError(err)) {
              err = err.retried;
              if (operation.retry(err || new Error())) {
                return;
              }
            }
            reject(err);
          });
        });
      });
    }
    __name(promiseRetry, "promiseRetry");
    module2.exports = promiseRetry;
  }
});

// node_modules/datadog-lambda-js/dist/metrics/batcher.js
var require_batcher = __commonJS({
  "node_modules/datadog-lambda-js/dist/metrics/batcher.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Batcher = void 0;
    var Batcher = function() {
      function Batcher2() {
        this.metrics = /* @__PURE__ */ new Map();
      }
      __name(Batcher2, "Batcher");
      Batcher2.prototype.add = function(metric) {
        var key = this.getBatchKey(metric);
        var result = this.metrics.get(key);
        if (result !== void 0) {
          metric = result.union(metric);
        }
        this.metrics.set(key, metric);
      };
      Batcher2.prototype.toAPIMetrics = function() {
        return __spreadArray([], __read(this.metrics.values()), false).map(function(metric) {
          return metric.toAPIMetrics();
        }).reduce(function(prev, curr) {
          return prev.concat(curr);
        }, []);
      };
      Batcher2.prototype.getBatchKey = function(metric) {
        return JSON.stringify({
          host: metric.host,
          metricType: metric.metricType,
          name: metric.name,
          tags: __spreadArray([], __read(metric.tags), false).sort()
        });
      };
      return Batcher2;
    }();
    exports2.Batcher = Batcher;
  }
});

// node_modules/datadog-lambda-js/dist/metrics/processor.js
var require_processor = __commonJS({
  "node_modules/datadog-lambda-js/dist/metrics/processor.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Processor = void 0;
    var promise_retry_1 = __importDefault(require_promise_retry());
    var utils_1 = require_utils2();
    var batcher_1 = require_batcher();
    var defaultRetryIntervalMS = 250;
    var Processor = function() {
      function Processor2(client, intervalMS, shouldRetryOnFail, retryInterval) {
        if (retryInterval === void 0) {
          retryInterval = defaultRetryIntervalMS;
        }
        this.client = client;
        this.shouldRetryOnFail = shouldRetryOnFail;
        this.retryInterval = retryInterval;
        this.batcher = new batcher_1.Batcher();
        this.timer = new utils_1.Timer(intervalMS);
      }
      __name(Processor2, "Processor");
      Processor2.prototype.startProcessing = function() {
        if (this.loopPromise !== void 0) {
          return;
        }
        this.timer.start();
        this.loopPromise = this.sendMetricsLoop();
      };
      Processor2.prototype.addMetric = function(metric) {
        this.batcher.add(metric);
      };
      Processor2.prototype.flush = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this.timer.complete();
                if (this.loopPromise === void 0) {
                  this.loopPromise = this.sendMetricsLoop();
                }
                return [4, this.loopPromise];
              case 1:
                _a.sent();
                return [2];
            }
          });
        });
      };
      Processor2.prototype.sendMetricsLoop = function() {
        return __awaiter(this, void 0, void 0, function() {
          var oldBatcher, metrics, _a, finalMetrics, options, _b;
          var _this = this;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                return [4, this.timer.nextTimeout()];
              case 1:
                if (!!_c.sent())
                  return [3, 6];
                oldBatcher = this.batcher;
                this.batcher = new batcher_1.Batcher();
                metrics = oldBatcher.toAPIMetrics();
                if (metrics.length === 0) {
                  return [3, 0];
                }
                _c.label = 2;
              case 2:
                _c.trys.push([2, 4, , 5]);
                return [4, this.client.sendMetrics(metrics)];
              case 3:
                _c.sent();
                return [3, 5];
              case 4:
                _a = _c.sent();
                if (this.shouldRetryOnFail) {
                  this.batcher = oldBatcher;
                }
                return [3, 5];
              case 5:
                return [3, 0];
              case 6:
                finalMetrics = this.batcher.toAPIMetrics();
                if (finalMetrics.length === 0) {
                  return [2];
                }
                _c.label = 7;
              case 7:
                _c.trys.push([7, 9, , 10]);
                options = {
                  maxTimeout: this.retryInterval,
                  minTimeout: this.retryInterval,
                  retries: this.shouldRetryOnFail ? 2 : 0
                };
                return [4, (0, promise_retry_1.default)(options, function(retry) {
                  return _this.client.sendMetrics(finalMetrics).catch(retry);
                })];
              case 8:
                _c.sent();
                return [3, 10];
              case 9:
                _b = _c.sent();
                throw Error("Failed to send metrics to Datadog");
              case 10:
                return [2];
            }
          });
        });
      };
      return Processor2;
    }();
    exports2.Processor = Processor;
  }
});

// node_modules/datadog-lambda-js/dist/metrics/listener.js
var require_listener = __commonJS({
  "node_modules/datadog-lambda-js/dist/metrics/listener.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetricsListener = void 0;
    var hot_shots_1 = require_hot_shots();
    var util_1 = __require("util");
    var utils_1 = require_utils2();
    var api_1 = require_api();
    var extension_1 = require_extension();
    var metric_log_1 = require_metric_log();
    var model_1 = require_model();
    var processor_1 = require_processor();
    var metricsBatchSendIntervalMS = 1e4;
    var MetricsListener = function() {
      function MetricsListener2(kmsClient, config) {
        this.kmsClient = kmsClient;
        this.config = config;
        this.isAgentRunning = void 0;
        this.apiKey = this.getAPIKey(config);
        this.config = config;
      }
      __name(MetricsListener2, "MetricsListener");
      MetricsListener2.prototype.onStartInvocation = function(_) {
        return __awaiter(this, void 0, void 0, function() {
          var _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!(this.isAgentRunning === void 0))
                  return [3, 2];
                _a = this;
                return [4, (0, extension_1.isAgentRunning)()];
              case 1:
                _a.isAgentRunning = _b.sent();
                (0, utils_1.logDebug)("Extension present: ".concat(this.isAgentRunning));
                _b.label = 2;
              case 2:
                if (this.isAgentRunning) {
                  (0, utils_1.logDebug)("Using StatsD client");
                  this.statsDClient = new hot_shots_1.StatsD({ host: "127.0.0.1", closingFlushInterval: 1 });
                  return [2];
                }
                if (this.config.logForwarding) {
                  (0, utils_1.logDebug)("logForwarding configured");
                  return [2];
                }
                this.currentProcessor = this.createProcessor(this.config, this.apiKey);
                return [2];
            }
          });
        });
      };
      MetricsListener2.prototype.onCompleteInvocation = function() {
        return __awaiter(this, void 0, void 0, function() {
          var processor, error_1, error_2;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                _a.trys.push([0, 7, , 8]);
                if (!(this.currentProcessor !== void 0))
                  return [3, 4];
                return [4, this.currentProcessor];
              case 1:
                processor = _a.sent();
                return [4, (0, util_1.promisify)(setImmediate)()];
              case 2:
                _a.sent();
                return [4, processor.flush()];
              case 3:
                _a.sent();
                _a.label = 4;
              case 4:
                if (!(this.statsDClient !== void 0))
                  return [3, 6];
                (0, utils_1.logDebug)("Flushing statsD");
                return [4, new Promise(function(resolve, reject) {
                  var _a2;
                  (_a2 = _this.statsDClient) === null || _a2 === void 0 ? void 0 : _a2.close(function(error) {
                    if (error !== void 0) {
                      reject(error);
                    }
                    resolve();
                  });
                })];
              case 5:
                _a.sent();
                this.statsDClient = void 0;
                _a.label = 6;
              case 6:
                return [3, 8];
              case 7:
                error_1 = _a.sent();
                if (error_1 instanceof Error) {
                  (0, utils_1.logError)("failed to flush metrics", error_1);
                }
                return [3, 8];
              case 8:
                _a.trys.push([8, 11, , 12]);
                if (!this.isAgentRunning)
                  return [3, 10];
                (0, utils_1.logDebug)("Flushing Extension");
                return [4, (0, extension_1.flushExtension)()];
              case 9:
                _a.sent();
                _a.label = 10;
              case 10:
                return [3, 12];
              case 11:
                error_2 = _a.sent();
                if (error_2 instanceof Error) {
                  (0, utils_1.logError)("failed to flush extension", error_2);
                }
                return [3, 12];
              case 12:
                this.currentProcessor = void 0;
                return [2];
            }
          });
        });
      };
      MetricsListener2.prototype.sendDistributionMetricWithDate = function(name, value, metricTime, forceAsync) {
        var _a;
        var tags = [];
        for (var _i = 4; _i < arguments.length; _i++) {
          tags[_i - 4] = arguments[_i];
        }
        if (this.isAgentRunning) {
          (_a = this.statsDClient) === null || _a === void 0 ? void 0 : _a.distribution(name, value, void 0, tags);
          return;
        }
        if (this.config.logForwarding || forceAsync) {
          (0, metric_log_1.writeMetricToStdout)(name, value, metricTime, tags);
          return;
        }
        var dist = new (model_1.Distribution.bind.apply(model_1.Distribution, __spreadArray([void 0, name, [{ timestamp: metricTime, value }]], __read(tags), false)))();
        if (!this.apiKey) {
          var errorMessage = "api key not configured, see https://dtdg.co/sls-node-metrics";
          (0, utils_1.logError)(errorMessage);
          return;
        }
        if (this.currentProcessor !== void 0) {
          this.currentProcessor.then(function(processor) {
            processor.addMetric(dist);
          });
        } else {
          (0, utils_1.logError)("can't send metrics, datadog lambda handler not set up.");
        }
      };
      MetricsListener2.prototype.sendDistributionMetric = function(name, value, forceAsync) {
        var tags = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          tags[_i - 3] = arguments[_i];
        }
        this.sendDistributionMetricWithDate.apply(this, __spreadArray([name, value, new Date(Date.now()), forceAsync], __read(tags), false));
      };
      MetricsListener2.prototype.createProcessor = function(config, apiKey) {
        return __awaiter(this, void 0, void 0, function() {
          var key, url, apiClient, processor;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, apiKey];
              case 1:
                key = _a.sent();
                url = "https://api.".concat(config.siteURL);
                apiClient = new api_1.APIClient(key, url);
                processor = new processor_1.Processor(apiClient, metricsBatchSendIntervalMS, config.shouldRetryMetrics);
                processor.startProcessing();
                return [2, processor];
            }
          });
        });
      };
      MetricsListener2.prototype.getAPIKey = function(config) {
        return __awaiter(this, void 0, void 0, function() {
          var error_3;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (config.apiKey !== "") {
                  return [2, config.apiKey];
                }
                if (!(config.apiKeyKMS !== ""))
                  return [3, 4];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this.kmsClient.decrypt(config.apiKeyKMS)];
              case 2:
                return [2, _a.sent()];
              case 3:
                error_3 = _a.sent();
                if (error_3 instanceof Error) {
                  (0, utils_1.logError)("couldn't decrypt kms api key", error_3);
                }
                return [3, 4];
              case 4:
                return [2, ""];
            }
          });
        });
      };
      return MetricsListener2;
    }();
    exports2.MetricsListener = MetricsListener;
  }
});

// node_modules/aws-sdk/lib/json/builder.js
var require_builder = __commonJS({
  "node_modules/aws-sdk/lib/json/builder.js"(exports2, module2) {
    var util = require_util9();
    function JsonBuilder() {
    }
    __name(JsonBuilder, "JsonBuilder");
    JsonBuilder.prototype.build = function(value, shape) {
      return JSON.stringify(translate(value, shape));
    };
    function translate(value, shape) {
      if (!shape || value === void 0 || value === null)
        return void 0;
      switch (shape.type) {
        case "structure":
          return translateStructure(value, shape);
        case "map":
          return translateMap(value, shape);
        case "list":
          return translateList(value, shape);
        default:
          return translateScalar(value, shape);
      }
    }
    __name(translate, "translate");
    function translateStructure(structure, shape) {
      if (shape.isDocument) {
        return structure;
      }
      var struct = {};
      util.each(structure, function(name, value) {
        var memberShape = shape.members[name];
        if (memberShape) {
          if (memberShape.location !== "body")
            return;
          var locationName = memberShape.isLocationName ? memberShape.name : name;
          var result = translate(value, memberShape);
          if (result !== void 0)
            struct[locationName] = result;
        }
      });
      return struct;
    }
    __name(translateStructure, "translateStructure");
    function translateList(list, shape) {
      var out = [];
      util.arrayEach(list, function(value) {
        var result = translate(value, shape.member);
        if (result !== void 0)
          out.push(result);
      });
      return out;
    }
    __name(translateList, "translateList");
    function translateMap(map, shape) {
      var out = {};
      util.each(map, function(key, value) {
        var result = translate(value, shape.value);
        if (result !== void 0)
          out[key] = result;
      });
      return out;
    }
    __name(translateMap, "translateMap");
    function translateScalar(value, shape) {
      return shape.toWireFormat(value);
    }
    __name(translateScalar, "translateScalar");
    module2.exports = JsonBuilder;
  }
});

// node_modules/aws-sdk/lib/json/parser.js
var require_parser2 = __commonJS({
  "node_modules/aws-sdk/lib/json/parser.js"(exports2, module2) {
    var util = require_util9();
    function JsonParser() {
    }
    __name(JsonParser, "JsonParser");
    JsonParser.prototype.parse = function(value, shape) {
      return translate(JSON.parse(value), shape);
    };
    function translate(value, shape) {
      if (!shape || value === void 0)
        return void 0;
      switch (shape.type) {
        case "structure":
          return translateStructure(value, shape);
        case "map":
          return translateMap(value, shape);
        case "list":
          return translateList(value, shape);
        default:
          return translateScalar(value, shape);
      }
    }
    __name(translate, "translate");
    function translateStructure(structure, shape) {
      if (structure == null)
        return void 0;
      if (shape.isDocument)
        return structure;
      var struct = {};
      var shapeMembers = shape.members;
      util.each(shapeMembers, function(name, memberShape) {
        var locationName = memberShape.isLocationName ? memberShape.name : name;
        if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
          var value = structure[locationName];
          var result = translate(value, memberShape);
          if (result !== void 0)
            struct[name] = result;
        }
      });
      return struct;
    }
    __name(translateStructure, "translateStructure");
    function translateList(list, shape) {
      if (list == null)
        return void 0;
      var out = [];
      util.arrayEach(list, function(value) {
        var result = translate(value, shape.member);
        if (result === void 0)
          out.push(null);
        else
          out.push(result);
      });
      return out;
    }
    __name(translateList, "translateList");
    function translateMap(map, shape) {
      if (map == null)
        return void 0;
      var out = {};
      util.each(map, function(key, value) {
        var result = translate(value, shape.value);
        if (result === void 0)
          out[key] = null;
        else
          out[key] = result;
      });
      return out;
    }
    __name(translateMap, "translateMap");
    function translateScalar(value, shape) {
      return shape.toType(value);
    }
    __name(translateScalar, "translateScalar");
    module2.exports = JsonParser;
  }
});

// node_modules/aws-sdk/lib/protocol/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/aws-sdk/lib/protocol/helpers.js"(exports2, module2) {
    var util = require_util9();
    var AWS2 = require_core();
    function populateHostPrefix(request) {
      var enabled = request.service.config.hostPrefixEnabled;
      if (!enabled)
        return request;
      var operationModel = request.service.api.operations[request.operation];
      if (hasEndpointDiscover(request))
        return request;
      if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
        var hostPrefixNotation = operationModel.endpoint.hostPrefix;
        var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
        prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
        validateHostname(request.httpRequest.endpoint.hostname);
      }
      return request;
    }
    __name(populateHostPrefix, "populateHostPrefix");
    function hasEndpointDiscover(request) {
      var api = request.service.api;
      var operationModel = api.operations[request.operation];
      var isEndpointOperation = api.endpointOperation && api.endpointOperation === util.string.lowerFirst(operationModel.name);
      return operationModel.endpointDiscoveryRequired !== "NULL" || isEndpointOperation === true;
    }
    __name(hasEndpointDiscover, "hasEndpointDiscover");
    function expandHostPrefix(hostPrefixNotation, params, shape) {
      util.each(shape.members, function(name, member) {
        if (member.hostLabel === true) {
          if (typeof params[name] !== "string" || params[name] === "") {
            throw util.error(new Error(), {
              message: "Parameter " + name + " should be a non-empty string.",
              code: "InvalidParameter"
            });
          }
          var regex = new RegExp("\\{" + name + "\\}", "g");
          hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
        }
      });
      return hostPrefixNotation;
    }
    __name(expandHostPrefix, "expandHostPrefix");
    function prependEndpointPrefix(endpoint, prefix) {
      if (endpoint.host) {
        endpoint.host = prefix + endpoint.host;
      }
      if (endpoint.hostname) {
        endpoint.hostname = prefix + endpoint.hostname;
      }
    }
    __name(prependEndpointPrefix, "prependEndpointPrefix");
    function validateHostname(hostname) {
      var labels = hostname.split(".");
      var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
      util.arrayEach(labels, function(label) {
        if (!label.length || label.length < 1 || label.length > 63) {
          throw util.error(new Error(), {
            code: "ValidationError",
            message: "Hostname label length should be between 1 to 63 characters, inclusive."
          });
        }
        if (!hostPattern.test(label)) {
          throw AWS2.util.error(
            new Error(),
            { code: "ValidationError", message: label + " is not hostname compatible." }
          );
        }
      });
    }
    __name(validateHostname, "validateHostname");
    module2.exports = {
      populateHostPrefix
    };
  }
});

// node_modules/aws-sdk/lib/protocol/json.js
var require_json = __commonJS({
  "node_modules/aws-sdk/lib/protocol/json.js"(exports2, module2) {
    var util = require_util9();
    var JsonBuilder = require_builder();
    var JsonParser = require_parser2();
    var populateHostPrefix = require_helpers2().populateHostPrefix;
    function buildRequest(req) {
      var httpRequest = req.httpRequest;
      var api = req.service.api;
      var target = api.targetPrefix + "." + api.operations[req.operation].name;
      var version = api.jsonVersion || "1.0";
      var input = api.operations[req.operation].input;
      var builder = new JsonBuilder();
      if (version === 1)
        version = "1.0";
      httpRequest.body = builder.build(req.params || {}, input);
      httpRequest.headers["Content-Type"] = "application/x-amz-json-" + version;
      httpRequest.headers["X-Amz-Target"] = target;
      populateHostPrefix(req);
    }
    __name(buildRequest, "buildRequest");
    function extractError(resp) {
      var error = {};
      var httpResponse = resp.httpResponse;
      error.code = httpResponse.headers["x-amzn-errortype"] || "UnknownError";
      if (typeof error.code === "string") {
        error.code = error.code.split(":")[0];
      }
      if (httpResponse.body.length > 0) {
        try {
          var e = JSON.parse(httpResponse.body.toString());
          var code = e.__type || e.code || e.Code;
          if (code) {
            error.code = code.split("#").pop();
          }
          if (error.code === "RequestEntityTooLarge") {
            error.message = "Request body must be less than 1 MB";
          } else {
            error.message = e.message || e.Message || null;
          }
        } catch (e2) {
          error.statusCode = httpResponse.statusCode;
          error.message = httpResponse.statusMessage;
        }
      } else {
        error.statusCode = httpResponse.statusCode;
        error.message = httpResponse.statusCode.toString();
      }
      resp.error = util.error(new Error(), error);
    }
    __name(extractError, "extractError");
    function extractData(resp) {
      var body = resp.httpResponse.body.toString() || "{}";
      if (resp.request.service.config.convertResponseTypes === false) {
        resp.data = JSON.parse(body);
      } else {
        var operation = resp.request.service.api.operations[resp.request.operation];
        var shape = operation.output || {};
        var parser = new JsonParser();
        resp.data = parser.parse(body, shape);
      }
    }
    __name(extractData, "extractData");
    module2.exports = {
      buildRequest,
      extractError,
      extractData
    };
  }
});

// node_modules/aws-sdk/lib/query/query_param_serializer.js
var require_query_param_serializer = __commonJS({
  "node_modules/aws-sdk/lib/query/query_param_serializer.js"(exports2, module2) {
    var util = require_util9();
    function QueryParamSerializer() {
    }
    __name(QueryParamSerializer, "QueryParamSerializer");
    QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
      serializeStructure("", params, shape, fn);
    };
    function ucfirst(shape) {
      if (shape.isQueryName || shape.api.protocol !== "ec2") {
        return shape.name;
      } else {
        return shape.name[0].toUpperCase() + shape.name.substr(1);
      }
    }
    __name(ucfirst, "ucfirst");
    function serializeStructure(prefix, struct, rules, fn) {
      util.each(rules.members, function(name, member) {
        var value = struct[name];
        if (value === null || value === void 0)
          return;
        var memberName = ucfirst(member);
        memberName = prefix ? prefix + "." + memberName : memberName;
        serializeMember(memberName, value, member, fn);
      });
    }
    __name(serializeStructure, "serializeStructure");
    function serializeMap(name, map, rules, fn) {
      var i = 1;
      util.each(map, function(key, value) {
        var prefix = rules.flattened ? "." : ".entry.";
        var position = prefix + i++ + ".";
        var keyName = position + (rules.key.name || "key");
        var valueName = position + (rules.value.name || "value");
        serializeMember(name + keyName, key, rules.key, fn);
        serializeMember(name + valueName, value, rules.value, fn);
      });
    }
    __name(serializeMap, "serializeMap");
    function serializeList(name, list, rules, fn) {
      var memberRules = rules.member || {};
      if (list.length === 0) {
        fn.call(this, name, null);
        return;
      }
      util.arrayEach(list, function(v, n) {
        var suffix = "." + (n + 1);
        if (rules.api.protocol === "ec2") {
          suffix = suffix + "";
        } else if (rules.flattened) {
          if (memberRules.name) {
            var parts = name.split(".");
            parts.pop();
            parts.push(ucfirst(memberRules));
            name = parts.join(".");
          }
        } else {
          suffix = "." + (memberRules.name ? memberRules.name : "member") + suffix;
        }
        serializeMember(name + suffix, v, memberRules, fn);
      });
    }
    __name(serializeList, "serializeList");
    function serializeMember(name, value, rules, fn) {
      if (value === null || value === void 0)
        return;
      if (rules.type === "structure") {
        serializeStructure(name, value, rules, fn);
      } else if (rules.type === "list") {
        serializeList(name, value, rules, fn);
      } else if (rules.type === "map") {
        serializeMap(name, value, rules, fn);
      } else {
        fn(name, rules.toWireFormat(value).toString());
      }
    }
    __name(serializeMember, "serializeMember");
    module2.exports = QueryParamSerializer;
  }
});

// node_modules/aws-sdk/lib/model/collection.js
var require_collection = __commonJS({
  "node_modules/aws-sdk/lib/model/collection.js"(exports2, module2) {
    var memoizedProperty = require_util9().memoizedProperty;
    function memoize(name, value, factory, nameTr) {
      memoizedProperty(this, nameTr(name), function() {
        return factory(name, value);
      });
    }
    __name(memoize, "memoize");
    function Collection(iterable, options, factory, nameTr, callback) {
      nameTr = nameTr || String;
      var self2 = this;
      for (var id in iterable) {
        if (Object.prototype.hasOwnProperty.call(iterable, id)) {
          memoize.call(self2, id, iterable[id], factory, nameTr);
          if (callback)
            callback(id, iterable[id]);
        }
      }
    }
    __name(Collection, "Collection");
    module2.exports = Collection;
  }
});

// node_modules/aws-sdk/lib/model/shape.js
var require_shape = __commonJS({
  "node_modules/aws-sdk/lib/model/shape.js"(exports2, module2) {
    var Collection = require_collection();
    var util = require_util9();
    function property(obj, name, value) {
      if (value !== null && value !== void 0) {
        util.property.apply(this, arguments);
      }
    }
    __name(property, "property");
    function memoizedProperty(obj, name) {
      if (!obj.constructor.prototype[name]) {
        util.memoizedProperty.apply(this, arguments);
      }
    }
    __name(memoizedProperty, "memoizedProperty");
    function Shape(shape, options, memberName) {
      options = options || {};
      property(this, "shape", shape.shape);
      property(this, "api", options.api, false);
      property(this, "type", shape.type);
      property(this, "enum", shape.enum);
      property(this, "min", shape.min);
      property(this, "max", shape.max);
      property(this, "pattern", shape.pattern);
      property(this, "location", shape.location || this.location || "body");
      property(this, "name", this.name || shape.xmlName || shape.queryName || shape.locationName || memberName);
      property(this, "isStreaming", shape.streaming || this.isStreaming || false);
      property(this, "requiresLength", shape.requiresLength, false);
      property(this, "isComposite", shape.isComposite || false);
      property(this, "isShape", true, false);
      property(this, "isQueryName", Boolean(shape.queryName), false);
      property(this, "isLocationName", Boolean(shape.locationName), false);
      property(this, "isIdempotent", shape.idempotencyToken === true);
      property(this, "isJsonValue", shape.jsonvalue === true);
      property(this, "isSensitive", shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
      property(this, "isEventStream", Boolean(shape.eventstream), false);
      property(this, "isEvent", Boolean(shape.event), false);
      property(this, "isEventPayload", Boolean(shape.eventpayload), false);
      property(this, "isEventHeader", Boolean(shape.eventheader), false);
      property(this, "isTimestampFormatSet", Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
      property(this, "endpointDiscoveryId", Boolean(shape.endpointdiscoveryid), false);
      property(this, "hostLabel", Boolean(shape.hostLabel), false);
      if (options.documentation) {
        property(this, "documentation", shape.documentation);
        property(this, "documentationUrl", shape.documentationUrl);
      }
      if (shape.xmlAttribute) {
        property(this, "isXmlAttribute", shape.xmlAttribute || false);
      }
      property(this, "defaultValue", null);
      this.toWireFormat = function(value) {
        if (value === null || value === void 0)
          return "";
        return value;
      };
      this.toType = function(value) {
        return value;
      };
    }
    __name(Shape, "Shape");
    Shape.normalizedTypes = {
      character: "string",
      double: "float",
      long: "integer",
      short: "integer",
      biginteger: "integer",
      bigdecimal: "float",
      blob: "binary"
    };
    Shape.types = {
      "structure": StructureShape,
      "list": ListShape,
      "map": MapShape,
      "boolean": BooleanShape,
      "timestamp": TimestampShape,
      "float": FloatShape,
      "integer": IntegerShape,
      "string": StringShape,
      "base64": Base64Shape,
      "binary": BinaryShape
    };
    Shape.resolve = /* @__PURE__ */ __name(function resolve(shape, options) {
      if (shape.shape) {
        var refShape = options.api.shapes[shape.shape];
        if (!refShape) {
          throw new Error("Cannot find shape reference: " + shape.shape);
        }
        return refShape;
      } else {
        return null;
      }
    }, "resolve");
    Shape.create = /* @__PURE__ */ __name(function create(shape, options, memberName) {
      if (shape.isShape)
        return shape;
      var refShape = Shape.resolve(shape, options);
      if (refShape) {
        var filteredKeys = Object.keys(shape);
        if (!options.documentation) {
          filteredKeys = filteredKeys.filter(function(name) {
            return !name.match(/documentation/);
          });
        }
        var InlineShape = /* @__PURE__ */ __name(function() {
          refShape.constructor.call(this, shape, options, memberName);
        }, "InlineShape");
        InlineShape.prototype = refShape;
        return new InlineShape();
      } else {
        if (!shape.type) {
          if (shape.members)
            shape.type = "structure";
          else if (shape.member)
            shape.type = "list";
          else if (shape.key)
            shape.type = "map";
          else
            shape.type = "string";
        }
        var origType = shape.type;
        if (Shape.normalizedTypes[shape.type]) {
          shape.type = Shape.normalizedTypes[shape.type];
        }
        if (Shape.types[shape.type]) {
          return new Shape.types[shape.type](shape, options, memberName);
        } else {
          throw new Error("Unrecognized shape type: " + origType);
        }
      }
    }, "create");
    function CompositeShape(shape) {
      Shape.apply(this, arguments);
      property(this, "isComposite", true);
      if (shape.flattened) {
        property(this, "flattened", shape.flattened || false);
      }
    }
    __name(CompositeShape, "CompositeShape");
    function StructureShape(shape, options) {
      var self2 = this;
      var requiredMap = null, firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, "defaultValue", function() {
          return {};
        });
        property(this, "members", {});
        property(this, "memberNames", []);
        property(this, "required", []);
        property(this, "isRequired", function() {
          return false;
        });
        property(this, "isDocument", Boolean(shape.document));
      }
      if (shape.members) {
        property(this, "members", new Collection(shape.members, options, function(name, member) {
          return Shape.create(member, options, name);
        }));
        memoizedProperty(this, "memberNames", function() {
          return shape.xmlOrder || Object.keys(shape.members);
        });
        if (shape.event) {
          memoizedProperty(this, "eventPayloadMemberName", function() {
            var members = self2.members;
            var memberNames = self2.memberNames;
            for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
              if (members[memberNames[i]].isEventPayload) {
                return memberNames[i];
              }
            }
          });
          memoizedProperty(this, "eventHeaderMemberNames", function() {
            var members = self2.members;
            var memberNames = self2.memberNames;
            var eventHeaderMemberNames = [];
            for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
              if (members[memberNames[i]].isEventHeader) {
                eventHeaderMemberNames.push(memberNames[i]);
              }
            }
            return eventHeaderMemberNames;
          });
        }
      }
      if (shape.required) {
        property(this, "required", shape.required);
        property(this, "isRequired", function(name) {
          if (!requiredMap) {
            requiredMap = {};
            for (var i = 0; i < shape.required.length; i++) {
              requiredMap[shape.required[i]] = true;
            }
          }
          return requiredMap[name];
        }, false, true);
      }
      property(this, "resultWrapper", shape.resultWrapper || null);
      if (shape.payload) {
        property(this, "payload", shape.payload);
      }
      if (typeof shape.xmlNamespace === "string") {
        property(this, "xmlNamespaceUri", shape.xmlNamespace);
      } else if (typeof shape.xmlNamespace === "object") {
        property(this, "xmlNamespacePrefix", shape.xmlNamespace.prefix);
        property(this, "xmlNamespaceUri", shape.xmlNamespace.uri);
      }
    }
    __name(StructureShape, "StructureShape");
    function ListShape(shape, options) {
      var self2 = this, firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, "defaultValue", function() {
          return [];
        });
      }
      if (shape.member) {
        memoizedProperty(this, "member", function() {
          return Shape.create(shape.member, options);
        });
      }
      if (this.flattened) {
        var oldName = this.name;
        memoizedProperty(this, "name", function() {
          return self2.member.name || oldName;
        });
      }
    }
    __name(ListShape, "ListShape");
    function MapShape(shape, options) {
      var firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, "defaultValue", function() {
          return {};
        });
        property(this, "key", Shape.create({ type: "string" }, options));
        property(this, "value", Shape.create({ type: "string" }, options));
      }
      if (shape.key) {
        memoizedProperty(this, "key", function() {
          return Shape.create(shape.key, options);
        });
      }
      if (shape.value) {
        memoizedProperty(this, "value", function() {
          return Shape.create(shape.value, options);
        });
      }
    }
    __name(MapShape, "MapShape");
    function TimestampShape(shape) {
      var self2 = this;
      Shape.apply(this, arguments);
      if (shape.timestampFormat) {
        property(this, "timestampFormat", shape.timestampFormat);
      } else if (self2.isTimestampFormatSet && this.timestampFormat) {
        property(this, "timestampFormat", this.timestampFormat);
      } else if (this.location === "header") {
        property(this, "timestampFormat", "rfc822");
      } else if (this.location === "querystring") {
        property(this, "timestampFormat", "iso8601");
      } else if (this.api) {
        switch (this.api.protocol) {
          case "json":
          case "rest-json":
            property(this, "timestampFormat", "unixTimestamp");
            break;
          case "rest-xml":
          case "query":
          case "ec2":
            property(this, "timestampFormat", "iso8601");
            break;
        }
      }
      this.toType = function(value) {
        if (value === null || value === void 0)
          return null;
        if (typeof value.toUTCString === "function")
          return value;
        return typeof value === "string" || typeof value === "number" ? util.date.parseTimestamp(value) : null;
      };
      this.toWireFormat = function(value) {
        return util.date.format(value, self2.timestampFormat);
      };
    }
    __name(TimestampShape, "TimestampShape");
    function StringShape() {
      Shape.apply(this, arguments);
      var nullLessProtocols = ["rest-xml", "query", "ec2"];
      this.toType = function(value) {
        value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ? value || "" : value;
        if (this.isJsonValue) {
          return JSON.parse(value);
        }
        return value && typeof value.toString === "function" ? value.toString() : value;
      };
      this.toWireFormat = function(value) {
        return this.isJsonValue ? JSON.stringify(value) : value;
      };
    }
    __name(StringShape, "StringShape");
    function FloatShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        if (value === null || value === void 0)
          return null;
        return parseFloat(value);
      };
      this.toWireFormat = this.toType;
    }
    __name(FloatShape, "FloatShape");
    function IntegerShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        if (value === null || value === void 0)
          return null;
        return parseInt(value, 10);
      };
      this.toWireFormat = this.toType;
    }
    __name(IntegerShape, "IntegerShape");
    function BinaryShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        var buf = util.base64.decode(value);
        if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === "function") {
          var secureBuf = util.Buffer.alloc(buf.length, buf);
          buf.fill(0);
          buf = secureBuf;
        }
        return buf;
      };
      this.toWireFormat = util.base64.encode;
    }
    __name(BinaryShape, "BinaryShape");
    function Base64Shape() {
      BinaryShape.apply(this, arguments);
    }
    __name(Base64Shape, "Base64Shape");
    function BooleanShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        if (typeof value === "boolean")
          return value;
        if (value === null || value === void 0)
          return null;
        return value === "true";
      };
    }
    __name(BooleanShape, "BooleanShape");
    Shape.shapes = {
      StructureShape,
      ListShape,
      MapShape,
      StringShape,
      BooleanShape,
      Base64Shape
    };
    module2.exports = Shape;
  }
});

// node_modules/aws-sdk/lib/protocol/query.js
var require_query = __commonJS({
  "node_modules/aws-sdk/lib/protocol/query.js"(exports2, module2) {
    var AWS2 = require_core();
    var util = require_util9();
    var QueryParamSerializer = require_query_param_serializer();
    var Shape = require_shape();
    var populateHostPrefix = require_helpers2().populateHostPrefix;
    function buildRequest(req) {
      var operation = req.service.api.operations[req.operation];
      var httpRequest = req.httpRequest;
      httpRequest.headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
      httpRequest.params = {
        Version: req.service.api.apiVersion,
        Action: operation.name
      };
      var builder = new QueryParamSerializer();
      builder.serialize(req.params, operation.input, function(name, value) {
        httpRequest.params[name] = value;
      });
      httpRequest.body = util.queryParamsToString(httpRequest.params);
      populateHostPrefix(req);
    }
    __name(buildRequest, "buildRequest");
    function extractError(resp) {
      var data, body = resp.httpResponse.body.toString();
      if (body.match("<UnknownOperationException")) {
        data = {
          Code: "UnknownOperation",
          Message: "Unknown operation " + resp.request.operation
        };
      } else {
        try {
          data = new AWS2.XML.Parser().parse(body);
        } catch (e) {
          data = {
            Code: resp.httpResponse.statusCode,
            Message: resp.httpResponse.statusMessage
          };
        }
      }
      if (data.requestId && !resp.requestId)
        resp.requestId = data.requestId;
      if (data.Errors)
        data = data.Errors;
      if (data.Error)
        data = data.Error;
      if (data.Code) {
        resp.error = util.error(new Error(), {
          code: data.Code,
          message: data.Message
        });
      } else {
        resp.error = util.error(new Error(), {
          code: resp.httpResponse.statusCode,
          message: null
        });
      }
    }
    __name(extractError, "extractError");
    function extractData(resp) {
      var req = resp.request;
      var operation = req.service.api.operations[req.operation];
      var shape = operation.output || {};
      var origRules = shape;
      if (origRules.resultWrapper) {
        var tmp = Shape.create({ type: "structure" });
        tmp.members[origRules.resultWrapper] = shape;
        tmp.memberNames = [origRules.resultWrapper];
        util.property(shape, "name", shape.resultWrapper);
        shape = tmp;
      }
      var parser = new AWS2.XML.Parser();
      if (shape && shape.members && !shape.members._XAMZRequestId) {
        var requestIdShape = Shape.create(
          { type: "string" },
          { api: { protocol: "query" } },
          "requestId"
        );
        shape.members._XAMZRequestId = requestIdShape;
      }
      var data = parser.parse(resp.httpResponse.body.toString(), shape);
      resp.requestId = data._XAMZRequestId || data.requestId;
      if (data._XAMZRequestId)
        delete data._XAMZRequestId;
      if (origRules.resultWrapper) {
        if (data[origRules.resultWrapper]) {
          util.update(data, data[origRules.resultWrapper]);
          delete data[origRules.resultWrapper];
        }
      }
      resp.data = data;
    }
    __name(extractData, "extractData");
    module2.exports = {
      buildRequest,
      extractError,
      extractData
    };
  }
});

// node_modules/aws-sdk/lib/protocol/rest.js
var require_rest = __commonJS({
  "node_modules/aws-sdk/lib/protocol/rest.js"(exports2, module2) {
    var util = require_util9();
    var populateHostPrefix = require_helpers2().populateHostPrefix;
    function populateMethod(req) {
      req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
    }
    __name(populateMethod, "populateMethod");
    function generateURI(endpointPath, operationPath, input, params) {
      var uri = [endpointPath, operationPath].join("/");
      uri = uri.replace(/\/+/g, "/");
      var queryString = {}, queryStringSet = false;
      util.each(input.members, function(name, member) {
        var paramValue = params[name];
        if (paramValue === null || paramValue === void 0)
          return;
        if (member.location === "uri") {
          var regex = new RegExp("\\{" + member.name + "(\\+)?\\}");
          uri = uri.replace(regex, function(_, plus) {
            var fn = plus ? util.uriEscapePath : util.uriEscape;
            return fn(String(paramValue));
          });
        } else if (member.location === "querystring") {
          queryStringSet = true;
          if (member.type === "list") {
            queryString[member.name] = paramValue.map(function(val) {
              return util.uriEscape(member.member.toWireFormat(val).toString());
            });
          } else if (member.type === "map") {
            util.each(paramValue, function(key, value) {
              if (Array.isArray(value)) {
                queryString[key] = value.map(function(val) {
                  return util.uriEscape(String(val));
                });
              } else {
                queryString[key] = util.uriEscape(String(value));
              }
            });
          } else {
            queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
          }
        }
      });
      if (queryStringSet) {
        uri += uri.indexOf("?") >= 0 ? "&" : "?";
        var parts = [];
        util.arrayEach(Object.keys(queryString).sort(), function(key) {
          if (!Array.isArray(queryString[key])) {
            queryString[key] = [queryString[key]];
          }
          for (var i = 0; i < queryString[key].length; i++) {
            parts.push(util.uriEscape(String(key)) + "=" + queryString[key][i]);
          }
        });
        uri += parts.join("&");
      }
      return uri;
    }
    __name(generateURI, "generateURI");
    function populateURI(req) {
      var operation = req.service.api.operations[req.operation];
      var input = operation.input;
      var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
      req.httpRequest.path = uri;
    }
    __name(populateURI, "populateURI");
    function populateHeaders(req) {
      var operation = req.service.api.operations[req.operation];
      util.each(operation.input.members, function(name, member) {
        var value = req.params[name];
        if (value === null || value === void 0)
          return;
        if (member.location === "headers" && member.type === "map") {
          util.each(value, function(key, memberValue) {
            req.httpRequest.headers[member.name + key] = memberValue;
          });
        } else if (member.location === "header") {
          value = member.toWireFormat(value).toString();
          if (member.isJsonValue) {
            value = util.base64.encode(value);
          }
          req.httpRequest.headers[member.name] = value;
        }
      });
    }
    __name(populateHeaders, "populateHeaders");
    function buildRequest(req) {
      populateMethod(req);
      populateURI(req);
      populateHeaders(req);
      populateHostPrefix(req);
    }
    __name(buildRequest, "buildRequest");
    function extractError() {
    }
    __name(extractError, "extractError");
    function extractData(resp) {
      var req = resp.request;
      var data = {};
      var r = resp.httpResponse;
      var operation = req.service.api.operations[req.operation];
      var output = operation.output;
      var headers = {};
      util.each(r.headers, function(k, v) {
        headers[k.toLowerCase()] = v;
      });
      util.each(output.members, function(name, member) {
        var header = (member.name || name).toLowerCase();
        if (member.location === "headers" && member.type === "map") {
          data[name] = {};
          var location = member.isLocationName ? member.name : "";
          var pattern = new RegExp("^" + location + "(.+)", "i");
          util.each(r.headers, function(k, v) {
            var result = k.match(pattern);
            if (result !== null) {
              data[name][result[1]] = v;
            }
          });
        } else if (member.location === "header") {
          if (headers[header] !== void 0) {
            var value = member.isJsonValue ? util.base64.decode(headers[header]) : headers[header];
            data[name] = member.toType(value);
          }
        } else if (member.location === "statusCode") {
          data[name] = parseInt(r.statusCode, 10);
        }
      });
      resp.data = data;
    }
    __name(extractData, "extractData");
    module2.exports = {
      buildRequest,
      extractError,
      extractData,
      generateURI
    };
  }
});

// node_modules/aws-sdk/lib/protocol/rest_json.js
var require_rest_json = __commonJS({
  "node_modules/aws-sdk/lib/protocol/rest_json.js"(exports2, module2) {
    var util = require_util9();
    var Rest = require_rest();
    var Json = require_json();
    var JsonBuilder = require_builder();
    var JsonParser = require_parser2();
    var METHODS_WITHOUT_BODY = ["GET", "HEAD", "DELETE"];
    function unsetContentLength(req) {
      var payloadMember = util.getRequestPayloadShape(req);
      if (payloadMember === void 0 && METHODS_WITHOUT_BODY.indexOf(req.httpRequest.method) >= 0) {
        delete req.httpRequest.headers["Content-Length"];
      }
    }
    __name(unsetContentLength, "unsetContentLength");
    function populateBody(req) {
      var builder = new JsonBuilder();
      var input = req.service.api.operations[req.operation].input;
      if (input.payload) {
        var params = {};
        var payloadShape = input.members[input.payload];
        params = req.params[input.payload];
        if (payloadShape.type === "structure") {
          req.httpRequest.body = builder.build(params || {}, payloadShape);
          applyContentTypeHeader(req);
        } else if (params !== void 0) {
          req.httpRequest.body = params;
          if (payloadShape.type === "binary" || payloadShape.isStreaming) {
            applyContentTypeHeader(req, true);
          }
        }
      } else {
        req.httpRequest.body = builder.build(req.params, input);
        applyContentTypeHeader(req);
      }
    }
    __name(populateBody, "populateBody");
    function applyContentTypeHeader(req, isBinary) {
      if (!req.httpRequest.headers["Content-Type"]) {
        var type = isBinary ? "binary/octet-stream" : "application/json";
        req.httpRequest.headers["Content-Type"] = type;
      }
    }
    __name(applyContentTypeHeader, "applyContentTypeHeader");
    function buildRequest(req) {
      Rest.buildRequest(req);
      if (METHODS_WITHOUT_BODY.indexOf(req.httpRequest.method) < 0) {
        populateBody(req);
      }
    }
    __name(buildRequest, "buildRequest");
    function extractError(resp) {
      Json.extractError(resp);
    }
    __name(extractError, "extractError");
    function extractData(resp) {
      Rest.extractData(resp);
      var req = resp.request;
      var operation = req.service.api.operations[req.operation];
      var rules = req.service.api.operations[req.operation].output || {};
      var parser;
      var hasEventOutput = operation.hasEventOutput;
      if (rules.payload) {
        var payloadMember = rules.members[rules.payload];
        var body = resp.httpResponse.body;
        if (payloadMember.isEventStream) {
          parser = new JsonParser();
          resp.data[payload] = util.createEventStream(
            AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
            parser,
            payloadMember
          );
        } else if (payloadMember.type === "structure" || payloadMember.type === "list") {
          var parser = new JsonParser();
          resp.data[rules.payload] = parser.parse(body, payloadMember);
        } else if (payloadMember.type === "binary" || payloadMember.isStreaming) {
          resp.data[rules.payload] = body;
        } else {
          resp.data[rules.payload] = payloadMember.toType(body);
        }
      } else {
        var data = resp.data;
        Json.extractData(resp);
        resp.data = util.merge(data, resp.data);
      }
    }
    __name(extractData, "extractData");
    module2.exports = {
      buildRequest,
      extractError,
      extractData,
      unsetContentLength
    };
  }
});

// node_modules/aws-sdk/lib/protocol/rest_xml.js
var require_rest_xml = __commonJS({
  "node_modules/aws-sdk/lib/protocol/rest_xml.js"(exports2, module2) {
    var AWS2 = require_core();
    var util = require_util9();
    var Rest = require_rest();
    function populateBody(req) {
      var input = req.service.api.operations[req.operation].input;
      var builder = new AWS2.XML.Builder();
      var params = req.params;
      var payload2 = input.payload;
      if (payload2) {
        var payloadMember = input.members[payload2];
        params = params[payload2];
        if (params === void 0)
          return;
        if (payloadMember.type === "structure") {
          var rootElement = payloadMember.name;
          req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
        } else {
          req.httpRequest.body = params;
        }
      } else {
        req.httpRequest.body = builder.toXML(params, input, input.name || input.shape || util.string.upperFirst(req.operation) + "Request");
      }
    }
    __name(populateBody, "populateBody");
    function buildRequest(req) {
      Rest.buildRequest(req);
      if (["GET", "HEAD"].indexOf(req.httpRequest.method) < 0) {
        populateBody(req);
      }
    }
    __name(buildRequest, "buildRequest");
    function extractError(resp) {
      Rest.extractError(resp);
      var data;
      try {
        data = new AWS2.XML.Parser().parse(resp.httpResponse.body.toString());
      } catch (e) {
        data = {
          Code: resp.httpResponse.statusCode,
          Message: resp.httpResponse.statusMessage
        };
      }
      if (data.Errors)
        data = data.Errors;
      if (data.Error)
        data = data.Error;
      if (data.Code) {
        resp.error = util.error(new Error(), {
          code: data.Code,
          message: data.Message
        });
      } else {
        resp.error = util.error(new Error(), {
          code: resp.httpResponse.statusCode,
          message: null
        });
      }
    }
    __name(extractError, "extractError");
    function extractData(resp) {
      Rest.extractData(resp);
      var parser;
      var req = resp.request;
      var body = resp.httpResponse.body;
      var operation = req.service.api.operations[req.operation];
      var output = operation.output;
      var hasEventOutput = operation.hasEventOutput;
      var payload2 = output.payload;
      if (payload2) {
        var payloadMember = output.members[payload2];
        if (payloadMember.isEventStream) {
          parser = new AWS2.XML.Parser();
          resp.data[payload2] = util.createEventStream(
            AWS2.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
            parser,
            payloadMember
          );
        } else if (payloadMember.type === "structure") {
          parser = new AWS2.XML.Parser();
          resp.data[payload2] = parser.parse(body.toString(), payloadMember);
        } else if (payloadMember.type === "binary" || payloadMember.isStreaming) {
          resp.data[payload2] = body;
        } else {
          resp.data[payload2] = payloadMember.toType(body);
        }
      } else if (body.length > 0) {
        parser = new AWS2.XML.Parser();
        var data = parser.parse(body.toString(), output);
        util.update(resp.data, data);
      }
    }
    __name(extractData, "extractData");
    module2.exports = {
      buildRequest,
      extractError,
      extractData
    };
  }
});

// node_modules/aws-sdk/lib/xml/escape-attribute.js
var require_escape_attribute = __commonJS({
  "node_modules/aws-sdk/lib/xml/escape-attribute.js"(exports2, module2) {
    function escapeAttribute(value) {
      return value.replace(/&/g, "&amp;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }
    __name(escapeAttribute, "escapeAttribute");
    module2.exports = {
      escapeAttribute
    };
  }
});

// node_modules/aws-sdk/lib/xml/xml-node.js
var require_xml_node = __commonJS({
  "node_modules/aws-sdk/lib/xml/xml-node.js"(exports2, module2) {
    var escapeAttribute = require_escape_attribute().escapeAttribute;
    function XmlNode(name, children) {
      if (children === void 0) {
        children = [];
      }
      this.name = name;
      this.children = children;
      this.attributes = {};
    }
    __name(XmlNode, "XmlNode");
    XmlNode.prototype.addAttribute = function(name, value) {
      this.attributes[name] = value;
      return this;
    };
    XmlNode.prototype.addChildNode = function(child) {
      this.children.push(child);
      return this;
    };
    XmlNode.prototype.removeAttribute = function(name) {
      delete this.attributes[name];
      return this;
    };
    XmlNode.prototype.toString = function() {
      var hasChildren = Boolean(this.children.length);
      var xmlText = "<" + this.name;
      var attributes = this.attributes;
      for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
        var attributeName = attributeNames[i];
        var attribute = attributes[attributeName];
        if (typeof attribute !== "undefined" && attribute !== null) {
          xmlText += " " + attributeName + '="' + escapeAttribute("" + attribute) + '"';
        }
      }
      return xmlText += !hasChildren ? "/>" : ">" + this.children.map(function(c) {
        return c.toString();
      }).join("") + "</" + this.name + ">";
    };
    module2.exports = {
      XmlNode
    };
  }
});

// node_modules/aws-sdk/lib/xml/escape-element.js
var require_escape_element = __commonJS({
  "node_modules/aws-sdk/lib/xml/escape-element.js"(exports2, module2) {
    function escapeElement(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
    }
    __name(escapeElement, "escapeElement");
    module2.exports = {
      escapeElement
    };
  }
});

// node_modules/aws-sdk/lib/xml/xml-text.js
var require_xml_text = __commonJS({
  "node_modules/aws-sdk/lib/xml/xml-text.js"(exports2, module2) {
    var escapeElement = require_escape_element().escapeElement;
    function XmlText(value) {
      this.value = value;
    }
    __name(XmlText, "XmlText");
    XmlText.prototype.toString = function() {
      return escapeElement("" + this.value);
    };
    module2.exports = {
      XmlText
    };
  }
});

// node_modules/aws-sdk/lib/xml/builder.js
var require_builder2 = __commonJS({
  "node_modules/aws-sdk/lib/xml/builder.js"(exports2, module2) {
    var util = require_util9();
    var XmlNode = require_xml_node().XmlNode;
    var XmlText = require_xml_text().XmlText;
    function XmlBuilder() {
    }
    __name(XmlBuilder, "XmlBuilder");
    XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
      var xml = new XmlNode(rootElement);
      applyNamespaces(xml, shape, true);
      serialize(xml, params, shape);
      return xml.children.length > 0 || noEmpty ? xml.toString() : "";
    };
    function serialize(xml, value, shape) {
      switch (shape.type) {
        case "structure":
          return serializeStructure(xml, value, shape);
        case "map":
          return serializeMap(xml, value, shape);
        case "list":
          return serializeList(xml, value, shape);
        default:
          return serializeScalar(xml, value, shape);
      }
    }
    __name(serialize, "serialize");
    function serializeStructure(xml, params, shape) {
      util.arrayEach(shape.memberNames, function(memberName) {
        var memberShape = shape.members[memberName];
        if (memberShape.location !== "body")
          return;
        var value = params[memberName];
        var name = memberShape.name;
        if (value !== void 0 && value !== null) {
          if (memberShape.isXmlAttribute) {
            xml.addAttribute(name, value);
          } else if (memberShape.flattened) {
            serialize(xml, value, memberShape);
          } else {
            var element = new XmlNode(name);
            xml.addChildNode(element);
            applyNamespaces(element, memberShape);
            serialize(element, value, memberShape);
          }
        }
      });
    }
    __name(serializeStructure, "serializeStructure");
    function serializeMap(xml, map, shape) {
      var xmlKey = shape.key.name || "key";
      var xmlValue = shape.value.name || "value";
      util.each(map, function(key, value) {
        var entry = new XmlNode(shape.flattened ? shape.name : "entry");
        xml.addChildNode(entry);
        var entryKey = new XmlNode(xmlKey);
        var entryValue = new XmlNode(xmlValue);
        entry.addChildNode(entryKey);
        entry.addChildNode(entryValue);
        serialize(entryKey, key, shape.key);
        serialize(entryValue, value, shape.value);
      });
    }
    __name(serializeMap, "serializeMap");
    function serializeList(xml, list, shape) {
      if (shape.flattened) {
        util.arrayEach(list, function(value) {
          var name = shape.member.name || shape.name;
          var element = new XmlNode(name);
          xml.addChildNode(element);
          serialize(element, value, shape.member);
        });
      } else {
        util.arrayEach(list, function(value) {
          var name = shape.member.name || "member";
          var element = new XmlNode(name);
          xml.addChildNode(element);
          serialize(element, value, shape.member);
        });
      }
    }
    __name(serializeList, "serializeList");
    function serializeScalar(xml, value, shape) {
      xml.addChildNode(
        new XmlText(shape.toWireFormat(value))
      );
    }
    __name(serializeScalar, "serializeScalar");
    function applyNamespaces(xml, shape, isRoot) {
      var uri, prefix = "xmlns";
      if (shape.xmlNamespaceUri) {
        uri = shape.xmlNamespaceUri;
        if (shape.xmlNamespacePrefix)
          prefix += ":" + shape.xmlNamespacePrefix;
      } else if (isRoot && shape.api.xmlNamespaceUri) {
        uri = shape.api.xmlNamespaceUri;
      }
      if (uri)
        xml.addAttribute(prefix, uri);
    }
    __name(applyNamespaces, "applyNamespaces");
    module2.exports = XmlBuilder;
  }
});

// node_modules/aws-sdk/lib/model/operation.js
var require_operation = __commonJS({
  "node_modules/aws-sdk/lib/model/operation.js"(exports2, module2) {
    var Shape = require_shape();
    var util = require_util9();
    var property = util.property;
    var memoizedProperty = util.memoizedProperty;
    function Operation(name, operation, options) {
      var self2 = this;
      options = options || {};
      property(this, "name", operation.name || name);
      property(this, "api", options.api, false);
      operation.http = operation.http || {};
      property(this, "endpoint", operation.endpoint);
      property(this, "httpMethod", operation.http.method || "POST");
      property(this, "httpPath", operation.http.requestUri || "/");
      property(this, "authtype", operation.authtype || "");
      property(
        this,
        "endpointDiscoveryRequired",
        operation.endpointdiscovery ? operation.endpointdiscovery.required ? "REQUIRED" : "OPTIONAL" : "NULL"
      );
      var httpChecksumRequired = operation.httpChecksumRequired || operation.httpChecksum && operation.httpChecksum.requestChecksumRequired;
      property(this, "httpChecksumRequired", httpChecksumRequired, false);
      memoizedProperty(this, "input", function() {
        if (!operation.input) {
          return new Shape.create({ type: "structure" }, options);
        }
        return Shape.create(operation.input, options);
      });
      memoizedProperty(this, "output", function() {
        if (!operation.output) {
          return new Shape.create({ type: "structure" }, options);
        }
        return Shape.create(operation.output, options);
      });
      memoizedProperty(this, "errors", function() {
        var list = [];
        if (!operation.errors)
          return null;
        for (var i = 0; i < operation.errors.length; i++) {
          list.push(Shape.create(operation.errors[i], options));
        }
        return list;
      });
      memoizedProperty(this, "paginator", function() {
        return options.api.paginators[name];
      });
      if (options.documentation) {
        property(this, "documentation", operation.documentation);
        property(this, "documentationUrl", operation.documentationUrl);
      }
      memoizedProperty(this, "idempotentMembers", function() {
        var idempotentMembers = [];
        var input = self2.input;
        var members = input.members;
        if (!input.members) {
          return idempotentMembers;
        }
        for (var name2 in members) {
          if (!members.hasOwnProperty(name2)) {
            continue;
          }
          if (members[name2].isIdempotent === true) {
            idempotentMembers.push(name2);
          }
        }
        return idempotentMembers;
      });
      memoizedProperty(this, "hasEventOutput", function() {
        var output = self2.output;
        return hasEventStream(output);
      });
    }
    __name(Operation, "Operation");
    function hasEventStream(topLevelShape) {
      var members = topLevelShape.members;
      var payload2 = topLevelShape.payload;
      if (!topLevelShape.members) {
        return false;
      }
      if (payload2) {
        var payloadMember = members[payload2];
        return payloadMember.isEventStream;
      }
      for (var name in members) {
        if (!members.hasOwnProperty(name)) {
          if (members[name].isEventStream === true) {
            return true;
          }
        }
      }
      return false;
    }
    __name(hasEventStream, "hasEventStream");
    module2.exports = Operation;
  }
});

// node_modules/aws-sdk/lib/model/paginator.js
var require_paginator = __commonJS({
  "node_modules/aws-sdk/lib/model/paginator.js"(exports2, module2) {
    var property = require_util9().property;
    function Paginator(name, paginator) {
      property(this, "inputToken", paginator.input_token);
      property(this, "limitKey", paginator.limit_key);
      property(this, "moreResults", paginator.more_results);
      property(this, "outputToken", paginator.output_token);
      property(this, "resultKey", paginator.result_key);
    }
    __name(Paginator, "Paginator");
    module2.exports = Paginator;
  }
});

// node_modules/aws-sdk/lib/model/resource_waiter.js
var require_resource_waiter = __commonJS({
  "node_modules/aws-sdk/lib/model/resource_waiter.js"(exports2, module2) {
    var util = require_util9();
    var property = util.property;
    function ResourceWaiter(name, waiter, options) {
      options = options || {};
      property(this, "name", name);
      property(this, "api", options.api, false);
      if (waiter.operation) {
        property(this, "operation", util.string.lowerFirst(waiter.operation));
      }
      var self2 = this;
      var keys = [
        "type",
        "description",
        "delay",
        "maxAttempts",
        "acceptors"
      ];
      keys.forEach(function(key) {
        var value = waiter[key];
        if (value) {
          property(self2, key, value);
        }
      });
    }
    __name(ResourceWaiter, "ResourceWaiter");
    module2.exports = ResourceWaiter;
  }
});

// node_modules/aws-sdk/apis/metadata.json
var require_metadata = __commonJS({
  "node_modules/aws-sdk/apis/metadata.json"(exports2, module2) {
    module2.exports = {
      acm: {
        name: "ACM",
        cors: true
      },
      apigateway: {
        name: "APIGateway",
        cors: true
      },
      applicationautoscaling: {
        prefix: "application-autoscaling",
        name: "ApplicationAutoScaling",
        cors: true
      },
      appstream: {
        name: "AppStream"
      },
      autoscaling: {
        name: "AutoScaling",
        cors: true
      },
      batch: {
        name: "Batch"
      },
      budgets: {
        name: "Budgets"
      },
      clouddirectory: {
        name: "CloudDirectory",
        versions: [
          "2016-05-10*"
        ]
      },
      cloudformation: {
        name: "CloudFormation",
        cors: true
      },
      cloudfront: {
        name: "CloudFront",
        versions: [
          "2013-05-12*",
          "2013-11-11*",
          "2014-05-31*",
          "2014-10-21*",
          "2014-11-06*",
          "2015-04-17*",
          "2015-07-27*",
          "2015-09-17*",
          "2016-01-13*",
          "2016-01-28*",
          "2016-08-01*",
          "2016-08-20*",
          "2016-09-07*",
          "2016-09-29*",
          "2016-11-25*",
          "2017-03-25*",
          "2017-10-30*",
          "2018-06-18*",
          "2018-11-05*",
          "2019-03-26*"
        ],
        cors: true
      },
      cloudhsm: {
        name: "CloudHSM",
        cors: true
      },
      cloudsearch: {
        name: "CloudSearch"
      },
      cloudsearchdomain: {
        name: "CloudSearchDomain"
      },
      cloudtrail: {
        name: "CloudTrail",
        cors: true
      },
      cloudwatch: {
        prefix: "monitoring",
        name: "CloudWatch",
        cors: true
      },
      cloudwatchevents: {
        prefix: "events",
        name: "CloudWatchEvents",
        versions: [
          "2014-02-03*"
        ],
        cors: true
      },
      cloudwatchlogs: {
        prefix: "logs",
        name: "CloudWatchLogs",
        cors: true
      },
      codebuild: {
        name: "CodeBuild",
        cors: true
      },
      codecommit: {
        name: "CodeCommit",
        cors: true
      },
      codedeploy: {
        name: "CodeDeploy",
        cors: true
      },
      codepipeline: {
        name: "CodePipeline",
        cors: true
      },
      cognitoidentity: {
        prefix: "cognito-identity",
        name: "CognitoIdentity",
        cors: true
      },
      cognitoidentityserviceprovider: {
        prefix: "cognito-idp",
        name: "CognitoIdentityServiceProvider",
        cors: true
      },
      cognitosync: {
        prefix: "cognito-sync",
        name: "CognitoSync",
        cors: true
      },
      configservice: {
        prefix: "config",
        name: "ConfigService",
        cors: true
      },
      cur: {
        name: "CUR",
        cors: true
      },
      datapipeline: {
        name: "DataPipeline"
      },
      devicefarm: {
        name: "DeviceFarm",
        cors: true
      },
      directconnect: {
        name: "DirectConnect",
        cors: true
      },
      directoryservice: {
        prefix: "ds",
        name: "DirectoryService"
      },
      discovery: {
        name: "Discovery"
      },
      dms: {
        name: "DMS"
      },
      dynamodb: {
        name: "DynamoDB",
        cors: true
      },
      dynamodbstreams: {
        prefix: "streams.dynamodb",
        name: "DynamoDBStreams",
        cors: true
      },
      ec2: {
        name: "EC2",
        versions: [
          "2013-06-15*",
          "2013-10-15*",
          "2014-02-01*",
          "2014-05-01*",
          "2014-06-15*",
          "2014-09-01*",
          "2014-10-01*",
          "2015-03-01*",
          "2015-04-15*",
          "2015-10-01*",
          "2016-04-01*",
          "2016-09-15*"
        ],
        cors: true
      },
      ecr: {
        name: "ECR",
        cors: true
      },
      ecs: {
        name: "ECS",
        cors: true
      },
      efs: {
        prefix: "elasticfilesystem",
        name: "EFS",
        cors: true
      },
      elasticache: {
        name: "ElastiCache",
        versions: [
          "2012-11-15*",
          "2014-03-24*",
          "2014-07-15*",
          "2014-09-30*"
        ],
        cors: true
      },
      elasticbeanstalk: {
        name: "ElasticBeanstalk",
        cors: true
      },
      elb: {
        prefix: "elasticloadbalancing",
        name: "ELB",
        cors: true
      },
      elbv2: {
        prefix: "elasticloadbalancingv2",
        name: "ELBv2",
        cors: true
      },
      emr: {
        prefix: "elasticmapreduce",
        name: "EMR",
        cors: true
      },
      es: {
        name: "ES"
      },
      elastictranscoder: {
        name: "ElasticTranscoder",
        cors: true
      },
      firehose: {
        name: "Firehose",
        cors: true
      },
      gamelift: {
        name: "GameLift",
        cors: true
      },
      glacier: {
        name: "Glacier"
      },
      health: {
        name: "Health"
      },
      iam: {
        name: "IAM",
        cors: true
      },
      importexport: {
        name: "ImportExport"
      },
      inspector: {
        name: "Inspector",
        versions: [
          "2015-08-18*"
        ],
        cors: true
      },
      iot: {
        name: "Iot",
        cors: true
      },
      iotdata: {
        prefix: "iot-data",
        name: "IotData",
        cors: true
      },
      kinesis: {
        name: "Kinesis",
        cors: true
      },
      kinesisanalytics: {
        name: "KinesisAnalytics"
      },
      kms: {
        name: "KMS",
        cors: true
      },
      lambda: {
        name: "Lambda",
        cors: true
      },
      lexruntime: {
        prefix: "runtime.lex",
        name: "LexRuntime",
        cors: true
      },
      lightsail: {
        name: "Lightsail"
      },
      machinelearning: {
        name: "MachineLearning",
        cors: true
      },
      marketplacecommerceanalytics: {
        name: "MarketplaceCommerceAnalytics",
        cors: true
      },
      marketplacemetering: {
        prefix: "meteringmarketplace",
        name: "MarketplaceMetering"
      },
      mturk: {
        prefix: "mturk-requester",
        name: "MTurk",
        cors: true
      },
      mobileanalytics: {
        name: "MobileAnalytics",
        cors: true
      },
      opsworks: {
        name: "OpsWorks",
        cors: true
      },
      opsworkscm: {
        name: "OpsWorksCM"
      },
      organizations: {
        name: "Organizations"
      },
      pinpoint: {
        name: "Pinpoint"
      },
      polly: {
        name: "Polly",
        cors: true
      },
      rds: {
        name: "RDS",
        versions: [
          "2014-09-01*"
        ],
        cors: true
      },
      redshift: {
        name: "Redshift",
        cors: true
      },
      rekognition: {
        name: "Rekognition",
        cors: true
      },
      resourcegroupstaggingapi: {
        name: "ResourceGroupsTaggingAPI"
      },
      route53: {
        name: "Route53",
        cors: true
      },
      route53domains: {
        name: "Route53Domains",
        cors: true
      },
      s3: {
        name: "S3",
        dualstackAvailable: true,
        cors: true
      },
      s3control: {
        name: "S3Control",
        dualstackAvailable: true,
        xmlNoDefaultLists: true
      },
      servicecatalog: {
        name: "ServiceCatalog",
        cors: true
      },
      ses: {
        prefix: "email",
        name: "SES",
        cors: true
      },
      shield: {
        name: "Shield"
      },
      simpledb: {
        prefix: "sdb",
        name: "SimpleDB"
      },
      sms: {
        name: "SMS"
      },
      snowball: {
        name: "Snowball"
      },
      sns: {
        name: "SNS",
        cors: true
      },
      sqs: {
        name: "SQS",
        cors: true
      },
      ssm: {
        name: "SSM",
        cors: true
      },
      storagegateway: {
        name: "StorageGateway",
        cors: true
      },
      stepfunctions: {
        prefix: "states",
        name: "StepFunctions"
      },
      sts: {
        name: "STS",
        cors: true
      },
      support: {
        name: "Support"
      },
      swf: {
        name: "SWF"
      },
      xray: {
        name: "XRay",
        cors: true
      },
      waf: {
        name: "WAF",
        cors: true
      },
      wafregional: {
        prefix: "waf-regional",
        name: "WAFRegional"
      },
      workdocs: {
        name: "WorkDocs",
        cors: true
      },
      workspaces: {
        name: "WorkSpaces"
      },
      codestar: {
        name: "CodeStar"
      },
      lexmodelbuildingservice: {
        prefix: "lex-models",
        name: "LexModelBuildingService",
        cors: true
      },
      marketplaceentitlementservice: {
        prefix: "entitlement.marketplace",
        name: "MarketplaceEntitlementService"
      },
      athena: {
        name: "Athena",
        cors: true
      },
      greengrass: {
        name: "Greengrass"
      },
      dax: {
        name: "DAX"
      },
      migrationhub: {
        prefix: "AWSMigrationHub",
        name: "MigrationHub"
      },
      cloudhsmv2: {
        name: "CloudHSMV2",
        cors: true
      },
      glue: {
        name: "Glue"
      },
      mobile: {
        name: "Mobile"
      },
      pricing: {
        name: "Pricing",
        cors: true
      },
      costexplorer: {
        prefix: "ce",
        name: "CostExplorer",
        cors: true
      },
      mediaconvert: {
        name: "MediaConvert"
      },
      medialive: {
        name: "MediaLive"
      },
      mediapackage: {
        name: "MediaPackage"
      },
      mediastore: {
        name: "MediaStore"
      },
      mediastoredata: {
        prefix: "mediastore-data",
        name: "MediaStoreData",
        cors: true
      },
      appsync: {
        name: "AppSync"
      },
      guardduty: {
        name: "GuardDuty"
      },
      mq: {
        name: "MQ"
      },
      comprehend: {
        name: "Comprehend",
        cors: true
      },
      iotjobsdataplane: {
        prefix: "iot-jobs-data",
        name: "IoTJobsDataPlane"
      },
      kinesisvideoarchivedmedia: {
        prefix: "kinesis-video-archived-media",
        name: "KinesisVideoArchivedMedia",
        cors: true
      },
      kinesisvideomedia: {
        prefix: "kinesis-video-media",
        name: "KinesisVideoMedia",
        cors: true
      },
      kinesisvideo: {
        name: "KinesisVideo",
        cors: true
      },
      sagemakerruntime: {
        prefix: "runtime.sagemaker",
        name: "SageMakerRuntime"
      },
      sagemaker: {
        name: "SageMaker"
      },
      translate: {
        name: "Translate",
        cors: true
      },
      resourcegroups: {
        prefix: "resource-groups",
        name: "ResourceGroups",
        cors: true
      },
      alexaforbusiness: {
        name: "AlexaForBusiness"
      },
      cloud9: {
        name: "Cloud9"
      },
      serverlessapplicationrepository: {
        prefix: "serverlessrepo",
        name: "ServerlessApplicationRepository"
      },
      servicediscovery: {
        name: "ServiceDiscovery"
      },
      workmail: {
        name: "WorkMail"
      },
      autoscalingplans: {
        prefix: "autoscaling-plans",
        name: "AutoScalingPlans"
      },
      transcribeservice: {
        prefix: "transcribe",
        name: "TranscribeService"
      },
      connect: {
        name: "Connect",
        cors: true
      },
      acmpca: {
        prefix: "acm-pca",
        name: "ACMPCA"
      },
      fms: {
        name: "FMS"
      },
      secretsmanager: {
        name: "SecretsManager",
        cors: true
      },
      iotanalytics: {
        name: "IoTAnalytics",
        cors: true
      },
      iot1clickdevicesservice: {
        prefix: "iot1click-devices",
        name: "IoT1ClickDevicesService"
      },
      iot1clickprojects: {
        prefix: "iot1click-projects",
        name: "IoT1ClickProjects"
      },
      pi: {
        name: "PI"
      },
      neptune: {
        name: "Neptune"
      },
      mediatailor: {
        name: "MediaTailor"
      },
      eks: {
        name: "EKS"
      },
      macie: {
        name: "Macie"
      },
      dlm: {
        name: "DLM"
      },
      signer: {
        name: "Signer"
      },
      chime: {
        name: "Chime"
      },
      pinpointemail: {
        prefix: "pinpoint-email",
        name: "PinpointEmail"
      },
      ram: {
        name: "RAM"
      },
      route53resolver: {
        name: "Route53Resolver"
      },
      pinpointsmsvoice: {
        prefix: "sms-voice",
        name: "PinpointSMSVoice"
      },
      quicksight: {
        name: "QuickSight"
      },
      rdsdataservice: {
        prefix: "rds-data",
        name: "RDSDataService"
      },
      amplify: {
        name: "Amplify"
      },
      datasync: {
        name: "DataSync"
      },
      robomaker: {
        name: "RoboMaker"
      },
      transfer: {
        name: "Transfer"
      },
      globalaccelerator: {
        name: "GlobalAccelerator"
      },
      comprehendmedical: {
        name: "ComprehendMedical",
        cors: true
      },
      kinesisanalyticsv2: {
        name: "KinesisAnalyticsV2"
      },
      mediaconnect: {
        name: "MediaConnect"
      },
      fsx: {
        name: "FSx"
      },
      securityhub: {
        name: "SecurityHub"
      },
      appmesh: {
        name: "AppMesh",
        versions: [
          "2018-10-01*"
        ]
      },
      licensemanager: {
        prefix: "license-manager",
        name: "LicenseManager"
      },
      kafka: {
        name: "Kafka"
      },
      apigatewaymanagementapi: {
        name: "ApiGatewayManagementApi"
      },
      apigatewayv2: {
        name: "ApiGatewayV2"
      },
      docdb: {
        name: "DocDB"
      },
      backup: {
        name: "Backup"
      },
      worklink: {
        name: "WorkLink"
      },
      textract: {
        name: "Textract"
      },
      managedblockchain: {
        name: "ManagedBlockchain"
      },
      mediapackagevod: {
        prefix: "mediapackage-vod",
        name: "MediaPackageVod"
      },
      groundstation: {
        name: "GroundStation"
      },
      iotthingsgraph: {
        name: "IoTThingsGraph"
      },
      iotevents: {
        name: "IoTEvents"
      },
      ioteventsdata: {
        prefix: "iotevents-data",
        name: "IoTEventsData"
      },
      personalize: {
        name: "Personalize",
        cors: true
      },
      personalizeevents: {
        prefix: "personalize-events",
        name: "PersonalizeEvents",
        cors: true
      },
      personalizeruntime: {
        prefix: "personalize-runtime",
        name: "PersonalizeRuntime",
        cors: true
      },
      applicationinsights: {
        prefix: "application-insights",
        name: "ApplicationInsights"
      },
      servicequotas: {
        prefix: "service-quotas",
        name: "ServiceQuotas"
      },
      ec2instanceconnect: {
        prefix: "ec2-instance-connect",
        name: "EC2InstanceConnect"
      },
      eventbridge: {
        name: "EventBridge"
      },
      lakeformation: {
        name: "LakeFormation"
      },
      forecastservice: {
        prefix: "forecast",
        name: "ForecastService",
        cors: true
      },
      forecastqueryservice: {
        prefix: "forecastquery",
        name: "ForecastQueryService",
        cors: true
      },
      qldb: {
        name: "QLDB"
      },
      qldbsession: {
        prefix: "qldb-session",
        name: "QLDBSession"
      },
      workmailmessageflow: {
        name: "WorkMailMessageFlow"
      },
      codestarnotifications: {
        prefix: "codestar-notifications",
        name: "CodeStarNotifications"
      },
      savingsplans: {
        name: "SavingsPlans"
      },
      sso: {
        name: "SSO"
      },
      ssooidc: {
        prefix: "sso-oidc",
        name: "SSOOIDC"
      },
      marketplacecatalog: {
        prefix: "marketplace-catalog",
        name: "MarketplaceCatalog",
        cors: true
      },
      dataexchange: {
        name: "DataExchange"
      },
      sesv2: {
        name: "SESV2"
      },
      migrationhubconfig: {
        prefix: "migrationhub-config",
        name: "MigrationHubConfig"
      },
      connectparticipant: {
        name: "ConnectParticipant"
      },
      appconfig: {
        name: "AppConfig"
      },
      iotsecuretunneling: {
        name: "IoTSecureTunneling"
      },
      wafv2: {
        name: "WAFV2"
      },
      elasticinference: {
        prefix: "elastic-inference",
        name: "ElasticInference"
      },
      imagebuilder: {
        name: "Imagebuilder"
      },
      schemas: {
        name: "Schemas"
      },
      accessanalyzer: {
        name: "AccessAnalyzer"
      },
      codegurureviewer: {
        prefix: "codeguru-reviewer",
        name: "CodeGuruReviewer"
      },
      codeguruprofiler: {
        name: "CodeGuruProfiler"
      },
      computeoptimizer: {
        prefix: "compute-optimizer",
        name: "ComputeOptimizer"
      },
      frauddetector: {
        name: "FraudDetector"
      },
      kendra: {
        name: "Kendra"
      },
      networkmanager: {
        name: "NetworkManager"
      },
      outposts: {
        name: "Outposts"
      },
      augmentedairuntime: {
        prefix: "sagemaker-a2i-runtime",
        name: "AugmentedAIRuntime"
      },
      ebs: {
        name: "EBS"
      },
      kinesisvideosignalingchannels: {
        prefix: "kinesis-video-signaling",
        name: "KinesisVideoSignalingChannels",
        cors: true
      },
      detective: {
        name: "Detective"
      },
      codestarconnections: {
        prefix: "codestar-connections",
        name: "CodeStarconnections"
      },
      synthetics: {
        name: "Synthetics"
      },
      iotsitewise: {
        name: "IoTSiteWise"
      },
      macie2: {
        name: "Macie2"
      },
      codeartifact: {
        name: "CodeArtifact"
      },
      honeycode: {
        name: "Honeycode"
      },
      ivs: {
        name: "IVS"
      },
      braket: {
        name: "Braket"
      },
      identitystore: {
        name: "IdentityStore"
      },
      appflow: {
        name: "Appflow"
      },
      redshiftdata: {
        prefix: "redshift-data",
        name: "RedshiftData"
      },
      ssoadmin: {
        prefix: "sso-admin",
        name: "SSOAdmin"
      },
      timestreamquery: {
        prefix: "timestream-query",
        name: "TimestreamQuery"
      },
      timestreamwrite: {
        prefix: "timestream-write",
        name: "TimestreamWrite"
      },
      s3outposts: {
        name: "S3Outposts"
      },
      databrew: {
        name: "DataBrew"
      },
      servicecatalogappregistry: {
        prefix: "servicecatalog-appregistry",
        name: "ServiceCatalogAppRegistry"
      },
      networkfirewall: {
        prefix: "network-firewall",
        name: "NetworkFirewall"
      },
      mwaa: {
        name: "MWAA"
      },
      amplifybackend: {
        name: "AmplifyBackend"
      },
      appintegrations: {
        name: "AppIntegrations"
      },
      connectcontactlens: {
        prefix: "connect-contact-lens",
        name: "ConnectContactLens"
      },
      devopsguru: {
        prefix: "devops-guru",
        name: "DevOpsGuru"
      },
      ecrpublic: {
        prefix: "ecr-public",
        name: "ECRPUBLIC"
      },
      lookoutvision: {
        name: "LookoutVision"
      },
      sagemakerfeaturestoreruntime: {
        prefix: "sagemaker-featurestore-runtime",
        name: "SageMakerFeatureStoreRuntime"
      },
      customerprofiles: {
        prefix: "customer-profiles",
        name: "CustomerProfiles"
      },
      auditmanager: {
        name: "AuditManager"
      },
      emrcontainers: {
        prefix: "emr-containers",
        name: "EMRcontainers"
      },
      healthlake: {
        name: "HealthLake"
      },
      sagemakeredge: {
        prefix: "sagemaker-edge",
        name: "SagemakerEdge"
      },
      amp: {
        name: "Amp"
      },
      greengrassv2: {
        name: "GreengrassV2"
      },
      iotdeviceadvisor: {
        name: "IotDeviceAdvisor"
      },
      iotfleethub: {
        name: "IoTFleetHub"
      },
      iotwireless: {
        name: "IoTWireless"
      },
      location: {
        name: "Location",
        cors: true
      },
      wellarchitected: {
        name: "WellArchitected"
      },
      lexmodelsv2: {
        prefix: "models.lex.v2",
        name: "LexModelsV2"
      },
      lexruntimev2: {
        prefix: "runtime.lex.v2",
        name: "LexRuntimeV2",
        cors: true
      },
      fis: {
        name: "Fis"
      },
      lookoutmetrics: {
        name: "LookoutMetrics"
      },
      mgn: {
        name: "Mgn"
      },
      lookoutequipment: {
        name: "LookoutEquipment"
      },
      nimble: {
        name: "Nimble"
      },
      finspace: {
        name: "Finspace"
      },
      finspacedata: {
        prefix: "finspace-data",
        name: "Finspacedata"
      },
      ssmcontacts: {
        prefix: "ssm-contacts",
        name: "SSMContacts"
      },
      ssmincidents: {
        prefix: "ssm-incidents",
        name: "SSMIncidents"
      },
      applicationcostprofiler: {
        name: "ApplicationCostProfiler"
      },
      apprunner: {
        name: "AppRunner"
      },
      proton: {
        name: "Proton"
      },
      route53recoverycluster: {
        prefix: "route53-recovery-cluster",
        name: "Route53RecoveryCluster"
      },
      route53recoverycontrolconfig: {
        prefix: "route53-recovery-control-config",
        name: "Route53RecoveryControlConfig"
      },
      route53recoveryreadiness: {
        prefix: "route53-recovery-readiness",
        name: "Route53RecoveryReadiness"
      },
      chimesdkidentity: {
        prefix: "chime-sdk-identity",
        name: "ChimeSDKIdentity"
      },
      chimesdkmessaging: {
        prefix: "chime-sdk-messaging",
        name: "ChimeSDKMessaging"
      },
      snowdevicemanagement: {
        prefix: "snow-device-management",
        name: "SnowDeviceManagement"
      },
      memorydb: {
        name: "MemoryDB"
      },
      opensearch: {
        name: "OpenSearch"
      },
      kafkaconnect: {
        name: "KafkaConnect"
      },
      voiceid: {
        prefix: "voice-id",
        name: "VoiceID"
      },
      wisdom: {
        name: "Wisdom"
      },
      account: {
        name: "Account"
      },
      cloudcontrol: {
        name: "CloudControl"
      },
      grafana: {
        name: "Grafana"
      },
      panorama: {
        name: "Panorama"
      },
      chimesdkmeetings: {
        prefix: "chime-sdk-meetings",
        name: "ChimeSDKMeetings"
      },
      resiliencehub: {
        name: "Resiliencehub"
      },
      migrationhubstrategy: {
        name: "MigrationHubStrategy"
      },
      appconfigdata: {
        name: "AppConfigData"
      },
      drs: {
        name: "Drs"
      },
      migrationhubrefactorspaces: {
        prefix: "migration-hub-refactor-spaces",
        name: "MigrationHubRefactorSpaces"
      },
      evidently: {
        name: "Evidently"
      },
      inspector2: {
        name: "Inspector2"
      },
      rbin: {
        name: "Rbin"
      },
      rum: {
        name: "RUM"
      },
      backupgateway: {
        prefix: "backup-gateway",
        name: "BackupGateway"
      },
      iottwinmaker: {
        name: "IoTTwinMaker"
      },
      workspacesweb: {
        prefix: "workspaces-web",
        name: "WorkSpacesWeb"
      },
      amplifyuibuilder: {
        name: "AmplifyUIBuilder"
      },
      keyspaces: {
        name: "Keyspaces"
      },
      billingconductor: {
        name: "Billingconductor"
      },
      gamesparks: {
        name: "GameSparks"
      },
      pinpointsmsvoicev2: {
        prefix: "pinpoint-sms-voice-v2",
        name: "PinpointSMSVoiceV2"
      },
      ivschat: {
        name: "Ivschat"
      },
      chimesdkmediapipelines: {
        prefix: "chime-sdk-media-pipelines",
        name: "ChimeSDKMediaPipelines"
      },
      emrserverless: {
        prefix: "emr-serverless",
        name: "EMRServerless"
      },
      m2: {
        name: "M2"
      },
      connectcampaigns: {
        name: "ConnectCampaigns"
      },
      redshiftserverless: {
        prefix: "redshift-serverless",
        name: "RedshiftServerless"
      },
      rolesanywhere: {
        name: "RolesAnywhere"
      },
      licensemanagerusersubscriptions: {
        prefix: "license-manager-user-subscriptions",
        name: "LicenseManagerUserSubscriptions"
      },
      backupstorage: {
        name: "BackupStorage"
      },
      privatenetworks: {
        name: "PrivateNetworks"
      },
      supportapp: {
        prefix: "support-app",
        name: "SupportApp"
      },
      controltower: {
        name: "ControlTower"
      },
      iotfleetwise: {
        name: "IoTFleetWise"
      },
      migrationhuborchestrator: {
        name: "MigrationHubOrchestrator"
      },
      connectcases: {
        name: "ConnectCases"
      },
      resourceexplorer2: {
        prefix: "resource-explorer-2",
        name: "ResourceExplorer2"
      },
      scheduler: {
        name: "Scheduler"
      },
      chimesdkvoice: {
        prefix: "chime-sdk-voice",
        name: "ChimeSDKVoice"
      },
      iotroborunner: {
        prefix: "iot-roborunner",
        name: "IoTRoboRunner"
      },
      ssmsap: {
        prefix: "ssm-sap",
        name: "SsmSap"
      },
      oam: {
        name: "OAM"
      },
      arczonalshift: {
        prefix: "arc-zonal-shift",
        name: "ARCZonalShift"
      },
      omics: {
        name: "Omics"
      },
      opensearchserverless: {
        name: "OpenSearchServerless"
      },
      securitylake: {
        name: "SecurityLake"
      },
      simspaceweaver: {
        name: "SimSpaceWeaver"
      },
      docdbelastic: {
        prefix: "docdb-elastic",
        name: "DocDBElastic"
      },
      sagemakergeospatial: {
        prefix: "sagemaker-geospatial",
        name: "SageMakerGeospatial"
      },
      codecatalyst: {
        name: "CodeCatalyst"
      },
      pipes: {
        name: "Pipes"
      },
      sagemakermetrics: {
        prefix: "sagemaker-metrics",
        name: "SageMakerMetrics"
      },
      kinesisvideowebrtcstorage: {
        prefix: "kinesis-video-webrtc-storage",
        name: "KinesisVideoWebRTCStorage"
      },
      licensemanagerlinuxsubscriptions: {
        prefix: "license-manager-linux-subscriptions",
        name: "LicenseManagerLinuxSubscriptions"
      },
      kendraranking: {
        prefix: "kendra-ranking",
        name: "KendraRanking"
      },
      cleanrooms: {
        name: "CleanRooms"
      },
      cloudtraildata: {
        prefix: "cloudtrail-data",
        name: "CloudTrailData"
      },
      tnb: {
        name: "Tnb"
      },
      internetmonitor: {
        name: "InternetMonitor"
      }
    };
  }
});

// node_modules/aws-sdk/lib/model/api.js
var require_api2 = __commonJS({
  "node_modules/aws-sdk/lib/model/api.js"(exports2, module2) {
    var Collection = require_collection();
    var Operation = require_operation();
    var Shape = require_shape();
    var Paginator = require_paginator();
    var ResourceWaiter = require_resource_waiter();
    var metadata = require_metadata();
    var util = require_util9();
    var property = util.property;
    var memoizedProperty = util.memoizedProperty;
    function Api(api, options) {
      var self2 = this;
      api = api || {};
      options = options || {};
      options.api = this;
      api.metadata = api.metadata || {};
      var serviceIdentifier = options.serviceIdentifier;
      delete options.serviceIdentifier;
      property(this, "isApi", true, false);
      property(this, "apiVersion", api.metadata.apiVersion);
      property(this, "endpointPrefix", api.metadata.endpointPrefix);
      property(this, "signingName", api.metadata.signingName);
      property(this, "globalEndpoint", api.metadata.globalEndpoint);
      property(this, "signatureVersion", api.metadata.signatureVersion);
      property(this, "jsonVersion", api.metadata.jsonVersion);
      property(this, "targetPrefix", api.metadata.targetPrefix);
      property(this, "protocol", api.metadata.protocol);
      property(this, "timestampFormat", api.metadata.timestampFormat);
      property(this, "xmlNamespaceUri", api.metadata.xmlNamespace);
      property(this, "abbreviation", api.metadata.serviceAbbreviation);
      property(this, "fullName", api.metadata.serviceFullName);
      property(this, "serviceId", api.metadata.serviceId);
      if (serviceIdentifier && metadata[serviceIdentifier]) {
        property(this, "xmlNoDefaultLists", metadata[serviceIdentifier].xmlNoDefaultLists, false);
      }
      memoizedProperty(this, "className", function() {
        var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
        if (!name)
          return null;
        name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, "");
        if (name === "ElasticLoadBalancing")
          name = "ELB";
        return name;
      });
      function addEndpointOperation(name, operation) {
        if (operation.endpointoperation === true) {
          property(self2, "endpointOperation", util.string.lowerFirst(name));
        }
        if (operation.endpointdiscovery && !self2.hasRequiredEndpointDiscovery) {
          property(
            self2,
            "hasRequiredEndpointDiscovery",
            operation.endpointdiscovery.required === true
          );
        }
      }
      __name(addEndpointOperation, "addEndpointOperation");
      property(this, "operations", new Collection(api.operations, options, function(name, operation) {
        return new Operation(name, operation, options);
      }, util.string.lowerFirst, addEndpointOperation));
      property(this, "shapes", new Collection(api.shapes, options, function(name, shape) {
        return Shape.create(shape, options);
      }));
      property(this, "paginators", new Collection(api.paginators, options, function(name, paginator) {
        return new Paginator(name, paginator, options);
      }));
      property(this, "waiters", new Collection(api.waiters, options, function(name, waiter) {
        return new ResourceWaiter(name, waiter, options);
      }, util.string.lowerFirst));
      if (options.documentation) {
        property(this, "documentation", api.documentation);
        property(this, "documentationUrl", api.documentationUrl);
      }
      property(this, "awsQueryCompatible", api.metadata.awsQueryCompatible);
    }
    __name(Api, "Api");
    module2.exports = Api;
  }
});

// node_modules/aws-sdk/lib/api_loader.js
var require_api_loader = __commonJS({
  "node_modules/aws-sdk/lib/api_loader.js"(exports2, module2) {
    function apiLoader(svc, version) {
      if (!apiLoader.services.hasOwnProperty(svc)) {
        throw new Error("InvalidService: Failed to load api for " + svc);
      }
      return apiLoader.services[svc][version];
    }
    __name(apiLoader, "apiLoader");
    apiLoader.services = {};
    module2.exports = apiLoader;
  }
});

// node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js
var require_LRU = __commonJS({
  "node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var LinkedListNode = function() {
      function LinkedListNode2(key, value) {
        this.key = key;
        this.value = value;
      }
      __name(LinkedListNode2, "LinkedListNode");
      return LinkedListNode2;
    }();
    var LRUCache = function() {
      function LRUCache2(size) {
        this.nodeMap = {};
        this.size = 0;
        if (typeof size !== "number" || size < 1) {
          throw new Error("Cache size can only be positive number");
        }
        this.sizeLimit = size;
      }
      __name(LRUCache2, "LRUCache");
      Object.defineProperty(LRUCache2.prototype, "length", {
        get: function() {
          return this.size;
        },
        enumerable: true,
        configurable: true
      });
      LRUCache2.prototype.prependToList = function(node) {
        if (!this.headerNode) {
          this.tailNode = node;
        } else {
          this.headerNode.prev = node;
          node.next = this.headerNode;
        }
        this.headerNode = node;
        this.size++;
      };
      LRUCache2.prototype.removeFromTail = function() {
        if (!this.tailNode) {
          return void 0;
        }
        var node = this.tailNode;
        var prevNode = node.prev;
        if (prevNode) {
          prevNode.next = void 0;
        }
        node.prev = void 0;
        this.tailNode = prevNode;
        this.size--;
        return node;
      };
      LRUCache2.prototype.detachFromList = function(node) {
        if (this.headerNode === node) {
          this.headerNode = node.next;
        }
        if (this.tailNode === node) {
          this.tailNode = node.prev;
        }
        if (node.prev) {
          node.prev.next = node.next;
        }
        if (node.next) {
          node.next.prev = node.prev;
        }
        node.next = void 0;
        node.prev = void 0;
        this.size--;
      };
      LRUCache2.prototype.get = function(key) {
        if (this.nodeMap[key]) {
          var node = this.nodeMap[key];
          this.detachFromList(node);
          this.prependToList(node);
          return node.value;
        }
      };
      LRUCache2.prototype.remove = function(key) {
        if (this.nodeMap[key]) {
          var node = this.nodeMap[key];
          this.detachFromList(node);
          delete this.nodeMap[key];
        }
      };
      LRUCache2.prototype.put = function(key, value) {
        if (this.nodeMap[key]) {
          this.remove(key);
        } else if (this.size === this.sizeLimit) {
          var tailNode = this.removeFromTail();
          var key_1 = tailNode.key;
          delete this.nodeMap[key_1];
        }
        var newNode = new LinkedListNode(key, value);
        this.nodeMap[key] = newNode;
        this.prependToList(newNode);
      };
      LRUCache2.prototype.empty = function() {
        var keys = Object.keys(this.nodeMap);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var node = this.nodeMap[key];
          this.detachFromList(node);
          delete this.nodeMap[key];
        }
      };
      return LRUCache2;
    }();
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/aws-sdk/vendor/endpoint-cache/index.js
var require_endpoint_cache = __commonJS({
  "node_modules/aws-sdk/vendor/endpoint-cache/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var LRU_1 = require_LRU();
    var CACHE_SIZE = 1e3;
    var EndpointCache = function() {
      function EndpointCache2(maxSize) {
        if (maxSize === void 0) {
          maxSize = CACHE_SIZE;
        }
        this.maxSize = maxSize;
        this.cache = new LRU_1.LRUCache(maxSize);
      }
      __name(EndpointCache2, "EndpointCache");
      ;
      Object.defineProperty(EndpointCache2.prototype, "size", {
        get: function() {
          return this.cache.length;
        },
        enumerable: true,
        configurable: true
      });
      EndpointCache2.prototype.put = function(key, value) {
        var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
        var endpointRecord = this.populateValue(value);
        this.cache.put(keyString, endpointRecord);
      };
      EndpointCache2.prototype.get = function(key) {
        var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
        var now = Date.now();
        var records = this.cache.get(keyString);
        if (records) {
          for (var i = records.length - 1; i >= 0; i--) {
            var record = records[i];
            if (record.Expire < now) {
              records.splice(i, 1);
            }
          }
          if (records.length === 0) {
            this.cache.remove(keyString);
            return void 0;
          }
        }
        return records;
      };
      EndpointCache2.getKeyString = function(key) {
        var identifiers = [];
        var identifierNames = Object.keys(key).sort();
        for (var i = 0; i < identifierNames.length; i++) {
          var identifierName = identifierNames[i];
          if (key[identifierName] === void 0)
            continue;
          identifiers.push(key[identifierName]);
        }
        return identifiers.join(" ");
      };
      EndpointCache2.prototype.populateValue = function(endpoints) {
        var now = Date.now();
        return endpoints.map(function(endpoint) {
          return {
            Address: endpoint.Address || "",
            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1e3
          };
        });
      };
      EndpointCache2.prototype.empty = function() {
        this.cache.empty();
      };
      EndpointCache2.prototype.remove = function(key) {
        var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
        this.cache.remove(keyString);
      };
      return EndpointCache2;
    }();
    exports2.EndpointCache = EndpointCache;
  }
});

// node_modules/aws-sdk/lib/sequential_executor.js
var require_sequential_executor = __commonJS({
  "node_modules/aws-sdk/lib/sequential_executor.js"(exports2, module2) {
    var AWS2 = require_core();
    AWS2.SequentialExecutor = AWS2.util.inherit({
      constructor: /* @__PURE__ */ __name(function SequentialExecutor() {
        this._events = {};
      }, "SequentialExecutor"),
      listeners: /* @__PURE__ */ __name(function listeners(eventName) {
        return this._events[eventName] ? this._events[eventName].slice(0) : [];
      }, "listeners"),
      on: /* @__PURE__ */ __name(function on(eventName, listener, toHead) {
        if (this._events[eventName]) {
          toHead ? this._events[eventName].unshift(listener) : this._events[eventName].push(listener);
        } else {
          this._events[eventName] = [listener];
        }
        return this;
      }, "on"),
      onAsync: /* @__PURE__ */ __name(function onAsync(eventName, listener, toHead) {
        listener._isAsync = true;
        return this.on(eventName, listener, toHead);
      }, "onAsync"),
      removeListener: /* @__PURE__ */ __name(function removeListener(eventName, listener) {
        var listeners = this._events[eventName];
        if (listeners) {
          var length = listeners.length;
          var position = -1;
          for (var i = 0; i < length; ++i) {
            if (listeners[i] === listener) {
              position = i;
            }
          }
          if (position > -1) {
            listeners.splice(position, 1);
          }
        }
        return this;
      }, "removeListener"),
      removeAllListeners: /* @__PURE__ */ __name(function removeAllListeners(eventName) {
        if (eventName) {
          delete this._events[eventName];
        } else {
          this._events = {};
        }
        return this;
      }, "removeAllListeners"),
      emit: /* @__PURE__ */ __name(function emit(eventName, eventArgs, doneCallback) {
        if (!doneCallback)
          doneCallback = /* @__PURE__ */ __name(function() {
          }, "doneCallback");
        var listeners = this.listeners(eventName);
        var count = listeners.length;
        this.callListeners(listeners, eventArgs, doneCallback);
        return count > 0;
      }, "emit"),
      callListeners: /* @__PURE__ */ __name(function callListeners(listeners, args, doneCallback, prevError) {
        var self2 = this;
        var error = prevError || null;
        function callNextListener(err) {
          if (err) {
            error = AWS2.util.error(error || new Error(), err);
            if (self2._haltHandlersOnError) {
              return doneCallback.call(self2, error);
            }
          }
          self2.callListeners(listeners, args, doneCallback, error);
        }
        __name(callNextListener, "callNextListener");
        while (listeners.length > 0) {
          var listener = listeners.shift();
          if (listener._isAsync) {
            listener.apply(self2, args.concat([callNextListener]));
            return;
          } else {
            try {
              listener.apply(self2, args);
            } catch (err) {
              error = AWS2.util.error(error || new Error(), err);
            }
            if (error && self2._haltHandlersOnError) {
              doneCallback.call(self2, error);
              return;
            }
          }
        }
        doneCallback.call(self2, error);
      }, "callListeners"),
      addListeners: /* @__PURE__ */ __name(function addListeners(listeners) {
        var self2 = this;
        if (listeners._events)
          listeners = listeners._events;
        AWS2.util.each(listeners, function(event, callbacks) {
          if (typeof callbacks === "function")
            callbacks = [callbacks];
          AWS2.util.arrayEach(callbacks, function(callback) {
            self2.on(event, callback);
          });
        });
        return self2;
      }, "addListeners"),
      addNamedListener: /* @__PURE__ */ __name(function addNamedListener(name, eventName, callback, toHead) {
        this[name] = callback;
        this.addListener(eventName, callback, toHead);
        return this;
      }, "addNamedListener"),
      addNamedAsyncListener: /* @__PURE__ */ __name(function addNamedAsyncListener(name, eventName, callback, toHead) {
        callback._isAsync = true;
        return this.addNamedListener(name, eventName, callback, toHead);
      }, "addNamedAsyncListener"),
      addNamedListeners: /* @__PURE__ */ __name(function addNamedListeners(callback) {
        var self2 = this;
        callback(
          function() {
            self2.addNamedListener.apply(self2, arguments);
          },
          function() {
            self2.addNamedAsyncListener.apply(self2, arguments);
          }
        );
        return this;
      }, "addNamedListeners")
    });
    AWS2.SequentialExecutor.prototype.addListener = AWS2.SequentialExecutor.prototype.on;
    module2.exports = AWS2.SequentialExecutor;
  }
});

// node_modules/aws-sdk/lib/region_config_data.json
var require_region_config_data = __commonJS({
  "node_modules/aws-sdk/lib/region_config_data.json"(exports2, module2) {
    module2.exports = {
      rules: {
        "*/*": {
          endpoint: "{service}.{region}.amazonaws.com"
        },
        "cn-*/*": {
          endpoint: "{service}.{region}.amazonaws.com.cn"
        },
        "us-iso-*/*": "usIso",
        "us-isob-*/*": "usIsob",
        "*/budgets": "globalSSL",
        "*/cloudfront": "globalSSL",
        "*/sts": "globalSSL",
        "*/importexport": {
          endpoint: "{service}.amazonaws.com",
          signatureVersion: "v2",
          globalEndpoint: true
        },
        "*/route53": "globalSSL",
        "cn-*/route53": {
          endpoint: "{service}.amazonaws.com.cn",
          globalEndpoint: true,
          signingRegion: "cn-northwest-1"
        },
        "us-gov-*/route53": "globalGovCloud",
        "us-iso-*/route53": {
          endpoint: "{service}.c2s.ic.gov",
          globalEndpoint: true,
          signingRegion: "us-iso-east-1"
        },
        "us-isob-*/route53": {
          endpoint: "{service}.sc2s.sgov.gov",
          globalEndpoint: true,
          signingRegion: "us-isob-east-1"
        },
        "*/waf": "globalSSL",
        "*/iam": "globalSSL",
        "cn-*/iam": {
          endpoint: "{service}.cn-north-1.amazonaws.com.cn",
          globalEndpoint: true,
          signingRegion: "cn-north-1"
        },
        "us-gov-*/iam": "globalGovCloud",
        "us-gov-*/sts": {
          endpoint: "{service}.{region}.amazonaws.com"
        },
        "us-gov-west-1/s3": "s3signature",
        "us-west-1/s3": "s3signature",
        "us-west-2/s3": "s3signature",
        "eu-west-1/s3": "s3signature",
        "ap-southeast-1/s3": "s3signature",
        "ap-southeast-2/s3": "s3signature",
        "ap-northeast-1/s3": "s3signature",
        "sa-east-1/s3": "s3signature",
        "us-east-1/s3": {
          endpoint: "{service}.amazonaws.com",
          signatureVersion: "s3"
        },
        "us-east-1/sdb": {
          endpoint: "{service}.amazonaws.com",
          signatureVersion: "v2"
        },
        "*/sdb": {
          endpoint: "{service}.{region}.amazonaws.com",
          signatureVersion: "v2"
        },
        "*/resource-explorer-2": "dualstackByDefault",
        "*/kendra-ranking": "dualstackByDefault",
        "*/internetmonitor": "dualstackByDefault",
        "*/codecatalyst": "globalDualstackByDefault"
      },
      fipsRules: {
        "*/*": "fipsStandard",
        "us-gov-*/*": "fipsStandard",
        "us-iso-*/*": {
          endpoint: "{service}-fips.{region}.c2s.ic.gov"
        },
        "us-iso-*/dms": "usIso",
        "us-isob-*/*": {
          endpoint: "{service}-fips.{region}.sc2s.sgov.gov"
        },
        "us-isob-*/dms": "usIsob",
        "cn-*/*": {
          endpoint: "{service}-fips.{region}.amazonaws.com.cn"
        },
        "*/api.ecr": "fips.api.ecr",
        "*/api.sagemaker": "fips.api.sagemaker",
        "*/batch": "fipsDotPrefix",
        "*/eks": "fipsDotPrefix",
        "*/models.lex": "fips.models.lex",
        "*/runtime.lex": "fips.runtime.lex",
        "*/runtime.sagemaker": {
          endpoint: "runtime-fips.sagemaker.{region}.amazonaws.com"
        },
        "*/iam": "fipsWithoutRegion",
        "*/route53": "fipsWithoutRegion",
        "*/transcribe": "fipsDotPrefix",
        "*/waf": "fipsWithoutRegion",
        "us-gov-*/transcribe": "fipsDotPrefix",
        "us-gov-*/api.ecr": "fips.api.ecr",
        "us-gov-*/api.sagemaker": "fips.api.sagemaker",
        "us-gov-*/models.lex": "fips.models.lex",
        "us-gov-*/runtime.lex": "fips.runtime.lex",
        "us-gov-*/acm-pca": "fipsWithServiceOnly",
        "us-gov-*/batch": "fipsWithServiceOnly",
        "us-gov-*/cloudformation": "fipsWithServiceOnly",
        "us-gov-*/config": "fipsWithServiceOnly",
        "us-gov-*/eks": "fipsWithServiceOnly",
        "us-gov-*/elasticmapreduce": "fipsWithServiceOnly",
        "us-gov-*/identitystore": "fipsWithServiceOnly",
        "us-gov-*/dynamodb": "fipsWithServiceOnly",
        "us-gov-*/elasticloadbalancing": "fipsWithServiceOnly",
        "us-gov-*/guardduty": "fipsWithServiceOnly",
        "us-gov-*/monitoring": "fipsWithServiceOnly",
        "us-gov-*/resource-groups": "fipsWithServiceOnly",
        "us-gov-*/runtime.sagemaker": "fipsWithServiceOnly",
        "us-gov-*/servicecatalog-appregistry": "fipsWithServiceOnly",
        "us-gov-*/servicequotas": "fipsWithServiceOnly",
        "us-gov-*/ssm": "fipsWithServiceOnly",
        "us-gov-*/sts": "fipsWithServiceOnly",
        "us-gov-*/support": "fipsWithServiceOnly",
        "us-gov-west-1/states": "fipsWithServiceOnly",
        "us-iso-east-1/elasticfilesystem": {
          endpoint: "elasticfilesystem-fips.{region}.c2s.ic.gov"
        },
        "us-gov-west-1/organizations": "fipsWithServiceOnly",
        "us-gov-west-1/route53": {
          endpoint: "route53.us-gov.amazonaws.com"
        },
        "*/resource-explorer-2": "fipsDualstackByDefault",
        "*/kendra-ranking": "dualstackByDefault",
        "*/internetmonitor": "dualstackByDefault",
        "*/codecatalyst": "fipsGlobalDualstackByDefault"
      },
      dualstackRules: {
        "*/*": {
          endpoint: "{service}.{region}.api.aws"
        },
        "cn-*/*": {
          endpoint: "{service}.{region}.api.amazonwebservices.com.cn"
        },
        "*/s3": "dualstackLegacy",
        "cn-*/s3": "dualstackLegacyCn",
        "*/s3-control": "dualstackLegacy",
        "cn-*/s3-control": "dualstackLegacyCn",
        "ap-south-1/ec2": "dualstackLegacyEc2",
        "eu-west-1/ec2": "dualstackLegacyEc2",
        "sa-east-1/ec2": "dualstackLegacyEc2",
        "us-east-1/ec2": "dualstackLegacyEc2",
        "us-east-2/ec2": "dualstackLegacyEc2",
        "us-west-2/ec2": "dualstackLegacyEc2"
      },
      dualstackFipsRules: {
        "*/*": {
          endpoint: "{service}-fips.{region}.api.aws"
        },
        "cn-*/*": {
          endpoint: "{service}-fips.{region}.api.amazonwebservices.com.cn"
        },
        "*/s3": "dualstackFipsLegacy",
        "cn-*/s3": "dualstackFipsLegacyCn",
        "*/s3-control": "dualstackFipsLegacy",
        "cn-*/s3-control": "dualstackFipsLegacyCn"
      },
      patterns: {
        globalSSL: {
          endpoint: "https://{service}.amazonaws.com",
          globalEndpoint: true,
          signingRegion: "us-east-1"
        },
        globalGovCloud: {
          endpoint: "{service}.us-gov.amazonaws.com",
          globalEndpoint: true,
          signingRegion: "us-gov-west-1"
        },
        s3signature: {
          endpoint: "{service}.{region}.amazonaws.com",
          signatureVersion: "s3"
        },
        usIso: {
          endpoint: "{service}.{region}.c2s.ic.gov"
        },
        usIsob: {
          endpoint: "{service}.{region}.sc2s.sgov.gov"
        },
        fipsStandard: {
          endpoint: "{service}-fips.{region}.amazonaws.com"
        },
        fipsDotPrefix: {
          endpoint: "fips.{service}.{region}.amazonaws.com"
        },
        fipsWithoutRegion: {
          endpoint: "{service}-fips.amazonaws.com"
        },
        "fips.api.ecr": {
          endpoint: "ecr-fips.{region}.amazonaws.com"
        },
        "fips.api.sagemaker": {
          endpoint: "api-fips.sagemaker.{region}.amazonaws.com"
        },
        "fips.models.lex": {
          endpoint: "models-fips.lex.{region}.amazonaws.com"
        },
        "fips.runtime.lex": {
          endpoint: "runtime-fips.lex.{region}.amazonaws.com"
        },
        fipsWithServiceOnly: {
          endpoint: "{service}.{region}.amazonaws.com"
        },
        dualstackLegacy: {
          endpoint: "{service}.dualstack.{region}.amazonaws.com"
        },
        dualstackLegacyCn: {
          endpoint: "{service}.dualstack.{region}.amazonaws.com.cn"
        },
        dualstackFipsLegacy: {
          endpoint: "{service}-fips.dualstack.{region}.amazonaws.com"
        },
        dualstackFipsLegacyCn: {
          endpoint: "{service}-fips.dualstack.{region}.amazonaws.com.cn"
        },
        dualstackLegacyEc2: {
          endpoint: "api.ec2.{region}.aws"
        },
        dualstackByDefault: {
          endpoint: "{service}.{region}.api.aws"
        },
        fipsDualstackByDefault: {
          endpoint: "{service}-fips.{region}.api.aws"
        },
        globalDualstackByDefault: {
          endpoint: "{service}.global.api.aws"
        },
        fipsGlobalDualstackByDefault: {
          endpoint: "{service}-fips.global.api.aws"
        }
      }
    };
  }
});

// node_modules/aws-sdk/lib/region_config.js
var require_region_config = __commonJS({
  "node_modules/aws-sdk/lib/region_config.js"(exports2, module2) {
    var util = require_util9();
    var regionConfig = require_region_config_data();
    function generateRegionPrefix(region) {
      if (!region)
        return null;
      var parts = region.split("-");
      if (parts.length < 3)
        return null;
      return parts.slice(0, parts.length - 2).join("-") + "-*";
    }
    __name(generateRegionPrefix, "generateRegionPrefix");
    function derivedKeys(service) {
      var region = service.config.region;
      var regionPrefix = generateRegionPrefix(region);
      var endpointPrefix = service.api.endpointPrefix;
      return [
        [region, endpointPrefix],
        [regionPrefix, endpointPrefix],
        [region, "*"],
        [regionPrefix, "*"],
        ["*", endpointPrefix],
        ["*", "*"]
      ].map(function(item) {
        return item[0] && item[1] ? item.join("/") : null;
      });
    }
    __name(derivedKeys, "derivedKeys");
    function applyConfig(service, config) {
      util.each(config, function(key, value) {
        if (key === "globalEndpoint")
          return;
        if (service.config[key] === void 0 || service.config[key] === null) {
          service.config[key] = value;
        }
      });
    }
    __name(applyConfig, "applyConfig");
    function configureEndpoint(service) {
      var keys = derivedKeys(service);
      var useFipsEndpoint = service.config.useFipsEndpoint;
      var useDualstackEndpoint = service.config.useDualstackEndpoint;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!key)
          continue;
        var rules = useFipsEndpoint ? useDualstackEndpoint ? regionConfig.dualstackFipsRules : regionConfig.fipsRules : useDualstackEndpoint ? regionConfig.dualstackRules : regionConfig.rules;
        if (Object.prototype.hasOwnProperty.call(rules, key)) {
          var config = rules[key];
          if (typeof config === "string") {
            config = regionConfig.patterns[config];
          }
          service.isGlobalEndpoint = !!config.globalEndpoint;
          if (config.signingRegion) {
            service.signingRegion = config.signingRegion;
          }
          if (!config.signatureVersion) {
            config.signatureVersion = "v4";
          }
          var useBearer = (service.api && service.api.signatureVersion) === "bearer";
          applyConfig(service, Object.assign(
            {},
            config,
            { signatureVersion: useBearer ? "bearer" : config.signatureVersion }
          ));
          return;
        }
      }
    }
    __name(configureEndpoint, "configureEndpoint");
    function getEndpointSuffix(region) {
      var regionRegexes = {
        "^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$": "amazonaws.com",
        "^cn\\-\\w+\\-\\d+$": "amazonaws.com.cn",
        "^us\\-gov\\-\\w+\\-\\d+$": "amazonaws.com",
        "^us\\-iso\\-\\w+\\-\\d+$": "c2s.ic.gov",
        "^us\\-isob\\-\\w+\\-\\d+$": "sc2s.sgov.gov"
      };
      var defaultSuffix = "amazonaws.com";
      var regexes = Object.keys(regionRegexes);
      for (var i = 0; i < regexes.length; i++) {
        var regionPattern = RegExp(regexes[i]);
        var dnsSuffix = regionRegexes[regexes[i]];
        if (regionPattern.test(region))
          return dnsSuffix;
      }
      return defaultSuffix;
    }
    __name(getEndpointSuffix, "getEndpointSuffix");
    module2.exports = {
      configureEndpoint,
      getEndpointSuffix
    };
  }
});

// node_modules/aws-sdk/lib/region/utils.js
var require_utils3 = __commonJS({
  "node_modules/aws-sdk/lib/region/utils.js"(exports2, module2) {
    function isFipsRegion(region) {
      return typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
    }
    __name(isFipsRegion, "isFipsRegion");
    function isGlobalRegion(region) {
      return typeof region === "string" && ["aws-global", "aws-us-gov-global"].includes(region);
    }
    __name(isGlobalRegion, "isGlobalRegion");
    function getRealRegion(region) {
      return ["fips-aws-global", "aws-fips", "aws-global"].includes(region) ? "us-east-1" : ["fips-aws-us-gov-global", "aws-us-gov-global"].includes(region) ? "us-gov-west-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "");
    }
    __name(getRealRegion, "getRealRegion");
    module2.exports = {
      isFipsRegion,
      isGlobalRegion,
      getRealRegion
    };
  }
});

// node_modules/aws-sdk/lib/service.js
var require_service2 = __commonJS({
  "node_modules/aws-sdk/lib/service.js"(exports2, module2) {
    var AWS2 = require_core();
    var Api = require_api2();
    var regionConfig = require_region_config();
    var inherit = AWS2.util.inherit;
    var clientCount = 0;
    var region_utils = require_utils3();
    AWS2.Service = inherit({
      constructor: /* @__PURE__ */ __name(function Service(config) {
        if (!this.loadServiceClass) {
          throw AWS2.util.error(
            new Error(),
            "Service must be constructed with `new' operator"
          );
        }
        if (config) {
          if (config.region) {
            var region = config.region;
            if (region_utils.isFipsRegion(region)) {
              config.region = region_utils.getRealRegion(region);
              config.useFipsEndpoint = true;
            }
            if (region_utils.isGlobalRegion(region)) {
              config.region = region_utils.getRealRegion(region);
            }
          }
          if (typeof config.useDualstack === "boolean" && typeof config.useDualstackEndpoint !== "boolean") {
            config.useDualstackEndpoint = config.useDualstack;
          }
        }
        var ServiceClass = this.loadServiceClass(config || {});
        if (ServiceClass) {
          var originalConfig = AWS2.util.copy(config);
          var svc = new ServiceClass(config);
          Object.defineProperty(svc, "_originalConfig", {
            get: function() {
              return originalConfig;
            },
            enumerable: false,
            configurable: true
          });
          svc._clientId = ++clientCount;
          return svc;
        }
        this.initialize(config);
      }, "Service"),
      initialize: /* @__PURE__ */ __name(function initialize(config) {
        var svcConfig = AWS2.config[this.serviceIdentifier];
        this.config = new AWS2.Config(AWS2.config);
        if (svcConfig)
          this.config.update(svcConfig, true);
        if (config)
          this.config.update(config, true);
        this.validateService();
        if (!this.config.endpoint)
          regionConfig.configureEndpoint(this);
        this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
        this.setEndpoint(this.config.endpoint);
        AWS2.SequentialExecutor.call(this);
        AWS2.Service.addDefaultMonitoringListeners(this);
        if ((this.config.clientSideMonitoring || AWS2.Service._clientSideMonitoring) && this.publisher) {
          var publisher = this.publisher;
          this.addNamedListener("PUBLISH_API_CALL", "apiCall", /* @__PURE__ */ __name(function PUBLISH_API_CALL(event) {
            process.nextTick(function() {
              publisher.eventHandler(event);
            });
          }, "PUBLISH_API_CALL"));
          this.addNamedListener("PUBLISH_API_ATTEMPT", "apiCallAttempt", /* @__PURE__ */ __name(function PUBLISH_API_ATTEMPT(event) {
            process.nextTick(function() {
              publisher.eventHandler(event);
            });
          }, "PUBLISH_API_ATTEMPT"));
        }
      }, "initialize"),
      validateService: /* @__PURE__ */ __name(function validateService() {
      }, "validateService"),
      loadServiceClass: /* @__PURE__ */ __name(function loadServiceClass(serviceConfig) {
        var config = serviceConfig;
        if (!AWS2.util.isEmpty(this.api)) {
          return null;
        } else if (config.apiConfig) {
          return AWS2.Service.defineServiceApi(this.constructor, config.apiConfig);
        } else if (!this.constructor.services) {
          return null;
        } else {
          config = new AWS2.Config(AWS2.config);
          config.update(serviceConfig, true);
          var version = config.apiVersions[this.constructor.serviceIdentifier];
          version = version || config.apiVersion;
          return this.getLatestServiceClass(version);
        }
      }, "loadServiceClass"),
      getLatestServiceClass: /* @__PURE__ */ __name(function getLatestServiceClass(version) {
        version = this.getLatestServiceVersion(version);
        if (this.constructor.services[version] === null) {
          AWS2.Service.defineServiceApi(this.constructor, version);
        }
        return this.constructor.services[version];
      }, "getLatestServiceClass"),
      getLatestServiceVersion: /* @__PURE__ */ __name(function getLatestServiceVersion(version) {
        if (!this.constructor.services || this.constructor.services.length === 0) {
          throw new Error("No services defined on " + this.constructor.serviceIdentifier);
        }
        if (!version) {
          version = "latest";
        } else if (AWS2.util.isType(version, Date)) {
          version = AWS2.util.date.iso8601(version).split("T")[0];
        }
        if (Object.hasOwnProperty(this.constructor.services, version)) {
          return version;
        }
        var keys = Object.keys(this.constructor.services).sort();
        var selectedVersion = null;
        for (var i = keys.length - 1; i >= 0; i--) {
          if (keys[i][keys[i].length - 1] !== "*") {
            selectedVersion = keys[i];
          }
          if (keys[i].substr(0, 10) <= version) {
            return selectedVersion;
          }
        }
        throw new Error("Could not find " + this.constructor.serviceIdentifier + " API to satisfy version constraint `" + version + "'");
      }, "getLatestServiceVersion"),
      api: {},
      defaultRetryCount: 3,
      customizeRequests: /* @__PURE__ */ __name(function customizeRequests(callback) {
        if (!callback) {
          this.customRequestHandler = null;
        } else if (typeof callback === "function") {
          this.customRequestHandler = callback;
        } else {
          throw new Error("Invalid callback type '" + typeof callback + "' provided in customizeRequests");
        }
      }, "customizeRequests"),
      makeRequest: /* @__PURE__ */ __name(function makeRequest(operation, params, callback) {
        if (typeof params === "function") {
          callback = params;
          params = null;
        }
        params = params || {};
        if (this.config.params) {
          var rules = this.api.operations[operation];
          if (rules) {
            params = AWS2.util.copy(params);
            AWS2.util.each(this.config.params, function(key, value) {
              if (rules.input.members[key]) {
                if (params[key] === void 0 || params[key] === null) {
                  params[key] = value;
                }
              }
            });
          }
        }
        var request = new AWS2.Request(this, operation, params);
        this.addAllRequestListeners(request);
        this.attachMonitoringEmitter(request);
        if (callback)
          request.send(callback);
        return request;
      }, "makeRequest"),
      makeUnauthenticatedRequest: /* @__PURE__ */ __name(function makeUnauthenticatedRequest(operation, params, callback) {
        if (typeof params === "function") {
          callback = params;
          params = {};
        }
        var request = this.makeRequest(operation, params).toUnauthenticated();
        return callback ? request.send(callback) : request;
      }, "makeUnauthenticatedRequest"),
      waitFor: /* @__PURE__ */ __name(function waitFor(state, params, callback) {
        var waiter = new AWS2.ResourceWaiter(this, state);
        return waiter.wait(params, callback);
      }, "waitFor"),
      addAllRequestListeners: /* @__PURE__ */ __name(function addAllRequestListeners(request) {
        var list = [
          AWS2.events,
          AWS2.EventListeners.Core,
          this.serviceInterface(),
          AWS2.EventListeners.CorePost
        ];
        for (var i = 0; i < list.length; i++) {
          if (list[i])
            request.addListeners(list[i]);
        }
        if (!this.config.paramValidation) {
          request.removeListener(
            "validate",
            AWS2.EventListeners.Core.VALIDATE_PARAMETERS
          );
        }
        if (this.config.logger) {
          request.addListeners(AWS2.EventListeners.Logger);
        }
        this.setupRequestListeners(request);
        if (typeof this.constructor.prototype.customRequestHandler === "function") {
          this.constructor.prototype.customRequestHandler(request);
        }
        if (Object.prototype.hasOwnProperty.call(this, "customRequestHandler") && typeof this.customRequestHandler === "function") {
          this.customRequestHandler(request);
        }
      }, "addAllRequestListeners"),
      apiCallEvent: /* @__PURE__ */ __name(function apiCallEvent(request) {
        var api = request.service.api.operations[request.operation];
        var monitoringEvent = {
          Type: "ApiCall",
          Api: api ? api.name : request.operation,
          Version: 1,
          Service: request.service.api.serviceId || request.service.api.endpointPrefix,
          Region: request.httpRequest.region,
          MaxRetriesExceeded: 0,
          UserAgent: request.httpRequest.getUserAgent()
        };
        var response = request.response;
        if (response.httpResponse.statusCode) {
          monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
        }
        if (response.error) {
          var error = response.error;
          var statusCode = response.httpResponse.statusCode;
          if (statusCode > 299) {
            if (error.code)
              monitoringEvent.FinalAwsException = error.code;
            if (error.message)
              monitoringEvent.FinalAwsExceptionMessage = error.message;
          } else {
            if (error.code || error.name)
              monitoringEvent.FinalSdkException = error.code || error.name;
            if (error.message)
              monitoringEvent.FinalSdkExceptionMessage = error.message;
          }
        }
        return monitoringEvent;
      }, "apiCallEvent"),
      apiAttemptEvent: /* @__PURE__ */ __name(function apiAttemptEvent(request) {
        var api = request.service.api.operations[request.operation];
        var monitoringEvent = {
          Type: "ApiCallAttempt",
          Api: api ? api.name : request.operation,
          Version: 1,
          Service: request.service.api.serviceId || request.service.api.endpointPrefix,
          Fqdn: request.httpRequest.endpoint.hostname,
          UserAgent: request.httpRequest.getUserAgent()
        };
        var response = request.response;
        if (response.httpResponse.statusCode) {
          monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
        }
        if (!request._unAuthenticated && request.service.config.credentials && request.service.config.credentials.accessKeyId) {
          monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
        }
        if (!response.httpResponse.headers)
          return monitoringEvent;
        if (request.httpRequest.headers["x-amz-security-token"]) {
          monitoringEvent.SessionToken = request.httpRequest.headers["x-amz-security-token"];
        }
        if (response.httpResponse.headers["x-amzn-requestid"]) {
          monitoringEvent.XAmznRequestId = response.httpResponse.headers["x-amzn-requestid"];
        }
        if (response.httpResponse.headers["x-amz-request-id"]) {
          monitoringEvent.XAmzRequestId = response.httpResponse.headers["x-amz-request-id"];
        }
        if (response.httpResponse.headers["x-amz-id-2"]) {
          monitoringEvent.XAmzId2 = response.httpResponse.headers["x-amz-id-2"];
        }
        return monitoringEvent;
      }, "apiAttemptEvent"),
      attemptFailEvent: /* @__PURE__ */ __name(function attemptFailEvent(request) {
        var monitoringEvent = this.apiAttemptEvent(request);
        var response = request.response;
        var error = response.error;
        if (response.httpResponse.statusCode > 299) {
          if (error.code)
            monitoringEvent.AwsException = error.code;
          if (error.message)
            monitoringEvent.AwsExceptionMessage = error.message;
        } else {
          if (error.code || error.name)
            monitoringEvent.SdkException = error.code || error.name;
          if (error.message)
            monitoringEvent.SdkExceptionMessage = error.message;
        }
        return monitoringEvent;
      }, "attemptFailEvent"),
      attachMonitoringEmitter: /* @__PURE__ */ __name(function attachMonitoringEmitter(request) {
        var attemptTimestamp;
        var attemptStartRealTime;
        var attemptLatency;
        var callStartRealTime;
        var attemptCount = 0;
        var region;
        var callTimestamp;
        var self2 = this;
        var addToHead = true;
        request.on("validate", function() {
          callStartRealTime = AWS2.util.realClock.now();
          callTimestamp = Date.now();
        }, addToHead);
        request.on("sign", function() {
          attemptStartRealTime = AWS2.util.realClock.now();
          attemptTimestamp = Date.now();
          region = request.httpRequest.region;
          attemptCount++;
        }, addToHead);
        request.on("validateResponse", function() {
          attemptLatency = Math.round(AWS2.util.realClock.now() - attemptStartRealTime);
        });
        request.addNamedListener("API_CALL_ATTEMPT", "success", /* @__PURE__ */ __name(function API_CALL_ATTEMPT() {
          var apiAttemptEvent = self2.apiAttemptEvent(request);
          apiAttemptEvent.Timestamp = attemptTimestamp;
          apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
          apiAttemptEvent.Region = region;
          self2.emit("apiCallAttempt", [apiAttemptEvent]);
        }, "API_CALL_ATTEMPT"));
        request.addNamedListener("API_CALL_ATTEMPT_RETRY", "retry", /* @__PURE__ */ __name(function API_CALL_ATTEMPT_RETRY() {
          var apiAttemptEvent = self2.attemptFailEvent(request);
          apiAttemptEvent.Timestamp = attemptTimestamp;
          attemptLatency = attemptLatency || Math.round(AWS2.util.realClock.now() - attemptStartRealTime);
          apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
          apiAttemptEvent.Region = region;
          self2.emit("apiCallAttempt", [apiAttemptEvent]);
        }, "API_CALL_ATTEMPT_RETRY"));
        request.addNamedListener("API_CALL", "complete", /* @__PURE__ */ __name(function API_CALL() {
          var apiCallEvent = self2.apiCallEvent(request);
          apiCallEvent.AttemptCount = attemptCount;
          if (apiCallEvent.AttemptCount <= 0)
            return;
          apiCallEvent.Timestamp = callTimestamp;
          var latency = Math.round(AWS2.util.realClock.now() - callStartRealTime);
          apiCallEvent.Latency = latency >= 0 ? latency : 0;
          var response = request.response;
          if (response.error && response.error.retryable && typeof response.retryCount === "number" && typeof response.maxRetries === "number" && response.retryCount >= response.maxRetries) {
            apiCallEvent.MaxRetriesExceeded = 1;
          }
          self2.emit("apiCall", [apiCallEvent]);
        }, "API_CALL"));
      }, "attachMonitoringEmitter"),
      setupRequestListeners: /* @__PURE__ */ __name(function setupRequestListeners(request) {
      }, "setupRequestListeners"),
      getSigningName: /* @__PURE__ */ __name(function getSigningName() {
        return this.api.signingName || this.api.endpointPrefix;
      }, "getSigningName"),
      getSignerClass: /* @__PURE__ */ __name(function getSignerClass(request) {
        var version;
        var operation = null;
        var authtype = "";
        if (request) {
          var operations = request.service.api.operations || {};
          operation = operations[request.operation] || null;
          authtype = operation ? operation.authtype : "";
        }
        if (this.config.signatureVersion) {
          version = this.config.signatureVersion;
        } else if (authtype === "v4" || authtype === "v4-unsigned-body") {
          version = "v4";
        } else if (authtype === "bearer") {
          version = "bearer";
        } else {
          version = this.api.signatureVersion;
        }
        return AWS2.Signers.RequestSigner.getVersion(version);
      }, "getSignerClass"),
      serviceInterface: /* @__PURE__ */ __name(function serviceInterface() {
        switch (this.api.protocol) {
          case "ec2":
            return AWS2.EventListeners.Query;
          case "query":
            return AWS2.EventListeners.Query;
          case "json":
            return AWS2.EventListeners.Json;
          case "rest-json":
            return AWS2.EventListeners.RestJson;
          case "rest-xml":
            return AWS2.EventListeners.RestXml;
        }
        if (this.api.protocol) {
          throw new Error("Invalid service `protocol' " + this.api.protocol + " in API config");
        }
      }, "serviceInterface"),
      successfulResponse: /* @__PURE__ */ __name(function successfulResponse(resp) {
        return resp.httpResponse.statusCode < 300;
      }, "successfulResponse"),
      numRetries: /* @__PURE__ */ __name(function numRetries() {
        if (this.config.maxRetries !== void 0) {
          return this.config.maxRetries;
        } else {
          return this.defaultRetryCount;
        }
      }, "numRetries"),
      retryDelays: /* @__PURE__ */ __name(function retryDelays(retryCount, err) {
        return AWS2.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
      }, "retryDelays"),
      retryableError: /* @__PURE__ */ __name(function retryableError(error) {
        if (this.timeoutError(error))
          return true;
        if (this.networkingError(error))
          return true;
        if (this.expiredCredentialsError(error))
          return true;
        if (this.throttledError(error))
          return true;
        if (error.statusCode >= 500)
          return true;
        return false;
      }, "retryableError"),
      networkingError: /* @__PURE__ */ __name(function networkingError(error) {
        return error.code === "NetworkingError";
      }, "networkingError"),
      timeoutError: /* @__PURE__ */ __name(function timeoutError(error) {
        return error.code === "TimeoutError";
      }, "timeoutError"),
      expiredCredentialsError: /* @__PURE__ */ __name(function expiredCredentialsError(error) {
        return error.code === "ExpiredTokenException";
      }, "expiredCredentialsError"),
      clockSkewError: /* @__PURE__ */ __name(function clockSkewError(error) {
        switch (error.code) {
          case "RequestTimeTooSkewed":
          case "RequestExpired":
          case "InvalidSignatureException":
          case "SignatureDoesNotMatch":
          case "AuthFailure":
          case "RequestInTheFuture":
            return true;
          default:
            return false;
        }
      }, "clockSkewError"),
      getSkewCorrectedDate: /* @__PURE__ */ __name(function getSkewCorrectedDate() {
        return new Date(Date.now() + this.config.systemClockOffset);
      }, "getSkewCorrectedDate"),
      applyClockOffset: /* @__PURE__ */ __name(function applyClockOffset(newServerTime) {
        if (newServerTime) {
          this.config.systemClockOffset = newServerTime - Date.now();
        }
      }, "applyClockOffset"),
      isClockSkewed: /* @__PURE__ */ __name(function isClockSkewed(newServerTime) {
        if (newServerTime) {
          return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 3e5;
        }
      }, "isClockSkewed"),
      throttledError: /* @__PURE__ */ __name(function throttledError(error) {
        if (error.statusCode === 429)
          return true;
        switch (error.code) {
          case "ProvisionedThroughputExceededException":
          case "Throttling":
          case "ThrottlingException":
          case "RequestLimitExceeded":
          case "RequestThrottled":
          case "RequestThrottledException":
          case "TooManyRequestsException":
          case "TransactionInProgressException":
          case "EC2ThrottledException":
            return true;
          default:
            return false;
        }
      }, "throttledError"),
      endpointFromTemplate: /* @__PURE__ */ __name(function endpointFromTemplate(endpoint) {
        if (typeof endpoint !== "string")
          return endpoint;
        var e = endpoint;
        e = e.replace(/\{service\}/g, this.api.endpointPrefix);
        e = e.replace(/\{region\}/g, this.config.region);
        e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? "https" : "http");
        return e;
      }, "endpointFromTemplate"),
      setEndpoint: /* @__PURE__ */ __name(function setEndpoint(endpoint) {
        this.endpoint = new AWS2.Endpoint(endpoint, this.config);
      }, "setEndpoint"),
      paginationConfig: /* @__PURE__ */ __name(function paginationConfig(operation, throwException) {
        var paginator = this.api.operations[operation].paginator;
        if (!paginator) {
          if (throwException) {
            var e = new Error();
            throw AWS2.util.error(e, "No pagination configuration for " + operation);
          }
          return null;
        }
        return paginator;
      }, "paginationConfig")
    });
    AWS2.util.update(AWS2.Service, {
      defineMethods: /* @__PURE__ */ __name(function defineMethods(svc) {
        AWS2.util.each(svc.prototype.api.operations, /* @__PURE__ */ __name(function iterator(method) {
          if (svc.prototype[method])
            return;
          var operation = svc.prototype.api.operations[method];
          if (operation.authtype === "none") {
            svc.prototype[method] = function(params, callback) {
              return this.makeUnauthenticatedRequest(method, params, callback);
            };
          } else {
            svc.prototype[method] = function(params, callback) {
              return this.makeRequest(method, params, callback);
            };
          }
        }, "iterator"));
      }, "defineMethods"),
      defineService: /* @__PURE__ */ __name(function defineService(serviceIdentifier, versions, features) {
        AWS2.Service._serviceMap[serviceIdentifier] = true;
        if (!Array.isArray(versions)) {
          features = versions;
          versions = [];
        }
        var svc = inherit(AWS2.Service, features || {});
        if (typeof serviceIdentifier === "string") {
          AWS2.Service.addVersions(svc, versions);
          var identifier = svc.serviceIdentifier || serviceIdentifier;
          svc.serviceIdentifier = identifier;
        } else {
          svc.prototype.api = serviceIdentifier;
          AWS2.Service.defineMethods(svc);
        }
        AWS2.SequentialExecutor.call(this.prototype);
        if (!this.prototype.publisher && AWS2.util.clientSideMonitoring) {
          var Publisher = AWS2.util.clientSideMonitoring.Publisher;
          var configProvider = AWS2.util.clientSideMonitoring.configProvider;
          var publisherConfig = configProvider();
          this.prototype.publisher = new Publisher(publisherConfig);
          if (publisherConfig.enabled) {
            AWS2.Service._clientSideMonitoring = true;
          }
        }
        AWS2.SequentialExecutor.call(svc.prototype);
        AWS2.Service.addDefaultMonitoringListeners(svc.prototype);
        return svc;
      }, "defineService"),
      addVersions: /* @__PURE__ */ __name(function addVersions(svc, versions) {
        if (!Array.isArray(versions))
          versions = [versions];
        svc.services = svc.services || {};
        for (var i = 0; i < versions.length; i++) {
          if (svc.services[versions[i]] === void 0) {
            svc.services[versions[i]] = null;
          }
        }
        svc.apiVersions = Object.keys(svc.services).sort();
      }, "addVersions"),
      defineServiceApi: /* @__PURE__ */ __name(function defineServiceApi(superclass, version, apiConfig) {
        var svc = inherit(superclass, {
          serviceIdentifier: superclass.serviceIdentifier
        });
        function setApi(api) {
          if (api.isApi) {
            svc.prototype.api = api;
          } else {
            svc.prototype.api = new Api(api, {
              serviceIdentifier: superclass.serviceIdentifier
            });
          }
        }
        __name(setApi, "setApi");
        if (typeof version === "string") {
          if (apiConfig) {
            setApi(apiConfig);
          } else {
            try {
              setApi(AWS2.apiLoader(superclass.serviceIdentifier, version));
            } catch (err) {
              throw AWS2.util.error(err, {
                message: "Could not find API configuration " + superclass.serviceIdentifier + "-" + version
              });
            }
          }
          if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
            superclass.apiVersions = superclass.apiVersions.concat(version).sort();
          }
          superclass.services[version] = svc;
        } else {
          setApi(version);
        }
        AWS2.Service.defineMethods(svc);
        return svc;
      }, "defineServiceApi"),
      hasService: function(identifier) {
        return Object.prototype.hasOwnProperty.call(AWS2.Service._serviceMap, identifier);
      },
      addDefaultMonitoringListeners: /* @__PURE__ */ __name(function addDefaultMonitoringListeners(attachOn) {
        attachOn.addNamedListener("MONITOR_EVENTS_BUBBLE", "apiCallAttempt", /* @__PURE__ */ __name(function EVENTS_BUBBLE(event) {
          var baseClass = Object.getPrototypeOf(attachOn);
          if (baseClass._events)
            baseClass.emit("apiCallAttempt", [event]);
        }, "EVENTS_BUBBLE"));
        attachOn.addNamedListener("CALL_EVENTS_BUBBLE", "apiCall", /* @__PURE__ */ __name(function CALL_EVENTS_BUBBLE(event) {
          var baseClass = Object.getPrototypeOf(attachOn);
          if (baseClass._events)
            baseClass.emit("apiCall", [event]);
        }, "CALL_EVENTS_BUBBLE"));
      }, "addDefaultMonitoringListeners"),
      _serviceMap: {}
    });
    AWS2.util.mixin(AWS2.Service, AWS2.SequentialExecutor);
    module2.exports = AWS2.Service;
  }
});

// node_modules/aws-sdk/lib/credentials.js
var require_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials.js"() {
    var AWS2 = require_core();
    AWS2.Credentials = AWS2.util.inherit({
      constructor: /* @__PURE__ */ __name(function Credentials() {
        AWS2.util.hideProperties(this, ["secretAccessKey"]);
        this.expired = false;
        this.expireTime = null;
        this.refreshCallbacks = [];
        if (arguments.length === 1 && typeof arguments[0] === "object") {
          var creds = arguments[0].credentials || arguments[0];
          this.accessKeyId = creds.accessKeyId;
          this.secretAccessKey = creds.secretAccessKey;
          this.sessionToken = creds.sessionToken;
        } else {
          this.accessKeyId = arguments[0];
          this.secretAccessKey = arguments[1];
          this.sessionToken = arguments[2];
        }
      }, "Credentials"),
      expiryWindow: 15,
      needsRefresh: /* @__PURE__ */ __name(function needsRefresh() {
        var currentTime = AWS2.util.date.getDate().getTime();
        var adjustedTime = new Date(currentTime + this.expiryWindow * 1e3);
        if (this.expireTime && adjustedTime > this.expireTime) {
          return true;
        } else {
          return this.expired || !this.accessKeyId || !this.secretAccessKey;
        }
      }, "needsRefresh"),
      get: /* @__PURE__ */ __name(function get(callback) {
        var self2 = this;
        if (this.needsRefresh()) {
          this.refresh(function(err) {
            if (!err)
              self2.expired = false;
            if (callback)
              callback(err);
          });
        } else if (callback) {
          callback();
        }
      }, "get"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        this.expired = false;
        callback();
      }, "refresh"),
      coalesceRefresh: /* @__PURE__ */ __name(function coalesceRefresh(callback, sync) {
        var self2 = this;
        if (self2.refreshCallbacks.push(callback) === 1) {
          self2.load(/* @__PURE__ */ __name(function onLoad(err) {
            AWS2.util.arrayEach(self2.refreshCallbacks, function(callback2) {
              if (sync) {
                callback2(err);
              } else {
                AWS2.util.defer(function() {
                  callback2(err);
                });
              }
            });
            self2.refreshCallbacks.length = 0;
          }, "onLoad"));
        }
      }, "coalesceRefresh"),
      load: /* @__PURE__ */ __name(function load(callback) {
        callback();
      }, "load")
    });
    AWS2.Credentials.addPromisesToClass = /* @__PURE__ */ __name(function addPromisesToClass(PromiseDependency) {
      this.prototype.getPromise = AWS2.util.promisifyMethod("get", PromiseDependency);
      this.prototype.refreshPromise = AWS2.util.promisifyMethod("refresh", PromiseDependency);
    }, "addPromisesToClass");
    AWS2.Credentials.deletePromisesFromClass = /* @__PURE__ */ __name(function deletePromisesFromClass() {
      delete this.prototype.getPromise;
      delete this.prototype.refreshPromise;
    }, "deletePromisesFromClass");
    AWS2.util.addPromises(AWS2.Credentials);
  }
});

// node_modules/aws-sdk/lib/credentials/credential_provider_chain.js
var require_credential_provider_chain = __commonJS({
  "node_modules/aws-sdk/lib/credentials/credential_provider_chain.js"() {
    var AWS2 = require_core();
    AWS2.CredentialProviderChain = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function CredentialProviderChain(providers) {
        if (providers) {
          this.providers = providers;
        } else {
          this.providers = AWS2.CredentialProviderChain.defaultProviders.slice(0);
        }
        this.resolveCallbacks = [];
      }, "CredentialProviderChain"),
      resolve: /* @__PURE__ */ __name(function resolve(callback) {
        var self2 = this;
        if (self2.providers.length === 0) {
          callback(new Error("No providers"));
          return self2;
        }
        if (self2.resolveCallbacks.push(callback) === 1) {
          let resolveNext2 = function(err, creds) {
            if (!err && creds || index === providers.length) {
              AWS2.util.arrayEach(self2.resolveCallbacks, function(callback2) {
                callback2(err, creds);
              });
              self2.resolveCallbacks.length = 0;
              return;
            }
            var provider = providers[index++];
            if (typeof provider === "function") {
              creds = provider.call();
            } else {
              creds = provider;
            }
            if (creds.get) {
              creds.get(function(getErr) {
                resolveNext2(getErr, getErr ? null : creds);
              });
            } else {
              resolveNext2(null, creds);
            }
          };
          var resolveNext = resolveNext2;
          __name(resolveNext2, "resolveNext");
          var index = 0;
          var providers = self2.providers.slice(0);
          resolveNext2();
        }
        return self2;
      }, "resolve")
    });
    AWS2.CredentialProviderChain.defaultProviders = [];
    AWS2.CredentialProviderChain.addPromisesToClass = /* @__PURE__ */ __name(function addPromisesToClass(PromiseDependency) {
      this.prototype.resolvePromise = AWS2.util.promisifyMethod("resolve", PromiseDependency);
    }, "addPromisesToClass");
    AWS2.CredentialProviderChain.deletePromisesFromClass = /* @__PURE__ */ __name(function deletePromisesFromClass() {
      delete this.prototype.resolvePromise;
    }, "deletePromisesFromClass");
    AWS2.util.addPromises(AWS2.CredentialProviderChain);
  }
});

// node_modules/aws-sdk/lib/config.js
var require_config3 = __commonJS({
  "node_modules/aws-sdk/lib/config.js"() {
    var AWS2 = require_core();
    require_credentials();
    require_credential_provider_chain();
    var PromisesDependency;
    AWS2.Config = AWS2.util.inherit({
      constructor: /* @__PURE__ */ __name(function Config(options) {
        if (options === void 0)
          options = {};
        options = this.extractCredentials(options);
        AWS2.util.each.call(this, this.keys, function(key, value) {
          this.set(key, options[key], value);
        });
      }, "Config"),
      getCredentials: /* @__PURE__ */ __name(function getCredentials(callback) {
        var self2 = this;
        function finish(err) {
          callback(err, err ? null : self2.credentials);
        }
        __name(finish, "finish");
        function credError(msg, err) {
          return new AWS2.util.error(err || new Error(), {
            code: "CredentialsError",
            message: msg,
            name: "CredentialsError"
          });
        }
        __name(credError, "credError");
        function getAsyncCredentials() {
          self2.credentials.get(function(err) {
            if (err) {
              var msg = "Could not load credentials from " + self2.credentials.constructor.name;
              err = credError(msg, err);
            }
            finish(err);
          });
        }
        __name(getAsyncCredentials, "getAsyncCredentials");
        function getStaticCredentials() {
          var err = null;
          if (!self2.credentials.accessKeyId || !self2.credentials.secretAccessKey) {
            err = credError("Missing credentials");
          }
          finish(err);
        }
        __name(getStaticCredentials, "getStaticCredentials");
        if (self2.credentials) {
          if (typeof self2.credentials.get === "function") {
            getAsyncCredentials();
          } else {
            getStaticCredentials();
          }
        } else if (self2.credentialProvider) {
          self2.credentialProvider.resolve(function(err, creds) {
            if (err) {
              err = credError("Could not load credentials from any providers", err);
            }
            self2.credentials = creds;
            finish(err);
          });
        } else {
          finish(credError("No credentials to load"));
        }
      }, "getCredentials"),
      getToken: /* @__PURE__ */ __name(function getToken(callback) {
        var self2 = this;
        function finish(err) {
          callback(err, err ? null : self2.token);
        }
        __name(finish, "finish");
        function tokenError(msg, err) {
          return new AWS2.util.error(err || new Error(), {
            code: "TokenError",
            message: msg,
            name: "TokenError"
          });
        }
        __name(tokenError, "tokenError");
        function getAsyncToken() {
          self2.token.get(function(err) {
            if (err) {
              var msg = "Could not load token from " + self2.token.constructor.name;
              err = tokenError(msg, err);
            }
            finish(err);
          });
        }
        __name(getAsyncToken, "getAsyncToken");
        function getStaticToken() {
          var err = null;
          if (!self2.token.token) {
            err = tokenError("Missing token");
          }
          finish(err);
        }
        __name(getStaticToken, "getStaticToken");
        if (self2.token) {
          if (typeof self2.token.get === "function") {
            getAsyncToken();
          } else {
            getStaticToken();
          }
        } else if (self2.tokenProvider) {
          self2.tokenProvider.resolve(function(err, token) {
            if (err) {
              err = tokenError("Could not load token from any providers", err);
            }
            self2.token = token;
            finish(err);
          });
        } else {
          finish(tokenError("No token to load"));
        }
      }, "getToken"),
      update: /* @__PURE__ */ __name(function update(options, allowUnknownKeys) {
        allowUnknownKeys = allowUnknownKeys || false;
        options = this.extractCredentials(options);
        AWS2.util.each.call(this, options, function(key, value) {
          if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) || AWS2.Service.hasService(key)) {
            this.set(key, value);
          }
        });
      }, "update"),
      loadFromPath: /* @__PURE__ */ __name(function loadFromPath(path) {
        this.clear();
        var options = JSON.parse(AWS2.util.readFileSync(path));
        var fileSystemCreds = new AWS2.FileSystemCredentials(path);
        var chain = new AWS2.CredentialProviderChain();
        chain.providers.unshift(fileSystemCreds);
        chain.resolve(function(err, creds) {
          if (err)
            throw err;
          else
            options.credentials = creds;
        });
        this.constructor(options);
        return this;
      }, "loadFromPath"),
      clear: /* @__PURE__ */ __name(function clear() {
        AWS2.util.each.call(this, this.keys, function(key) {
          delete this[key];
        });
        this.set("credentials", void 0);
        this.set("credentialProvider", void 0);
      }, "clear"),
      set: /* @__PURE__ */ __name(function set(property, value, defaultValue) {
        if (value === void 0) {
          if (defaultValue === void 0) {
            defaultValue = this.keys[property];
          }
          if (typeof defaultValue === "function") {
            this[property] = defaultValue.call(this);
          } else {
            this[property] = defaultValue;
          }
        } else if (property === "httpOptions" && this[property]) {
          this[property] = AWS2.util.merge(this[property], value);
        } else {
          this[property] = value;
        }
      }, "set"),
      keys: {
        credentials: null,
        credentialProvider: null,
        region: null,
        logger: null,
        apiVersions: {},
        apiVersion: null,
        endpoint: void 0,
        httpOptions: {
          timeout: 12e4
        },
        maxRetries: void 0,
        maxRedirects: 10,
        paramValidation: true,
        sslEnabled: true,
        s3ForcePathStyle: false,
        s3BucketEndpoint: false,
        s3DisableBodySigning: true,
        s3UsEast1RegionalEndpoint: "legacy",
        s3UseArnRegion: void 0,
        computeChecksums: true,
        convertResponseTypes: true,
        correctClockSkew: false,
        customUserAgent: null,
        dynamoDbCrc32: true,
        systemClockOffset: 0,
        signatureVersion: null,
        signatureCache: true,
        retryDelayOptions: {},
        useAccelerateEndpoint: false,
        clientSideMonitoring: false,
        endpointDiscoveryEnabled: void 0,
        endpointCacheSize: 1e3,
        hostPrefixEnabled: true,
        stsRegionalEndpoints: "legacy",
        useFipsEndpoint: false,
        useDualstackEndpoint: false,
        token: null
      },
      extractCredentials: /* @__PURE__ */ __name(function extractCredentials(options) {
        if (options.accessKeyId && options.secretAccessKey) {
          options = AWS2.util.copy(options);
          options.credentials = new AWS2.Credentials(options);
        }
        return options;
      }, "extractCredentials"),
      setPromisesDependency: /* @__PURE__ */ __name(function setPromisesDependency(dep) {
        PromisesDependency = dep;
        if (dep === null && typeof Promise === "function") {
          PromisesDependency = Promise;
        }
        var constructors = [AWS2.Request, AWS2.Credentials, AWS2.CredentialProviderChain];
        if (AWS2.S3) {
          constructors.push(AWS2.S3);
          if (AWS2.S3.ManagedUpload) {
            constructors.push(AWS2.S3.ManagedUpload);
          }
        }
        AWS2.util.addPromises(constructors, PromisesDependency);
      }, "setPromisesDependency"),
      getPromisesDependency: /* @__PURE__ */ __name(function getPromisesDependency() {
        return PromisesDependency;
      }, "getPromisesDependency")
    });
    AWS2.config = new AWS2.Config();
  }
});

// node_modules/aws-sdk/lib/http.js
var require_http3 = __commonJS({
  "node_modules/aws-sdk/lib/http.js"() {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    AWS2.Endpoint = inherit({
      constructor: /* @__PURE__ */ __name(function Endpoint(endpoint, config) {
        AWS2.util.hideProperties(this, ["slashes", "auth", "hash", "search", "query"]);
        if (typeof endpoint === "undefined" || endpoint === null) {
          throw new Error("Invalid endpoint: " + endpoint);
        } else if (typeof endpoint !== "string") {
          return AWS2.util.copy(endpoint);
        }
        if (!endpoint.match(/^http/)) {
          var useSSL = config && config.sslEnabled !== void 0 ? config.sslEnabled : AWS2.config.sslEnabled;
          endpoint = (useSSL ? "https" : "http") + "://" + endpoint;
        }
        AWS2.util.update(this, AWS2.util.urlParse(endpoint));
        if (this.port) {
          this.port = parseInt(this.port, 10);
        } else {
          this.port = this.protocol === "https:" ? 443 : 80;
        }
      }, "Endpoint")
    });
    AWS2.HttpRequest = inherit({
      constructor: /* @__PURE__ */ __name(function HttpRequest(endpoint, region) {
        endpoint = new AWS2.Endpoint(endpoint);
        this.method = "POST";
        this.path = endpoint.path || "/";
        this.headers = {};
        this.body = "";
        this.endpoint = endpoint;
        this.region = region;
        this._userAgent = "";
        this.setUserAgent();
      }, "HttpRequest"),
      setUserAgent: /* @__PURE__ */ __name(function setUserAgent() {
        this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS2.util.userAgent();
      }, "setUserAgent"),
      getUserAgentHeaderName: /* @__PURE__ */ __name(function getUserAgentHeaderName() {
        var prefix = AWS2.util.isBrowser() ? "X-Amz-" : "";
        return prefix + "User-Agent";
      }, "getUserAgentHeaderName"),
      appendToUserAgent: /* @__PURE__ */ __name(function appendToUserAgent(agentPartial) {
        if (typeof agentPartial === "string" && agentPartial) {
          this._userAgent += " " + agentPartial;
        }
        this.headers[this.getUserAgentHeaderName()] = this._userAgent;
      }, "appendToUserAgent"),
      getUserAgent: /* @__PURE__ */ __name(function getUserAgent() {
        return this._userAgent;
      }, "getUserAgent"),
      pathname: /* @__PURE__ */ __name(function pathname() {
        return this.path.split("?", 1)[0];
      }, "pathname"),
      search: /* @__PURE__ */ __name(function search() {
        var query = this.path.split("?", 2)[1];
        if (query) {
          query = AWS2.util.queryStringParse(query);
          return AWS2.util.queryParamsToString(query);
        }
        return "";
      }, "search"),
      updateEndpoint: /* @__PURE__ */ __name(function updateEndpoint(endpointStr) {
        var newEndpoint = new AWS2.Endpoint(endpointStr);
        this.endpoint = newEndpoint;
        this.path = newEndpoint.path || "/";
        if (this.headers["Host"]) {
          this.headers["Host"] = newEndpoint.host;
        }
      }, "updateEndpoint")
    });
    AWS2.HttpResponse = inherit({
      constructor: /* @__PURE__ */ __name(function HttpResponse() {
        this.statusCode = void 0;
        this.headers = {};
        this.body = void 0;
        this.streaming = false;
        this.stream = null;
      }, "HttpResponse"),
      createUnbufferedStream: /* @__PURE__ */ __name(function createUnbufferedStream() {
        this.streaming = true;
        return this.stream;
      }, "createUnbufferedStream")
    });
    AWS2.HttpClient = inherit({});
    AWS2.HttpClient.getInstance = /* @__PURE__ */ __name(function getInstance() {
      if (this.singleton === void 0) {
        this.singleton = new this();
      }
      return this.singleton;
    }, "getInstance");
  }
});

// node_modules/aws-sdk/lib/discover_endpoint.js
var require_discover_endpoint = __commonJS({
  "node_modules/aws-sdk/lib/discover_endpoint.js"(exports2, module2) {
    var AWS2 = require_core();
    var util = require_util9();
    var endpointDiscoveryEnabledEnvs = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"];
    function getCacheKey(request) {
      var service = request.service;
      var api = service.api || {};
      var operations = api.operations;
      var identifiers = {};
      if (service.config.region) {
        identifiers.region = service.config.region;
      }
      if (api.serviceId) {
        identifiers.serviceId = api.serviceId;
      }
      if (service.config.credentials.accessKeyId) {
        identifiers.accessKeyId = service.config.credentials.accessKeyId;
      }
      return identifiers;
    }
    __name(getCacheKey, "getCacheKey");
    function marshallCustomIdentifiersHelper(result, params, shape) {
      if (!shape || params === void 0 || params === null)
        return;
      if (shape.type === "structure" && shape.required && shape.required.length > 0) {
        util.arrayEach(shape.required, function(name) {
          var memberShape = shape.members[name];
          if (memberShape.endpointDiscoveryId === true) {
            var locationName = memberShape.isLocationName ? memberShape.name : name;
            result[locationName] = String(params[name]);
          } else {
            marshallCustomIdentifiersHelper(result, params[name], memberShape);
          }
        });
      }
    }
    __name(marshallCustomIdentifiersHelper, "marshallCustomIdentifiersHelper");
    function marshallCustomIdentifiers(request, shape) {
      var identifiers = {};
      marshallCustomIdentifiersHelper(identifiers, request.params, shape);
      return identifiers;
    }
    __name(marshallCustomIdentifiers, "marshallCustomIdentifiers");
    function optionalDiscoverEndpoint(request) {
      var service = request.service;
      var api = service.api;
      var operationModel = api.operations ? api.operations[request.operation] : void 0;
      var inputShape = operationModel ? operationModel.input : void 0;
      var identifiers = marshallCustomIdentifiers(request, inputShape);
      var cacheKey = getCacheKey(request);
      if (Object.keys(identifiers).length > 0) {
        cacheKey = util.update(cacheKey, identifiers);
        if (operationModel)
          cacheKey.operation = operationModel.name;
      }
      var endpoints = AWS2.endpointCache.get(cacheKey);
      if (endpoints && endpoints.length === 1 && endpoints[0].Address === "") {
        return;
      } else if (endpoints && endpoints.length > 0) {
        request.httpRequest.updateEndpoint(endpoints[0].Address);
      } else {
        var endpointRequest = service.makeRequest(api.endpointOperation, {
          Operation: operationModel.name,
          Identifiers: identifiers
        });
        addApiVersionHeader(endpointRequest);
        endpointRequest.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_PARAMETERS);
        endpointRequest.removeListener("retry", AWS2.EventListeners.Core.RETRY_CHECK);
        AWS2.endpointCache.put(cacheKey, [{
          Address: "",
          CachePeriodInMinutes: 1
        }]);
        endpointRequest.send(function(err, data) {
          if (data && data.Endpoints) {
            AWS2.endpointCache.put(cacheKey, data.Endpoints);
          } else if (err) {
            AWS2.endpointCache.put(cacheKey, [{
              Address: "",
              CachePeriodInMinutes: 1
            }]);
          }
        });
      }
    }
    __name(optionalDiscoverEndpoint, "optionalDiscoverEndpoint");
    var requestQueue = {};
    function requiredDiscoverEndpoint(request, done) {
      var service = request.service;
      var api = service.api;
      var operationModel = api.operations ? api.operations[request.operation] : void 0;
      var inputShape = operationModel ? operationModel.input : void 0;
      var identifiers = marshallCustomIdentifiers(request, inputShape);
      var cacheKey = getCacheKey(request);
      if (Object.keys(identifiers).length > 0) {
        cacheKey = util.update(cacheKey, identifiers);
        if (operationModel)
          cacheKey.operation = operationModel.name;
      }
      var cacheKeyStr = AWS2.EndpointCache.getKeyString(cacheKey);
      var endpoints = AWS2.endpointCache.get(cacheKeyStr);
      if (endpoints && endpoints.length === 1 && endpoints[0].Address === "") {
        if (!requestQueue[cacheKeyStr])
          requestQueue[cacheKeyStr] = [];
        requestQueue[cacheKeyStr].push({ request, callback: done });
        return;
      } else if (endpoints && endpoints.length > 0) {
        request.httpRequest.updateEndpoint(endpoints[0].Address);
        done();
      } else {
        var endpointRequest = service.makeRequest(api.endpointOperation, {
          Operation: operationModel.name,
          Identifiers: identifiers
        });
        endpointRequest.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_PARAMETERS);
        addApiVersionHeader(endpointRequest);
        AWS2.endpointCache.put(cacheKeyStr, [{
          Address: "",
          CachePeriodInMinutes: 60
        }]);
        endpointRequest.send(function(err, data) {
          if (err) {
            request.response.error = util.error(err, { retryable: false });
            AWS2.endpointCache.remove(cacheKey);
            if (requestQueue[cacheKeyStr]) {
              var pendingRequests = requestQueue[cacheKeyStr];
              util.arrayEach(pendingRequests, function(requestContext) {
                requestContext.request.response.error = util.error(err, { retryable: false });
                requestContext.callback();
              });
              delete requestQueue[cacheKeyStr];
            }
          } else if (data) {
            AWS2.endpointCache.put(cacheKeyStr, data.Endpoints);
            request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
            if (requestQueue[cacheKeyStr]) {
              var pendingRequests = requestQueue[cacheKeyStr];
              util.arrayEach(pendingRequests, function(requestContext) {
                requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
                requestContext.callback();
              });
              delete requestQueue[cacheKeyStr];
            }
          }
          done();
        });
      }
    }
    __name(requiredDiscoverEndpoint, "requiredDiscoverEndpoint");
    function addApiVersionHeader(endpointRequest) {
      var api = endpointRequest.service.api;
      var apiVersion = api.apiVersion;
      if (apiVersion && !endpointRequest.httpRequest.headers["x-amz-api-version"]) {
        endpointRequest.httpRequest.headers["x-amz-api-version"] = apiVersion;
      }
    }
    __name(addApiVersionHeader, "addApiVersionHeader");
    function invalidateCachedEndpoints(response) {
      var error = response.error;
      var httpResponse = response.httpResponse;
      if (error && (error.code === "InvalidEndpointException" || httpResponse.statusCode === 421)) {
        var request = response.request;
        var operations = request.service.api.operations || {};
        var inputShape = operations[request.operation] ? operations[request.operation].input : void 0;
        var identifiers = marshallCustomIdentifiers(request, inputShape);
        var cacheKey = getCacheKey(request);
        if (Object.keys(identifiers).length > 0) {
          cacheKey = util.update(cacheKey, identifiers);
          if (operations[request.operation])
            cacheKey.operation = operations[request.operation].name;
        }
        AWS2.endpointCache.remove(cacheKey);
      }
    }
    __name(invalidateCachedEndpoints, "invalidateCachedEndpoints");
    function hasCustomEndpoint(client) {
      if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
        throw util.error(new Error(), {
          code: "ConfigurationException",
          message: "Custom endpoint is supplied; endpointDiscoveryEnabled must not be true."
        });
      }
      ;
      var svcConfig = AWS2.config[client.serviceIdentifier] || {};
      return Boolean(AWS2.config.endpoint || svcConfig.endpoint || client._originalConfig && client._originalConfig.endpoint);
    }
    __name(hasCustomEndpoint, "hasCustomEndpoint");
    function isFalsy(value) {
      return ["false", "0"].indexOf(value) >= 0;
    }
    __name(isFalsy, "isFalsy");
    function resolveEndpointDiscoveryConfig(request) {
      var service = request.service || {};
      if (service.config.endpointDiscoveryEnabled !== void 0) {
        return service.config.endpointDiscoveryEnabled;
      }
      if (util.isBrowser())
        return void 0;
      for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
        var env = endpointDiscoveryEnabledEnvs[i];
        if (Object.prototype.hasOwnProperty.call(process.env, env)) {
          if (process.env[env] === "" || process.env[env] === void 0) {
            throw util.error(new Error(), {
              code: "ConfigurationException",
              message: "environmental variable " + env + " cannot be set to nothing"
            });
          }
          return !isFalsy(process.env[env]);
        }
      }
      var configFile = {};
      try {
        configFile = AWS2.util.iniLoader ? AWS2.util.iniLoader.loadFrom({
          isConfig: true,
          filename: process.env[AWS2.util.sharedConfigFileEnv]
        }) : {};
      } catch (e) {
      }
      var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS2.util.defaultProfile] || {};
      if (Object.prototype.hasOwnProperty.call(sharedFileConfig, "endpoint_discovery_enabled")) {
        if (sharedFileConfig.endpoint_discovery_enabled === void 0) {
          throw util.error(new Error(), {
            code: "ConfigurationException",
            message: "config file entry 'endpoint_discovery_enabled' cannot be set to nothing"
          });
        }
        return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);
      }
      return void 0;
    }
    __name(resolveEndpointDiscoveryConfig, "resolveEndpointDiscoveryConfig");
    function discoverEndpoint(request, done) {
      var service = request.service || {};
      if (hasCustomEndpoint(service) || request.isPresigned())
        return done();
      var operations = service.api.operations || {};
      var operationModel = operations[request.operation];
      var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : "NULL";
      var isEnabled = resolveEndpointDiscoveryConfig(request);
      var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;
      if (isEnabled || hasRequiredEndpointDiscovery) {
        request.httpRequest.appendToUserAgent("endpoint-discovery");
      }
      switch (isEndpointDiscoveryRequired) {
        case "OPTIONAL":
          if (isEnabled || hasRequiredEndpointDiscovery) {
            optionalDiscoverEndpoint(request);
            request.addNamedListener("INVALIDATE_CACHED_ENDPOINTS", "extractError", invalidateCachedEndpoints);
          }
          done();
          break;
        case "REQUIRED":
          if (isEnabled === false) {
            request.response.error = util.error(new Error(), {
              code: "ConfigurationException",
              message: "Endpoint Discovery is disabled but " + service.api.className + "." + request.operation + "() requires it. Please check your configurations."
            });
            done();
            break;
          }
          request.addNamedListener("INVALIDATE_CACHED_ENDPOINTS", "extractError", invalidateCachedEndpoints);
          requiredDiscoverEndpoint(request, done);
          break;
        case "NULL":
        default:
          done();
          break;
      }
    }
    __name(discoverEndpoint, "discoverEndpoint");
    module2.exports = {
      discoverEndpoint,
      requiredDiscoverEndpoint,
      optionalDiscoverEndpoint,
      marshallCustomIdentifiers,
      getCacheKey,
      invalidateCachedEndpoint: invalidateCachedEndpoints
    };
  }
});

// node_modules/aws-sdk/lib/event_listeners.js
var require_event_listeners = __commonJS({
  "node_modules/aws-sdk/lib/event_listeners.js"() {
    var AWS2 = require_core();
    var SequentialExecutor = require_sequential_executor();
    var DISCOVER_ENDPOINT = require_discover_endpoint().discoverEndpoint;
    AWS2.EventListeners = {
      Core: {}
    };
    function getOperationAuthtype(req) {
      if (!req.service.api.operations) {
        return "";
      }
      var operation = req.service.api.operations[req.operation];
      return operation ? operation.authtype : "";
    }
    __name(getOperationAuthtype, "getOperationAuthtype");
    function getIdentityType(req) {
      var service = req.service;
      if (service.config.signatureVersion) {
        return service.config.signatureVersion;
      }
      if (service.api.signatureVersion) {
        return service.api.signatureVersion;
      }
      return getOperationAuthtype(req);
    }
    __name(getIdentityType, "getIdentityType");
    AWS2.EventListeners = {
      Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
        addAsync(
          "VALIDATE_CREDENTIALS",
          "validate",
          /* @__PURE__ */ __name(function VALIDATE_CREDENTIALS(req, done) {
            if (!req.service.api.signatureVersion && !req.service.config.signatureVersion)
              return done();
            var identityType = getIdentityType(req);
            if (identityType === "bearer") {
              req.service.config.getToken(function(err) {
                if (err) {
                  req.response.error = AWS2.util.error(err, { code: "TokenError" });
                }
                done();
              });
              return;
            }
            req.service.config.getCredentials(function(err) {
              if (err) {
                req.response.error = AWS2.util.error(
                  err,
                  {
                    code: "CredentialsError",
                    message: "Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1"
                  }
                );
              }
              done();
            });
          }, "VALIDATE_CREDENTIALS")
        );
        add("VALIDATE_REGION", "validate", /* @__PURE__ */ __name(function VALIDATE_REGION(req) {
          if (!req.service.isGlobalEndpoint) {
            var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
            if (!req.service.config.region) {
              req.response.error = AWS2.util.error(
                new Error(),
                { code: "ConfigError", message: "Missing region in config" }
              );
            } else if (!dnsHostRegex.test(req.service.config.region)) {
              req.response.error = AWS2.util.error(
                new Error(),
                { code: "ConfigError", message: "Invalid region in config" }
              );
            }
          }
        }, "VALIDATE_REGION"));
        add("BUILD_IDEMPOTENCY_TOKENS", "validate", /* @__PURE__ */ __name(function BUILD_IDEMPOTENCY_TOKENS(req) {
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          if (!operation) {
            return;
          }
          var idempotentMembers = operation.idempotentMembers;
          if (!idempotentMembers.length) {
            return;
          }
          var params = AWS2.util.copy(req.params);
          for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
            if (!params[idempotentMembers[i]]) {
              params[idempotentMembers[i]] = AWS2.util.uuid.v4();
            }
          }
          req.params = params;
        }, "BUILD_IDEMPOTENCY_TOKENS"));
        add("VALIDATE_PARAMETERS", "validate", /* @__PURE__ */ __name(function VALIDATE_PARAMETERS(req) {
          if (!req.service.api.operations) {
            return;
          }
          var rules = req.service.api.operations[req.operation].input;
          var validation = req.service.config.paramValidation;
          new AWS2.ParamValidator(validation).validate(rules, req.params);
        }, "VALIDATE_PARAMETERS"));
        add("COMPUTE_CHECKSUM", "afterBuild", /* @__PURE__ */ __name(function COMPUTE_CHECKSUM(req) {
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          if (!operation) {
            return;
          }
          var body = req.httpRequest.body;
          var isNonStreamingPayload = body && (AWS2.util.Buffer.isBuffer(body) || typeof body === "string");
          var headers = req.httpRequest.headers;
          if (operation.httpChecksumRequired && req.service.config.computeChecksums && isNonStreamingPayload && !headers["Content-MD5"]) {
            var md5 = AWS2.util.crypto.md5(body, "base64");
            headers["Content-MD5"] = md5;
          }
        }, "COMPUTE_CHECKSUM"));
        addAsync("COMPUTE_SHA256", "afterBuild", /* @__PURE__ */ __name(function COMPUTE_SHA256(req, done) {
          req.haltHandlersOnError();
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          var authtype = operation ? operation.authtype : "";
          if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion)
            return done();
          if (req.service.getSignerClass(req) === AWS2.Signers.V4) {
            var body = req.httpRequest.body || "";
            if (authtype.indexOf("unsigned-body") >= 0) {
              req.httpRequest.headers["X-Amz-Content-Sha256"] = "UNSIGNED-PAYLOAD";
              return done();
            }
            AWS2.util.computeSha256(body, function(err, sha) {
              if (err) {
                done(err);
              } else {
                req.httpRequest.headers["X-Amz-Content-Sha256"] = sha;
                done();
              }
            });
          } else {
            done();
          }
        }, "COMPUTE_SHA256"));
        add("SET_CONTENT_LENGTH", "afterBuild", /* @__PURE__ */ __name(function SET_CONTENT_LENGTH(req) {
          var authtype = getOperationAuthtype(req);
          var payloadMember = AWS2.util.getRequestPayloadShape(req);
          if (req.httpRequest.headers["Content-Length"] === void 0) {
            try {
              var length = AWS2.util.string.byteLength(req.httpRequest.body);
              req.httpRequest.headers["Content-Length"] = length;
            } catch (err) {
              if (payloadMember && payloadMember.isStreaming) {
                if (payloadMember.requiresLength) {
                  throw err;
                } else if (authtype.indexOf("unsigned-body") >= 0) {
                  req.httpRequest.headers["Transfer-Encoding"] = "chunked";
                  return;
                } else {
                  throw err;
                }
              }
              throw err;
            }
          }
        }, "SET_CONTENT_LENGTH"));
        add("SET_HTTP_HOST", "afterBuild", /* @__PURE__ */ __name(function SET_HTTP_HOST(req) {
          req.httpRequest.headers["Host"] = req.httpRequest.endpoint.host;
        }, "SET_HTTP_HOST"));
        add("SET_TRACE_ID", "afterBuild", /* @__PURE__ */ __name(function SET_TRACE_ID(req) {
          var traceIdHeaderName = "X-Amzn-Trace-Id";
          if (AWS2.util.isNode() && !Object.hasOwnProperty.call(req.httpRequest.headers, traceIdHeaderName)) {
            var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
            var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
            var functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
            var traceId = process.env[ENV_TRACE_ID];
            if (typeof functionName === "string" && functionName.length > 0 && typeof traceId === "string" && traceId.length > 0) {
              req.httpRequest.headers[traceIdHeaderName] = traceId;
            }
          }
        }, "SET_TRACE_ID"));
        add("RESTART", "restart", /* @__PURE__ */ __name(function RESTART() {
          var err = this.response.error;
          if (!err || !err.retryable)
            return;
          this.httpRequest = new AWS2.HttpRequest(
            this.service.endpoint,
            this.service.region
          );
          if (this.response.retryCount < this.service.config.maxRetries) {
            this.response.retryCount++;
          } else {
            this.response.error = null;
          }
        }, "RESTART"));
        var addToHead = true;
        addAsync("DISCOVER_ENDPOINT", "sign", DISCOVER_ENDPOINT, addToHead);
        addAsync("SIGN", "sign", /* @__PURE__ */ __name(function SIGN(req, done) {
          var service = req.service;
          var identityType = getIdentityType(req);
          if (!identityType || identityType.length === 0)
            return done();
          if (identityType === "bearer") {
            service.config.getToken(function(err, token) {
              if (err) {
                req.response.error = err;
                return done();
              }
              try {
                var SignerClass = service.getSignerClass(req);
                var signer = new SignerClass(req.httpRequest);
                signer.addAuthorization(token);
              } catch (e) {
                req.response.error = e;
              }
              done();
            });
          } else {
            service.config.getCredentials(function(err, credentials) {
              if (err) {
                req.response.error = err;
                return done();
              }
              try {
                var date = service.getSkewCorrectedDate();
                var SignerClass = service.getSignerClass(req);
                var operations = req.service.api.operations || {};
                var operation = operations[req.operation];
                var signer = new SignerClass(
                  req.httpRequest,
                  service.getSigningName(req),
                  {
                    signatureCache: service.config.signatureCache,
                    operation,
                    signatureVersion: service.api.signatureVersion
                  }
                );
                signer.setServiceClientId(service._clientId);
                delete req.httpRequest.headers["Authorization"];
                delete req.httpRequest.headers["Date"];
                delete req.httpRequest.headers["X-Amz-Date"];
                signer.addAuthorization(credentials, date);
                req.signedAt = date;
              } catch (e) {
                req.response.error = e;
              }
              done();
            });
          }
        }, "SIGN"));
        add("VALIDATE_RESPONSE", "validateResponse", /* @__PURE__ */ __name(function VALIDATE_RESPONSE(resp) {
          if (this.service.successfulResponse(resp, this)) {
            resp.data = {};
            resp.error = null;
          } else {
            resp.data = null;
            resp.error = AWS2.util.error(
              new Error(),
              { code: "UnknownError", message: "An unknown error occurred." }
            );
          }
        }, "VALIDATE_RESPONSE"));
        add("ERROR", "error", /* @__PURE__ */ __name(function ERROR(err, resp) {
          var awsQueryCompatible = resp.request.service.api.awsQueryCompatible;
          if (awsQueryCompatible) {
            var headers = resp.httpResponse.headers;
            var queryErrorCode = headers ? headers["x-amzn-query-error"] : void 0;
            if (queryErrorCode && queryErrorCode.includes(";")) {
              resp.error.code = queryErrorCode.split(";")[0];
            }
          }
        }, "ERROR"), true);
        addAsync("SEND", "send", /* @__PURE__ */ __name(function SEND(resp, done) {
          resp.httpResponse._abortCallback = done;
          resp.error = null;
          resp.data = null;
          function callback(httpResp) {
            resp.httpResponse.stream = httpResp;
            var stream = resp.request.httpRequest.stream;
            var service = resp.request.service;
            var api = service.api;
            var operationName = resp.request.operation;
            var operation = api.operations[operationName] || {};
            httpResp.on("headers", /* @__PURE__ */ __name(function onHeaders(statusCode, headers, statusMessage) {
              resp.request.emit(
                "httpHeaders",
                [statusCode, headers, resp, statusMessage]
              );
              if (!resp.httpResponse.streaming) {
                if (AWS2.HttpClient.streamsApiVersion === 2) {
                  if (operation.hasEventOutput && service.successfulResponse(resp)) {
                    resp.request.emit("httpDone");
                    done();
                    return;
                  }
                  httpResp.on("readable", /* @__PURE__ */ __name(function onReadable() {
                    var data = httpResp.read();
                    if (data !== null) {
                      resp.request.emit("httpData", [data, resp]);
                    }
                  }, "onReadable"));
                } else {
                  httpResp.on("data", /* @__PURE__ */ __name(function onData(data) {
                    resp.request.emit("httpData", [data, resp]);
                  }, "onData"));
                }
              }
            }, "onHeaders"));
            httpResp.on("end", /* @__PURE__ */ __name(function onEnd() {
              if (!stream || !stream.didCallback) {
                if (AWS2.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
                  return;
                }
                resp.request.emit("httpDone");
                done();
              }
            }, "onEnd"));
          }
          __name(callback, "callback");
          function progress(httpResp) {
            httpResp.on("sendProgress", /* @__PURE__ */ __name(function onSendProgress(value) {
              resp.request.emit("httpUploadProgress", [value, resp]);
            }, "onSendProgress"));
            httpResp.on("receiveProgress", /* @__PURE__ */ __name(function onReceiveProgress(value) {
              resp.request.emit("httpDownloadProgress", [value, resp]);
            }, "onReceiveProgress"));
          }
          __name(progress, "progress");
          function error(err) {
            if (err.code !== "RequestAbortedError") {
              var errCode = err.code === "TimeoutError" ? err.code : "NetworkingError";
              err = AWS2.util.error(err, {
                code: errCode,
                region: resp.request.httpRequest.region,
                hostname: resp.request.httpRequest.endpoint.hostname,
                retryable: true
              });
            }
            resp.error = err;
            resp.request.emit("httpError", [resp.error, resp], function() {
              done();
            });
          }
          __name(error, "error");
          function executeSend() {
            var http = AWS2.HttpClient.getInstance();
            var httpOptions = resp.request.service.config.httpOptions || {};
            try {
              var stream = http.handleRequest(
                resp.request.httpRequest,
                httpOptions,
                callback,
                error
              );
              progress(stream);
            } catch (err) {
              error(err);
            }
          }
          __name(executeSend, "executeSend");
          var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1e3;
          if (timeDiff >= 60 * 10) {
            this.emit("sign", [this], function(err) {
              if (err)
                done(err);
              else
                executeSend();
            });
          } else {
            executeSend();
          }
        }, "SEND"));
        add(
          "HTTP_HEADERS",
          "httpHeaders",
          /* @__PURE__ */ __name(function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
            resp.httpResponse.statusCode = statusCode;
            resp.httpResponse.statusMessage = statusMessage;
            resp.httpResponse.headers = headers;
            resp.httpResponse.body = AWS2.util.buffer.toBuffer("");
            resp.httpResponse.buffers = [];
            resp.httpResponse.numBytes = 0;
            var dateHeader = headers.date || headers.Date;
            var service = resp.request.service;
            if (dateHeader) {
              var serverTime = Date.parse(dateHeader);
              if (service.config.correctClockSkew && service.isClockSkewed(serverTime)) {
                service.applyClockOffset(serverTime);
              }
            }
          }, "HTTP_HEADERS")
        );
        add("HTTP_DATA", "httpData", /* @__PURE__ */ __name(function HTTP_DATA(chunk, resp) {
          if (chunk) {
            if (AWS2.util.isNode()) {
              resp.httpResponse.numBytes += chunk.length;
              var total = resp.httpResponse.headers["content-length"];
              var progress = { loaded: resp.httpResponse.numBytes, total };
              resp.request.emit("httpDownloadProgress", [progress, resp]);
            }
            resp.httpResponse.buffers.push(AWS2.util.buffer.toBuffer(chunk));
          }
        }, "HTTP_DATA"));
        add("HTTP_DONE", "httpDone", /* @__PURE__ */ __name(function HTTP_DONE(resp) {
          if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
            var body = AWS2.util.buffer.concat(resp.httpResponse.buffers);
            resp.httpResponse.body = body;
          }
          delete resp.httpResponse.numBytes;
          delete resp.httpResponse.buffers;
        }, "HTTP_DONE"));
        add("FINALIZE_ERROR", "retry", /* @__PURE__ */ __name(function FINALIZE_ERROR(resp) {
          if (resp.httpResponse.statusCode) {
            resp.error.statusCode = resp.httpResponse.statusCode;
            if (resp.error.retryable === void 0) {
              resp.error.retryable = this.service.retryableError(resp.error, this);
            }
          }
        }, "FINALIZE_ERROR"));
        add("INVALIDATE_CREDENTIALS", "retry", /* @__PURE__ */ __name(function INVALIDATE_CREDENTIALS(resp) {
          if (!resp.error)
            return;
          switch (resp.error.code) {
            case "RequestExpired":
            case "ExpiredTokenException":
            case "ExpiredToken":
              resp.error.retryable = true;
              resp.request.service.config.credentials.expired = true;
          }
        }, "INVALIDATE_CREDENTIALS"));
        add("EXPIRED_SIGNATURE", "retry", /* @__PURE__ */ __name(function EXPIRED_SIGNATURE(resp) {
          var err = resp.error;
          if (!err)
            return;
          if (typeof err.code === "string" && typeof err.message === "string") {
            if (err.code.match(/Signature/) && err.message.match(/expired/)) {
              resp.error.retryable = true;
            }
          }
        }, "EXPIRED_SIGNATURE"));
        add("CLOCK_SKEWED", "retry", /* @__PURE__ */ __name(function CLOCK_SKEWED(resp) {
          if (!resp.error)
            return;
          if (this.service.clockSkewError(resp.error) && this.service.config.correctClockSkew) {
            resp.error.retryable = true;
          }
        }, "CLOCK_SKEWED"));
        add("REDIRECT", "retry", /* @__PURE__ */ __name(function REDIRECT(resp) {
          if (resp.error && resp.error.statusCode >= 300 && resp.error.statusCode < 400 && resp.httpResponse.headers["location"]) {
            this.httpRequest.endpoint = new AWS2.Endpoint(resp.httpResponse.headers["location"]);
            this.httpRequest.headers["Host"] = this.httpRequest.endpoint.host;
            resp.error.redirect = true;
            resp.error.retryable = true;
          }
        }, "REDIRECT"));
        add("RETRY_CHECK", "retry", /* @__PURE__ */ __name(function RETRY_CHECK(resp) {
          if (resp.error) {
            if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
              resp.error.retryDelay = 0;
            } else if (resp.retryCount < resp.maxRetries) {
              resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
            }
          }
        }, "RETRY_CHECK"));
        addAsync("RESET_RETRY_STATE", "afterRetry", /* @__PURE__ */ __name(function RESET_RETRY_STATE(resp, done) {
          var delay, willRetry = false;
          if (resp.error) {
            delay = resp.error.retryDelay || 0;
            if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
              resp.retryCount++;
              willRetry = true;
            } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
              resp.redirectCount++;
              willRetry = true;
            }
          }
          if (willRetry && delay >= 0) {
            resp.error = null;
            setTimeout(done, delay);
          } else {
            done();
          }
        }, "RESET_RETRY_STATE"));
      }),
      CorePost: new SequentialExecutor().addNamedListeners(function(add) {
        add("EXTRACT_REQUEST_ID", "extractData", AWS2.util.extractRequestId);
        add("EXTRACT_REQUEST_ID", "extractError", AWS2.util.extractRequestId);
        add("ENOTFOUND_ERROR", "httpError", /* @__PURE__ */ __name(function ENOTFOUND_ERROR(err) {
          function isDNSError(err2) {
            return err2.errno === "ENOTFOUND" || typeof err2.errno === "number" && typeof AWS2.util.getSystemErrorName === "function" && ["EAI_NONAME", "EAI_NODATA"].indexOf(AWS2.util.getSystemErrorName(err2.errno) >= 0);
          }
          __name(isDNSError, "isDNSError");
          if (err.code === "NetworkingError" && isDNSError(err)) {
            var message = "Inaccessible host: `" + err.hostname + "' at port `" + err.port + "'. This service may not be available in the `" + err.region + "' region.";
            this.response.error = AWS2.util.error(new Error(message), {
              code: "UnknownEndpoint",
              region: err.region,
              hostname: err.hostname,
              retryable: true,
              originalError: err
            });
          }
        }, "ENOTFOUND_ERROR"));
      }),
      Logger: new SequentialExecutor().addNamedListeners(function(add) {
        add("LOG_REQUEST", "complete", /* @__PURE__ */ __name(function LOG_REQUEST(resp) {
          var req = resp.request;
          var logger = req.service.config.logger;
          if (!logger)
            return;
          function filterSensitiveLog(inputShape, shape) {
            if (!shape) {
              return shape;
            }
            if (inputShape.isSensitive) {
              return "***SensitiveInformation***";
            }
            switch (inputShape.type) {
              case "structure":
                var struct = {};
                AWS2.util.each(shape, function(subShapeName, subShape) {
                  if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                    struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
                  } else {
                    struct[subShapeName] = subShape;
                  }
                });
                return struct;
              case "list":
                var list = [];
                AWS2.util.arrayEach(shape, function(subShape, index) {
                  list.push(filterSensitiveLog(inputShape.member, subShape));
                });
                return list;
              case "map":
                var map = {};
                AWS2.util.each(shape, function(key, value) {
                  map[key] = filterSensitiveLog(inputShape.value, value);
                });
                return map;
              default:
                return shape;
            }
          }
          __name(filterSensitiveLog, "filterSensitiveLog");
          function buildMessage() {
            var time = resp.request.service.getSkewCorrectedDate().getTime();
            var delta = (time - req.startTime.getTime()) / 1e3;
            var ansi = logger.isTTY ? true : false;
            var status = resp.httpResponse.statusCode;
            var censoredParams = req.params;
            if (req.service.api.operations && req.service.api.operations[req.operation] && req.service.api.operations[req.operation].input) {
              var inputShape = req.service.api.operations[req.operation].input;
              censoredParams = filterSensitiveLog(inputShape, req.params);
            }
            var params = __require("util").inspect(censoredParams, true, null);
            var message = "";
            if (ansi)
              message += "\x1B[33m";
            message += "[AWS " + req.service.serviceIdentifier + " " + status;
            message += " " + delta.toString() + "s " + resp.retryCount + " retries]";
            if (ansi)
              message += "\x1B[0;1m";
            message += " " + AWS2.util.string.lowerFirst(req.operation);
            message += "(" + params + ")";
            if (ansi)
              message += "\x1B[0m";
            return message;
          }
          __name(buildMessage, "buildMessage");
          var line = buildMessage();
          if (typeof logger.log === "function") {
            logger.log(line);
          } else if (typeof logger.write === "function") {
            logger.write(line + "\n");
          }
        }, "LOG_REQUEST"));
      }),
      Json: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_json();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      }),
      Rest: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_rest();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      }),
      RestJson: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_rest_json();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
        add("UNSET_CONTENT_LENGTH", "afterBuild", svc.unsetContentLength);
      }),
      RestXml: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_rest_xml();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      }),
      Query: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_query();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      })
    };
  }
});

// node_modules/aws-sdk/lib/state_machine.js
var require_state_machine = __commonJS({
  "node_modules/aws-sdk/lib/state_machine.js"(exports2, module2) {
    function AcceptorStateMachine(states, state) {
      this.currentState = state || null;
      this.states = states || {};
    }
    __name(AcceptorStateMachine, "AcceptorStateMachine");
    AcceptorStateMachine.prototype.runTo = /* @__PURE__ */ __name(function runTo(finalState, done, bindObject, inputError) {
      if (typeof finalState === "function") {
        inputError = bindObject;
        bindObject = done;
        done = finalState;
        finalState = null;
      }
      var self2 = this;
      var state = self2.states[self2.currentState];
      state.fn.call(bindObject || self2, inputError, function(err) {
        if (err) {
          if (state.fail)
            self2.currentState = state.fail;
          else
            return done ? done.call(bindObject, err) : null;
        } else {
          if (state.accept)
            self2.currentState = state.accept;
          else
            return done ? done.call(bindObject) : null;
        }
        if (self2.currentState === finalState) {
          return done ? done.call(bindObject, err) : null;
        }
        self2.runTo(finalState, done, bindObject, err);
      });
    }, "runTo");
    AcceptorStateMachine.prototype.addState = /* @__PURE__ */ __name(function addState(name, acceptState, failState, fn) {
      if (typeof acceptState === "function") {
        fn = acceptState;
        acceptState = null;
        failState = null;
      } else if (typeof failState === "function") {
        fn = failState;
        failState = null;
      }
      if (!this.currentState)
        this.currentState = name;
      this.states[name] = { accept: acceptState, fail: failState, fn };
      return this;
    }, "addState");
    module2.exports = AcceptorStateMachine;
  }
});

// node_modules/jmespath/jmespath.js
var require_jmespath = __commonJS({
  "node_modules/jmespath/jmespath.js"(exports2) {
    (function(exports3) {
      "use strict";
      function isArray(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        } else {
          return false;
        }
      }
      __name(isArray, "isArray");
      function isObject(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        } else {
          return false;
        }
      }
      __name(isObject, "isObject");
      function strictDeepEqual(first, second) {
        if (first === second) {
          return true;
        }
        var firstType = Object.prototype.toString.call(first);
        if (firstType !== Object.prototype.toString.call(second)) {
          return false;
        }
        if (isArray(first) === true) {
          if (first.length !== second.length) {
            return false;
          }
          for (var i = 0; i < first.length; i++) {
            if (strictDeepEqual(first[i], second[i]) === false) {
              return false;
            }
          }
          return true;
        }
        if (isObject(first) === true) {
          var keysSeen = {};
          for (var key in first) {
            if (hasOwnProperty.call(first, key)) {
              if (strictDeepEqual(first[key], second[key]) === false) {
                return false;
              }
              keysSeen[key] = true;
            }
          }
          for (var key2 in second) {
            if (hasOwnProperty.call(second, key2)) {
              if (keysSeen[key2] !== true) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      __name(strictDeepEqual, "strictDeepEqual");
      function isFalse(obj) {
        if (obj === "" || obj === false || obj === null) {
          return true;
        } else if (isArray(obj) && obj.length === 0) {
          return true;
        } else if (isObject(obj)) {
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
      __name(isFalse, "isFalse");
      function objValues(obj) {
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
          values.push(obj[keys[i]]);
        }
        return values;
      }
      __name(objValues, "objValues");
      function merge(a, b) {
        var merged = {};
        for (var key in a) {
          merged[key] = a[key];
        }
        for (var key2 in b) {
          merged[key2] = b[key2];
        }
        return merged;
      }
      __name(merge, "merge");
      var trimLeft;
      if (typeof String.prototype.trimLeft === "function") {
        trimLeft = /* @__PURE__ */ __name(function(str) {
          return str.trimLeft();
        }, "trimLeft");
      } else {
        trimLeft = /* @__PURE__ */ __name(function(str) {
          return str.match(/^\s*(.*)/)[1];
        }, "trimLeft");
      }
      var TYPE_NUMBER = 0;
      var TYPE_ANY = 1;
      var TYPE_STRING = 2;
      var TYPE_ARRAY = 3;
      var TYPE_OBJECT = 4;
      var TYPE_BOOLEAN = 5;
      var TYPE_EXPREF = 6;
      var TYPE_NULL = 7;
      var TYPE_ARRAY_NUMBER = 8;
      var TYPE_ARRAY_STRING = 9;
      var TYPE_NAME_TABLE = {
        0: "number",
        1: "any",
        2: "string",
        3: "array",
        4: "object",
        5: "boolean",
        6: "expression",
        7: "null",
        8: "Array<number>",
        9: "Array<string>"
      };
      var TOK_EOF = "EOF";
      var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
      var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
      var TOK_RBRACKET = "Rbracket";
      var TOK_RPAREN = "Rparen";
      var TOK_COMMA = "Comma";
      var TOK_COLON = "Colon";
      var TOK_RBRACE = "Rbrace";
      var TOK_NUMBER = "Number";
      var TOK_CURRENT = "Current";
      var TOK_EXPREF = "Expref";
      var TOK_PIPE = "Pipe";
      var TOK_OR = "Or";
      var TOK_AND = "And";
      var TOK_EQ = "EQ";
      var TOK_GT = "GT";
      var TOK_LT = "LT";
      var TOK_GTE = "GTE";
      var TOK_LTE = "LTE";
      var TOK_NE = "NE";
      var TOK_FLATTEN = "Flatten";
      var TOK_STAR = "Star";
      var TOK_FILTER = "Filter";
      var TOK_DOT = "Dot";
      var TOK_NOT = "Not";
      var TOK_LBRACE = "Lbrace";
      var TOK_LBRACKET = "Lbracket";
      var TOK_LPAREN = "Lparen";
      var TOK_LITERAL = "Literal";
      var basicTokens = {
        ".": TOK_DOT,
        "*": TOK_STAR,
        ",": TOK_COMMA,
        ":": TOK_COLON,
        "{": TOK_LBRACE,
        "}": TOK_RBRACE,
        "]": TOK_RBRACKET,
        "(": TOK_LPAREN,
        ")": TOK_RPAREN,
        "@": TOK_CURRENT
      };
      var operatorStartToken = {
        "<": true,
        ">": true,
        "=": true,
        "!": true
      };
      var skipChars = {
        " ": true,
        "	": true,
        "\n": true
      };
      function isAlpha(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_";
      }
      __name(isAlpha, "isAlpha");
      function isNum(ch) {
        return ch >= "0" && ch <= "9" || ch === "-";
      }
      __name(isNum, "isNum");
      function isAlphaNum(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9" || ch === "_";
      }
      __name(isAlphaNum, "isAlphaNum");
      function Lexer() {
      }
      __name(Lexer, "Lexer");
      Lexer.prototype = {
        tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
            if (isAlpha(stream[this._current])) {
              start = this._current;
              identifier = this._consumeUnquotedIdentifier(stream);
              tokens.push({
                type: TOK_UNQUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (basicTokens[stream[this._current]] !== void 0) {
              tokens.push({
                type: basicTokens[stream[this._current]],
                value: stream[this._current],
                start: this._current
              });
              this._current++;
            } else if (isNum(stream[this._current])) {
              token = this._consumeNumber(stream);
              tokens.push(token);
            } else if (stream[this._current] === "[") {
              token = this._consumeLBracket(stream);
              tokens.push(token);
            } else if (stream[this._current] === '"') {
              start = this._current;
              identifier = this._consumeQuotedIdentifier(stream);
              tokens.push({
                type: TOK_QUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "'") {
              start = this._current;
              identifier = this._consumeRawStringLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "`") {
              start = this._current;
              var literal = this._consumeLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: literal,
                start
              });
            } else if (operatorStartToken[stream[this._current]] !== void 0) {
              tokens.push(this._consumeOperator(stream));
            } else if (skipChars[stream[this._current]] !== void 0) {
              this._current++;
            } else if (stream[this._current] === "&") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "&") {
                this._current++;
                tokens.push({ type: TOK_AND, value: "&&", start });
              } else {
                tokens.push({ type: TOK_EXPREF, value: "&", start });
              }
            } else if (stream[this._current] === "|") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "|") {
                this._current++;
                tokens.push({ type: TOK_OR, value: "||", start });
              } else {
                tokens.push({ type: TOK_PIPE, value: "|", start });
              }
            } else {
              var error = new Error("Unknown character:" + stream[this._current]);
              error.name = "LexerError";
              throw error;
            }
          }
          return tokens;
        },
        _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
            this._current++;
          }
          return stream.slice(start, this._current);
        },
        _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== '"' && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === '"')) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
        },
        _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "'")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
        },
        _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
            this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return { type: TOK_NUMBER, value, start };
        },
        _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
            this._current++;
            return { type: TOK_FILTER, value: "[?", start };
          } else if (stream[this._current] === "]") {
            this._current++;
            return { type: TOK_FLATTEN, value: "[]", start };
          } else {
            return { type: TOK_LBRACKET, value: "[", start };
          }
        },
        _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_NE, value: "!=", start };
            } else {
              return { type: TOK_NOT, value: "!", start };
            }
          } else if (startingChar === "<") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_LTE, value: "<=", start };
            } else {
              return { type: TOK_LT, value: "<", start };
            }
          } else if (startingChar === ">") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_GTE, value: ">=", start };
            } else {
              return { type: TOK_GT, value: ">", start };
            }
          } else if (startingChar === "=") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_EQ, value: "==", start };
            }
          }
        },
        _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while (stream[this._current] !== "`" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "`")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
            literal = JSON.parse(literalString);
          } else {
            literal = JSON.parse('"' + literalString + '"');
          }
          this._current++;
          return literal;
        },
        _looksLikeJSON: function(literalString) {
          var startingChars = '[{"';
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";
          if (literalString === "") {
            return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
            return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
            return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
            try {
              JSON.parse(literalString);
              return true;
            } catch (ex) {
              return false;
            }
          } else {
            return false;
          }
        }
      };
      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;
      function Parser() {
      }
      __name(Parser, "Parser");
      Parser.prototype = {
        parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
            var t = this._lookaheadToken(0);
            var error = new Error(
              "Unexpected token type: " + t.type + ", value: " + t.value
            );
            error.name = "ParserError";
            throw error;
          }
          return ast;
        },
        _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({ type: TOK_EOF, value: "", start: expression.length });
          this.tokens = tokens;
        },
        expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
            this._advance();
            left = this.led(currentToken, left);
            currentToken = this._lookahead(0);
          }
          return left;
        },
        _lookahead: function(number) {
          return this.tokens[this.index + number].type;
        },
        _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
        },
        _advance: function() {
          this.index++;
        },
        nud: function(token) {
          var left;
          var right;
          var expression;
          switch (token.type) {
            case TOK_LITERAL:
              return { type: "Literal", value: token.value };
            case TOK_UNQUOTEDIDENTIFIER:
              return { type: "Field", name: token.value };
            case TOK_QUOTEDIDENTIFIER:
              var node = { type: "Field", name: token.value };
              if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
              }
              return node;
            case TOK_NOT:
              right = this.expression(bindingPower.Not);
              return { type: "NotExpression", children: [right] };
            case TOK_STAR:
              left = { type: "Identity" };
              right = null;
              if (this._lookahead(0) === TOK_RBRACKET) {
                right = { type: "Identity" };
              } else {
                right = this._parseProjectionRHS(bindingPower.Star);
              }
              return { type: "ValueProjection", children: [left, right] };
            case TOK_FILTER:
              return this.led(token.type, { type: "Identity" });
            case TOK_LBRACE:
              return this._parseMultiselectHash();
            case TOK_FLATTEN:
              left = { type: TOK_FLATTEN, children: [{ type: "Identity" }] };
              right = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: "Projection", children: [left, right] };
            case TOK_LBRACKET:
              if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({ type: "Identity" }, right);
              } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {
                  type: "Projection",
                  children: [{ type: "Identity" }, right]
                };
              }
              return this._parseMultiselectList();
            case TOK_CURRENT:
              return { type: TOK_CURRENT };
            case TOK_EXPREF:
              expression = this.expression(bindingPower.Expref);
              return { type: "ExpressionReference", children: [expression] };
            case TOK_LPAREN:
              var args = [];
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              return args[0];
            default:
              this._errorToken(token);
          }
        },
        led: function(tokenName, left) {
          var right;
          switch (tokenName) {
            case TOK_DOT:
              var rbp = bindingPower.Dot;
              if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return { type: "Subexpression", children: [left, right] };
              }
              this._advance();
              right = this._parseProjectionRHS(rbp);
              return { type: "ValueProjection", children: [left, right] };
            case TOK_PIPE:
              right = this.expression(bindingPower.Pipe);
              return { type: TOK_PIPE, children: [left, right] };
            case TOK_OR:
              right = this.expression(bindingPower.Or);
              return { type: "OrExpression", children: [left, right] };
            case TOK_AND:
              right = this.expression(bindingPower.And);
              return { type: "AndExpression", children: [left, right] };
            case TOK_LPAREN:
              var name = left.name;
              var args = [];
              var expression, node;
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              node = { type: "Function", name, children: args };
              return node;
            case TOK_FILTER:
              var condition = this.expression(0);
              this._match(TOK_RBRACKET);
              if (this._lookahead(0) === TOK_FLATTEN) {
                right = { type: "Identity" };
              } else {
                right = this._parseProjectionRHS(bindingPower.Filter);
              }
              return { type: "FilterProjection", children: [left, right, condition] };
            case TOK_FLATTEN:
              var leftNode = { type: TOK_FLATTEN, children: [left] };
              var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: "Projection", children: [leftNode, rightNode] };
            case TOK_EQ:
            case TOK_NE:
            case TOK_GT:
            case TOK_GTE:
            case TOK_LT:
            case TOK_LTE:
              return this._parseComparator(left, tokenName);
            case TOK_LBRACKET:
              var token = this._lookaheadToken(0);
              if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
              }
              this._match(TOK_STAR);
              this._match(TOK_RBRACKET);
              right = this._parseProjectionRHS(bindingPower.Star);
              return { type: "Projection", children: [left, right] };
            default:
              this._errorToken(this._lookaheadToken(0));
          }
        },
        _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
            this._advance();
          } else {
            var t = this._lookaheadToken(0);
            var error = new Error("Expected " + tokenType + ", got: " + t.type);
            error.name = "ParserError";
            throw error;
          }
        },
        _errorToken: function(token) {
          var error = new Error("Invalid token (" + token.type + '): "' + token.value + '"');
          error.name = "ParserError";
          throw error;
        },
        _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
            return this._parseSliceExpression();
          } else {
            var node = {
              type: "Index",
              value: this._lookaheadToken(0).value
            };
            this._advance();
            this._match(TOK_RBRACKET);
            return node;
          }
        },
        _projectIfSlice: function(left, right) {
          var indexExpr = { type: "IndexExpression", children: [left, right] };
          if (right.type === "Slice") {
            return {
              type: "Projection",
              children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
            };
          } else {
            return indexExpr;
          }
        },
        _parseSliceExpression: function() {
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
            if (currentToken === TOK_COLON) {
              index++;
              this._advance();
            } else if (currentToken === TOK_NUMBER) {
              parts[index] = this._lookaheadToken(0).value;
              this._advance();
            } else {
              var t = this._lookahead(0);
              var error = new Error("Syntax error, unexpected token: " + t.value + "(" + t.type + ")");
              error.name = "Parsererror";
              throw error;
            }
            currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
            type: "Slice",
            children: parts
          };
        },
        _parseComparator: function(left, comparator) {
          var right = this.expression(bindingPower[comparator]);
          return { type: "Comparator", name: comparator, children: [left, right] };
        },
        _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
            return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
            this._match(TOK_LBRACKET);
            return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
            this._match(TOK_LBRACE);
            return this._parseMultiselectHash();
          }
        },
        _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
            right = { type: "Identity" };
          } else if (this._lookahead(0) === TOK_LBRACKET) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
            this._match(TOK_DOT);
            right = this._parseDotRHS(rbp);
          } else {
            var t = this._lookaheadToken(0);
            var error = new Error("Sytanx error, unexpected token: " + t.value + "(" + t.type + ")");
            error.name = "ParserError";
            throw error;
          }
          return right;
        },
        _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
            var expression = this.expression(0);
            expressions.push(expression);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
              if (this._lookahead(0) === TOK_RBRACKET) {
                throw new Error("Unexpected token Rbracket");
              }
            }
          }
          this._match(TOK_RBRACKET);
          return { type: "MultiSelectList", children: expressions };
        },
        _parseMultiselectHash: function() {
          var pairs = [];
          var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
          var keyToken, keyName, value, node;
          for (; ; ) {
            keyToken = this._lookaheadToken(0);
            if (identifierTypes.indexOf(keyToken.type) < 0) {
              throw new Error("Expecting an identifier token, got: " + keyToken.type);
            }
            keyName = keyToken.value;
            this._advance();
            this._match(TOK_COLON);
            value = this.expression(0);
            node = { type: "KeyValuePair", name: keyName, value };
            pairs.push(node);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
            } else if (this._lookahead(0) === TOK_RBRACE) {
              this._match(TOK_RBRACE);
              break;
            }
          }
          return { type: "MultiSelectHash", children: pairs };
        }
      };
      function TreeInterpreter(runtime) {
        this.runtime = runtime;
      }
      __name(TreeInterpreter, "TreeInterpreter");
      TreeInterpreter.prototype = {
        search: function(node, value) {
          return this.visit(node, value);
        },
        visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value !== null && isObject(value)) {
                field = value[node.name];
                if (field === void 0) {
                  return null;
                } else {
                  return field;
                }
              }
              return null;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                result = this.visit(node.children[1], result);
                if (result === null) {
                  return null;
                }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === void 0) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                for (i = start; i < stop; i += step) {
                  result.push(value[i]);
                }
              } else {
                for (i = start; i > stop; i += step) {
                  result.push(value[i]);
                }
              }
              return result;
            case "Projection":
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch (node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);
              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
        },
        computeSliceParams: function(arrayLength, sliceParams) {
          var start = sliceParams[0];
          var stop = sliceParams[1];
          var step = sliceParams[2];
          var computed = [null, null, null];
          if (step === null) {
            step = 1;
          } else if (step === 0) {
            var error = new Error("Invalid slice, step cannot be 0");
            error.name = "RuntimeError";
            throw error;
          }
          var stepValueNegative = step < 0 ? true : false;
          if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
          } else {
            start = this.capSliceRange(arrayLength, start, step);
          }
          if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
          } else {
            stop = this.capSliceRange(arrayLength, stop, step);
          }
          computed[0] = start;
          computed[1] = stop;
          computed[2] = step;
          return computed;
        },
        capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
            actualValue += arrayLength;
            if (actualValue < 0) {
              actualValue = step < 0 ? -1 : 0;
            }
          } else if (actualValue >= arrayLength) {
            actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
        }
      };
      function Runtime(interpreter) {
        this._interpreter = interpreter;
        this.functionTable = {
          abs: { _func: this._functionAbs, _signature: [{ types: [TYPE_NUMBER] }] },
          avg: { _func: this._functionAvg, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          ceil: { _func: this._functionCeil, _signature: [{ types: [TYPE_NUMBER] }] },
          contains: {
            _func: this._functionContains,
            _signature: [
              { types: [TYPE_STRING, TYPE_ARRAY] },
              { types: [TYPE_ANY] }
            ]
          },
          "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
          },
          floor: { _func: this._functionFloor, _signature: [{ types: [TYPE_NUMBER] }] },
          length: {
            _func: this._functionLength,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }]
          },
          map: {
            _func: this._functionMap,
            _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }]
          },
          max: {
            _func: this._functionMax,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
          },
          "merge": {
            _func: this._functionMerge,
            _signature: [{ types: [TYPE_OBJECT], variadic: true }]
          },
          "max_by": {
            _func: this._functionMaxBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          sum: { _func: this._functionSum, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
          },
          min: {
            _func: this._functionMin,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
          },
          "min_by": {
            _func: this._functionMinBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          type: { _func: this._functionType, _signature: [{ types: [TYPE_ANY] }] },
          keys: { _func: this._functionKeys, _signature: [{ types: [TYPE_OBJECT] }] },
          values: { _func: this._functionValues, _signature: [{ types: [TYPE_OBJECT] }] },
          sort: { _func: this._functionSort, _signature: [{ types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }] },
          "sort_by": {
            _func: this._functionSortBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          join: {
            _func: this._functionJoin,
            _signature: [
              { types: [TYPE_STRING] },
              { types: [TYPE_ARRAY_STRING] }
            ]
          },
          reverse: {
            _func: this._functionReverse,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }]
          },
          "to_array": { _func: this._functionToArray, _signature: [{ types: [TYPE_ANY] }] },
          "to_string": { _func: this._functionToString, _signature: [{ types: [TYPE_ANY] }] },
          "to_number": { _func: this._functionToNumber, _signature: [{ types: [TYPE_ANY] }] },
          "not_null": {
            _func: this._functionNotNull,
            _signature: [{ types: [TYPE_ANY], variadic: true }]
          }
        };
      }
      __name(Runtime, "Runtime");
      Runtime.prototype = {
        callFunction: function(name, resolvedArgs) {
          var functionEntry = this.functionTable[name];
          if (functionEntry === void 0) {
            throw new Error("Unknown function: " + name + "()");
          }
          this._validateArgs(name, resolvedArgs, functionEntry._signature);
          return functionEntry._func.call(this, resolvedArgs);
        },
        _validateArgs: function(name, args, signature) {
          var pluralized;
          if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
              pluralized = signature.length === 1 ? " argument" : " arguments";
              throw new Error("ArgumentError: " + name + "() takes at least" + signature.length + pluralized + " but received " + args.length);
            }
          } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() takes " + signature.length + pluralized + " but received " + args.length);
          }
          var currentSpec;
          var actualType;
          var typeMatched;
          for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
              if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                typeMatched = true;
                break;
              }
            }
            if (!typeMatched) {
              var expected = currentSpec.map(function(typeIdentifier) {
                return TYPE_NAME_TABLE[typeIdentifier];
              }).join(",");
              throw new Error("TypeError: " + name + "() expected argument " + (i + 1) + " to be type " + expected + " but received type " + TYPE_NAME_TABLE[actualType] + " instead.");
            }
          }
        },
        _typeMatches: function(actual, expected, argValue) {
          if (expected === TYPE_ANY) {
            return true;
          }
          if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
            if (expected === TYPE_ARRAY) {
              return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
              var subtype;
              if (expected === TYPE_ARRAY_NUMBER) {
                subtype = TYPE_NUMBER;
              } else if (expected === TYPE_ARRAY_STRING) {
                subtype = TYPE_STRING;
              }
              for (var i = 0; i < argValue.length; i++) {
                if (!this._typeMatches(
                  this._getTypeName(argValue[i]),
                  subtype,
                  argValue[i]
                )) {
                  return false;
                }
              }
              return true;
            }
          } else {
            return actual === expected;
          }
        },
        _getTypeName: function(obj) {
          switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
          }
        },
        _functionStartsWith: function(resolvedArgs) {
          return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
        },
        _functionEndsWith: function(resolvedArgs) {
          var searchStr = resolvedArgs[0];
          var suffix = resolvedArgs[1];
          return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
        },
        _functionReverse: function(resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);
          if (typeName === TYPE_STRING) {
            var originalStr = resolvedArgs[0];
            var reversedStr = "";
            for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
            }
            return reversedStr;
          } else {
            var reversedArray = resolvedArgs[0].slice(0);
            reversedArray.reverse();
            return reversedArray;
          }
        },
        _functionAbs: function(resolvedArgs) {
          return Math.abs(resolvedArgs[0]);
        },
        _functionCeil: function(resolvedArgs) {
          return Math.ceil(resolvedArgs[0]);
        },
        _functionAvg: function(resolvedArgs) {
          var sum = 0;
          var inputArray = resolvedArgs[0];
          for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
          }
          return sum / inputArray.length;
        },
        _functionContains: function(resolvedArgs) {
          return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
        },
        _functionFloor: function(resolvedArgs) {
          return Math.floor(resolvedArgs[0]);
        },
        _functionLength: function(resolvedArgs) {
          if (!isObject(resolvedArgs[0])) {
            return resolvedArgs[0].length;
          } else {
            return Object.keys(resolvedArgs[0]).length;
          }
        },
        _functionMap: function(resolvedArgs) {
          var mapped = [];
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[0];
          var elements = resolvedArgs[1];
          for (var i = 0; i < elements.length; i++) {
            mapped.push(interpreter.visit(exprefNode, elements[i]));
          }
          return mapped;
        },
        _functionMerge: function(resolvedArgs) {
          var merged = {};
          for (var i = 0; i < resolvedArgs.length; i++) {
            var current = resolvedArgs[i];
            for (var key in current) {
              merged[key] = current[key];
            }
          }
          return merged;
        },
        _functionMax: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);
            if (typeName === TYPE_NUMBER) {
              return Math.max.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var maxElement = elements[0];
              for (var i = 1; i < elements.length; i++) {
                if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
                }
              }
              return maxElement;
            }
          } else {
            return null;
          }
        },
        _functionMin: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);
            if (typeName === TYPE_NUMBER) {
              return Math.min.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var minElement = elements[0];
              for (var i = 1; i < elements.length; i++) {
                if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
                }
              }
              return minElement;
            }
          } else {
            return null;
          }
        },
        _functionSum: function(resolvedArgs) {
          var sum = 0;
          var listToSum = resolvedArgs[0];
          for (var i = 0; i < listToSum.length; i++) {
            sum += listToSum[i];
          }
          return sum;
        },
        _functionType: function(resolvedArgs) {
          switch (this._getTypeName(resolvedArgs[0])) {
            case TYPE_NUMBER:
              return "number";
            case TYPE_STRING:
              return "string";
            case TYPE_ARRAY:
              return "array";
            case TYPE_OBJECT:
              return "object";
            case TYPE_BOOLEAN:
              return "boolean";
            case TYPE_EXPREF:
              return "expref";
            case TYPE_NULL:
              return "null";
          }
        },
        _functionKeys: function(resolvedArgs) {
          return Object.keys(resolvedArgs[0]);
        },
        _functionValues: function(resolvedArgs) {
          var obj = resolvedArgs[0];
          var keys = Object.keys(obj);
          var values = [];
          for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
          }
          return values;
        },
        _functionJoin: function(resolvedArgs) {
          var joinChar = resolvedArgs[0];
          var listJoin = resolvedArgs[1];
          return listJoin.join(joinChar);
        },
        _functionToArray: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
          } else {
            return [resolvedArgs[0]];
          }
        },
        _functionToString: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
          } else {
            return JSON.stringify(resolvedArgs[0]);
          }
        },
        _functionToNumber: function(resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);
          var convertedValue;
          if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
          } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
              return convertedValue;
            }
          }
          return null;
        },
        _functionNotNull: function(resolvedArgs) {
          for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
              return resolvedArgs[i];
            }
          }
          return null;
        },
        _functionSort: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          sortedArray.sort();
          return sortedArray;
        },
        _functionSortBy: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          if (sortedArray.length === 0) {
            return sortedArray;
          }
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[1];
          var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0])
          );
          if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
          }
          var that = this;
          var decorated = [];
          for (var i = 0; i < sortedArray.length; i++) {
            decorated.push([i, sortedArray[i]]);
          }
          decorated.sort(function(a, b) {
            var exprA = interpreter.visit(exprefNode, a[1]);
            var exprB = interpreter.visit(exprefNode, b[1]);
            if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                "TypeError: expected " + requiredType + ", received " + that._getTypeName(exprA)
              );
            } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                "TypeError: expected " + requiredType + ", received " + that._getTypeName(exprB)
              );
            }
            if (exprA > exprB) {
              return 1;
            } else if (exprA < exprB) {
              return -1;
            } else {
              return a[0] - b[0];
            }
          });
          for (var j = 0; j < decorated.length; j++) {
            sortedArray[j] = decorated[j][1];
          }
          return sortedArray;
        },
        _functionMaxBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var maxNumber = -Infinity;
          var maxRecord;
          var current;
          for (var i = 0; i < resolvedArray.length; i++) {
            current = keyFunction(resolvedArray[i]);
            if (current > maxNumber) {
              maxNumber = current;
              maxRecord = resolvedArray[i];
            }
          }
          return maxRecord;
        },
        _functionMinBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var minNumber = Infinity;
          var minRecord;
          var current;
          for (var i = 0; i < resolvedArray.length; i++) {
            current = keyFunction(resolvedArray[i]);
            if (current < minNumber) {
              minNumber = current;
              minRecord = resolvedArray[i];
            }
          }
          return minRecord;
        },
        createKeyFunction: function(exprefNode, allowedTypes) {
          var that = this;
          var interpreter = this._interpreter;
          var keyFunc = /* @__PURE__ */ __name(function(x) {
            var current = interpreter.visit(exprefNode, x);
            if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
              var msg = "TypeError: expected one of " + allowedTypes + ", received " + that._getTypeName(current);
              throw new Error(msg);
            }
            return current;
          }, "keyFunc");
          return keyFunc;
        }
      };
      function compile(stream) {
        var parser = new Parser();
        var ast = parser.parse(stream);
        return ast;
      }
      __name(compile, "compile");
      function tokenize(stream) {
        var lexer = new Lexer();
        return lexer.tokenize(stream);
      }
      __name(tokenize, "tokenize");
      function search(data, expression) {
        var parser = new Parser();
        var runtime = new Runtime();
        var interpreter = new TreeInterpreter(runtime);
        runtime._interpreter = interpreter;
        var node = parser.parse(expression);
        return interpreter.search(node, data);
      }
      __name(search, "search");
      exports3.tokenize = tokenize;
      exports3.compile = compile;
      exports3.search = search;
      exports3.strictDeepEqual = strictDeepEqual;
    })(typeof exports2 === "undefined" ? exports2.jmespath = {} : exports2);
  }
});

// node_modules/aws-sdk/lib/request.js
var require_request3 = __commonJS({
  "node_modules/aws-sdk/lib/request.js"() {
    var AWS2 = require_core();
    var AcceptorStateMachine = require_state_machine();
    var inherit = AWS2.util.inherit;
    var domain = AWS2.util.domain;
    var jmespath = require_jmespath();
    var hardErrorStates = { success: 1, error: 1, complete: 1 };
    function isTerminalState(machine) {
      return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
    }
    __name(isTerminalState, "isTerminalState");
    var fsm = new AcceptorStateMachine();
    fsm.setupStates = function() {
      var transition = /* @__PURE__ */ __name(function(_, done) {
        var self2 = this;
        self2._haltHandlersOnError = false;
        self2.emit(self2._asm.currentState, function(err) {
          if (err) {
            if (isTerminalState(self2)) {
              if (domain && self2.domain instanceof domain.Domain) {
                err.domainEmitter = self2;
                err.domain = self2.domain;
                err.domainThrown = false;
                self2.domain.emit("error", err);
              } else {
                throw err;
              }
            } else {
              self2.response.error = err;
              done(err);
            }
          } else {
            done(self2.response.error);
          }
        });
      }, "transition");
      this.addState("validate", "build", "error", transition);
      this.addState("build", "afterBuild", "restart", transition);
      this.addState("afterBuild", "sign", "restart", transition);
      this.addState("sign", "send", "retry", transition);
      this.addState("retry", "afterRetry", "afterRetry", transition);
      this.addState("afterRetry", "sign", "error", transition);
      this.addState("send", "validateResponse", "retry", transition);
      this.addState("validateResponse", "extractData", "extractError", transition);
      this.addState("extractError", "extractData", "retry", transition);
      this.addState("extractData", "success", "retry", transition);
      this.addState("restart", "build", "error", transition);
      this.addState("success", "complete", "complete", transition);
      this.addState("error", "complete", "complete", transition);
      this.addState("complete", null, null, transition);
    };
    fsm.setupStates();
    AWS2.Request = inherit({
      constructor: /* @__PURE__ */ __name(function Request(service, operation, params) {
        var endpoint = service.endpoint;
        var region = service.config.region;
        var customUserAgent = service.config.customUserAgent;
        if (service.signingRegion) {
          region = service.signingRegion;
        } else if (service.isGlobalEndpoint) {
          region = "us-east-1";
        }
        this.domain = domain && domain.active;
        this.service = service;
        this.operation = operation;
        this.params = params || {};
        this.httpRequest = new AWS2.HttpRequest(endpoint, region);
        this.httpRequest.appendToUserAgent(customUserAgent);
        this.startTime = service.getSkewCorrectedDate();
        this.response = new AWS2.Response(this);
        this._asm = new AcceptorStateMachine(fsm.states, "validate");
        this._haltHandlersOnError = false;
        AWS2.SequentialExecutor.call(this);
        this.emit = this.emitEvent;
      }, "Request"),
      send: /* @__PURE__ */ __name(function send(callback) {
        if (callback) {
          this.httpRequest.appendToUserAgent("callback");
          this.on("complete", function(resp) {
            callback.call(resp, resp.error, resp.data);
          });
        }
        this.runTo();
        return this.response;
      }, "send"),
      build: /* @__PURE__ */ __name(function build(callback) {
        return this.runTo("send", callback);
      }, "build"),
      runTo: /* @__PURE__ */ __name(function runTo(state, done) {
        this._asm.runTo(state, done, this);
        return this;
      }, "runTo"),
      abort: /* @__PURE__ */ __name(function abort() {
        this.removeAllListeners("validateResponse");
        this.removeAllListeners("extractError");
        this.on("validateResponse", /* @__PURE__ */ __name(function addAbortedError(resp) {
          resp.error = AWS2.util.error(new Error("Request aborted by user"), {
            code: "RequestAbortedError",
            retryable: false
          });
        }, "addAbortedError"));
        if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) {
          this.httpRequest.stream.abort();
          if (this.httpRequest._abortCallback) {
            this.httpRequest._abortCallback();
          } else {
            this.removeAllListeners("send");
          }
        }
        return this;
      }, "abort"),
      eachPage: /* @__PURE__ */ __name(function eachPage(callback) {
        callback = AWS2.util.fn.makeAsync(callback, 3);
        function wrappedCallback(response) {
          callback.call(response, response.error, response.data, function(result) {
            if (result === false)
              return;
            if (response.hasNextPage()) {
              response.nextPage().on("complete", wrappedCallback).send();
            } else {
              callback.call(response, null, null, AWS2.util.fn.noop);
            }
          });
        }
        __name(wrappedCallback, "wrappedCallback");
        this.on("complete", wrappedCallback).send();
      }, "eachPage"),
      eachItem: /* @__PURE__ */ __name(function eachItem(callback) {
        var self2 = this;
        function wrappedCallback(err, data) {
          if (err)
            return callback(err, null);
          if (data === null)
            return callback(null, null);
          var config = self2.service.paginationConfig(self2.operation);
          var resultKey = config.resultKey;
          if (Array.isArray(resultKey))
            resultKey = resultKey[0];
          var items = jmespath.search(data, resultKey);
          var continueIteration = true;
          AWS2.util.arrayEach(items, function(item) {
            continueIteration = callback(null, item);
            if (continueIteration === false) {
              return AWS2.util.abort;
            }
          });
          return continueIteration;
        }
        __name(wrappedCallback, "wrappedCallback");
        this.eachPage(wrappedCallback);
      }, "eachItem"),
      isPageable: /* @__PURE__ */ __name(function isPageable() {
        return this.service.paginationConfig(this.operation) ? true : false;
      }, "isPageable"),
      createReadStream: /* @__PURE__ */ __name(function createReadStream() {
        var streams = AWS2.util.stream;
        var req = this;
        var stream = null;
        if (AWS2.HttpClient.streamsApiVersion === 2) {
          stream = new streams.PassThrough();
          process.nextTick(function() {
            req.send();
          });
        } else {
          stream = new streams.Stream();
          stream.readable = true;
          stream.sent = false;
          stream.on("newListener", function(event) {
            if (!stream.sent && event === "data") {
              stream.sent = true;
              process.nextTick(function() {
                req.send();
              });
            }
          });
        }
        this.on("error", function(err) {
          stream.emit("error", err);
        });
        this.on("httpHeaders", /* @__PURE__ */ __name(function streamHeaders(statusCode, headers, resp) {
          if (statusCode < 300) {
            req.removeListener("httpData", AWS2.EventListeners.Core.HTTP_DATA);
            req.removeListener("httpError", AWS2.EventListeners.Core.HTTP_ERROR);
            req.on("httpError", /* @__PURE__ */ __name(function streamHttpError(error) {
              resp.error = error;
              resp.error.retryable = false;
            }, "streamHttpError"));
            var shouldCheckContentLength = false;
            var expectedLen;
            if (req.httpRequest.method !== "HEAD") {
              expectedLen = parseInt(headers["content-length"], 10);
            }
            if (expectedLen !== void 0 && !isNaN(expectedLen) && expectedLen >= 0) {
              shouldCheckContentLength = true;
              var receivedLen = 0;
            }
            var checkContentLengthAndEmit = /* @__PURE__ */ __name(function checkContentLengthAndEmit2() {
              if (shouldCheckContentLength && receivedLen !== expectedLen) {
                stream.emit("error", AWS2.util.error(
                  new Error("Stream content length mismatch. Received " + receivedLen + " of " + expectedLen + " bytes."),
                  { code: "StreamContentLengthMismatch" }
                ));
              } else if (AWS2.HttpClient.streamsApiVersion === 2) {
                stream.end();
              } else {
                stream.emit("end");
              }
            }, "checkContentLengthAndEmit");
            var httpStream = resp.httpResponse.createUnbufferedStream();
            if (AWS2.HttpClient.streamsApiVersion === 2) {
              if (shouldCheckContentLength) {
                var lengthAccumulator = new streams.PassThrough();
                lengthAccumulator._write = function(chunk) {
                  if (chunk && chunk.length) {
                    receivedLen += chunk.length;
                  }
                  return streams.PassThrough.prototype._write.apply(this, arguments);
                };
                lengthAccumulator.on("end", checkContentLengthAndEmit);
                stream.on("error", function(err) {
                  shouldCheckContentLength = false;
                  httpStream.unpipe(lengthAccumulator);
                  lengthAccumulator.emit("end");
                  lengthAccumulator.end();
                });
                httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
              } else {
                httpStream.pipe(stream);
              }
            } else {
              if (shouldCheckContentLength) {
                httpStream.on("data", function(arg) {
                  if (arg && arg.length) {
                    receivedLen += arg.length;
                  }
                });
              }
              httpStream.on("data", function(arg) {
                stream.emit("data", arg);
              });
              httpStream.on("end", checkContentLengthAndEmit);
            }
            httpStream.on("error", function(err) {
              shouldCheckContentLength = false;
              stream.emit("error", err);
            });
          }
        }, "streamHeaders"));
        return stream;
      }, "createReadStream"),
      emitEvent: /* @__PURE__ */ __name(function emit(eventName, args, done) {
        if (typeof args === "function") {
          done = args;
          args = null;
        }
        if (!done)
          done = /* @__PURE__ */ __name(function() {
          }, "done");
        if (!args)
          args = this.eventParameters(eventName, this.response);
        var origEmit = AWS2.SequentialExecutor.prototype.emit;
        origEmit.call(this, eventName, args, function(err) {
          if (err)
            this.response.error = err;
          done.call(this, err);
        });
      }, "emit"),
      eventParameters: /* @__PURE__ */ __name(function eventParameters(eventName) {
        switch (eventName) {
          case "restart":
          case "validate":
          case "sign":
          case "build":
          case "afterValidate":
          case "afterBuild":
            return [this];
          case "error":
            return [this.response.error, this.response];
          default:
            return [this.response];
        }
      }, "eventParameters"),
      presign: /* @__PURE__ */ __name(function presign(expires, callback) {
        if (!callback && typeof expires === "function") {
          callback = expires;
          expires = null;
        }
        return new AWS2.Signers.Presign().sign(this.toGet(), expires, callback);
      }, "presign"),
      isPresigned: /* @__PURE__ */ __name(function isPresigned() {
        return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, "presigned-expires");
      }, "isPresigned"),
      toUnauthenticated: /* @__PURE__ */ __name(function toUnauthenticated() {
        this._unAuthenticated = true;
        this.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_CREDENTIALS);
        this.removeListener("sign", AWS2.EventListeners.Core.SIGN);
        return this;
      }, "toUnauthenticated"),
      toGet: /* @__PURE__ */ __name(function toGet() {
        if (this.service.api.protocol === "query" || this.service.api.protocol === "ec2") {
          this.removeListener("build", this.buildAsGet);
          this.addListener("build", this.buildAsGet);
        }
        return this;
      }, "toGet"),
      buildAsGet: /* @__PURE__ */ __name(function buildAsGet(request) {
        request.httpRequest.method = "GET";
        request.httpRequest.path = request.service.endpoint.path + "?" + request.httpRequest.body;
        request.httpRequest.body = "";
        delete request.httpRequest.headers["Content-Length"];
        delete request.httpRequest.headers["Content-Type"];
      }, "buildAsGet"),
      haltHandlersOnError: /* @__PURE__ */ __name(function haltHandlersOnError() {
        this._haltHandlersOnError = true;
      }, "haltHandlersOnError")
    });
    AWS2.Request.addPromisesToClass = /* @__PURE__ */ __name(function addPromisesToClass(PromiseDependency) {
      this.prototype.promise = /* @__PURE__ */ __name(function promise() {
        var self2 = this;
        this.httpRequest.appendToUserAgent("promise");
        return new PromiseDependency(function(resolve, reject) {
          self2.on("complete", function(resp) {
            if (resp.error) {
              reject(resp.error);
            } else {
              resolve(Object.defineProperty(
                resp.data || {},
                "$response",
                { value: resp }
              ));
            }
          });
          self2.runTo();
        });
      }, "promise");
    }, "addPromisesToClass");
    AWS2.Request.deletePromisesFromClass = /* @__PURE__ */ __name(function deletePromisesFromClass() {
      delete this.prototype.promise;
    }, "deletePromisesFromClass");
    AWS2.util.addPromises(AWS2.Request);
    AWS2.util.mixin(AWS2.Request, AWS2.SequentialExecutor);
  }
});

// node_modules/aws-sdk/lib/response.js
var require_response = __commonJS({
  "node_modules/aws-sdk/lib/response.js"() {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    var jmespath = require_jmespath();
    AWS2.Response = inherit({
      constructor: /* @__PURE__ */ __name(function Response(request) {
        this.request = request;
        this.data = null;
        this.error = null;
        this.retryCount = 0;
        this.redirectCount = 0;
        this.httpResponse = new AWS2.HttpResponse();
        if (request) {
          this.maxRetries = request.service.numRetries();
          this.maxRedirects = request.service.config.maxRedirects;
        }
      }, "Response"),
      nextPage: /* @__PURE__ */ __name(function nextPage(callback) {
        var config;
        var service = this.request.service;
        var operation = this.request.operation;
        try {
          config = service.paginationConfig(operation, true);
        } catch (e) {
          this.error = e;
        }
        if (!this.hasNextPage()) {
          if (callback)
            callback(this.error, null);
          else if (this.error)
            throw this.error;
          return null;
        }
        var params = AWS2.util.copy(this.request.params);
        if (!this.nextPageTokens) {
          return callback ? callback(null, null) : null;
        } else {
          var inputTokens = config.inputToken;
          if (typeof inputTokens === "string")
            inputTokens = [inputTokens];
          for (var i = 0; i < inputTokens.length; i++) {
            params[inputTokens[i]] = this.nextPageTokens[i];
          }
          return service.makeRequest(this.request.operation, params, callback);
        }
      }, "nextPage"),
      hasNextPage: /* @__PURE__ */ __name(function hasNextPage() {
        this.cacheNextPageTokens();
        if (this.nextPageTokens)
          return true;
        if (this.nextPageTokens === void 0)
          return void 0;
        else
          return false;
      }, "hasNextPage"),
      cacheNextPageTokens: /* @__PURE__ */ __name(function cacheNextPageTokens() {
        if (Object.prototype.hasOwnProperty.call(this, "nextPageTokens"))
          return this.nextPageTokens;
        this.nextPageTokens = void 0;
        var config = this.request.service.paginationConfig(this.request.operation);
        if (!config)
          return this.nextPageTokens;
        this.nextPageTokens = null;
        if (config.moreResults) {
          if (!jmespath.search(this.data, config.moreResults)) {
            return this.nextPageTokens;
          }
        }
        var exprs = config.outputToken;
        if (typeof exprs === "string")
          exprs = [exprs];
        AWS2.util.arrayEach.call(this, exprs, function(expr) {
          var output = jmespath.search(this.data, expr);
          if (output) {
            this.nextPageTokens = this.nextPageTokens || [];
            this.nextPageTokens.push(output);
          }
        });
        return this.nextPageTokens;
      }, "cacheNextPageTokens")
    });
  }
});

// node_modules/aws-sdk/lib/resource_waiter.js
var require_resource_waiter2 = __commonJS({
  "node_modules/aws-sdk/lib/resource_waiter.js"() {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    var jmespath = require_jmespath();
    function CHECK_ACCEPTORS(resp) {
      var waiter = resp.request._waiter;
      var acceptors = waiter.config.acceptors;
      var acceptorMatched = false;
      var state = "retry";
      acceptors.forEach(function(acceptor) {
        if (!acceptorMatched) {
          var matcher = waiter.matchers[acceptor.matcher];
          if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
            acceptorMatched = true;
            state = acceptor.state;
          }
        }
      });
      if (!acceptorMatched && resp.error)
        state = "failure";
      if (state === "success") {
        waiter.setSuccess(resp);
      } else {
        waiter.setError(resp, state === "retry");
      }
    }
    __name(CHECK_ACCEPTORS, "CHECK_ACCEPTORS");
    AWS2.ResourceWaiter = inherit({
      constructor: /* @__PURE__ */ __name(function constructor(service, state) {
        this.service = service;
        this.state = state;
        this.loadWaiterConfig(this.state);
      }, "constructor"),
      service: null,
      state: null,
      config: null,
      matchers: {
        path: function(resp, expected, argument) {
          try {
            var result = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          return jmespath.strictDeepEqual(result, expected);
        },
        pathAll: function(resp, expected, argument) {
          try {
            var results = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          if (!Array.isArray(results))
            results = [results];
          var numResults = results.length;
          if (!numResults)
            return false;
          for (var ind = 0; ind < numResults; ind++) {
            if (!jmespath.strictDeepEqual(results[ind], expected)) {
              return false;
            }
          }
          return true;
        },
        pathAny: function(resp, expected, argument) {
          try {
            var results = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          if (!Array.isArray(results))
            results = [results];
          var numResults = results.length;
          for (var ind = 0; ind < numResults; ind++) {
            if (jmespath.strictDeepEqual(results[ind], expected)) {
              return true;
            }
          }
          return false;
        },
        status: function(resp, expected) {
          var statusCode = resp.httpResponse.statusCode;
          return typeof statusCode === "number" && statusCode === expected;
        },
        error: function(resp, expected) {
          if (typeof expected === "string" && resp.error) {
            return expected === resp.error.code;
          }
          return expected === !!resp.error;
        }
      },
      listeners: new AWS2.SequentialExecutor().addNamedListeners(function(add) {
        add("RETRY_CHECK", "retry", function(resp) {
          var waiter = resp.request._waiter;
          if (resp.error && resp.error.code === "ResourceNotReady") {
            resp.error.retryDelay = (waiter.config.delay || 0) * 1e3;
          }
        });
        add("CHECK_OUTPUT", "extractData", CHECK_ACCEPTORS);
        add("CHECK_ERROR", "extractError", CHECK_ACCEPTORS);
      }),
      wait: /* @__PURE__ */ __name(function wait(params, callback) {
        if (typeof params === "function") {
          callback = params;
          params = void 0;
        }
        if (params && params.$waiter) {
          params = AWS2.util.copy(params);
          if (typeof params.$waiter.delay === "number") {
            this.config.delay = params.$waiter.delay;
          }
          if (typeof params.$waiter.maxAttempts === "number") {
            this.config.maxAttempts = params.$waiter.maxAttempts;
          }
          delete params.$waiter;
        }
        var request = this.service.makeRequest(this.config.operation, params);
        request._waiter = this;
        request.response.maxRetries = this.config.maxAttempts;
        request.addListeners(this.listeners);
        if (callback)
          request.send(callback);
        return request;
      }, "wait"),
      setSuccess: /* @__PURE__ */ __name(function setSuccess(resp) {
        resp.error = null;
        resp.data = resp.data || {};
        resp.request.removeAllListeners("extractData");
      }, "setSuccess"),
      setError: /* @__PURE__ */ __name(function setError(resp, retryable) {
        resp.data = null;
        resp.error = AWS2.util.error(resp.error || new Error(), {
          code: "ResourceNotReady",
          message: "Resource is not in the state " + this.state,
          retryable
        });
      }, "setError"),
      loadWaiterConfig: /* @__PURE__ */ __name(function loadWaiterConfig(state) {
        if (!this.service.api.waiters[state]) {
          throw new AWS2.util.error(new Error(), {
            code: "StateNotFoundError",
            message: "State " + state + " not found."
          });
        }
        this.config = AWS2.util.copy(this.service.api.waiters[state]);
      }, "loadWaiterConfig")
    });
  }
});

// node_modules/aws-sdk/lib/signers/v2.js
var require_v2 = __commonJS({
  "node_modules/aws-sdk/lib/signers/v2.js"(exports2, module2) {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.V2 = inherit(AWS2.Signers.RequestSigner, {
      addAuthorization: /* @__PURE__ */ __name(function addAuthorization(credentials, date) {
        if (!date)
          date = AWS2.util.date.getDate();
        var r = this.request;
        r.params.Timestamp = AWS2.util.date.iso8601(date);
        r.params.SignatureVersion = "2";
        r.params.SignatureMethod = "HmacSHA256";
        r.params.AWSAccessKeyId = credentials.accessKeyId;
        if (credentials.sessionToken) {
          r.params.SecurityToken = credentials.sessionToken;
        }
        delete r.params.Signature;
        r.params.Signature = this.signature(credentials);
        r.body = AWS2.util.queryParamsToString(r.params);
        r.headers["Content-Length"] = r.body.length;
      }, "addAuthorization"),
      signature: /* @__PURE__ */ __name(function signature(credentials) {
        return AWS2.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), "base64");
      }, "signature"),
      stringToSign: /* @__PURE__ */ __name(function stringToSign() {
        var parts = [];
        parts.push(this.request.method);
        parts.push(this.request.endpoint.host.toLowerCase());
        parts.push(this.request.pathname());
        parts.push(AWS2.util.queryParamsToString(this.request.params));
        return parts.join("\n");
      }, "stringToSign")
    });
    module2.exports = AWS2.Signers.V2;
  }
});

// node_modules/aws-sdk/lib/signers/v3.js
var require_v3 = __commonJS({
  "node_modules/aws-sdk/lib/signers/v3.js"(exports2, module2) {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.V3 = inherit(AWS2.Signers.RequestSigner, {
      addAuthorization: /* @__PURE__ */ __name(function addAuthorization(credentials, date) {
        var datetime = AWS2.util.date.rfc822(date);
        this.request.headers["X-Amz-Date"] = datetime;
        if (credentials.sessionToken) {
          this.request.headers["x-amz-security-token"] = credentials.sessionToken;
        }
        this.request.headers["X-Amzn-Authorization"] = this.authorization(credentials, datetime);
      }, "addAuthorization"),
      authorization: /* @__PURE__ */ __name(function authorization(credentials) {
        return "AWS3 AWSAccessKeyId=" + credentials.accessKeyId + ",Algorithm=HmacSHA256,SignedHeaders=" + this.signedHeaders() + ",Signature=" + this.signature(credentials);
      }, "authorization"),
      signedHeaders: /* @__PURE__ */ __name(function signedHeaders() {
        var headers = [];
        AWS2.util.arrayEach(this.headersToSign(), /* @__PURE__ */ __name(function iterator(h) {
          headers.push(h.toLowerCase());
        }, "iterator"));
        return headers.sort().join(";");
      }, "signedHeaders"),
      canonicalHeaders: /* @__PURE__ */ __name(function canonicalHeaders() {
        var headers = this.request.headers;
        var parts = [];
        AWS2.util.arrayEach(this.headersToSign(), /* @__PURE__ */ __name(function iterator(h) {
          parts.push(h.toLowerCase().trim() + ":" + String(headers[h]).trim());
        }, "iterator"));
        return parts.sort().join("\n") + "\n";
      }, "canonicalHeaders"),
      headersToSign: /* @__PURE__ */ __name(function headersToSign() {
        var headers = [];
        AWS2.util.each(this.request.headers, /* @__PURE__ */ __name(function iterator(k) {
          if (k === "Host" || k === "Content-Encoding" || k.match(/^X-Amz/i)) {
            headers.push(k);
          }
        }, "iterator"));
        return headers;
      }, "headersToSign"),
      signature: /* @__PURE__ */ __name(function signature(credentials) {
        return AWS2.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), "base64");
      }, "signature"),
      stringToSign: /* @__PURE__ */ __name(function stringToSign() {
        var parts = [];
        parts.push(this.request.method);
        parts.push("/");
        parts.push("");
        parts.push(this.canonicalHeaders());
        parts.push(this.request.body);
        return AWS2.util.crypto.sha256(parts.join("\n"));
      }, "stringToSign")
    });
    module2.exports = AWS2.Signers.V3;
  }
});

// node_modules/aws-sdk/lib/signers/v3https.js
var require_v3https = __commonJS({
  "node_modules/aws-sdk/lib/signers/v3https.js"(exports2, module2) {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    require_v3();
    AWS2.Signers.V3Https = inherit(AWS2.Signers.V3, {
      authorization: /* @__PURE__ */ __name(function authorization(credentials) {
        return "AWS3-HTTPS AWSAccessKeyId=" + credentials.accessKeyId + ",Algorithm=HmacSHA256,Signature=" + this.signature(credentials);
      }, "authorization"),
      stringToSign: /* @__PURE__ */ __name(function stringToSign() {
        return this.request.headers["X-Amz-Date"];
      }, "stringToSign")
    });
    module2.exports = AWS2.Signers.V3Https;
  }
});

// node_modules/aws-sdk/lib/signers/v4_credentials.js
var require_v4_credentials = __commonJS({
  "node_modules/aws-sdk/lib/signers/v4_credentials.js"(exports2, module2) {
    var AWS2 = require_core();
    var cachedSecret = {};
    var cacheQueue = [];
    var maxCacheEntries = 50;
    var v4Identifier = "aws4_request";
    module2.exports = {
      createScope: /* @__PURE__ */ __name(function createScope(date, region, serviceName) {
        return [
          date.substr(0, 8),
          region,
          serviceName,
          v4Identifier
        ].join("/");
      }, "createScope"),
      getSigningKey: /* @__PURE__ */ __name(function getSigningKey(credentials, date, region, service, shouldCache) {
        var credsIdentifier = AWS2.util.crypto.hmac(credentials.secretAccessKey, credentials.accessKeyId, "base64");
        var cacheKey = [credsIdentifier, date, region, service].join("_");
        shouldCache = shouldCache !== false;
        if (shouldCache && cacheKey in cachedSecret) {
          return cachedSecret[cacheKey];
        }
        var kDate = AWS2.util.crypto.hmac(
          "AWS4" + credentials.secretAccessKey,
          date,
          "buffer"
        );
        var kRegion = AWS2.util.crypto.hmac(kDate, region, "buffer");
        var kService = AWS2.util.crypto.hmac(kRegion, service, "buffer");
        var signingKey = AWS2.util.crypto.hmac(kService, v4Identifier, "buffer");
        if (shouldCache) {
          cachedSecret[cacheKey] = signingKey;
          cacheQueue.push(cacheKey);
          if (cacheQueue.length > maxCacheEntries) {
            delete cachedSecret[cacheQueue.shift()];
          }
        }
        return signingKey;
      }, "getSigningKey"),
      emptyCache: /* @__PURE__ */ __name(function emptyCache() {
        cachedSecret = {};
        cacheQueue = [];
      }, "emptyCache")
    };
  }
});

// node_modules/aws-sdk/lib/signers/v4.js
var require_v4 = __commonJS({
  "node_modules/aws-sdk/lib/signers/v4.js"(exports2, module2) {
    var AWS2 = require_core();
    var v4Credentials = require_v4_credentials();
    var inherit = AWS2.util.inherit;
    var expiresHeader = "presigned-expires";
    AWS2.Signers.V4 = inherit(AWS2.Signers.RequestSigner, {
      constructor: /* @__PURE__ */ __name(function V4(request, serviceName, options) {
        AWS2.Signers.RequestSigner.call(this, request);
        this.serviceName = serviceName;
        options = options || {};
        this.signatureCache = typeof options.signatureCache === "boolean" ? options.signatureCache : true;
        this.operation = options.operation;
        this.signatureVersion = options.signatureVersion;
      }, "V4"),
      algorithm: "AWS4-HMAC-SHA256",
      addAuthorization: /* @__PURE__ */ __name(function addAuthorization(credentials, date) {
        var datetime = AWS2.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, "");
        if (this.isPresigned()) {
          this.updateForPresigned(credentials, datetime);
        } else {
          this.addHeaders(credentials, datetime);
        }
        this.request.headers["Authorization"] = this.authorization(credentials, datetime);
      }, "addAuthorization"),
      addHeaders: /* @__PURE__ */ __name(function addHeaders(credentials, datetime) {
        this.request.headers["X-Amz-Date"] = datetime;
        if (credentials.sessionToken) {
          this.request.headers["x-amz-security-token"] = credentials.sessionToken;
        }
      }, "addHeaders"),
      updateForPresigned: /* @__PURE__ */ __name(function updateForPresigned(credentials, datetime) {
        var credString = this.credentialString(datetime);
        var qs = {
          "X-Amz-Date": datetime,
          "X-Amz-Algorithm": this.algorithm,
          "X-Amz-Credential": credentials.accessKeyId + "/" + credString,
          "X-Amz-Expires": this.request.headers[expiresHeader],
          "X-Amz-SignedHeaders": this.signedHeaders()
        };
        if (credentials.sessionToken) {
          qs["X-Amz-Security-Token"] = credentials.sessionToken;
        }
        if (this.request.headers["Content-Type"]) {
          qs["Content-Type"] = this.request.headers["Content-Type"];
        }
        if (this.request.headers["Content-MD5"]) {
          qs["Content-MD5"] = this.request.headers["Content-MD5"];
        }
        if (this.request.headers["Cache-Control"]) {
          qs["Cache-Control"] = this.request.headers["Cache-Control"];
        }
        AWS2.util.each.call(this, this.request.headers, function(key, value) {
          if (key === expiresHeader)
            return;
          if (this.isSignableHeader(key)) {
            var lowerKey = key.toLowerCase();
            if (lowerKey.indexOf("x-amz-meta-") === 0) {
              qs[lowerKey] = value;
            } else if (lowerKey.indexOf("x-amz-") === 0) {
              qs[key] = value;
            }
          }
        });
        var sep = this.request.path.indexOf("?") >= 0 ? "&" : "?";
        this.request.path += sep + AWS2.util.queryParamsToString(qs);
      }, "updateForPresigned"),
      authorization: /* @__PURE__ */ __name(function authorization(credentials, datetime) {
        var parts = [];
        var credString = this.credentialString(datetime);
        parts.push(this.algorithm + " Credential=" + credentials.accessKeyId + "/" + credString);
        parts.push("SignedHeaders=" + this.signedHeaders());
        parts.push("Signature=" + this.signature(credentials, datetime));
        return parts.join(", ");
      }, "authorization"),
      signature: /* @__PURE__ */ __name(function signature(credentials, datetime) {
        var signingKey = v4Credentials.getSigningKey(
          credentials,
          datetime.substr(0, 8),
          this.request.region,
          this.serviceName,
          this.signatureCache
        );
        return AWS2.util.crypto.hmac(signingKey, this.stringToSign(datetime), "hex");
      }, "signature"),
      stringToSign: /* @__PURE__ */ __name(function stringToSign(datetime) {
        var parts = [];
        parts.push("AWS4-HMAC-SHA256");
        parts.push(datetime);
        parts.push(this.credentialString(datetime));
        parts.push(this.hexEncodedHash(this.canonicalString()));
        return parts.join("\n");
      }, "stringToSign"),
      canonicalString: /* @__PURE__ */ __name(function canonicalString() {
        var parts = [], pathname = this.request.pathname();
        if (this.serviceName !== "s3" && this.signatureVersion !== "s3v4")
          pathname = AWS2.util.uriEscapePath(pathname);
        parts.push(this.request.method);
        parts.push(pathname);
        parts.push(this.request.search());
        parts.push(this.canonicalHeaders() + "\n");
        parts.push(this.signedHeaders());
        parts.push(this.hexEncodedBodyHash());
        return parts.join("\n");
      }, "canonicalString"),
      canonicalHeaders: /* @__PURE__ */ __name(function canonicalHeaders() {
        var headers = [];
        AWS2.util.each.call(this, this.request.headers, function(key, item) {
          headers.push([key, item]);
        });
        headers.sort(function(a, b) {
          return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
        });
        var parts = [];
        AWS2.util.arrayEach.call(this, headers, function(item) {
          var key = item[0].toLowerCase();
          if (this.isSignableHeader(key)) {
            var value = item[1];
            if (typeof value === "undefined" || value === null || typeof value.toString !== "function") {
              throw AWS2.util.error(new Error("Header " + key + " contains invalid value"), {
                code: "InvalidHeader"
              });
            }
            parts.push(key + ":" + this.canonicalHeaderValues(value.toString()));
          }
        });
        return parts.join("\n");
      }, "canonicalHeaders"),
      canonicalHeaderValues: /* @__PURE__ */ __name(function canonicalHeaderValues(values) {
        return values.replace(/\s+/g, " ").replace(/^\s+|\s+$/g, "");
      }, "canonicalHeaderValues"),
      signedHeaders: /* @__PURE__ */ __name(function signedHeaders() {
        var keys = [];
        AWS2.util.each.call(this, this.request.headers, function(key) {
          key = key.toLowerCase();
          if (this.isSignableHeader(key))
            keys.push(key);
        });
        return keys.sort().join(";");
      }, "signedHeaders"),
      credentialString: /* @__PURE__ */ __name(function credentialString(datetime) {
        return v4Credentials.createScope(
          datetime.substr(0, 8),
          this.request.region,
          this.serviceName
        );
      }, "credentialString"),
      hexEncodedHash: /* @__PURE__ */ __name(function hash(string) {
        return AWS2.util.crypto.sha256(string, "hex");
      }, "hash"),
      hexEncodedBodyHash: /* @__PURE__ */ __name(function hexEncodedBodyHash() {
        var request = this.request;
        if (this.isPresigned() && ["s3", "s3-object-lambda"].indexOf(this.serviceName) > -1 && !request.body) {
          return "UNSIGNED-PAYLOAD";
        } else if (request.headers["X-Amz-Content-Sha256"]) {
          return request.headers["X-Amz-Content-Sha256"];
        } else {
          return this.hexEncodedHash(this.request.body || "");
        }
      }, "hexEncodedBodyHash"),
      unsignableHeaders: [
        "authorization",
        "content-type",
        "content-length",
        "user-agent",
        expiresHeader,
        "expect",
        "x-amzn-trace-id"
      ],
      isSignableHeader: /* @__PURE__ */ __name(function isSignableHeader(key) {
        if (key.toLowerCase().indexOf("x-amz-") === 0)
          return true;
        return this.unsignableHeaders.indexOf(key) < 0;
      }, "isSignableHeader"),
      isPresigned: /* @__PURE__ */ __name(function isPresigned() {
        return this.request.headers[expiresHeader] ? true : false;
      }, "isPresigned")
    });
    module2.exports = AWS2.Signers.V4;
  }
});

// node_modules/aws-sdk/lib/signers/s3.js
var require_s32 = __commonJS({
  "node_modules/aws-sdk/lib/signers/s3.js"(exports2, module2) {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.S3 = inherit(AWS2.Signers.RequestSigner, {
      subResources: {
        "acl": 1,
        "accelerate": 1,
        "analytics": 1,
        "cors": 1,
        "lifecycle": 1,
        "delete": 1,
        "inventory": 1,
        "location": 1,
        "logging": 1,
        "metrics": 1,
        "notification": 1,
        "partNumber": 1,
        "policy": 1,
        "requestPayment": 1,
        "replication": 1,
        "restore": 1,
        "tagging": 1,
        "torrent": 1,
        "uploadId": 1,
        "uploads": 1,
        "versionId": 1,
        "versioning": 1,
        "versions": 1,
        "website": 1
      },
      responseHeaders: {
        "response-content-type": 1,
        "response-content-language": 1,
        "response-expires": 1,
        "response-cache-control": 1,
        "response-content-disposition": 1,
        "response-content-encoding": 1
      },
      addAuthorization: /* @__PURE__ */ __name(function addAuthorization(credentials, date) {
        if (!this.request.headers["presigned-expires"]) {
          this.request.headers["X-Amz-Date"] = AWS2.util.date.rfc822(date);
        }
        if (credentials.sessionToken) {
          this.request.headers["x-amz-security-token"] = credentials.sessionToken;
        }
        var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
        var auth = "AWS " + credentials.accessKeyId + ":" + signature;
        this.request.headers["Authorization"] = auth;
      }, "addAuthorization"),
      stringToSign: /* @__PURE__ */ __name(function stringToSign() {
        var r = this.request;
        var parts = [];
        parts.push(r.method);
        parts.push(r.headers["Content-MD5"] || "");
        parts.push(r.headers["Content-Type"] || "");
        parts.push(r.headers["presigned-expires"] || "");
        var headers = this.canonicalizedAmzHeaders();
        if (headers)
          parts.push(headers);
        parts.push(this.canonicalizedResource());
        return parts.join("\n");
      }, "stringToSign"),
      canonicalizedAmzHeaders: /* @__PURE__ */ __name(function canonicalizedAmzHeaders() {
        var amzHeaders = [];
        AWS2.util.each(this.request.headers, function(name) {
          if (name.match(/^x-amz-/i))
            amzHeaders.push(name);
        });
        amzHeaders.sort(function(a, b) {
          return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
        });
        var parts = [];
        AWS2.util.arrayEach.call(this, amzHeaders, function(name) {
          parts.push(name.toLowerCase() + ":" + String(this.request.headers[name]));
        });
        return parts.join("\n");
      }, "canonicalizedAmzHeaders"),
      canonicalizedResource: /* @__PURE__ */ __name(function canonicalizedResource() {
        var r = this.request;
        var parts = r.path.split("?");
        var path = parts[0];
        var querystring = parts[1];
        var resource = "";
        if (r.virtualHostedBucket)
          resource += "/" + r.virtualHostedBucket;
        resource += path;
        if (querystring) {
          var resources = [];
          AWS2.util.arrayEach.call(this, querystring.split("&"), function(param) {
            var name = param.split("=")[0];
            var value = param.split("=")[1];
            if (this.subResources[name] || this.responseHeaders[name]) {
              var subresource = { name };
              if (value !== void 0) {
                if (this.subResources[name]) {
                  subresource.value = value;
                } else {
                  subresource.value = decodeURIComponent(value);
                }
              }
              resources.push(subresource);
            }
          });
          resources.sort(function(a, b) {
            return a.name < b.name ? -1 : 1;
          });
          if (resources.length) {
            querystring = [];
            AWS2.util.arrayEach(resources, function(res) {
              if (res.value === void 0) {
                querystring.push(res.name);
              } else {
                querystring.push(res.name + "=" + res.value);
              }
            });
            resource += "?" + querystring.join("&");
          }
        }
        return resource;
      }, "canonicalizedResource"),
      sign: /* @__PURE__ */ __name(function sign(secret, string) {
        return AWS2.util.crypto.hmac(secret, string, "base64", "sha1");
      }, "sign")
    });
    module2.exports = AWS2.Signers.S3;
  }
});

// node_modules/aws-sdk/lib/signers/presign.js
var require_presign = __commonJS({
  "node_modules/aws-sdk/lib/signers/presign.js"(exports2, module2) {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    var expiresHeader = "presigned-expires";
    function signedUrlBuilder(request) {
      var expires = request.httpRequest.headers[expiresHeader];
      var signerClass = request.service.getSignerClass(request);
      delete request.httpRequest.headers["User-Agent"];
      delete request.httpRequest.headers["X-Amz-User-Agent"];
      if (signerClass === AWS2.Signers.V4) {
        if (expires > 604800) {
          var message = "Presigning does not support expiry time greater than a week with SigV4 signing.";
          throw AWS2.util.error(new Error(), {
            code: "InvalidExpiryTime",
            message,
            retryable: false
          });
        }
        request.httpRequest.headers[expiresHeader] = expires;
      } else if (signerClass === AWS2.Signers.S3) {
        var now = request.service ? request.service.getSkewCorrectedDate() : AWS2.util.date.getDate();
        request.httpRequest.headers[expiresHeader] = parseInt(
          AWS2.util.date.unixTimestamp(now) + expires,
          10
        ).toString();
      } else {
        throw AWS2.util.error(new Error(), {
          message: "Presigning only supports S3 or SigV4 signing.",
          code: "UnsupportedSigner",
          retryable: false
        });
      }
    }
    __name(signedUrlBuilder, "signedUrlBuilder");
    function signedUrlSigner(request) {
      var endpoint = request.httpRequest.endpoint;
      var parsedUrl = AWS2.util.urlParse(request.httpRequest.path);
      var queryParams = {};
      if (parsedUrl.search) {
        queryParams = AWS2.util.queryStringParse(parsedUrl.search.substr(1));
      }
      var auth = request.httpRequest.headers["Authorization"].split(" ");
      if (auth[0] === "AWS") {
        auth = auth[1].split(":");
        queryParams["Signature"] = auth.pop();
        queryParams["AWSAccessKeyId"] = auth.join(":");
        AWS2.util.each(request.httpRequest.headers, function(key, value) {
          if (key === expiresHeader)
            key = "Expires";
          if (key.indexOf("x-amz-meta-") === 0) {
            delete queryParams[key];
            key = key.toLowerCase();
          }
          queryParams[key] = value;
        });
        delete request.httpRequest.headers[expiresHeader];
        delete queryParams["Authorization"];
        delete queryParams["Host"];
      } else if (auth[0] === "AWS4-HMAC-SHA256") {
        auth.shift();
        var rest = auth.join(" ");
        var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
        queryParams["X-Amz-Signature"] = signature;
        delete queryParams["Expires"];
      }
      endpoint.pathname = parsedUrl.pathname;
      endpoint.search = AWS2.util.queryParamsToString(queryParams);
    }
    __name(signedUrlSigner, "signedUrlSigner");
    AWS2.Signers.Presign = inherit({
      sign: /* @__PURE__ */ __name(function sign(request, expireTime, callback) {
        request.httpRequest.headers[expiresHeader] = expireTime || 3600;
        request.on("build", signedUrlBuilder);
        request.on("sign", signedUrlSigner);
        request.removeListener(
          "afterBuild",
          AWS2.EventListeners.Core.SET_CONTENT_LENGTH
        );
        request.removeListener(
          "afterBuild",
          AWS2.EventListeners.Core.COMPUTE_SHA256
        );
        request.emit("beforePresign", [request]);
        if (callback) {
          request.build(function() {
            if (this.response.error)
              callback(this.response.error);
            else {
              callback(null, AWS2.util.urlFormat(request.httpRequest.endpoint));
            }
          });
        } else {
          request.build();
          if (request.response.error)
            throw request.response.error;
          return AWS2.util.urlFormat(request.httpRequest.endpoint);
        }
      }, "sign")
    });
    module2.exports = AWS2.Signers.Presign;
  }
});

// node_modules/aws-sdk/lib/signers/bearer.js
var require_bearer = __commonJS({
  "node_modules/aws-sdk/lib/signers/bearer.js"() {
    var AWS2 = require_core();
    AWS2.Signers.Bearer = AWS2.util.inherit(AWS2.Signers.RequestSigner, {
      constructor: /* @__PURE__ */ __name(function Bearer(request) {
        AWS2.Signers.RequestSigner.call(this, request);
      }, "Bearer"),
      addAuthorization: /* @__PURE__ */ __name(function addAuthorization(token) {
        this.request.headers["Authorization"] = "Bearer " + token.token;
      }, "addAuthorization")
    });
  }
});

// node_modules/aws-sdk/lib/signers/request_signer.js
var require_request_signer = __commonJS({
  "node_modules/aws-sdk/lib/signers/request_signer.js"() {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.RequestSigner = inherit({
      constructor: /* @__PURE__ */ __name(function RequestSigner(request) {
        this.request = request;
      }, "RequestSigner"),
      setServiceClientId: /* @__PURE__ */ __name(function setServiceClientId(id) {
        this.serviceClientId = id;
      }, "setServiceClientId"),
      getServiceClientId: /* @__PURE__ */ __name(function getServiceClientId() {
        return this.serviceClientId;
      }, "getServiceClientId")
    });
    AWS2.Signers.RequestSigner.getVersion = /* @__PURE__ */ __name(function getVersion(version) {
      switch (version) {
        case "v2":
          return AWS2.Signers.V2;
        case "v3":
          return AWS2.Signers.V3;
        case "s3v4":
          return AWS2.Signers.V4;
        case "v4":
          return AWS2.Signers.V4;
        case "s3":
          return AWS2.Signers.S3;
        case "v3https":
          return AWS2.Signers.V3Https;
        case "bearer":
          return AWS2.Signers.Bearer;
      }
      throw new Error("Unknown signing version " + version);
    }, "getVersion");
    require_v2();
    require_v3();
    require_v3https();
    require_v4();
    require_s32();
    require_presign();
    require_bearer();
  }
});

// node_modules/aws-sdk/lib/param_validator.js
var require_param_validator = __commonJS({
  "node_modules/aws-sdk/lib/param_validator.js"() {
    var AWS2 = require_core();
    AWS2.ParamValidator = AWS2.util.inherit({
      constructor: /* @__PURE__ */ __name(function ParamValidator(validation) {
        if (validation === true || validation === void 0) {
          validation = { "min": true };
        }
        this.validation = validation;
      }, "ParamValidator"),
      validate: /* @__PURE__ */ __name(function validate(shape, params, context) {
        this.errors = [];
        this.validateMember(shape, params || {}, context || "params");
        if (this.errors.length > 1) {
          var msg = this.errors.join("\n* ");
          msg = "There were " + this.errors.length + " validation errors:\n* " + msg;
          throw AWS2.util.error(
            new Error(msg),
            { code: "MultipleValidationErrors", errors: this.errors }
          );
        } else if (this.errors.length === 1) {
          throw this.errors[0];
        } else {
          return true;
        }
      }, "validate"),
      fail: /* @__PURE__ */ __name(function fail(code, message) {
        this.errors.push(AWS2.util.error(new Error(message), { code }));
      }, "fail"),
      validateStructure: /* @__PURE__ */ __name(function validateStructure(shape, params, context) {
        if (shape.isDocument)
          return true;
        this.validateType(params, context, ["object"], "structure");
        var paramName;
        for (var i = 0; shape.required && i < shape.required.length; i++) {
          paramName = shape.required[i];
          var value = params[paramName];
          if (value === void 0 || value === null) {
            this.fail(
              "MissingRequiredParameter",
              "Missing required key '" + paramName + "' in " + context
            );
          }
        }
        for (paramName in params) {
          if (!Object.prototype.hasOwnProperty.call(params, paramName))
            continue;
          var paramValue = params[paramName], memberShape = shape.members[paramName];
          if (memberShape !== void 0) {
            var memberContext = [context, paramName].join(".");
            this.validateMember(memberShape, paramValue, memberContext);
          } else if (paramValue !== void 0 && paramValue !== null) {
            this.fail(
              "UnexpectedParameter",
              "Unexpected key '" + paramName + "' found in " + context
            );
          }
        }
        return true;
      }, "validateStructure"),
      validateMember: /* @__PURE__ */ __name(function validateMember(shape, param, context) {
        switch (shape.type) {
          case "structure":
            return this.validateStructure(shape, param, context);
          case "list":
            return this.validateList(shape, param, context);
          case "map":
            return this.validateMap(shape, param, context);
          default:
            return this.validateScalar(shape, param, context);
        }
      }, "validateMember"),
      validateList: /* @__PURE__ */ __name(function validateList(shape, params, context) {
        if (this.validateType(params, context, [Array])) {
          this.validateRange(shape, params.length, context, "list member count");
          for (var i = 0; i < params.length; i++) {
            this.validateMember(shape.member, params[i], context + "[" + i + "]");
          }
        }
      }, "validateList"),
      validateMap: /* @__PURE__ */ __name(function validateMap(shape, params, context) {
        if (this.validateType(params, context, ["object"], "map")) {
          var mapCount = 0;
          for (var param in params) {
            if (!Object.prototype.hasOwnProperty.call(params, param))
              continue;
            this.validateMember(
              shape.key,
              param,
              context + "[key='" + param + "']"
            );
            this.validateMember(
              shape.value,
              params[param],
              context + "['" + param + "']"
            );
            mapCount++;
          }
          this.validateRange(shape, mapCount, context, "map member count");
        }
      }, "validateMap"),
      validateScalar: /* @__PURE__ */ __name(function validateScalar(shape, value, context) {
        switch (shape.type) {
          case null:
          case void 0:
          case "string":
            return this.validateString(shape, value, context);
          case "base64":
          case "binary":
            return this.validatePayload(value, context);
          case "integer":
          case "float":
            return this.validateNumber(shape, value, context);
          case "boolean":
            return this.validateType(value, context, ["boolean"]);
          case "timestamp":
            return this.validateType(
              value,
              context,
              [
                Date,
                /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/,
                "number"
              ],
              "Date object, ISO-8601 string, or a UNIX timestamp"
            );
          default:
            return this.fail("UnkownType", "Unhandled type " + shape.type + " for " + context);
        }
      }, "validateScalar"),
      validateString: /* @__PURE__ */ __name(function validateString(shape, value, context) {
        var validTypes = ["string"];
        if (shape.isJsonValue) {
          validTypes = validTypes.concat(["number", "object", "boolean"]);
        }
        if (value !== null && this.validateType(value, context, validTypes)) {
          this.validateEnum(shape, value, context);
          this.validateRange(shape, value.length, context, "string length");
          this.validatePattern(shape, value, context);
          this.validateUri(shape, value, context);
        }
      }, "validateString"),
      validateUri: /* @__PURE__ */ __name(function validateUri(shape, value, context) {
        if (shape["location"] === "uri") {
          if (value.length === 0) {
            this.fail("UriParameterError", 'Expected uri parameter to have length >= 1, but found "' + value + '" for ' + context);
          }
        }
      }, "validateUri"),
      validatePattern: /* @__PURE__ */ __name(function validatePattern(shape, value, context) {
        if (this.validation["pattern"] && shape["pattern"] !== void 0) {
          if (!new RegExp(shape["pattern"]).test(value)) {
            this.fail("PatternMatchError", 'Provided value "' + value + '" does not match regex pattern /' + shape["pattern"] + "/ for " + context);
          }
        }
      }, "validatePattern"),
      validateRange: /* @__PURE__ */ __name(function validateRange(shape, value, context, descriptor) {
        if (this.validation["min"]) {
          if (shape["min"] !== void 0 && value < shape["min"]) {
            this.fail("MinRangeError", "Expected " + descriptor + " >= " + shape["min"] + ", but found " + value + " for " + context);
          }
        }
        if (this.validation["max"]) {
          if (shape["max"] !== void 0 && value > shape["max"]) {
            this.fail("MaxRangeError", "Expected " + descriptor + " <= " + shape["max"] + ", but found " + value + " for " + context);
          }
        }
      }, "validateRange"),
      validateEnum: /* @__PURE__ */ __name(function validateRange(shape, value, context) {
        if (this.validation["enum"] && shape["enum"] !== void 0) {
          if (shape["enum"].indexOf(value) === -1) {
            this.fail("EnumError", "Found string value of " + value + ", but expected " + shape["enum"].join("|") + " for " + context);
          }
        }
      }, "validateRange"),
      validateType: /* @__PURE__ */ __name(function validateType(value, context, acceptedTypes, type) {
        if (value === null || value === void 0)
          return false;
        var foundInvalidType = false;
        for (var i = 0; i < acceptedTypes.length; i++) {
          if (typeof acceptedTypes[i] === "string") {
            if (typeof value === acceptedTypes[i])
              return true;
          } else if (acceptedTypes[i] instanceof RegExp) {
            if ((value || "").toString().match(acceptedTypes[i]))
              return true;
          } else {
            if (value instanceof acceptedTypes[i])
              return true;
            if (AWS2.util.isType(value, acceptedTypes[i]))
              return true;
            if (!type && !foundInvalidType)
              acceptedTypes = acceptedTypes.slice();
            acceptedTypes[i] = AWS2.util.typeName(acceptedTypes[i]);
          }
          foundInvalidType = true;
        }
        var acceptedType = type;
        if (!acceptedType) {
          acceptedType = acceptedTypes.join(", ").replace(/,([^,]+)$/, ", or$1");
        }
        var vowel = acceptedType.match(/^[aeiou]/i) ? "n" : "";
        this.fail("InvalidParameterType", "Expected " + context + " to be a" + vowel + " " + acceptedType);
        return false;
      }, "validateType"),
      validateNumber: /* @__PURE__ */ __name(function validateNumber(shape, value, context) {
        if (value === null || value === void 0)
          return;
        if (typeof value === "string") {
          var castedValue = parseFloat(value);
          if (castedValue.toString() === value)
            value = castedValue;
        }
        if (this.validateType(value, context, ["number"])) {
          this.validateRange(shape, value, context, "numeric value");
        }
      }, "validateNumber"),
      validatePayload: /* @__PURE__ */ __name(function validatePayload(value, context) {
        if (value === null || value === void 0)
          return;
        if (typeof value === "string")
          return;
        if (value && typeof value.byteLength === "number")
          return;
        if (AWS2.util.isNode()) {
          var Stream = AWS2.util.stream.Stream;
          if (AWS2.util.Buffer.isBuffer(value) || value instanceof Stream)
            return;
        } else {
          if (typeof Blob !== void 0 && value instanceof Blob)
            return;
        }
        var types = ["Buffer", "Stream", "File", "Blob", "ArrayBuffer", "DataView"];
        if (value) {
          for (var i = 0; i < types.length; i++) {
            if (AWS2.util.isType(value, types[i]))
              return;
            if (AWS2.util.typeName(value.constructor) === types[i])
              return;
          }
        }
        this.fail("InvalidParameterType", "Expected " + context + " to be a string, Buffer, Stream, Blob, or typed array object");
      }, "validatePayload")
    });
  }
});

// node_modules/aws-sdk/lib/maintenance_mode_message.js
var require_maintenance_mode_message = __commonJS({
  "node_modules/aws-sdk/lib/maintenance_mode_message.js"(exports2, module2) {
    var warning = [
      "We are formalizing our plans to enter AWS SDK for JavaScript (v2) into maintenance mode in 2023.\n",
      "Please migrate your code to use AWS SDK for JavaScript (v3).",
      "For more information, check the migration guide at https://a.co/7PzMCcy"
    ].join("\n");
    module2.exports = {
      suppress: false
    };
    function emitWarning() {
      if (typeof process !== "undefined" && typeof process.emitWarning === "function") {
        process.emitWarning(warning, {
          type: "NOTE"
        });
      }
    }
    __name(emitWarning, "emitWarning");
    setTimeout(function() {
      if (!module2.exports.suppress) {
        emitWarning();
      }
    }, 0);
  }
});

// node_modules/aws-sdk/lib/core.js
var require_core = __commonJS({
  "node_modules/aws-sdk/lib/core.js"(exports2, module2) {
    var AWS2 = { util: require_util9() };
    var _hidden = {};
    _hidden.toString();
    module2.exports = AWS2;
    AWS2.util.update(AWS2, {
      VERSION: "2.1325.0",
      Signers: {},
      Protocol: {
        Json: require_json(),
        Query: require_query(),
        Rest: require_rest(),
        RestJson: require_rest_json(),
        RestXml: require_rest_xml()
      },
      XML: {
        Builder: require_builder2(),
        Parser: null
      },
      JSON: {
        Builder: require_builder(),
        Parser: require_parser2()
      },
      Model: {
        Api: require_api2(),
        Operation: require_operation(),
        Shape: require_shape(),
        Paginator: require_paginator(),
        ResourceWaiter: require_resource_waiter()
      },
      apiLoader: require_api_loader(),
      EndpointCache: require_endpoint_cache().EndpointCache
    });
    require_sequential_executor();
    require_service2();
    require_config3();
    require_http3();
    require_event_listeners();
    require_request3();
    require_response();
    require_resource_waiter2();
    require_request_signer();
    require_param_validator();
    require_maintenance_mode_message();
    AWS2.events = new AWS2.SequentialExecutor();
    AWS2.util.memoizedProperty(AWS2, "endpointCache", function() {
      return new AWS2.EndpointCache(AWS2.config.endpointCacheSize);
    }, true);
  }
});

// node_modules/aws-sdk/node_modules/uuid/dist/rng.js
var require_rng = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/dist/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var _crypto = _interopRequireDefault(__require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function rng() {
      return _crypto.default.randomBytes(16);
    }
    __name(rng, "rng");
  }
});

// node_modules/aws-sdk/node_modules/uuid/dist/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/dist/bytesToUuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]]].join("");
    }
    __name(bytesToUuid, "bytesToUuid");
    var _default = bytesToUuid;
    exports2.default = _default;
  }
});

// node_modules/aws-sdk/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/dist/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : (0, _bytesToUuid.default)(b);
    }
    __name(v1, "v1");
    var _default = v1;
    exports2.default = _default;
  }
});

// node_modules/aws-sdk/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/dist/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    exports2.URL = exports2.DNS = void 0;
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function uuidToBytes(uuid) {
      var bytes = [];
      uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
        bytes.push(parseInt(hex, 16));
      });
      return bytes;
    }
    __name(uuidToBytes, "uuidToBytes");
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      var bytes = new Array(str.length);
      for (var i = 0; i < str.length; i++) {
        bytes[i] = str.charCodeAt(i);
      }
      return bytes;
    }
    __name(stringToBytes, "stringToBytes");
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL2;
    function _default(name, version, hashfunc) {
      var generateUUID = /* @__PURE__ */ __name(function(value, namespace, buf, offset) {
        var off = buf && offset || 0;
        if (typeof value == "string")
          value = stringToBytes(value);
        if (typeof namespace == "string")
          namespace = uuidToBytes(namespace);
        if (!Array.isArray(value))
          throw TypeError("value must be an array of bytes");
        if (!Array.isArray(namespace) || namespace.length !== 16)
          throw TypeError("namespace must be uuid string or an Array of 16 byte values");
        var bytes = hashfunc(namespace.concat(value));
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          for (var idx = 0; idx < 16; ++idx) {
            buf[off + idx] = bytes[idx];
          }
        }
        return buf || (0, _bytesToUuid.default)(bytes);
      }, "generateUUID");
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
    __name(_default, "_default");
  }
});

// node_modules/aws-sdk/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/dist/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(__require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    __name(md5, "md5");
    var _default = md5;
    exports2.default = _default;
  }
});

// node_modules/aws-sdk/node_modules/uuid/dist/v3.js
var require_v32 = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/dist/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports2.default = _default;
  }
});

// node_modules/aws-sdk/node_modules/uuid/dist/v4.js
var require_v42 = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/dist/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || (0, _bytesToUuid.default)(rnds);
    }
    __name(v4, "v4");
    var _default = v4;
    exports2.default = _default;
  }
});

// node_modules/aws-sdk/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/dist/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(__require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    __name(sha1, "sha1");
    var _default = sha1;
    exports2.default = _default;
  }
});

// node_modules/aws-sdk/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/dist/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports2.default = _default;
  }
});

// node_modules/aws-sdk/node_modules/uuid/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/aws-sdk/node_modules/uuid/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v32());
    var _v3 = _interopRequireDefault(require_v42());
    var _v4 = _interopRequireDefault(require_v5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
  }
});

// node_modules/aws-sdk/lib/util.js
var require_util9 = __commonJS({
  "node_modules/aws-sdk/lib/util.js"(exports2, module2) {
    var AWS2;
    var util = {
      environment: "nodejs",
      engine: /* @__PURE__ */ __name(function engine() {
        if (util.isBrowser() && typeof navigator !== "undefined") {
          return navigator.userAgent;
        } else {
          var engine2 = process.platform + "/" + process.version;
          if (process.env.AWS_EXECUTION_ENV) {
            engine2 += " exec-env/" + process.env.AWS_EXECUTION_ENV;
          }
          return engine2;
        }
      }, "engine"),
      userAgent: /* @__PURE__ */ __name(function userAgent() {
        var name = util.environment;
        var agent = "aws-sdk-" + name + "/" + require_core().VERSION;
        if (name === "nodejs")
          agent += " " + util.engine();
        return agent;
      }, "userAgent"),
      uriEscape: /* @__PURE__ */ __name(function uriEscape(string) {
        var output = encodeURIComponent(string);
        output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);
        output = output.replace(/[*]/g, function(ch) {
          return "%" + ch.charCodeAt(0).toString(16).toUpperCase();
        });
        return output;
      }, "uriEscape"),
      uriEscapePath: /* @__PURE__ */ __name(function uriEscapePath(string) {
        var parts = [];
        util.arrayEach(string.split("/"), function(part) {
          parts.push(util.uriEscape(part));
        });
        return parts.join("/");
      }, "uriEscapePath"),
      urlParse: /* @__PURE__ */ __name(function urlParse(url) {
        return util.url.parse(url);
      }, "urlParse"),
      urlFormat: /* @__PURE__ */ __name(function urlFormat(url) {
        return util.url.format(url);
      }, "urlFormat"),
      queryStringParse: /* @__PURE__ */ __name(function queryStringParse(qs) {
        return util.querystring.parse(qs);
      }, "queryStringParse"),
      queryParamsToString: /* @__PURE__ */ __name(function queryParamsToString(params) {
        var items = [];
        var escape2 = util.uriEscape;
        var sortedKeys = Object.keys(params).sort();
        util.arrayEach(sortedKeys, function(name) {
          var value = params[name];
          var ename = escape2(name);
          var result = ename + "=";
          if (Array.isArray(value)) {
            var vals = [];
            util.arrayEach(value, function(item) {
              vals.push(escape2(item));
            });
            result = ename + "=" + vals.sort().join("&" + ename + "=");
          } else if (value !== void 0 && value !== null) {
            result = ename + "=" + escape2(value);
          }
          items.push(result);
        });
        return items.join("&");
      }, "queryParamsToString"),
      readFileSync: /* @__PURE__ */ __name(function readFileSync(path) {
        if (util.isBrowser())
          return null;
        return __require("fs").readFileSync(path, "utf-8");
      }, "readFileSync"),
      base64: {
        encode: /* @__PURE__ */ __name(function encode64(string) {
          if (typeof string === "number") {
            throw util.error(new Error("Cannot base64 encode number " + string));
          }
          if (string === null || typeof string === "undefined") {
            return string;
          }
          var buf = util.buffer.toBuffer(string);
          return buf.toString("base64");
        }, "encode64"),
        decode: /* @__PURE__ */ __name(function decode64(string) {
          if (typeof string === "number") {
            throw util.error(new Error("Cannot base64 decode number " + string));
          }
          if (string === null || typeof string === "undefined") {
            return string;
          }
          return util.buffer.toBuffer(string, "base64");
        }, "decode64")
      },
      buffer: {
        toBuffer: function(data, encoding) {
          return typeof util.Buffer.from === "function" && util.Buffer.from !== Uint8Array.from ? util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
        },
        alloc: function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new Error("size passed to alloc must be a number.");
          }
          if (typeof util.Buffer.alloc === "function") {
            return util.Buffer.alloc(size, fill, encoding);
          } else {
            var buf = new util.Buffer(size);
            if (fill !== void 0 && typeof buf.fill === "function") {
              buf.fill(fill, void 0, void 0, encoding);
            }
            return buf;
          }
        },
        toStream: /* @__PURE__ */ __name(function toStream(buffer) {
          if (!util.Buffer.isBuffer(buffer))
            buffer = util.buffer.toBuffer(buffer);
          var readable = new util.stream.Readable();
          var pos = 0;
          readable._read = function(size) {
            if (pos >= buffer.length)
              return readable.push(null);
            var end = pos + size;
            if (end > buffer.length)
              end = buffer.length;
            readable.push(buffer.slice(pos, end));
            pos = end;
          };
          return readable;
        }, "toStream"),
        concat: function(buffers) {
          var length = 0, offset = 0, buffer = null, i;
          for (i = 0; i < buffers.length; i++) {
            length += buffers[i].length;
          }
          buffer = util.buffer.alloc(length);
          for (i = 0; i < buffers.length; i++) {
            buffers[i].copy(buffer, offset);
            offset += buffers[i].length;
          }
          return buffer;
        }
      },
      string: {
        byteLength: /* @__PURE__ */ __name(function byteLength(string) {
          if (string === null || string === void 0)
            return 0;
          if (typeof string === "string")
            string = util.buffer.toBuffer(string);
          if (typeof string.byteLength === "number") {
            return string.byteLength;
          } else if (typeof string.length === "number") {
            return string.length;
          } else if (typeof string.size === "number") {
            return string.size;
          } else if (typeof string.path === "string") {
            return __require("fs").lstatSync(string.path).size;
          } else {
            throw util.error(
              new Error("Cannot determine length of " + string),
              { object: string }
            );
          }
        }, "byteLength"),
        upperFirst: /* @__PURE__ */ __name(function upperFirst(string) {
          return string[0].toUpperCase() + string.substr(1);
        }, "upperFirst"),
        lowerFirst: /* @__PURE__ */ __name(function lowerFirst(string) {
          return string[0].toLowerCase() + string.substr(1);
        }, "lowerFirst")
      },
      ini: {
        parse: /* @__PURE__ */ __name(function string(ini) {
          var currentSection, map = {};
          util.arrayEach(ini.split(/\r?\n/), function(line) {
            line = line.split(/(^|\s)[;#]/)[0].trim();
            var isSection = line[0] === "[" && line[line.length - 1] === "]";
            if (isSection) {
              currentSection = line.substring(1, line.length - 1);
              if (currentSection === "__proto__" || currentSection.split(/\s/)[1] === "__proto__") {
                throw util.error(
                  new Error("Cannot load profile name '" + currentSection + "' from shared ini file.")
                );
              }
            } else if (currentSection) {
              var indexOfEqualsSign = line.indexOf("=");
              var start = 0;
              var end = line.length - 1;
              var isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
              if (isAssignment) {
                var name = line.substring(0, indexOfEqualsSign).trim();
                var value = line.substring(indexOfEqualsSign + 1).trim();
                map[currentSection] = map[currentSection] || {};
                map[currentSection][name] = value;
              }
            }
          });
          return map;
        }, "string")
      },
      fn: {
        noop: function() {
        },
        callback: function(err) {
          if (err)
            throw err;
        },
        makeAsync: /* @__PURE__ */ __name(function makeAsync(fn, expectedArgs) {
          if (expectedArgs && expectedArgs <= fn.length) {
            return fn;
          }
          return function() {
            var args = Array.prototype.slice.call(arguments, 0);
            var callback = args.pop();
            var result = fn.apply(null, args);
            callback(result);
          };
        }, "makeAsync")
      },
      date: {
        getDate: /* @__PURE__ */ __name(function getDate() {
          if (!AWS2)
            AWS2 = require_core();
          if (AWS2.config.systemClockOffset) {
            return new Date(new Date().getTime() + AWS2.config.systemClockOffset);
          } else {
            return new Date();
          }
        }, "getDate"),
        iso8601: /* @__PURE__ */ __name(function iso8601(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.toISOString().replace(/\.\d{3}Z$/, "Z");
        }, "iso8601"),
        rfc822: /* @__PURE__ */ __name(function rfc822(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.toUTCString();
        }, "rfc822"),
        unixTimestamp: /* @__PURE__ */ __name(function unixTimestamp(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.getTime() / 1e3;
        }, "unixTimestamp"),
        from: /* @__PURE__ */ __name(function format(date) {
          if (typeof date === "number") {
            return new Date(date * 1e3);
          } else {
            return new Date(date);
          }
        }, "format"),
        format: /* @__PURE__ */ __name(function format(date, formatter) {
          if (!formatter)
            formatter = "iso8601";
          return util.date[formatter](util.date.from(date));
        }, "format"),
        parseTimestamp: /* @__PURE__ */ __name(function parseTimestamp(value) {
          if (typeof value === "number") {
            return new Date(value * 1e3);
          } else if (value.match(/^\d+$/)) {
            return new Date(value * 1e3);
          } else if (value.match(/^\d{4}/)) {
            return new Date(value);
          } else if (value.match(/^\w{3},/)) {
            return new Date(value);
          } else {
            throw util.error(
              new Error("unhandled timestamp format: " + value),
              { code: "TimestampParserError" }
            );
          }
        }, "parseTimestamp")
      },
      crypto: {
        crc32Table: [
          0,
          1996959894,
          3993919788,
          2567524794,
          124634137,
          1886057615,
          3915621685,
          2657392035,
          249268274,
          2044508324,
          3772115230,
          2547177864,
          162941995,
          2125561021,
          3887607047,
          2428444049,
          498536548,
          1789927666,
          4089016648,
          2227061214,
          450548861,
          1843258603,
          4107580753,
          2211677639,
          325883990,
          1684777152,
          4251122042,
          2321926636,
          335633487,
          1661365465,
          4195302755,
          2366115317,
          997073096,
          1281953886,
          3579855332,
          2724688242,
          1006888145,
          1258607687,
          3524101629,
          2768942443,
          901097722,
          1119000684,
          3686517206,
          2898065728,
          853044451,
          1172266101,
          3705015759,
          2882616665,
          651767980,
          1373503546,
          3369554304,
          3218104598,
          565507253,
          1454621731,
          3485111705,
          3099436303,
          671266974,
          1594198024,
          3322730930,
          2970347812,
          795835527,
          1483230225,
          3244367275,
          3060149565,
          1994146192,
          31158534,
          2563907772,
          4023717930,
          1907459465,
          112637215,
          2680153253,
          3904427059,
          2013776290,
          251722036,
          2517215374,
          3775830040,
          2137656763,
          141376813,
          2439277719,
          3865271297,
          1802195444,
          476864866,
          2238001368,
          4066508878,
          1812370925,
          453092731,
          2181625025,
          4111451223,
          1706088902,
          314042704,
          2344532202,
          4240017532,
          1658658271,
          366619977,
          2362670323,
          4224994405,
          1303535960,
          984961486,
          2747007092,
          3569037538,
          1256170817,
          1037604311,
          2765210733,
          3554079995,
          1131014506,
          879679996,
          2909243462,
          3663771856,
          1141124467,
          855842277,
          2852801631,
          3708648649,
          1342533948,
          654459306,
          3188396048,
          3373015174,
          1466479909,
          544179635,
          3110523913,
          3462522015,
          1591671054,
          702138776,
          2966460450,
          3352799412,
          1504918807,
          783551873,
          3082640443,
          3233442989,
          3988292384,
          2596254646,
          62317068,
          1957810842,
          3939845945,
          2647816111,
          81470997,
          1943803523,
          3814918930,
          2489596804,
          225274430,
          2053790376,
          3826175755,
          2466906013,
          167816743,
          2097651377,
          4027552580,
          2265490386,
          503444072,
          1762050814,
          4150417245,
          2154129355,
          426522225,
          1852507879,
          4275313526,
          2312317920,
          282753626,
          1742555852,
          4189708143,
          2394877945,
          397917763,
          1622183637,
          3604390888,
          2714866558,
          953729732,
          1340076626,
          3518719985,
          2797360999,
          1068828381,
          1219638859,
          3624741850,
          2936675148,
          906185462,
          1090812512,
          3747672003,
          2825379669,
          829329135,
          1181335161,
          3412177804,
          3160834842,
          628085408,
          1382605366,
          3423369109,
          3138078467,
          570562233,
          1426400815,
          3317316542,
          2998733608,
          733239954,
          1555261956,
          3268935591,
          3050360625,
          752459403,
          1541320221,
          2607071920,
          3965973030,
          1969922972,
          40735498,
          2617837225,
          3943577151,
          1913087877,
          83908371,
          2512341634,
          3803740692,
          2075208622,
          213261112,
          2463272603,
          3855990285,
          2094854071,
          198958881,
          2262029012,
          4057260610,
          1759359992,
          534414190,
          2176718541,
          4139329115,
          1873836001,
          414664567,
          2282248934,
          4279200368,
          1711684554,
          285281116,
          2405801727,
          4167216745,
          1634467795,
          376229701,
          2685067896,
          3608007406,
          1308918612,
          956543938,
          2808555105,
          3495958263,
          1231636301,
          1047427035,
          2932959818,
          3654703836,
          1088359270,
          936918e3,
          2847714899,
          3736837829,
          1202900863,
          817233897,
          3183342108,
          3401237130,
          1404277552,
          615818150,
          3134207493,
          3453421203,
          1423857449,
          601450431,
          3009837614,
          3294710456,
          1567103746,
          711928724,
          3020668471,
          3272380065,
          1510334235,
          755167117
        ],
        crc32: /* @__PURE__ */ __name(function crc32(data) {
          var tbl = util.crypto.crc32Table;
          var crc = 0 ^ -1;
          if (typeof data === "string") {
            data = util.buffer.toBuffer(data);
          }
          for (var i = 0; i < data.length; i++) {
            var code = data.readUInt8(i);
            crc = crc >>> 8 ^ tbl[(crc ^ code) & 255];
          }
          return (crc ^ -1) >>> 0;
        }, "crc32"),
        hmac: /* @__PURE__ */ __name(function hmac(key, string, digest, fn) {
          if (!digest)
            digest = "binary";
          if (digest === "buffer") {
            digest = void 0;
          }
          if (!fn)
            fn = "sha256";
          if (typeof string === "string")
            string = util.buffer.toBuffer(string);
          return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
        }, "hmac"),
        md5: /* @__PURE__ */ __name(function md5(data, digest, callback) {
          return util.crypto.hash("md5", data, digest, callback);
        }, "md5"),
        sha256: /* @__PURE__ */ __name(function sha256(data, digest, callback) {
          return util.crypto.hash("sha256", data, digest, callback);
        }, "sha256"),
        hash: function(algorithm, data, digest, callback) {
          var hash = util.crypto.createHash(algorithm);
          if (!digest) {
            digest = "binary";
          }
          if (digest === "buffer") {
            digest = void 0;
          }
          if (typeof data === "string")
            data = util.buffer.toBuffer(data);
          var sliceFn = util.arraySliceFn(data);
          var isBuffer = util.Buffer.isBuffer(data);
          if (util.isBrowser() && typeof ArrayBuffer !== "undefined" && data && data.buffer instanceof ArrayBuffer)
            isBuffer = true;
          if (callback && typeof data === "object" && typeof data.on === "function" && !isBuffer) {
            data.on("data", function(chunk) {
              hash.update(chunk);
            });
            data.on("error", function(err) {
              callback(err);
            });
            data.on("end", function() {
              callback(null, hash.digest(digest));
            });
          } else if (callback && sliceFn && !isBuffer && typeof FileReader !== "undefined") {
            var index = 0, size = 1024 * 512;
            var reader = new FileReader();
            reader.onerror = function() {
              callback(new Error("Failed to read data."));
            };
            reader.onload = function() {
              var buf = new util.Buffer(new Uint8Array(reader.result));
              hash.update(buf);
              index += buf.length;
              reader._continueReading();
            };
            reader._continueReading = function() {
              if (index >= data.size) {
                callback(null, hash.digest(digest));
                return;
              }
              var back = index + size;
              if (back > data.size)
                back = data.size;
              reader.readAsArrayBuffer(sliceFn.call(data, index, back));
            };
            reader._continueReading();
          } else {
            if (util.isBrowser() && typeof data === "object" && !isBuffer) {
              data = new util.Buffer(new Uint8Array(data));
            }
            var out = hash.update(data).digest(digest);
            if (callback)
              callback(null, out);
            return out;
          }
        },
        toHex: /* @__PURE__ */ __name(function toHex(data) {
          var out = [];
          for (var i = 0; i < data.length; i++) {
            out.push(("0" + data.charCodeAt(i).toString(16)).substr(-2, 2));
          }
          return out.join("");
        }, "toHex"),
        createHash: /* @__PURE__ */ __name(function createHash(algorithm) {
          return util.crypto.lib.createHash(algorithm);
        }, "createHash")
      },
      abort: {},
      each: /* @__PURE__ */ __name(function each(object, iterFunction) {
        for (var key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            var ret = iterFunction.call(this, key, object[key]);
            if (ret === util.abort)
              break;
          }
        }
      }, "each"),
      arrayEach: /* @__PURE__ */ __name(function arrayEach(array, iterFunction) {
        for (var idx in array) {
          if (Object.prototype.hasOwnProperty.call(array, idx)) {
            var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
            if (ret === util.abort)
              break;
          }
        }
      }, "arrayEach"),
      update: /* @__PURE__ */ __name(function update(obj1, obj2) {
        util.each(obj2, /* @__PURE__ */ __name(function iterator(key, item) {
          obj1[key] = item;
        }, "iterator"));
        return obj1;
      }, "update"),
      merge: /* @__PURE__ */ __name(function merge(obj1, obj2) {
        return util.update(util.copy(obj1), obj2);
      }, "merge"),
      copy: /* @__PURE__ */ __name(function copy(object) {
        if (object === null || object === void 0)
          return object;
        var dupe = {};
        for (var key in object) {
          dupe[key] = object[key];
        }
        return dupe;
      }, "copy"),
      isEmpty: /* @__PURE__ */ __name(function isEmpty(obj) {
        for (var prop in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, prop)) {
            return false;
          }
        }
        return true;
      }, "isEmpty"),
      arraySliceFn: /* @__PURE__ */ __name(function arraySliceFn(obj) {
        var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
        return typeof fn === "function" ? fn : null;
      }, "arraySliceFn"),
      isType: /* @__PURE__ */ __name(function isType(obj, type) {
        if (typeof type === "function")
          type = util.typeName(type);
        return Object.prototype.toString.call(obj) === "[object " + type + "]";
      }, "isType"),
      typeName: /* @__PURE__ */ __name(function typeName(type) {
        if (Object.prototype.hasOwnProperty.call(type, "name"))
          return type.name;
        var str = type.toString();
        var match = str.match(/^\s*function (.+)\(/);
        return match ? match[1] : str;
      }, "typeName"),
      error: /* @__PURE__ */ __name(function error(err, options) {
        var originalError = null;
        if (typeof err.message === "string" && err.message !== "") {
          if (typeof options === "string" || options && options.message) {
            originalError = util.copy(err);
            originalError.message = err.message;
          }
        }
        err.message = err.message || null;
        if (typeof options === "string") {
          err.message = options;
        } else if (typeof options === "object" && options !== null) {
          util.update(err, options);
          if (options.message)
            err.message = options.message;
          if (options.code || options.name)
            err.code = options.code || options.name;
          if (options.stack)
            err.stack = options.stack;
        }
        if (typeof Object.defineProperty === "function") {
          Object.defineProperty(err, "name", { writable: true, enumerable: false });
          Object.defineProperty(err, "message", { enumerable: true });
        }
        err.name = String(options && options.name || err.name || err.code || "Error");
        err.time = new Date();
        if (originalError)
          err.originalError = originalError;
        return err;
      }, "error"),
      inherit: /* @__PURE__ */ __name(function inherit(klass, features) {
        var newObject = null;
        if (features === void 0) {
          features = klass;
          klass = Object;
          newObject = {};
        } else {
          var ctor = /* @__PURE__ */ __name(function ConstructorWrapper() {
          }, "ConstructorWrapper");
          ctor.prototype = klass.prototype;
          newObject = new ctor();
        }
        if (features.constructor === Object) {
          features.constructor = function() {
            if (klass !== Object) {
              return klass.apply(this, arguments);
            }
          };
        }
        features.constructor.prototype = newObject;
        util.update(features.constructor.prototype, features);
        features.constructor.__super__ = klass;
        return features.constructor;
      }, "inherit"),
      mixin: /* @__PURE__ */ __name(function mixin() {
        var klass = arguments[0];
        for (var i = 1; i < arguments.length; i++) {
          for (var prop in arguments[i].prototype) {
            var fn = arguments[i].prototype[prop];
            if (prop !== "constructor") {
              klass.prototype[prop] = fn;
            }
          }
        }
        return klass;
      }, "mixin"),
      hideProperties: /* @__PURE__ */ __name(function hideProperties(obj, props) {
        if (typeof Object.defineProperty !== "function")
          return;
        util.arrayEach(props, function(key) {
          Object.defineProperty(obj, key, {
            enumerable: false,
            writable: true,
            configurable: true
          });
        });
      }, "hideProperties"),
      property: /* @__PURE__ */ __name(function property(obj, name, value, enumerable, isValue) {
        var opts = {
          configurable: true,
          enumerable: enumerable !== void 0 ? enumerable : true
        };
        if (typeof value === "function" && !isValue) {
          opts.get = value;
        } else {
          opts.value = value;
          opts.writable = true;
        }
        Object.defineProperty(obj, name, opts);
      }, "property"),
      memoizedProperty: /* @__PURE__ */ __name(function memoizedProperty(obj, name, get, enumerable) {
        var cachedValue = null;
        util.property(obj, name, function() {
          if (cachedValue === null) {
            cachedValue = get();
          }
          return cachedValue;
        }, enumerable);
      }, "memoizedProperty"),
      hoistPayloadMember: /* @__PURE__ */ __name(function hoistPayloadMember(resp) {
        var req = resp.request;
        var operationName = req.operation;
        var operation = req.service.api.operations[operationName];
        var output = operation.output;
        if (output.payload && !operation.hasEventOutput) {
          var payloadMember = output.members[output.payload];
          var responsePayload = resp.data[output.payload];
          if (payloadMember.type === "structure") {
            util.each(responsePayload, function(key, value) {
              util.property(resp.data, key, value, false);
            });
          }
        }
      }, "hoistPayloadMember"),
      computeSha256: /* @__PURE__ */ __name(function computeSha256(body, done) {
        if (util.isNode()) {
          var Stream = util.stream.Stream;
          var fs = __require("fs");
          if (typeof Stream === "function" && body instanceof Stream) {
            if (typeof body.path === "string") {
              var settings = {};
              if (typeof body.start === "number") {
                settings.start = body.start;
              }
              if (typeof body.end === "number") {
                settings.end = body.end;
              }
              body = fs.createReadStream(body.path, settings);
            } else {
              return done(new Error("Non-file stream objects are not supported with SigV4"));
            }
          }
        }
        util.crypto.sha256(body, "hex", function(err, sha) {
          if (err)
            done(err);
          else
            done(null, sha);
        });
      }, "computeSha256"),
      isClockSkewed: /* @__PURE__ */ __name(function isClockSkewed(serverTime) {
        if (serverTime) {
          util.property(
            AWS2.config,
            "isClockSkewed",
            Math.abs(new Date().getTime() - serverTime) >= 3e5,
            false
          );
          return AWS2.config.isClockSkewed;
        }
      }, "isClockSkewed"),
      applyClockOffset: /* @__PURE__ */ __name(function applyClockOffset(serverTime) {
        if (serverTime)
          AWS2.config.systemClockOffset = serverTime - new Date().getTime();
      }, "applyClockOffset"),
      extractRequestId: /* @__PURE__ */ __name(function extractRequestId(resp) {
        var requestId = resp.httpResponse.headers["x-amz-request-id"] || resp.httpResponse.headers["x-amzn-requestid"];
        if (!requestId && resp.data && resp.data.ResponseMetadata) {
          requestId = resp.data.ResponseMetadata.RequestId;
        }
        if (requestId) {
          resp.requestId = requestId;
        }
        if (resp.error) {
          resp.error.requestId = requestId;
        }
      }, "extractRequestId"),
      addPromises: /* @__PURE__ */ __name(function addPromises(constructors, PromiseDependency) {
        var deletePromises = false;
        if (PromiseDependency === void 0 && AWS2 && AWS2.config) {
          PromiseDependency = AWS2.config.getPromisesDependency();
        }
        if (PromiseDependency === void 0 && typeof Promise !== "undefined") {
          PromiseDependency = Promise;
        }
        if (typeof PromiseDependency !== "function")
          deletePromises = true;
        if (!Array.isArray(constructors))
          constructors = [constructors];
        for (var ind = 0; ind < constructors.length; ind++) {
          var constructor = constructors[ind];
          if (deletePromises) {
            if (constructor.deletePromisesFromClass) {
              constructor.deletePromisesFromClass();
            }
          } else if (constructor.addPromisesToClass) {
            constructor.addPromisesToClass(PromiseDependency);
          }
        }
      }, "addPromises"),
      promisifyMethod: /* @__PURE__ */ __name(function promisifyMethod(methodName, PromiseDependency) {
        return /* @__PURE__ */ __name(function promise() {
          var self2 = this;
          var args = Array.prototype.slice.call(arguments);
          return new PromiseDependency(function(resolve, reject) {
            args.push(function(err, data) {
              if (err) {
                reject(err);
              } else {
                resolve(data);
              }
            });
            self2[methodName].apply(self2, args);
          });
        }, "promise");
      }, "promisifyMethod"),
      isDualstackAvailable: /* @__PURE__ */ __name(function isDualstackAvailable(service) {
        if (!service)
          return false;
        var metadata = require_metadata();
        if (typeof service !== "string")
          service = service.serviceIdentifier;
        if (typeof service !== "string" || !metadata.hasOwnProperty(service))
          return false;
        return !!metadata[service].dualstackAvailable;
      }, "isDualstackAvailable"),
      calculateRetryDelay: /* @__PURE__ */ __name(function calculateRetryDelay(retryCount, retryDelayOptions, err) {
        if (!retryDelayOptions)
          retryDelayOptions = {};
        var customBackoff = retryDelayOptions.customBackoff || null;
        if (typeof customBackoff === "function") {
          return customBackoff(retryCount, err);
        }
        var base = typeof retryDelayOptions.base === "number" ? retryDelayOptions.base : 100;
        var delay = Math.random() * (Math.pow(2, retryCount) * base);
        return delay;
      }, "calculateRetryDelay"),
      handleRequestWithRetries: /* @__PURE__ */ __name(function handleRequestWithRetries(httpRequest, options, cb) {
        if (!options)
          options = {};
        var http = AWS2.HttpClient.getInstance();
        var httpOptions = options.httpOptions || {};
        var retryCount = 0;
        var errCallback = /* @__PURE__ */ __name(function(err) {
          var maxRetries = options.maxRetries || 0;
          if (err && err.code === "TimeoutError")
            err.retryable = true;
          if (err && err.retryable && retryCount < maxRetries) {
            var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
            if (delay >= 0) {
              retryCount++;
              setTimeout(sendRequest, delay + (err.retryAfter || 0));
              return;
            }
          }
          cb(err);
        }, "errCallback");
        var sendRequest = /* @__PURE__ */ __name(function() {
          var data = "";
          http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
            httpResponse.on("data", function(chunk) {
              data += chunk.toString();
            });
            httpResponse.on("end", function() {
              var statusCode = httpResponse.statusCode;
              if (statusCode < 300) {
                cb(null, data);
              } else {
                var retryAfter = parseInt(httpResponse.headers["retry-after"], 10) * 1e3 || 0;
                var err = util.error(
                  new Error(),
                  {
                    statusCode,
                    retryable: statusCode >= 500 || statusCode === 429
                  }
                );
                if (retryAfter && err.retryable)
                  err.retryAfter = retryAfter;
                errCallback(err);
              }
            });
          }, errCallback);
        }, "sendRequest");
        AWS2.util.defer(sendRequest);
      }, "handleRequestWithRetries"),
      uuid: {
        v4: /* @__PURE__ */ __name(function uuidV4() {
          return require_dist2().v4();
        }, "uuidV4")
      },
      convertPayloadToString: /* @__PURE__ */ __name(function convertPayloadToString(resp) {
        var req = resp.request;
        var operation = req.operation;
        var rules = req.service.api.operations[operation].output || {};
        if (rules.payload && resp.data[rules.payload]) {
          resp.data[rules.payload] = resp.data[rules.payload].toString();
        }
      }, "convertPayloadToString"),
      defer: /* @__PURE__ */ __name(function defer(callback) {
        if (typeof process === "object" && typeof process.nextTick === "function") {
          process.nextTick(callback);
        } else if (typeof setImmediate === "function") {
          setImmediate(callback);
        } else {
          setTimeout(callback, 0);
        }
      }, "defer"),
      getRequestPayloadShape: /* @__PURE__ */ __name(function getRequestPayloadShape(req) {
        var operations = req.service.api.operations;
        if (!operations)
          return void 0;
        var operation = (operations || {})[req.operation];
        if (!operation || !operation.input || !operation.input.payload)
          return void 0;
        return operation.input.members[operation.input.payload];
      }, "getRequestPayloadShape"),
      getProfilesFromSharedConfig: /* @__PURE__ */ __name(function getProfilesFromSharedConfig(iniLoader, filename) {
        var profiles = {};
        var profilesFromConfig = {};
        if (process.env[util.configOptInEnv]) {
          var profilesFromConfig = iniLoader.loadFrom({
            isConfig: true,
            filename: process.env[util.sharedConfigFileEnv]
          });
        }
        var profilesFromCreds = {};
        try {
          var profilesFromCreds = iniLoader.loadFrom({
            filename: filename || process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv]
          });
        } catch (error) {
          if (!process.env[util.configOptInEnv])
            throw error;
        }
        for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
          profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromConfig[profileNames[i]]);
        }
        for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
          profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromCreds[profileNames[i]]);
        }
        return profiles;
        function objectAssign(target, source) {
          for (var i2 = 0, keys = Object.keys(source); i2 < keys.length; i2++) {
            target[keys[i2]] = source[keys[i2]];
          }
          return target;
        }
        __name(objectAssign, "objectAssign");
      }, "getProfilesFromSharedConfig"),
      ARN: {
        validate: /* @__PURE__ */ __name(function validateARN(str) {
          return str && str.indexOf("arn:") === 0 && str.split(":").length >= 6;
        }, "validateARN"),
        parse: /* @__PURE__ */ __name(function parseARN(arn) {
          var matched = arn.split(":");
          return {
            partition: matched[1],
            service: matched[2],
            region: matched[3],
            accountId: matched[4],
            resource: matched.slice(5).join(":")
          };
        }, "parseARN"),
        build: /* @__PURE__ */ __name(function buildARN(arnObject) {
          if (arnObject.service === void 0 || arnObject.region === void 0 || arnObject.accountId === void 0 || arnObject.resource === void 0)
            throw util.error(new Error("Input ARN object is invalid"));
          return "arn:" + (arnObject.partition || "aws") + ":" + arnObject.service + ":" + arnObject.region + ":" + arnObject.accountId + ":" + arnObject.resource;
        }, "buildARN")
      },
      defaultProfile: "default",
      configOptInEnv: "AWS_SDK_LOAD_CONFIG",
      sharedCredentialsFileEnv: "AWS_SHARED_CREDENTIALS_FILE",
      sharedConfigFileEnv: "AWS_CONFIG_FILE",
      imdsDisabledEnv: "AWS_EC2_METADATA_DISABLED"
    };
    module2.exports = util;
  }
});

// node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js
var require_event_message_chunker_stream = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js"(exports2, module2) {
    var util = require_core().util;
    var Transform = __require("stream").Transform;
    var allocBuffer = util.buffer.alloc;
    function EventMessageChunkerStream(options) {
      Transform.call(this, options);
      this.currentMessageTotalLength = 0;
      this.currentMessagePendingLength = 0;
      this.currentMessage = null;
      this.messageLengthBuffer = null;
    }
    __name(EventMessageChunkerStream, "EventMessageChunkerStream");
    EventMessageChunkerStream.prototype = Object.create(Transform.prototype);
    EventMessageChunkerStream.prototype._transform = function(chunk, encoding, callback) {
      var chunkLength = chunk.length;
      var currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!this.currentMessage) {
          var bytesRemaining = chunkLength - currentOffset;
          if (!this.messageLengthBuffer) {
            this.messageLengthBuffer = allocBuffer(4);
          }
          var numBytesForTotal = Math.min(
            4 - this.currentMessagePendingLength,
            bytesRemaining
          );
          chunk.copy(
            this.messageLengthBuffer,
            this.currentMessagePendingLength,
            currentOffset,
            currentOffset + numBytesForTotal
          );
          this.currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (this.currentMessagePendingLength < 4) {
            break;
          }
          this.allocateMessage(this.messageLengthBuffer.readUInt32BE(0));
          this.messageLengthBuffer = null;
        }
        var numBytesToWrite = Math.min(
          this.currentMessageTotalLength - this.currentMessagePendingLength,
          chunkLength - currentOffset
        );
        chunk.copy(
          this.currentMessage,
          this.currentMessagePendingLength,
          currentOffset,
          currentOffset + numBytesToWrite
        );
        this.currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (this.currentMessageTotalLength && this.currentMessageTotalLength === this.currentMessagePendingLength) {
          this.push(this.currentMessage);
          this.currentMessage = null;
          this.currentMessageTotalLength = 0;
          this.currentMessagePendingLength = 0;
        }
      }
      callback();
    };
    EventMessageChunkerStream.prototype._flush = function(callback) {
      if (this.currentMessageTotalLength) {
        if (this.currentMessageTotalLength === this.currentMessagePendingLength) {
          callback(null, this.currentMessage);
        } else {
          callback(new Error("Truncated event message received."));
        }
      } else {
        callback();
      }
    };
    EventMessageChunkerStream.prototype.allocateMessage = function(size) {
      if (typeof size !== "number") {
        throw new Error("Attempted to allocate an event message where size was not a number: " + size);
      }
      this.currentMessageTotalLength = size;
      this.currentMessagePendingLength = 4;
      this.currentMessage = allocBuffer(size);
      this.currentMessage.writeUInt32BE(size, 0);
    };
    module2.exports = {
      EventMessageChunkerStream
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/int64.js
var require_int64 = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/int64.js"(exports2, module2) {
    var util = require_core().util;
    var toBuffer = util.buffer.toBuffer;
    function Int64(bytes) {
      if (bytes.length !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
      if (!util.Buffer.isBuffer(bytes))
        bytes = toBuffer(bytes);
      this.bytes = bytes;
    }
    __name(Int64, "Int64");
    Int64.fromNumber = function(number) {
      if (number > 9223372036854776e3 || number < -9223372036854776e3) {
        throw new Error(
          number + " is too large (or, if negative, too small) to represent as an Int64"
        );
      }
      var bytes = new Uint8Array(8);
      for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
        bytes[i] = remaining;
      }
      if (number < 0) {
        negate(bytes);
      }
      return new Int64(bytes);
    };
    Int64.prototype.valueOf = function() {
      var bytes = this.bytes.slice(0);
      var negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt(bytes.toString("hex"), 16) * (negative ? -1 : 1);
    };
    Int64.prototype.toString = function() {
      return String(this.valueOf());
    };
    function negate(bytes) {
      for (var i = 0; i < 8; i++) {
        bytes[i] ^= 255;
      }
      for (var i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0) {
          break;
        }
      }
    }
    __name(negate, "negate");
    module2.exports = {
      Int64
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/split-message.js
var require_split_message = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/split-message.js"(exports2, module2) {
    var util = require_core().util;
    var toBuffer = util.buffer.toBuffer;
    var PRELUDE_MEMBER_LENGTH = 4;
    var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
    var CHECKSUM_LENGTH = 4;
    var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
    function splitMessage(message) {
      if (!util.Buffer.isBuffer(message))
        message = toBuffer(message);
      if (message.length < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
      }
      if (message.length !== message.readUInt32BE(0)) {
        throw new Error("Reported message length does not match received message length");
      }
      var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);
      if (expectedPreludeChecksum !== util.crypto.crc32(
        message.slice(0, PRELUDE_LENGTH)
      )) {
        throw new Error(
          "The prelude checksum specified in the message (" + expectedPreludeChecksum + ") does not match the calculated CRC32 checksum."
        );
      }
      var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);
      if (expectedMessageChecksum !== util.crypto.crc32(
        message.slice(0, message.length - CHECKSUM_LENGTH)
      )) {
        throw new Error(
          "The message checksum did not match the expected value of " + expectedMessageChecksum
        );
      }
      var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
      var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);
      return {
        headers: message.slice(headersStart, headersEnd),
        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH)
      };
    }
    __name(splitMessage, "splitMessage");
    module2.exports = {
      splitMessage
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/parse-message.js
var require_parse_message = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/parse-message.js"(exports2, module2) {
    var Int64 = require_int64().Int64;
    var splitMessage = require_split_message().splitMessage;
    var BOOLEAN_TAG = "boolean";
    var BYTE_TAG = "byte";
    var SHORT_TAG = "short";
    var INT_TAG = "integer";
    var LONG_TAG = "long";
    var BINARY_TAG = "binary";
    var STRING_TAG = "string";
    var TIMESTAMP_TAG = "timestamp";
    var UUID_TAG = "uuid";
    function parseHeaders(headers) {
      var out = {};
      var position = 0;
      while (position < headers.length) {
        var nameLength = headers.readUInt8(position++);
        var name = headers.slice(position, position + nameLength).toString();
        position += nameLength;
        switch (headers.readUInt8(position++)) {
          case 0:
            out[name] = {
              type: BOOLEAN_TAG,
              value: true
            };
            break;
          case 1:
            out[name] = {
              type: BOOLEAN_TAG,
              value: false
            };
            break;
          case 2:
            out[name] = {
              type: BYTE_TAG,
              value: headers.readInt8(position++)
            };
            break;
          case 3:
            out[name] = {
              type: SHORT_TAG,
              value: headers.readInt16BE(position)
            };
            position += 2;
            break;
          case 4:
            out[name] = {
              type: INT_TAG,
              value: headers.readInt32BE(position)
            };
            position += 4;
            break;
          case 5:
            out[name] = {
              type: LONG_TAG,
              value: new Int64(headers.slice(position, position + 8))
            };
            position += 8;
            break;
          case 6:
            var binaryLength = headers.readUInt16BE(position);
            position += 2;
            out[name] = {
              type: BINARY_TAG,
              value: headers.slice(position, position + binaryLength)
            };
            position += binaryLength;
            break;
          case 7:
            var stringLength = headers.readUInt16BE(position);
            position += 2;
            out[name] = {
              type: STRING_TAG,
              value: headers.slice(
                position,
                position + stringLength
              ).toString()
            };
            position += stringLength;
            break;
          case 8:
            out[name] = {
              type: TIMESTAMP_TAG,
              value: new Date(
                new Int64(headers.slice(position, position + 8)).valueOf()
              )
            };
            position += 8;
            break;
          case 9:
            var uuidChars = headers.slice(position, position + 16).toString("hex");
            position += 16;
            out[name] = {
              type: UUID_TAG,
              value: uuidChars.substr(0, 8) + "-" + uuidChars.substr(8, 4) + "-" + uuidChars.substr(12, 4) + "-" + uuidChars.substr(16, 4) + "-" + uuidChars.substr(20)
            };
            break;
          default:
            throw new Error("Unrecognized header type tag");
        }
      }
      return out;
    }
    __name(parseHeaders, "parseHeaders");
    function parseMessage(message) {
      var parsed = splitMessage(message);
      return { headers: parseHeaders(parsed.headers), body: parsed.body };
    }
    __name(parseMessage, "parseMessage");
    module2.exports = {
      parseMessage
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/parse-event.js
var require_parse_event = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/parse-event.js"(exports2, module2) {
    var parseMessage = require_parse_message().parseMessage;
    function parseEvent(parser, message, shape) {
      var parsedMessage = parseMessage(message);
      var messageType = parsedMessage.headers[":message-type"];
      if (messageType) {
        if (messageType.value === "error") {
          throw parseError(parsedMessage);
        } else if (messageType.value !== "event") {
          return;
        }
      }
      var eventType = parsedMessage.headers[":event-type"];
      var eventModel = shape.members[eventType.value];
      if (!eventModel) {
        return;
      }
      var result = {};
      var eventPayloadMemberName = eventModel.eventPayloadMemberName;
      if (eventPayloadMemberName) {
        var payloadShape = eventModel.members[eventPayloadMemberName];
        if (payloadShape.type === "binary") {
          result[eventPayloadMemberName] = parsedMessage.body;
        } else {
          result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
        }
      }
      var eventHeaderNames = eventModel.eventHeaderMemberNames;
      for (var i = 0; i < eventHeaderNames.length; i++) {
        var name = eventHeaderNames[i];
        if (parsedMessage.headers[name]) {
          result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
        }
      }
      var output = {};
      output[eventType.value] = result;
      return output;
    }
    __name(parseEvent, "parseEvent");
    function parseError(message) {
      var errorCode = message.headers[":error-code"];
      var errorMessage = message.headers[":error-message"];
      var error = new Error(errorMessage.value || errorMessage);
      error.code = error.name = errorCode.value || errorCode;
      return error;
    }
    __name(parseError, "parseError");
    module2.exports = {
      parseEvent
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js
var require_event_message_unmarshaller_stream = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream.js"(exports2, module2) {
    var Transform = __require("stream").Transform;
    var parseEvent = require_parse_event().parseEvent;
    function EventUnmarshallerStream(options) {
      options = options || {};
      options.readableObjectMode = true;
      Transform.call(this, options);
      this._readableState.objectMode = true;
      this.parser = options.parser;
      this.eventStreamModel = options.eventStreamModel;
    }
    __name(EventUnmarshallerStream, "EventUnmarshallerStream");
    EventUnmarshallerStream.prototype = Object.create(Transform.prototype);
    EventUnmarshallerStream.prototype._transform = function(chunk, encoding, callback) {
      try {
        var event = parseEvent(this.parser, chunk, this.eventStreamModel);
        this.push(event);
        return callback();
      } catch (err) {
        callback(err);
      }
    };
    module2.exports = {
      EventUnmarshallerStream
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js
var require_streaming_create_event_stream = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream.js"(exports2, module2) {
    var EventMessageChunkerStream = require_event_message_chunker_stream().EventMessageChunkerStream;
    var EventUnmarshallerStream = require_event_message_unmarshaller_stream().EventUnmarshallerStream;
    function createEventStream(stream, parser, model) {
      var eventStream = new EventUnmarshallerStream({
        parser,
        eventStreamModel: model
      });
      var eventMessageChunker = new EventMessageChunkerStream();
      stream.pipe(
        eventMessageChunker
      ).pipe(eventStream);
      stream.on("error", function(err) {
        eventMessageChunker.emit("error", err);
      });
      eventMessageChunker.on("error", function(err) {
        eventStream.emit("error", err);
      });
      return eventStream;
    }
    __name(createEventStream, "createEventStream");
    module2.exports = {
      createEventStream
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/event-message-chunker.js
var require_event_message_chunker = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/event-message-chunker.js"(exports2, module2) {
    function eventMessageChunker(buffer) {
      var messages = [];
      var offset = 0;
      while (offset < buffer.length) {
        var totalLength = buffer.readInt32BE(offset);
        var message = buffer.slice(offset, totalLength + offset);
        offset += totalLength;
        messages.push(message);
      }
      return messages;
    }
    __name(eventMessageChunker, "eventMessageChunker");
    module2.exports = {
      eventMessageChunker
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js
var require_buffered_create_event_stream = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js"(exports2, module2) {
    var eventMessageChunker = require_event_message_chunker().eventMessageChunker;
    var parseEvent = require_parse_event().parseEvent;
    function createEventStream(body, parser, model) {
      var eventMessages = eventMessageChunker(body);
      var events = [];
      for (var i = 0; i < eventMessages.length; i++) {
        events.push(parseEvent(parser, eventMessages[i], model));
      }
      return events;
    }
    __name(createEventStream, "createEventStream");
    module2.exports = {
      createEventStream
    };
  }
});

// node_modules/aws-sdk/lib/realclock/nodeClock.js
var require_nodeClock = __commonJS({
  "node_modules/aws-sdk/lib/realclock/nodeClock.js"(exports2, module2) {
    module2.exports = {
      now: /* @__PURE__ */ __name(function now() {
        var second = process.hrtime();
        return second[0] * 1e3 + second[1] / 1e6;
      }, "now")
    };
  }
});

// node_modules/aws-sdk/lib/publisher/index.js
var require_publisher = __commonJS({
  "node_modules/aws-sdk/lib/publisher/index.js"(exports2, module2) {
    var util = require_core().util;
    var dgram = __require("dgram");
    var stringToBuffer = util.buffer.toBuffer;
    var MAX_MESSAGE_SIZE = 1024 * 8;
    function Publisher(options) {
      options = options || {};
      this.enabled = options.enabled || false;
      this.port = options.port || 31e3;
      this.clientId = options.clientId || "";
      this.address = options.host || "127.0.0.1";
      if (this.clientId.length > 255) {
        this.clientId = this.clientId.substr(0, 255);
      }
      this.messagesInFlight = 0;
    }
    __name(Publisher, "Publisher");
    Publisher.prototype.fieldsToTrim = {
      UserAgent: 256,
      SdkException: 128,
      SdkExceptionMessage: 512,
      AwsException: 128,
      AwsExceptionMessage: 512,
      FinalSdkException: 128,
      FinalSdkExceptionMessage: 512,
      FinalAwsException: 128,
      FinalAwsExceptionMessage: 512
    };
    Publisher.prototype.trimFields = function(event) {
      var trimmableFields = Object.keys(this.fieldsToTrim);
      for (var i = 0, iLen = trimmableFields.length; i < iLen; i++) {
        var field = trimmableFields[i];
        if (event.hasOwnProperty(field)) {
          var maxLength = this.fieldsToTrim[field];
          var value = event[field];
          if (value && value.length > maxLength) {
            event[field] = value.substr(0, maxLength);
          }
        }
      }
      return event;
    };
    Publisher.prototype.eventHandler = function(event) {
      event.ClientId = this.clientId;
      this.trimFields(event);
      var message = stringToBuffer(JSON.stringify(event));
      if (!this.enabled || message.length > MAX_MESSAGE_SIZE) {
        return;
      }
      this.publishDatagram(message);
    };
    Publisher.prototype.publishDatagram = function(message) {
      var self2 = this;
      var client = this.getClient();
      this.messagesInFlight++;
      this.client.send(message, 0, message.length, this.port, this.address, function(err, bytes) {
        if (--self2.messagesInFlight <= 0) {
          self2.destroyClient();
        }
      });
    };
    Publisher.prototype.getClient = function() {
      if (!this.client) {
        this.client = dgram.createSocket("udp4");
      }
      return this.client;
    };
    Publisher.prototype.destroyClient = function() {
      if (this.client) {
        this.client.close();
        this.client = void 0;
      }
    };
    module2.exports = {
      Publisher
    };
  }
});

// node_modules/aws-sdk/lib/publisher/configuration.js
var require_configuration = __commonJS({
  "node_modules/aws-sdk/lib/publisher/configuration.js"(exports2, module2) {
    var AWS2 = require_core();
    function resolveMonitoringConfig() {
      var config = {
        port: void 0,
        clientId: void 0,
        enabled: void 0,
        host: void 0
      };
      if (fromEnvironment(config) || fromConfigFile(config))
        return toJSType(config);
      return toJSType(config);
    }
    __name(resolveMonitoringConfig, "resolveMonitoringConfig");
    function fromEnvironment(config) {
      config.port = config.port || process.env.AWS_CSM_PORT;
      config.enabled = config.enabled || process.env.AWS_CSM_ENABLED;
      config.clientId = config.clientId || process.env.AWS_CSM_CLIENT_ID;
      config.host = config.host || process.env.AWS_CSM_HOST;
      return config.port && config.enabled && config.clientId && config.host || ["false", "0"].indexOf(config.enabled) >= 0;
    }
    __name(fromEnvironment, "fromEnvironment");
    function fromConfigFile(config) {
      var sharedFileConfig;
      try {
        var configFile = AWS2.util.iniLoader.loadFrom({
          isConfig: true,
          filename: process.env[AWS2.util.sharedConfigFileEnv]
        });
        var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS2.util.defaultProfile];
      } catch (err) {
        return false;
      }
      if (!sharedFileConfig)
        return config;
      config.port = config.port || sharedFileConfig.csm_port;
      config.enabled = config.enabled || sharedFileConfig.csm_enabled;
      config.clientId = config.clientId || sharedFileConfig.csm_client_id;
      config.host = config.host || sharedFileConfig.csm_host;
      return config.port && config.enabled && config.clientId && config.host;
    }
    __name(fromConfigFile, "fromConfigFile");
    function toJSType(config) {
      var falsyNotations = ["false", "0", void 0];
      if (!config.enabled || falsyNotations.indexOf(config.enabled.toLowerCase()) >= 0) {
        config.enabled = false;
      } else {
        config.enabled = true;
      }
      config.port = config.port ? parseInt(config.port, 10) : void 0;
      return config;
    }
    __name(toJSType, "toJSType");
    module2.exports = resolveMonitoringConfig;
  }
});

// node_modules/aws-sdk/lib/shared-ini/ini-loader.js
var require_ini_loader = __commonJS({
  "node_modules/aws-sdk/lib/shared-ini/ini-loader.js"(exports2, module2) {
    var AWS2 = require_core();
    var os = __require("os");
    var path = __require("path");
    function parseFile(filename) {
      return AWS2.util.ini.parse(AWS2.util.readFileSync(filename));
    }
    __name(parseFile, "parseFile");
    function getProfiles(fileContent) {
      var tmpContent = {};
      Object.keys(fileContent).forEach(function(sectionName) {
        if (/^sso-session\s/.test(sectionName))
          return;
        Object.defineProperty(tmpContent, sectionName.replace(/^profile\s/, ""), {
          value: fileContent[sectionName],
          enumerable: true
        });
      });
      return tmpContent;
    }
    __name(getProfiles, "getProfiles");
    function getSsoSessions(fileContent) {
      var tmpContent = {};
      Object.keys(fileContent).forEach(function(sectionName) {
        if (!/^sso-session\s/.test(sectionName))
          return;
        Object.defineProperty(tmpContent, sectionName.replace(/^sso-session\s/, ""), {
          value: fileContent[sectionName],
          enumerable: true
        });
      });
      return tmpContent;
    }
    __name(getSsoSessions, "getSsoSessions");
    AWS2.IniLoader = AWS2.util.inherit({
      constructor: /* @__PURE__ */ __name(function IniLoader2() {
        this.resolvedProfiles = {};
        this.resolvedSsoSessions = {};
      }, "IniLoader"),
      clearCachedFiles: /* @__PURE__ */ __name(function clearCachedFiles() {
        this.resolvedProfiles = {};
        this.resolvedSsoSessions = {};
      }, "clearCachedFiles"),
      loadFrom: /* @__PURE__ */ __name(function loadFrom(options) {
        options = options || {};
        var isConfig = options.isConfig === true;
        var filename = options.filename || this.getDefaultFilePath(isConfig);
        if (!this.resolvedProfiles[filename]) {
          var fileContent = parseFile(filename);
          if (isConfig) {
            Object.defineProperty(this.resolvedProfiles, filename, {
              value: getProfiles(fileContent)
            });
          } else {
            Object.defineProperty(this.resolvedProfiles, filename, { value: fileContent });
          }
        }
        return this.resolvedProfiles[filename];
      }, "loadFrom"),
      loadSsoSessionsFrom: /* @__PURE__ */ __name(function loadSsoSessionsFrom(options) {
        options = options || {};
        var filename = options.filename || this.getDefaultFilePath(true);
        if (!this.resolvedSsoSessions[filename]) {
          var fileContent = parseFile(filename);
          Object.defineProperty(this.resolvedSsoSessions, filename, {
            value: getSsoSessions(fileContent)
          });
        }
        return this.resolvedSsoSessions[filename];
      }, "loadSsoSessionsFrom"),
      getDefaultFilePath: /* @__PURE__ */ __name(function getDefaultFilePath(isConfig) {
        return path.join(
          this.getHomeDir(),
          ".aws",
          isConfig ? "config" : "credentials"
        );
      }, "getDefaultFilePath"),
      getHomeDir: /* @__PURE__ */ __name(function getHomeDir() {
        var env = process.env;
        var home = env.HOME || env.USERPROFILE || (env.HOMEPATH ? (env.HOMEDRIVE || "C:/") + env.HOMEPATH : null);
        if (home) {
          return home;
        }
        if (typeof os.homedir === "function") {
          return os.homedir();
        }
        throw AWS2.util.error(
          new Error("Cannot load credentials, HOME path not set")
        );
      }, "getHomeDir")
    });
    var IniLoader = AWS2.IniLoader;
    module2.exports = {
      IniLoader
    };
  }
});

// node_modules/aws-sdk/lib/shared-ini/index.js
var require_shared_ini = __commonJS({
  "node_modules/aws-sdk/lib/shared-ini/index.js"(exports2, module2) {
    var IniLoader = require_ini_loader().IniLoader;
    module2.exports.iniLoader = new IniLoader();
  }
});

// node_modules/aws-sdk/lib/config_regional_endpoint.js
var require_config_regional_endpoint = __commonJS({
  "node_modules/aws-sdk/lib/config_regional_endpoint.js"(exports2, module2) {
    var AWS2 = require_core();
    function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
      if (typeof configValue !== "string")
        return void 0;
      else if (["legacy", "regional"].indexOf(configValue.toLowerCase()) >= 0) {
        return configValue.toLowerCase();
      } else {
        throw AWS2.util.error(new Error(), errorOptions);
      }
    }
    __name(validateRegionalEndpointsFlagValue, "validateRegionalEndpointsFlagValue");
    function resolveRegionalEndpointsFlag(originalConfig, options) {
      originalConfig = originalConfig || {};
      var resolved;
      if (originalConfig[options.clientConfig]) {
        resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
          code: "InvalidConfiguration",
          message: 'invalid "' + options.clientConfig + '" configuration. Expect "legacy"  or "regional". Got "' + originalConfig[options.clientConfig] + '".'
        });
        if (resolved)
          return resolved;
      }
      if (!AWS2.util.isNode())
        return resolved;
      if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
        var envFlag = process.env[options.env];
        resolved = validateRegionalEndpointsFlagValue(envFlag, {
          code: "InvalidEnvironmentalVariable",
          message: "invalid " + options.env + ' environmental variable. Expect "legacy"  or "regional". Got "' + process.env[options.env] + '".'
        });
        if (resolved)
          return resolved;
      }
      var profile = {};
      try {
        var profiles = AWS2.util.getProfilesFromSharedConfig(AWS2.util.iniLoader);
        profile = profiles[process.env.AWS_PROFILE || AWS2.util.defaultProfile];
      } catch (e) {
      }
      ;
      if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
        var fileFlag = profile[options.sharedConfig];
        resolved = validateRegionalEndpointsFlagValue(fileFlag, {
          code: "InvalidConfiguration",
          message: "invalid " + options.sharedConfig + ' profile config. Expect "legacy"  or "regional". Got "' + profile[options.sharedConfig] + '".'
        });
        if (resolved)
          return resolved;
      }
      return resolved;
    }
    __name(resolveRegionalEndpointsFlag, "resolveRegionalEndpointsFlag");
    module2.exports = resolveRegionalEndpointsFlag;
  }
});

// node_modules/aws-sdk/lib/services/sts.js
var require_sts = __commonJS({
  "node_modules/aws-sdk/lib/services/sts.js"() {
    var AWS2 = require_core();
    var resolveRegionalEndpointsFlag = require_config_regional_endpoint();
    var ENV_REGIONAL_ENDPOINT_ENABLED = "AWS_STS_REGIONAL_ENDPOINTS";
    var CONFIG_REGIONAL_ENDPOINT_ENABLED = "sts_regional_endpoints";
    AWS2.util.update(AWS2.STS.prototype, {
      credentialsFrom: /* @__PURE__ */ __name(function credentialsFrom(data, credentials) {
        if (!data)
          return null;
        if (!credentials)
          credentials = new AWS2.TemporaryCredentials();
        credentials.expired = false;
        credentials.accessKeyId = data.Credentials.AccessKeyId;
        credentials.secretAccessKey = data.Credentials.SecretAccessKey;
        credentials.sessionToken = data.Credentials.SessionToken;
        credentials.expireTime = data.Credentials.Expiration;
        return credentials;
      }, "credentialsFrom"),
      assumeRoleWithWebIdentity: /* @__PURE__ */ __name(function assumeRoleWithWebIdentity(params, callback) {
        return this.makeUnauthenticatedRequest("assumeRoleWithWebIdentity", params, callback);
      }, "assumeRoleWithWebIdentity"),
      assumeRoleWithSAML: /* @__PURE__ */ __name(function assumeRoleWithSAML(params, callback) {
        return this.makeUnauthenticatedRequest("assumeRoleWithSAML", params, callback);
      }, "assumeRoleWithSAML"),
      setupRequestListeners: /* @__PURE__ */ __name(function setupRequestListeners(request) {
        request.addListener("validate", this.optInRegionalEndpoint, true);
      }, "setupRequestListeners"),
      optInRegionalEndpoint: /* @__PURE__ */ __name(function optInRegionalEndpoint(req) {
        var service = req.service;
        var config = service.config;
        config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
          env: ENV_REGIONAL_ENDPOINT_ENABLED,
          sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
          clientConfig: "stsRegionalEndpoints"
        });
        if (config.stsRegionalEndpoints === "regional" && service.isGlobalEndpoint) {
          if (!config.region) {
            throw AWS2.util.error(
              new Error(),
              { code: "ConfigError", message: "Missing region in config" }
            );
          }
          var insertPoint = config.endpoint.indexOf(".amazonaws.com");
          var regionalEndpoint = config.endpoint.substring(0, insertPoint) + "." + config.region + config.endpoint.substring(insertPoint);
          req.httpRequest.updateEndpoint(regionalEndpoint);
          req.httpRequest.region = config.region;
        }
      }, "optInRegionalEndpoint")
    });
  }
});

// node_modules/aws-sdk/apis/sts-2011-06-15.min.json
var require_sts_2011_06_15_min = __commonJS({
  "node_modules/aws-sdk/apis/sts-2011-06-15.min.json"(exports2, module2) {
    module2.exports = {
      version: "2.0",
      metadata: {
        apiVersion: "2011-06-15",
        endpointPrefix: "sts",
        globalEndpoint: "sts.amazonaws.com",
        protocol: "query",
        serviceAbbreviation: "AWS STS",
        serviceFullName: "AWS Security Token Service",
        serviceId: "STS",
        signatureVersion: "v4",
        uid: "sts-2011-06-15",
        xmlNamespace: "https://sts.amazonaws.com/doc/2011-06-15/"
      },
      operations: {
        AssumeRole: {
          input: {
            type: "structure",
            required: [
              "RoleArn",
              "RoleSessionName"
            ],
            members: {
              RoleArn: {},
              RoleSessionName: {},
              PolicyArns: {
                shape: "S4"
              },
              Policy: {},
              DurationSeconds: {
                type: "integer"
              },
              Tags: {
                shape: "S8"
              },
              TransitiveTagKeys: {
                type: "list",
                member: {}
              },
              ExternalId: {},
              SerialNumber: {},
              TokenCode: {},
              SourceIdentity: {}
            }
          },
          output: {
            resultWrapper: "AssumeRoleResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Si"
              },
              AssumedRoleUser: {
                shape: "Sn"
              },
              PackedPolicySize: {
                type: "integer"
              },
              SourceIdentity: {}
            }
          }
        },
        AssumeRoleWithSAML: {
          input: {
            type: "structure",
            required: [
              "RoleArn",
              "PrincipalArn",
              "SAMLAssertion"
            ],
            members: {
              RoleArn: {},
              PrincipalArn: {},
              SAMLAssertion: {},
              PolicyArns: {
                shape: "S4"
              },
              Policy: {},
              DurationSeconds: {
                type: "integer"
              }
            }
          },
          output: {
            resultWrapper: "AssumeRoleWithSAMLResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Si"
              },
              AssumedRoleUser: {
                shape: "Sn"
              },
              PackedPolicySize: {
                type: "integer"
              },
              Subject: {},
              SubjectType: {},
              Issuer: {},
              Audience: {},
              NameQualifier: {},
              SourceIdentity: {}
            }
          }
        },
        AssumeRoleWithWebIdentity: {
          input: {
            type: "structure",
            required: [
              "RoleArn",
              "RoleSessionName",
              "WebIdentityToken"
            ],
            members: {
              RoleArn: {},
              RoleSessionName: {},
              WebIdentityToken: {},
              ProviderId: {},
              PolicyArns: {
                shape: "S4"
              },
              Policy: {},
              DurationSeconds: {
                type: "integer"
              }
            }
          },
          output: {
            resultWrapper: "AssumeRoleWithWebIdentityResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Si"
              },
              SubjectFromWebIdentityToken: {},
              AssumedRoleUser: {
                shape: "Sn"
              },
              PackedPolicySize: {
                type: "integer"
              },
              Provider: {},
              Audience: {},
              SourceIdentity: {}
            }
          }
        },
        DecodeAuthorizationMessage: {
          input: {
            type: "structure",
            required: [
              "EncodedMessage"
            ],
            members: {
              EncodedMessage: {}
            }
          },
          output: {
            resultWrapper: "DecodeAuthorizationMessageResult",
            type: "structure",
            members: {
              DecodedMessage: {}
            }
          }
        },
        GetAccessKeyInfo: {
          input: {
            type: "structure",
            required: [
              "AccessKeyId"
            ],
            members: {
              AccessKeyId: {}
            }
          },
          output: {
            resultWrapper: "GetAccessKeyInfoResult",
            type: "structure",
            members: {
              Account: {}
            }
          }
        },
        GetCallerIdentity: {
          input: {
            type: "structure",
            members: {}
          },
          output: {
            resultWrapper: "GetCallerIdentityResult",
            type: "structure",
            members: {
              UserId: {},
              Account: {},
              Arn: {}
            }
          }
        },
        GetFederationToken: {
          input: {
            type: "structure",
            required: [
              "Name"
            ],
            members: {
              Name: {},
              Policy: {},
              PolicyArns: {
                shape: "S4"
              },
              DurationSeconds: {
                type: "integer"
              },
              Tags: {
                shape: "S8"
              }
            }
          },
          output: {
            resultWrapper: "GetFederationTokenResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Si"
              },
              FederatedUser: {
                type: "structure",
                required: [
                  "FederatedUserId",
                  "Arn"
                ],
                members: {
                  FederatedUserId: {},
                  Arn: {}
                }
              },
              PackedPolicySize: {
                type: "integer"
              }
            }
          }
        },
        GetSessionToken: {
          input: {
            type: "structure",
            members: {
              DurationSeconds: {
                type: "integer"
              },
              SerialNumber: {},
              TokenCode: {}
            }
          },
          output: {
            resultWrapper: "GetSessionTokenResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Si"
              }
            }
          }
        }
      },
      shapes: {
        S4: {
          type: "list",
          member: {
            type: "structure",
            members: {
              arn: {}
            }
          }
        },
        S8: {
          type: "list",
          member: {
            type: "structure",
            required: [
              "Key",
              "Value"
            ],
            members: {
              Key: {},
              Value: {}
            }
          }
        },
        Si: {
          type: "structure",
          required: [
            "AccessKeyId",
            "SecretAccessKey",
            "SessionToken",
            "Expiration"
          ],
          members: {
            AccessKeyId: {},
            SecretAccessKey: {},
            SessionToken: {},
            Expiration: {
              type: "timestamp"
            }
          }
        },
        Sn: {
          type: "structure",
          required: [
            "AssumedRoleId",
            "Arn"
          ],
          members: {
            AssumedRoleId: {},
            Arn: {}
          }
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json
var require_sts_2011_06_15_paginators = __commonJS({
  "node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json"(exports2, module2) {
    module2.exports = {
      pagination: {}
    };
  }
});

// node_modules/aws-sdk/clients/sts.js
var require_sts2 = __commonJS({
  "node_modules/aws-sdk/clients/sts.js"(exports2, module2) {
    require_node_loader();
    var AWS2 = require_core();
    var Service = AWS2.Service;
    var apiLoader = AWS2.apiLoader;
    apiLoader.services["sts"] = {};
    AWS2.STS = Service.defineService("sts", ["2011-06-15"]);
    require_sts();
    Object.defineProperty(apiLoader.services["sts"], "2011-06-15", {
      get: /* @__PURE__ */ __name(function get() {
        var model = require_sts_2011_06_15_min();
        model.paginators = require_sts_2011_06_15_paginators().pagination;
        return model;
      }, "get"),
      enumerable: true,
      configurable: true
    });
    module2.exports = AWS2.STS;
  }
});

// node_modules/aws-sdk/lib/credentials/temporary_credentials.js
var require_temporary_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/temporary_credentials.js"() {
    var AWS2 = require_core();
    var STS = require_sts2();
    AWS2.TemporaryCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function TemporaryCredentials(params, masterCredentials) {
        AWS2.Credentials.call(this);
        this.loadMasterCredentials(masterCredentials);
        this.expired = true;
        this.params = params || {};
        if (this.params.RoleArn) {
          this.params.RoleSessionName = this.params.RoleSessionName || "temporary-credentials";
        }
      }, "TemporaryCredentials"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        self2.createClients();
        self2.masterCredentials.get(function() {
          self2.service.config.credentials = self2.masterCredentials;
          var operation = self2.params.RoleArn ? self2.service.assumeRole : self2.service.getSessionToken;
          operation.call(self2.service, function(err, data) {
            if (!err) {
              self2.service.credentialsFrom(data, self2);
            }
            callback(err);
          });
        });
      }, "load"),
      loadMasterCredentials: /* @__PURE__ */ __name(function loadMasterCredentials(masterCredentials) {
        this.masterCredentials = masterCredentials || AWS2.config.credentials;
        while (this.masterCredentials.masterCredentials) {
          this.masterCredentials = this.masterCredentials.masterCredentials;
        }
        if (typeof this.masterCredentials.get !== "function") {
          this.masterCredentials = new AWS2.Credentials(this.masterCredentials);
        }
      }, "loadMasterCredentials"),
      createClients: function() {
        this.service = this.service || new STS({ params: this.params });
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js
var require_chainable_temporary_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js"() {
    var AWS2 = require_core();
    var STS = require_sts2();
    AWS2.ChainableTemporaryCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function ChainableTemporaryCredentials(options) {
        AWS2.Credentials.call(this);
        options = options || {};
        this.errorCode = "ChainableTemporaryCredentialsProviderFailure";
        this.expired = true;
        this.tokenCodeFn = null;
        var params = AWS2.util.copy(options.params) || {};
        if (params.RoleArn) {
          params.RoleSessionName = params.RoleSessionName || "temporary-credentials";
        }
        if (params.SerialNumber) {
          if (!options.tokenCodeFn || typeof options.tokenCodeFn !== "function") {
            throw new AWS2.util.error(
              new Error("tokenCodeFn must be a function when params.SerialNumber is given"),
              { code: this.errorCode }
            );
          } else {
            this.tokenCodeFn = options.tokenCodeFn;
          }
        }
        var config = AWS2.util.merge(
          {
            params,
            credentials: options.masterCredentials || AWS2.config.credentials
          },
          options.stsConfig || {}
        );
        this.service = new STS(config);
      }, "ChainableTemporaryCredentials"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        var operation = self2.service.config.params.RoleArn ? "assumeRole" : "getSessionToken";
        this.getTokenCode(function(err, tokenCode) {
          var params = {};
          if (err) {
            callback(err);
            return;
          }
          if (tokenCode) {
            params.TokenCode = tokenCode;
          }
          self2.service[operation](params, function(err2, data) {
            if (!err2) {
              self2.service.credentialsFrom(data, self2);
            }
            callback(err2);
          });
        });
      }, "load"),
      getTokenCode: /* @__PURE__ */ __name(function getTokenCode(callback) {
        var self2 = this;
        if (this.tokenCodeFn) {
          this.tokenCodeFn(this.service.config.params.SerialNumber, function(err, token) {
            if (err) {
              var message = err;
              if (err instanceof Error) {
                message = err.message;
              }
              callback(
                AWS2.util.error(
                  new Error("Error fetching MFA token: " + message),
                  { code: self2.errorCode }
                )
              );
              return;
            }
            callback(null, token);
          });
        } else {
          callback(null);
        }
      }, "getTokenCode")
    });
  }
});

// node_modules/aws-sdk/lib/credentials/web_identity_credentials.js
var require_web_identity_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/web_identity_credentials.js"() {
    var AWS2 = require_core();
    var STS = require_sts2();
    AWS2.WebIdentityCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function WebIdentityCredentials(params, clientConfig) {
        AWS2.Credentials.call(this);
        this.expired = true;
        this.params = params;
        this.params.RoleSessionName = this.params.RoleSessionName || "web-identity";
        this.data = null;
        this._clientConfig = AWS2.util.copy(clientConfig || {});
      }, "WebIdentityCredentials"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        self2.createClients();
        self2.service.assumeRoleWithWebIdentity(function(err, data) {
          self2.data = null;
          if (!err) {
            self2.data = data;
            self2.service.credentialsFrom(data, self2);
          }
          callback(err);
        });
      }, "load"),
      createClients: function() {
        if (!this.service) {
          var stsConfig = AWS2.util.merge({}, this._clientConfig);
          stsConfig.params = this.params;
          this.service = new STS(stsConfig);
        }
      }
    });
  }
});

// node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json
var require_cognito_identity_2014_06_30_min = __commonJS({
  "node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json"(exports2, module2) {
    module2.exports = {
      version: "2.0",
      metadata: {
        apiVersion: "2014-06-30",
        endpointPrefix: "cognito-identity",
        jsonVersion: "1.1",
        protocol: "json",
        serviceFullName: "Amazon Cognito Identity",
        serviceId: "Cognito Identity",
        signatureVersion: "v4",
        targetPrefix: "AWSCognitoIdentityService",
        uid: "cognito-identity-2014-06-30"
      },
      operations: {
        CreateIdentityPool: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolName",
              "AllowUnauthenticatedIdentities"
            ],
            members: {
              IdentityPoolName: {},
              AllowUnauthenticatedIdentities: {
                type: "boolean"
              },
              AllowClassicFlow: {
                type: "boolean"
              },
              SupportedLoginProviders: {
                shape: "S5"
              },
              DeveloperProviderName: {},
              OpenIdConnectProviderARNs: {
                shape: "S9"
              },
              CognitoIdentityProviders: {
                shape: "Sb"
              },
              SamlProviderARNs: {
                shape: "Sg"
              },
              IdentityPoolTags: {
                shape: "Sh"
              }
            }
          },
          output: {
            shape: "Sk"
          }
        },
        DeleteIdentities: {
          input: {
            type: "structure",
            required: [
              "IdentityIdsToDelete"
            ],
            members: {
              IdentityIdsToDelete: {
                type: "list",
                member: {}
              }
            }
          },
          output: {
            type: "structure",
            members: {
              UnprocessedIdentityIds: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    IdentityId: {},
                    ErrorCode: {}
                  }
                }
              }
            }
          }
        },
        DeleteIdentityPool: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {}
            }
          }
        },
        DescribeIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId"
            ],
            members: {
              IdentityId: {}
            }
          },
          output: {
            shape: "Sv"
          }
        },
        DescribeIdentityPool: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {}
            }
          },
          output: {
            shape: "Sk"
          }
        },
        GetCredentialsForIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId"
            ],
            members: {
              IdentityId: {},
              Logins: {
                shape: "S10"
              },
              CustomRoleArn: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              Credentials: {
                type: "structure",
                members: {
                  AccessKeyId: {},
                  SecretKey: {},
                  SessionToken: {},
                  Expiration: {
                    type: "timestamp"
                  }
                }
              }
            }
          },
          authtype: "none"
        },
        GetId: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              AccountId: {},
              IdentityPoolId: {},
              Logins: {
                shape: "S10"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {}
            }
          },
          authtype: "none"
        },
        GetIdentityPoolRoles: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              Roles: {
                shape: "S1c"
              },
              RoleMappings: {
                shape: "S1e"
              }
            }
          }
        },
        GetOpenIdToken: {
          input: {
            type: "structure",
            required: [
              "IdentityId"
            ],
            members: {
              IdentityId: {},
              Logins: {
                shape: "S10"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              Token: {}
            }
          },
          authtype: "none"
        },
        GetOpenIdTokenForDeveloperIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "Logins"
            ],
            members: {
              IdentityPoolId: {},
              IdentityId: {},
              Logins: {
                shape: "S10"
              },
              PrincipalTags: {
                shape: "S1s"
              },
              TokenDuration: {
                type: "long"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              Token: {}
            }
          }
        },
        GetPrincipalTagAttributeMap: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "IdentityProviderName"
            ],
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: "boolean"
              },
              PrincipalTags: {
                shape: "S1s"
              }
            }
          }
        },
        ListIdentities: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "MaxResults"
            ],
            members: {
              IdentityPoolId: {},
              MaxResults: {
                type: "integer"
              },
              NextToken: {},
              HideDisabled: {
                type: "boolean"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              Identities: {
                type: "list",
                member: {
                  shape: "Sv"
                }
              },
              NextToken: {}
            }
          }
        },
        ListIdentityPools: {
          input: {
            type: "structure",
            required: [
              "MaxResults"
            ],
            members: {
              MaxResults: {
                type: "integer"
              },
              NextToken: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPools: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    IdentityPoolId: {},
                    IdentityPoolName: {}
                  }
                }
              },
              NextToken: {}
            }
          }
        },
        ListTagsForResource: {
          input: {
            type: "structure",
            required: [
              "ResourceArn"
            ],
            members: {
              ResourceArn: {}
            }
          },
          output: {
            type: "structure",
            members: {
              Tags: {
                shape: "Sh"
              }
            }
          }
        },
        LookupDeveloperIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {},
              IdentityId: {},
              DeveloperUserIdentifier: {},
              MaxResults: {
                type: "integer"
              },
              NextToken: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              DeveloperUserIdentifierList: {
                type: "list",
                member: {}
              },
              NextToken: {}
            }
          }
        },
        MergeDeveloperIdentities: {
          input: {
            type: "structure",
            required: [
              "SourceUserIdentifier",
              "DestinationUserIdentifier",
              "DeveloperProviderName",
              "IdentityPoolId"
            ],
            members: {
              SourceUserIdentifier: {},
              DestinationUserIdentifier: {},
              DeveloperProviderName: {},
              IdentityPoolId: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {}
            }
          }
        },
        SetIdentityPoolRoles: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "Roles"
            ],
            members: {
              IdentityPoolId: {},
              Roles: {
                shape: "S1c"
              },
              RoleMappings: {
                shape: "S1e"
              }
            }
          }
        },
        SetPrincipalTagAttributeMap: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "IdentityProviderName"
            ],
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: "boolean"
              },
              PrincipalTags: {
                shape: "S1s"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: "boolean"
              },
              PrincipalTags: {
                shape: "S1s"
              }
            }
          }
        },
        TagResource: {
          input: {
            type: "structure",
            required: [
              "ResourceArn",
              "Tags"
            ],
            members: {
              ResourceArn: {},
              Tags: {
                shape: "Sh"
              }
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        UnlinkDeveloperIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId",
              "IdentityPoolId",
              "DeveloperProviderName",
              "DeveloperUserIdentifier"
            ],
            members: {
              IdentityId: {},
              IdentityPoolId: {},
              DeveloperProviderName: {},
              DeveloperUserIdentifier: {}
            }
          }
        },
        UnlinkIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId",
              "Logins",
              "LoginsToRemove"
            ],
            members: {
              IdentityId: {},
              Logins: {
                shape: "S10"
              },
              LoginsToRemove: {
                shape: "Sw"
              }
            }
          },
          authtype: "none"
        },
        UntagResource: {
          input: {
            type: "structure",
            required: [
              "ResourceArn",
              "TagKeys"
            ],
            members: {
              ResourceArn: {},
              TagKeys: {
                type: "list",
                member: {}
              }
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        UpdateIdentityPool: {
          input: {
            shape: "Sk"
          },
          output: {
            shape: "Sk"
          }
        }
      },
      shapes: {
        S5: {
          type: "map",
          key: {},
          value: {}
        },
        S9: {
          type: "list",
          member: {}
        },
        Sb: {
          type: "list",
          member: {
            type: "structure",
            members: {
              ProviderName: {},
              ClientId: {},
              ServerSideTokenCheck: {
                type: "boolean"
              }
            }
          }
        },
        Sg: {
          type: "list",
          member: {}
        },
        Sh: {
          type: "map",
          key: {},
          value: {}
        },
        Sk: {
          type: "structure",
          required: [
            "IdentityPoolId",
            "IdentityPoolName",
            "AllowUnauthenticatedIdentities"
          ],
          members: {
            IdentityPoolId: {},
            IdentityPoolName: {},
            AllowUnauthenticatedIdentities: {
              type: "boolean"
            },
            AllowClassicFlow: {
              type: "boolean"
            },
            SupportedLoginProviders: {
              shape: "S5"
            },
            DeveloperProviderName: {},
            OpenIdConnectProviderARNs: {
              shape: "S9"
            },
            CognitoIdentityProviders: {
              shape: "Sb"
            },
            SamlProviderARNs: {
              shape: "Sg"
            },
            IdentityPoolTags: {
              shape: "Sh"
            }
          }
        },
        Sv: {
          type: "structure",
          members: {
            IdentityId: {},
            Logins: {
              shape: "Sw"
            },
            CreationDate: {
              type: "timestamp"
            },
            LastModifiedDate: {
              type: "timestamp"
            }
          }
        },
        Sw: {
          type: "list",
          member: {}
        },
        S10: {
          type: "map",
          key: {},
          value: {}
        },
        S1c: {
          type: "map",
          key: {},
          value: {}
        },
        S1e: {
          type: "map",
          key: {},
          value: {
            type: "structure",
            required: [
              "Type"
            ],
            members: {
              Type: {},
              AmbiguousRoleResolution: {},
              RulesConfiguration: {
                type: "structure",
                required: [
                  "Rules"
                ],
                members: {
                  Rules: {
                    type: "list",
                    member: {
                      type: "structure",
                      required: [
                        "Claim",
                        "MatchType",
                        "Value",
                        "RoleARN"
                      ],
                      members: {
                        Claim: {},
                        MatchType: {},
                        Value: {},
                        RoleARN: {}
                      }
                    }
                  }
                }
              }
            }
          }
        },
        S1s: {
          type: "map",
          key: {},
          value: {}
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json
var require_cognito_identity_2014_06_30_paginators = __commonJS({
  "node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json"(exports2, module2) {
    module2.exports = {
      pagination: {
        ListIdentityPools: {
          input_token: "NextToken",
          limit_key: "MaxResults",
          output_token: "NextToken",
          result_key: "IdentityPools"
        }
      }
    };
  }
});

// node_modules/aws-sdk/clients/cognitoidentity.js
var require_cognitoidentity = __commonJS({
  "node_modules/aws-sdk/clients/cognitoidentity.js"(exports2, module2) {
    require_node_loader();
    var AWS2 = require_core();
    var Service = AWS2.Service;
    var apiLoader = AWS2.apiLoader;
    apiLoader.services["cognitoidentity"] = {};
    AWS2.CognitoIdentity = Service.defineService("cognitoidentity", ["2014-06-30"]);
    Object.defineProperty(apiLoader.services["cognitoidentity"], "2014-06-30", {
      get: /* @__PURE__ */ __name(function get() {
        var model = require_cognito_identity_2014_06_30_min();
        model.paginators = require_cognito_identity_2014_06_30_paginators().pagination;
        return model;
      }, "get"),
      enumerable: true,
      configurable: true
    });
    module2.exports = AWS2.CognitoIdentity;
  }
});

// node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js
var require_cognito_identity_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js"() {
    var AWS2 = require_core();
    var CognitoIdentity = require_cognitoidentity();
    var STS = require_sts2();
    AWS2.CognitoIdentityCredentials = AWS2.util.inherit(AWS2.Credentials, {
      localStorageKey: {
        id: "aws.cognito.identity-id.",
        providers: "aws.cognito.identity-providers."
      },
      constructor: /* @__PURE__ */ __name(function CognitoIdentityCredentials(params, clientConfig) {
        AWS2.Credentials.call(this);
        this.expired = true;
        this.params = params;
        this.data = null;
        this._identityId = null;
        this._clientConfig = AWS2.util.copy(clientConfig || {});
        this.loadCachedId();
        var self2 = this;
        Object.defineProperty(this, "identityId", {
          get: function() {
            self2.loadCachedId();
            return self2._identityId || self2.params.IdentityId;
          },
          set: function(identityId) {
            self2._identityId = identityId;
          }
        });
      }, "CognitoIdentityCredentials"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        self2.createClients();
        self2.data = null;
        self2._identityId = null;
        self2.getId(function(err) {
          if (!err) {
            if (!self2.params.RoleArn) {
              self2.getCredentialsForIdentity(callback);
            } else {
              self2.getCredentialsFromSTS(callback);
            }
          } else {
            self2.clearIdOnNotAuthorized(err);
            callback(err);
          }
        });
      }, "load"),
      clearCachedId: /* @__PURE__ */ __name(function clearCache() {
        this._identityId = null;
        delete this.params.IdentityId;
        var poolId = this.params.IdentityPoolId;
        var loginId = this.params.LoginId || "";
        delete this.storage[this.localStorageKey.id + poolId + loginId];
        delete this.storage[this.localStorageKey.providers + poolId + loginId];
      }, "clearCache"),
      clearIdOnNotAuthorized: /* @__PURE__ */ __name(function clearIdOnNotAuthorized(err) {
        var self2 = this;
        if (err.code == "NotAuthorizedException") {
          self2.clearCachedId();
        }
      }, "clearIdOnNotAuthorized"),
      getId: /* @__PURE__ */ __name(function getId(callback) {
        var self2 = this;
        if (typeof self2.params.IdentityId === "string") {
          return callback(null, self2.params.IdentityId);
        }
        self2.cognito.getId(function(err, data) {
          if (!err && data.IdentityId) {
            self2.params.IdentityId = data.IdentityId;
            callback(null, data.IdentityId);
          } else {
            callback(err);
          }
        });
      }, "getId"),
      loadCredentials: /* @__PURE__ */ __name(function loadCredentials(data, credentials) {
        if (!data || !credentials)
          return;
        credentials.expired = false;
        credentials.accessKeyId = data.Credentials.AccessKeyId;
        credentials.secretAccessKey = data.Credentials.SecretKey;
        credentials.sessionToken = data.Credentials.SessionToken;
        credentials.expireTime = data.Credentials.Expiration;
      }, "loadCredentials"),
      getCredentialsForIdentity: /* @__PURE__ */ __name(function getCredentialsForIdentity(callback) {
        var self2 = this;
        self2.cognito.getCredentialsForIdentity(function(err, data) {
          if (!err) {
            self2.cacheId(data);
            self2.data = data;
            self2.loadCredentials(self2.data, self2);
          } else {
            self2.clearIdOnNotAuthorized(err);
          }
          callback(err);
        });
      }, "getCredentialsForIdentity"),
      getCredentialsFromSTS: /* @__PURE__ */ __name(function getCredentialsFromSTS(callback) {
        var self2 = this;
        self2.cognito.getOpenIdToken(function(err, data) {
          if (!err) {
            self2.cacheId(data);
            self2.params.WebIdentityToken = data.Token;
            self2.webIdentityCredentials.refresh(function(webErr) {
              if (!webErr) {
                self2.data = self2.webIdentityCredentials.data;
                self2.sts.credentialsFrom(self2.data, self2);
              }
              callback(webErr);
            });
          } else {
            self2.clearIdOnNotAuthorized(err);
            callback(err);
          }
        });
      }, "getCredentialsFromSTS"),
      loadCachedId: /* @__PURE__ */ __name(function loadCachedId() {
        var self2 = this;
        if (AWS2.util.isBrowser() && !self2.params.IdentityId) {
          var id = self2.getStorage("id");
          if (id && self2.params.Logins) {
            var actualProviders = Object.keys(self2.params.Logins);
            var cachedProviders = (self2.getStorage("providers") || "").split(",");
            var intersect = cachedProviders.filter(function(n) {
              return actualProviders.indexOf(n) !== -1;
            });
            if (intersect.length !== 0) {
              self2.params.IdentityId = id;
            }
          } else if (id) {
            self2.params.IdentityId = id;
          }
        }
      }, "loadCachedId"),
      createClients: function() {
        var clientConfig = this._clientConfig;
        this.webIdentityCredentials = this.webIdentityCredentials || new AWS2.WebIdentityCredentials(this.params, clientConfig);
        if (!this.cognito) {
          var cognitoConfig = AWS2.util.merge({}, clientConfig);
          cognitoConfig.params = this.params;
          this.cognito = new CognitoIdentity(cognitoConfig);
        }
        this.sts = this.sts || new STS(clientConfig);
      },
      cacheId: /* @__PURE__ */ __name(function cacheId(data) {
        this._identityId = data.IdentityId;
        this.params.IdentityId = this._identityId;
        if (AWS2.util.isBrowser()) {
          this.setStorage("id", data.IdentityId);
          if (this.params.Logins) {
            this.setStorage("providers", Object.keys(this.params.Logins).join(","));
          }
        }
      }, "cacheId"),
      getStorage: /* @__PURE__ */ __name(function getStorage(key) {
        return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || "")];
      }, "getStorage"),
      setStorage: /* @__PURE__ */ __name(function setStorage(key, val) {
        try {
          this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || "")] = val;
        } catch (_) {
        }
      }, "setStorage"),
      storage: function() {
        try {
          var storage = AWS2.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === "object" ? window.localStorage : {};
          storage["aws.test-storage"] = "foobar";
          delete storage["aws.test-storage"];
          return storage;
        } catch (_) {
          return {};
        }
      }()
    });
  }
});

// node_modules/aws-sdk/lib/credentials/saml_credentials.js
var require_saml_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/saml_credentials.js"() {
    var AWS2 = require_core();
    var STS = require_sts2();
    AWS2.SAMLCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function SAMLCredentials(params) {
        AWS2.Credentials.call(this);
        this.expired = true;
        this.params = params;
      }, "SAMLCredentials"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        self2.createClients();
        self2.service.assumeRoleWithSAML(function(err, data) {
          if (!err) {
            self2.service.credentialsFrom(data, self2);
          }
          callback(err);
        });
      }, "load"),
      createClients: function() {
        this.service = this.service || new STS({ params: this.params });
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/process_credentials.js
var require_process_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/process_credentials.js"() {
    var AWS2 = require_core();
    var proc = __require("child_process");
    var iniLoader = AWS2.util.iniLoader;
    AWS2.ProcessCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function ProcessCredentials(options) {
        AWS2.Credentials.call(this);
        options = options || {};
        this.filename = options.filename;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS2.util.defaultProfile;
        this.get(options.callback || AWS2.util.fn.noop);
      }, "ProcessCredentials"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        try {
          var profiles = AWS2.util.getProfilesFromSharedConfig(iniLoader, this.filename);
          var profile = profiles[this.profile] || {};
          if (Object.keys(profile).length === 0) {
            throw AWS2.util.error(
              new Error("Profile " + this.profile + " not found"),
              { code: "ProcessCredentialsProviderFailure" }
            );
          }
          if (profile["credential_process"]) {
            this.loadViaCredentialProcess(profile, function(err, data) {
              if (err) {
                callback(err, null);
              } else {
                self2.expired = false;
                self2.accessKeyId = data.AccessKeyId;
                self2.secretAccessKey = data.SecretAccessKey;
                self2.sessionToken = data.SessionToken;
                if (data.Expiration) {
                  self2.expireTime = new Date(data.Expiration);
                }
                callback(null);
              }
            });
          } else {
            throw AWS2.util.error(
              new Error("Profile " + this.profile + " did not include credential process"),
              { code: "ProcessCredentialsProviderFailure" }
            );
          }
        } catch (err) {
          callback(err);
        }
      }, "load"),
      loadViaCredentialProcess: /* @__PURE__ */ __name(function loadViaCredentialProcess(profile, callback) {
        proc.exec(profile["credential_process"], { env: process.env }, function(err, stdOut, stdErr) {
          if (err) {
            callback(AWS2.util.error(
              new Error("credential_process returned error"),
              { code: "ProcessCredentialsProviderFailure" }
            ), null);
          } else {
            try {
              var credData = JSON.parse(stdOut);
              if (credData.Expiration) {
                var currentTime = AWS2.util.date.getDate();
                var expireTime = new Date(credData.Expiration);
                if (expireTime < currentTime) {
                  throw Error("credential_process returned expired credentials");
                }
              }
              if (credData.Version !== 1) {
                throw Error("credential_process does not return Version == 1");
              }
              callback(null, credData);
            } catch (err2) {
              callback(AWS2.util.error(
                new Error(err2.message),
                { code: "ProcessCredentialsProviderFailure" }
              ), null);
            }
          }
        });
      }, "loadViaCredentialProcess"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh")
    });
  }
});

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/xml2js/lib/defaults.js"(exports2) {
    (function() {
      exports2.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: "@@",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: ""
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          preserveChildrenOrder: false,
          childkey: "$$",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: "root",
          xmldec: {
            "version": "1.0",
            "encoding": "UTF-8",
            "standalone": true
          },
          doctype: null,
          renderOpts: {
            "pretty": true,
            "indent": "  ",
            "newline": "\n"
          },
          headless: false,
          chunkSize: 1e4,
          emptyTag: "",
          cdata: false
        }
      };
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/xmlbuilder/lib/Utility.js"(exports2, module2) {
    (function() {
      var assign, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
      assign = /* @__PURE__ */ __name(function() {
        var i, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i = 0, len = sources.length; i < len; i++) {
            source = sources[i];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      }, "assign");
      isFunction = /* @__PURE__ */ __name(function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
      }, "isFunction");
      isObject = /* @__PURE__ */ __name(function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      }, "isObject");
      isArray = /* @__PURE__ */ __name(function(val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      }, "isArray");
      isEmpty = /* @__PURE__ */ __name(function(val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key))
              continue;
            return false;
          }
          return true;
        }
      }, "isEmpty");
      isPlainObject = /* @__PURE__ */ __name(function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
      }, "isPlainObject");
      module2.exports.assign = assign;
      module2.exports.isFunction = isFunction;
      module2.exports.isObject = isObject;
      module2.exports.isArray = isArray;
      module2.exports.isEmpty = isEmpty;
      module2.exports.isPlainObject = isPlainObject;
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports2, module2) {
    (function() {
      var XMLAttribute;
      module2.exports = XMLAttribute = function() {
        function XMLAttribute2(parent, name, value) {
          this.options = parent.options;
          this.stringify = parent.stringify;
          if (name == null) {
            throw new Error("Missing attribute name of element " + parent.name);
          }
          if (value == null) {
            throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
          }
          this.name = this.stringify.attName(name);
          this.value = this.stringify.attValue(value);
        }
        __name(XMLAttribute2, "XMLAttribute");
        XMLAttribute2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function(options) {
          return this.options.writer.set(options).attribute(this);
        };
        return XMLAttribute2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLElement.js"(exports2, module2) {
    (function() {
      var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction;
      XMLNode = require_XMLNode();
      XMLAttribute = require_XMLAttribute();
      module2.exports = XMLElement = function(superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent, name, attributes) {
          XMLElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing element name");
          }
          this.name = this.stringify.eleName(name);
          this.attributes = {};
          if (attributes != null) {
            this.attribute(attributes);
          }
          if (parent.isDocument) {
            this.isRoot = true;
            this.documentObject = parent;
            parent.rootObject = this;
          }
        }
        __name(XMLElement2, "XMLElement");
        XMLElement2.prototype.clone = function() {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attributes = {};
          ref1 = this.attributes;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName))
              continue;
            att = ref1[attName];
            clonedSelf.attributes[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (name != null) {
            name = name.valueOf();
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (!this.options.skipNullAttributes || value != null) {
              this.attributes[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function(name) {
          var attName, i, len;
          if (name == null) {
            throw new Error("Missing attribute name");
          }
          name = name.valueOf();
          if (Array.isArray(name)) {
            for (i = 0, len = name.length; i < len; i++) {
              attName = name[i];
              delete this.attributes[attName];
            }
          } else {
            delete this.attributes[name];
          }
          return this;
        };
        XMLElement2.prototype.toString = function(options) {
          return this.options.writer.set(options).element(this);
        };
        XMLElement2.prototype.att = function(name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.a = function(name, value) {
          return this.attribute(name, value);
        };
        return XMLElement2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCData.js"(exports2, module2) {
    (function() {
      var XMLCData, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLCData = function(superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent, text) {
          XMLCData2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing CDATA text");
          }
          this.text = this.stringify.cdata(text);
        }
        __name(XMLCData2, "XMLCData");
        XMLCData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function(options) {
          return this.options.writer.set(options).cdata(this);
        };
        return XMLCData2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/xmlbuilder/lib/XMLComment.js"(exports2, module2) {
    (function() {
      var XMLComment, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLComment = function(superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent, text) {
          XMLComment2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing comment text");
          }
          this.text = this.stringify.comment(text);
        }
        __name(XMLComment2, "XMLComment");
        XMLComment2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function(options) {
          return this.options.writer.set(options).comment(this);
        };
        return XMLComment2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports2, module2) {
    (function() {
      var XMLDeclaration, XMLNode, isObject, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      module2.exports = XMLDeclaration = function(superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent, version, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent);
          if (isObject(version)) {
            ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
          }
          if (!version) {
            version = "1.0";
          }
          this.version = this.stringify.xmlVersion(version);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        __name(XMLDeclaration2, "XMLDeclaration");
        XMLDeclaration2.prototype.toString = function(options) {
          return this.options.writer.set(options).declaration(this);
        };
        return XMLDeclaration2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports2, module2) {
    (function() {
      var XMLDTDAttList, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDAttList = function(superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name");
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name");
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type");
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default");
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT");
          }
          this.elementName = this.stringify.eleName(elementName);
          this.attributeName = this.stringify.attName(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          this.defaultValueType = defaultValueType;
        }
        __name(XMLDTDAttList2, "XMLDTDAttList");
        XMLDTDAttList2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdAttList(this);
        };
        return XMLDTDAttList2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports2, module2) {
    (function() {
      var XMLDTDEntity, XMLNode, isObject, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDEntity = function(superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent, pe, name, value) {
          XMLDTDEntity2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing entity name");
          }
          if (value == null) {
            throw new Error("Missing entity value");
          }
          this.pe = !!pe;
          this.name = this.stringify.eleName(name);
          if (!isObject(value)) {
            this.value = this.stringify.dtdEntityValue(value);
          } else {
            if (!value.pubID && !value.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity");
            }
            if (value.pubID && !value.sysID) {
              throw new Error("System identifier is required for a public external entity");
            }
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
            if (value.nData != null) {
              this.nData = this.stringify.dtdNData(value.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity");
            }
          }
        }
        __name(XMLDTDEntity2, "XMLDTDEntity");
        XMLDTDEntity2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdEntity(this);
        };
        return XMLDTDEntity2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports2, module2) {
    (function() {
      var XMLDTDElement, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDElement = function(superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent, name, value) {
          XMLDTDElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD element name");
          }
          if (!value) {
            value = "(#PCDATA)";
          }
          if (Array.isArray(value)) {
            value = "(" + value.join(",") + ")";
          }
          this.name = this.stringify.eleName(name);
          this.value = this.stringify.dtdElementValue(value);
        }
        __name(XMLDTDElement2, "XMLDTDElement");
        XMLDTDElement2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdElement(this);
        };
        return XMLDTDElement2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports2, module2) {
    (function() {
      var XMLDTDNotation, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDNotation = function(superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent, name, value) {
          XMLDTDNotation2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing notation name");
          }
          if (!value.pubID && !value.sysID) {
            throw new Error("Public or system identifiers are required for an external entity");
          }
          this.name = this.stringify.eleName(name);
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
        }
        __name(XMLDTDNotation2, "XMLDTDNotation");
        XMLDTDNotation2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdNotation(this);
        };
        return XMLDTDNotation2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocType.js"(exports2, module2) {
    (function() {
      var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      module2.exports = XMLDocType = function(superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent, pubID, sysID) {
          var ref, ref1;
          XMLDocType2.__super__.constructor.call(this, parent);
          this.documentObject = parent;
          if (isObject(pubID)) {
            ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
          }
          if (sysID == null) {
            ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        __name(XMLDocType2, "XMLDocType");
        XMLDocType2.prototype.element = function(name, value) {
          var child;
          child = new XMLDTDElement(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, false, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, true, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function(name, value) {
          var child;
          child = new XMLDTDNotation(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function(options) {
          return this.options.writer.set(options).docType(this);
        };
        XMLDocType2.prototype.ele = function(name, value) {
          return this.element(name, value);
        };
        XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocType2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocType2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        XMLDocType2.prototype.up = function() {
          return this.root() || this.documentObject;
        };
        return XMLDocType2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/xmlbuilder/lib/XMLRaw.js"(exports2, module2) {
    (function() {
      var XMLNode, XMLRaw, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLRaw = function(superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent, text) {
          XMLRaw2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing raw text");
          }
          this.value = this.stringify.raw(text);
        }
        __name(XMLRaw2, "XMLRaw");
        XMLRaw2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function(options) {
          return this.options.writer.set(options).raw(this);
        };
        return XMLRaw2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/xmlbuilder/lib/XMLText.js"(exports2, module2) {
    (function() {
      var XMLNode, XMLText, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLText = function(superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent, text) {
          XMLText2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing element text");
          }
          this.value = this.stringify.eleText(text);
        }
        __name(XMLText2, "XMLText");
        XMLText2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function(options) {
          return this.options.writer.set(options).text(this);
        };
        return XMLText2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports2, module2) {
    (function() {
      var XMLNode, XMLProcessingInstruction, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLProcessingInstruction = function(superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent, target, value) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent);
          if (target == null) {
            throw new Error("Missing instruction target");
          }
          this.target = this.stringify.insTarget(target);
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
        __name(XMLProcessingInstruction2, "XMLProcessingInstruction");
        XMLProcessingInstruction2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function(options) {
          return this.options.writer.set(options).processingInstruction(this);
        };
        return XMLProcessingInstruction2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNode.js"(exports2, module2) {
    (function() {
      var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      module2.exports = XMLNode = function() {
        function XMLNode2(parent) {
          this.parent = parent;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.children = [];
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
          }
        }
        __name(XMLNode2, "XMLNode");
        XMLNode2.prototype.element = function(name, attributes, text) {
          var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
          lastChild = null;
          if (attributes == null) {
            attributes = {};
          }
          attributes = attributes.valueOf();
          if (!isObject(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          if (name != null) {
            name = name.valueOf();
          }
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              item = name[j];
              lastChild = this.element(item);
            }
          } else if (isFunction(name)) {
            lastChild = this.element(name.apply());
          } else if (isObject(name)) {
            for (key in name) {
              if (!hasProp.call(name, key))
                continue;
              val = name[key];
              if (isFunction(val)) {
                val = val.apply();
              }
              if (isObject(val) && isEmpty(val)) {
                val = null;
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                for (k = 0, len1 = val.length; k < len1; k++) {
                  item = val[k];
                  childNode = {};
                  childNode[key] = item;
                  lastChild = this.element(childNode);
                }
              } else if (isObject(val)) {
                lastChild = this.element(key);
                lastChild.element(val);
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
            } else {
              lastChild = this.node(name, attributes, text);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name);
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function(name, attributes, text) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level");
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.insertAfter = function(name, attributes, text) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level");
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function() {
          var i, ref1;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element");
          }
          i = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
          return this.parent;
        };
        XMLNode2.prototype.node = function(name, attributes, text) {
          var child, ref1;
          if (name != null) {
            name = name.valueOf();
          }
          attributes || (attributes = {});
          attributes = attributes.valueOf();
          if (!isObject(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          child = new XMLElement(this, name, attributes);
          if (text != null) {
            child.text(text);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function(value) {
          var child;
          child = new XMLText(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function(value) {
          var child;
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function(value) {
          var child;
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function(value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function(value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function(value) {
          var child;
          child = new XMLRaw(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.instruction = function(target, value) {
          var insTarget, insValue, instruction, j, len;
          if (target != null) {
            target = target.valueOf();
          }
          if (value != null) {
            value = value.valueOf();
          }
          if (Array.isArray(target)) {
            for (j = 0, len = target.length; j < len; j++) {
              insTarget = target[j];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function(target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function(target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function(version, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version, encoding, standalone);
          if (doc.children[0] instanceof XMLDeclaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.doctype = function(pubID, sysID) {
          var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref1 = doc.children;
          for (i = j = 0, len = ref1.length; j < len; i = ++j) {
            child = ref1[i];
            if (child instanceof XMLDocType) {
              doc.children[i] = doctype;
              return doctype;
            }
          }
          ref2 = doc.children;
          for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
            child = ref2[i];
            if (child.isRoot) {
              doc.children.splice(i, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function() {
          var node;
          node = this;
          while (node) {
            if (node.isDocument) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function() {
          var node;
          node = this;
          while (node) {
            if (node.isDocument) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function(options) {
          return this.document().end(options);
        };
        XMLNode2.prototype.prev = function() {
          var i;
          i = this.parent.children.indexOf(this);
          if (i < 1) {
            throw new Error("Already at the first node");
          }
          return this.parent.children[i - 1];
        };
        XMLNode2.prototype.next = function() {
          var i;
          i = this.parent.children.indexOf(this);
          if (i === -1 || i === this.parent.children.length - 1) {
            throw new Error("Already at the last node");
          }
          return this.parent.children[i + 1];
        };
        XMLNode2.prototype.importDocument = function(doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.ele = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.doc = function() {
          return this.document();
        };
        XMLNode2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLNode2.prototype.dtd = function(pubID, sysID) {
          return this.doctype(pubID, sysID);
        };
        XMLNode2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLNode2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.u = function() {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function(doc) {
          return this.importDocument(doc);
        };
        return XMLNode2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports2, module2) {
    (function() {
      var XMLStringifier, bind = /* @__PURE__ */ __name(function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, "bind"), hasProp = {}.hasOwnProperty;
      module2.exports = XMLStringifier = function() {
        function XMLStringifier2(options) {
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key, ref, value;
          options || (options = {});
          this.noDoubleEncoding = options.noDoubleEncoding;
          ref = options.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this[key] = value;
          }
        }
        __name(XMLStringifier2, "XMLStringifier");
        XMLStringifier2.prototype.eleName = function(val) {
          val = "" + val || "";
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.eleText = function(val) {
          val = "" + val || "";
          return this.assertLegalChar(this.elEscape(val));
        };
        XMLStringifier2.prototype.cdata = function(val) {
          val = "" + val || "";
          val = val.replace("]]>", "]]]]><![CDATA[>");
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.comment = function(val) {
          val = "" + val || "";
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.raw = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.attName = function(val) {
          return val = "" + val || "";
        };
        XMLStringifier2.prototype.attValue = function(val) {
          val = "" + val || "";
          return this.attEscape(val);
        };
        XMLStringifier2.prototype.insTarget = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.insValue = function(val) {
          val = "" + val || "";
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlVersion = function(val) {
          val = "" + val || "";
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlEncoding = function(val) {
          val = "" + val || "";
          if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error("Invalid encoding: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlStandalone = function(val) {
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier2.prototype.dtdPubID = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdSysID = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdElementValue = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdAttType = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdAttDefault = function(val) {
          if (val != null) {
            return "" + val || "";
          } else {
            return val;
          }
        };
        XMLStringifier2.prototype.dtdEntityValue = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdNData = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        XMLStringifier2.prototype.assertLegalChar = function(str) {
          var res;
          res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
          if (res) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
          return str;
        };
        XMLStringifier2.prototype.elEscape = function(str) {
          var ampregex;
          ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier2.prototype.attEscape = function(str) {
          var ampregex;
          ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports2, module2) {
    (function() {
      var XMLWriterBase, hasProp = {}.hasOwnProperty;
      module2.exports = XMLWriterBase = function() {
        function XMLWriterBase2(options) {
          var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
          options || (options = {});
          this.pretty = options.pretty || false;
          this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
          if (this.pretty) {
            this.indent = (ref1 = options.indent) != null ? ref1 : "  ";
            this.newline = (ref2 = options.newline) != null ? ref2 : "\n";
            this.offset = (ref3 = options.offset) != null ? ref3 : 0;
            this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
          } else {
            this.indent = "";
            this.newline = "";
            this.offset = 0;
            this.dontprettytextnodes = 0;
          }
          this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : "";
          if (this.spacebeforeslash === true) {
            this.spacebeforeslash = " ";
          }
          this.newlinedefault = this.newline;
          this.prettydefault = this.pretty;
          ref6 = options.writer || {};
          for (key in ref6) {
            if (!hasProp.call(ref6, key))
              continue;
            value = ref6[key];
            this[key] = value;
          }
        }
        __name(XMLWriterBase2, "XMLWriterBase");
        XMLWriterBase2.prototype.set = function(options) {
          var key, ref, value;
          options || (options = {});
          if ("pretty" in options) {
            this.pretty = options.pretty;
          }
          if ("allowEmpty" in options) {
            this.allowEmpty = options.allowEmpty;
          }
          if (this.pretty) {
            this.indent = "indent" in options ? options.indent : "  ";
            this.newline = "newline" in options ? options.newline : "\n";
            this.offset = "offset" in options ? options.offset : 0;
            this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
          } else {
            this.indent = "";
            this.newline = "";
            this.offset = 0;
            this.dontprettytextnodes = 0;
          }
          this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : "";
          if (this.spacebeforeslash === true) {
            this.spacebeforeslash = " ";
          }
          this.newlinedefault = this.newline;
          this.prettydefault = this.pretty;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this[key] = value;
          }
          return this;
        };
        XMLWriterBase2.prototype.space = function(level) {
          var indent;
          if (this.pretty) {
            indent = (level || 0) + this.offset + 1;
            if (indent > 0) {
              return new Array(indent).join(this.indent);
            } else {
              return "";
            }
          } else {
            return "";
          }
        };
        return XMLWriterBase2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports2, module2) {
    (function() {
      var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStringWriter = function(superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options) {
          XMLStringWriter2.__super__.constructor.call(this, options);
        }
        __name(XMLStringWriter2, "XMLStringWriter");
        XMLStringWriter2.prototype.document = function(doc) {
          var child, i, len, r, ref;
          this.textispresent = false;
          r = "";
          ref = doc.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            r += function() {
              switch (false) {
                case !(child instanceof XMLDeclaration):
                  return this.declaration(child);
                case !(child instanceof XMLDocType):
                  return this.docType(child);
                case !(child instanceof XMLComment):
                  return this.comment(child);
                case !(child instanceof XMLProcessingInstruction):
                  return this.processingInstruction(child);
                default:
                  return this.element(child, 0);
              }
            }.call(this);
          }
          if (this.pretty && r.slice(-this.newline.length) === this.newline) {
            r = r.slice(0, -this.newline.length);
          }
          return r;
        };
        XMLStringWriter2.prototype.attribute = function(att) {
          return " " + att.name + '="' + att.value + '"';
        };
        XMLStringWriter2.prototype.cdata = function(node, level) {
          return this.space(level) + "<![CDATA[" + node.text + "]]>" + this.newline;
        };
        XMLStringWriter2.prototype.comment = function(node, level) {
          return this.space(level) + "<!-- " + node.text + " -->" + this.newline;
        };
        XMLStringWriter2.prototype.declaration = function(node, level) {
          var r;
          r = this.space(level);
          r += '<?xml version="' + node.version + '"';
          if (node.encoding != null) {
            r += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r += ' standalone="' + node.standalone + '"';
          }
          r += this.spacebeforeslash + "?>";
          r += this.newline;
          return r;
        };
        XMLStringWriter2.prototype.docType = function(node, level) {
          var child, i, len, r, ref;
          level || (level = 0);
          r = this.space(level);
          r += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r += " [";
            r += this.newline;
            ref = node.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              r += function() {
                switch (false) {
                  case !(child instanceof XMLDTDAttList):
                    return this.dtdAttList(child, level + 1);
                  case !(child instanceof XMLDTDElement):
                    return this.dtdElement(child, level + 1);
                  case !(child instanceof XMLDTDEntity):
                    return this.dtdEntity(child, level + 1);
                  case !(child instanceof XMLDTDNotation):
                    return this.dtdNotation(child, level + 1);
                  case !(child instanceof XMLCData):
                    return this.cdata(child, level + 1);
                  case !(child instanceof XMLComment):
                    return this.comment(child, level + 1);
                  case !(child instanceof XMLProcessingInstruction):
                    return this.processingInstruction(child, level + 1);
                  default:
                    throw new Error("Unknown DTD node type: " + child.constructor.name);
                }
              }.call(this);
            }
            r += "]";
          }
          r += this.spacebeforeslash + ">";
          r += this.newline;
          return r;
        };
        XMLStringWriter2.prototype.element = function(node, level) {
          var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
          level || (level = 0);
          textispresentwasset = false;
          if (this.textispresent) {
            this.newline = "";
            this.pretty = false;
          } else {
            this.newline = this.newlinedefault;
            this.pretty = this.prettydefault;
          }
          space = this.space(level);
          r = "";
          r += space + "<" + node.name;
          ref = node.attributes;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            r += this.attribute(att);
          }
          if (node.children.length === 0 || node.children.every(function(e) {
            return e.value === "";
          })) {
            if (this.allowEmpty) {
              r += "></" + node.name + ">" + this.newline;
            } else {
              r += this.spacebeforeslash + "/>" + this.newline;
            }
          } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
            r += ">";
            r += node.children[0].value;
            r += "</" + node.name + ">" + this.newline;
          } else {
            if (this.dontprettytextnodes) {
              ref1 = node.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                if (child.value != null) {
                  this.textispresent++;
                  textispresentwasset = true;
                  break;
                }
              }
            }
            if (this.textispresent) {
              this.newline = "";
              this.pretty = false;
              space = this.space(level);
            }
            r += ">" + this.newline;
            ref2 = node.children;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              r += function() {
                switch (false) {
                  case !(child instanceof XMLCData):
                    return this.cdata(child, level + 1);
                  case !(child instanceof XMLComment):
                    return this.comment(child, level + 1);
                  case !(child instanceof XMLElement):
                    return this.element(child, level + 1);
                  case !(child instanceof XMLRaw):
                    return this.raw(child, level + 1);
                  case !(child instanceof XMLText):
                    return this.text(child, level + 1);
                  case !(child instanceof XMLProcessingInstruction):
                    return this.processingInstruction(child, level + 1);
                  default:
                    throw new Error("Unknown XML node type: " + child.constructor.name);
                }
              }.call(this);
            }
            if (textispresentwasset) {
              this.textispresent--;
            }
            if (!this.textispresent) {
              this.newline = this.newlinedefault;
              this.pretty = this.prettydefault;
            }
            r += space + "</" + node.name + ">" + this.newline;
          }
          return r;
        };
        XMLStringWriter2.prototype.processingInstruction = function(node, level) {
          var r;
          r = this.space(level) + "<?" + node.target;
          if (node.value) {
            r += " " + node.value;
          }
          r += this.spacebeforeslash + "?>" + this.newline;
          return r;
        };
        XMLStringWriter2.prototype.raw = function(node, level) {
          return this.space(level) + node.value + this.newline;
        };
        XMLStringWriter2.prototype.text = function(node, level) {
          return this.space(level) + node.value + this.newline;
        };
        XMLStringWriter2.prototype.dtdAttList = function(node, level) {
          var r;
          r = this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r += ' "' + node.defaultValue + '"';
          }
          r += this.spacebeforeslash + ">" + this.newline;
          return r;
        };
        XMLStringWriter2.prototype.dtdElement = function(node, level) {
          return this.space(level) + "<!ELEMENT " + node.name + " " + node.value + this.spacebeforeslash + ">" + this.newline;
        };
        XMLStringWriter2.prototype.dtdEntity = function(node, level) {
          var r;
          r = this.space(level) + "<!ENTITY";
          if (node.pe) {
            r += " %";
          }
          r += " " + node.name;
          if (node.value) {
            r += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r += " NDATA " + node.nData;
            }
          }
          r += this.spacebeforeslash + ">" + this.newline;
          return r;
        };
        XMLStringWriter2.prototype.dtdNotation = function(node, level) {
          var r;
          r = this.space(level) + "<!NOTATION " + node.name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          r += this.spacebeforeslash + ">" + this.newline;
          return r;
        };
        XMLStringWriter2.prototype.openNode = function(node, level) {
          var att, name, r, ref;
          level || (level = 0);
          if (node instanceof XMLElement) {
            r = this.space(level) + "<" + node.name;
            ref = node.attributes;
            for (name in ref) {
              if (!hasProp.call(ref, name))
                continue;
              att = ref[name];
              r += this.attribute(att);
            }
            r += (node.children ? ">" : "/>") + this.newline;
            return r;
          } else {
            r = this.space(level) + "<!DOCTYPE " + node.rootNodeName;
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            r += (node.children ? " [" : ">") + this.newline;
            return r;
          }
        };
        XMLStringWriter2.prototype.closeNode = function(node, level) {
          level || (level = 0);
          switch (false) {
            case !(node instanceof XMLElement):
              return this.space(level) + "</" + node.name + ">" + this.newline;
            case !(node instanceof XMLDocType):
              return this.space(level) + "]>" + this.newline;
          }
        };
        return XMLStringWriter2;
      }(XMLWriterBase);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocument.js"(exports2, module2) {
    (function() {
      var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLNode = require_XMLNode();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocument = function(superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options) {
          XMLDocument2.__super__.constructor.call(this, null);
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
          this.isDocument = true;
        }
        __name(XMLDocument2, "XMLDocument");
        XMLDocument2.prototype.end = function(writer) {
          var writerOptions;
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer.set(writerOptions);
          }
          return writer.document(this);
        };
        XMLDocument2.prototype.toString = function(options) {
          return this.options.writer.set(options).document(this);
        };
        return XMLDocument2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports2, module2) {
    (function() {
      var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocumentCB = function() {
        function XMLDocumentCB2(options, onData, onEnd) {
          var writerOptions;
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter(options);
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter(writerOptions);
          }
          this.options = options;
          this.writer = options.writer;
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        __name(XMLDocumentCB2, "XMLDocumentCB");
        XMLDocumentCB2.prototype.node = function(name, attributes, text) {
          var ref1;
          if (name == null) {
            throw new Error("Missing node name");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node");
          }
          this.openCurrent();
          name = name.valueOf();
          if (attributes == null) {
            attributes = {};
          }
          attributes = attributes.valueOf();
          if (!isObject(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          this.currentNode = new XMLElement(this, name, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function(name, attributes, text) {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.dtdElement.apply(this, arguments);
          } else {
            return this.node(name, attributes, text);
          }
        };
        XMLDocumentCB2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode");
          }
          if (name != null) {
            name = name.valueOf();
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (!this.options.skipNullAttributes || value != null) {
              this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function(value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(this.writer.text(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function(value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(this.writer.cdata(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.comment = function(value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(this.writer.comment(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.raw = function(value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(this.writer.raw(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function(target, value) {
          var i, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = target.valueOf();
          }
          if (value != null) {
            value = value.valueOf();
          }
          if (Array.isArray(target)) {
            for (i = 0, len = target.length; i < len; i++) {
              insTarget = target[i];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node");
          }
          node = new XMLDeclaration(this, version, encoding, standalone);
          this.onData(this.writer.declaration(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
          this.openCurrent();
          if (root == null) {
            throw new Error("Missing root node name");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value);
          this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.entity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value);
          this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value);
          this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.notation = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value);
          this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
          return this;
        };
        XMLDocumentCB2.prototype.up = function() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function(node) {
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
              this.root = node;
            }
            this.onData(this.writer.openNode(node, this.currentLevel));
            return node.isOpen = true;
          }
        };
        XMLDocumentCB2.prototype.closeNode = function(node) {
          if (!node.isClosed) {
            this.onData(this.writer.closeNode(node, this.currentLevel));
            return node.isClosed = true;
          }
        };
        XMLDocumentCB2.prototype.onData = function(chunk) {
          this.documentStarted = true;
          return this.onDataCallback(chunk);
        };
        XMLDocumentCB2.prototype.onEnd = function() {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.ele = function() {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
          return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLDocumentCB2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLDocumentCB2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.att = function() {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function() {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocumentCB2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocumentCB2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        return XMLDocumentCB2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports2, module2) {
    (function() {
      var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStreamWriter = function(superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream, options) {
          XMLStreamWriter2.__super__.constructor.call(this, options);
          this.stream = stream;
        }
        __name(XMLStreamWriter2, "XMLStreamWriter");
        XMLStreamWriter2.prototype.document = function(doc) {
          var child, i, j, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            child.isLastRootNode = false;
          }
          doc.children[doc.children.length - 1].isLastRootNode = true;
          ref1 = doc.children;
          results = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            child = ref1[j];
            switch (false) {
              case !(child instanceof XMLDeclaration):
                results.push(this.declaration(child));
                break;
              case !(child instanceof XMLDocType):
                results.push(this.docType(child));
                break;
              case !(child instanceof XMLComment):
                results.push(this.comment(child));
                break;
              case !(child instanceof XMLProcessingInstruction):
                results.push(this.processingInstruction(child));
                break;
              default:
                results.push(this.element(child));
            }
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function(att) {
          return this.stream.write(" " + att.name + '="' + att.value + '"');
        };
        XMLStreamWriter2.prototype.cdata = function(node, level) {
          return this.stream.write(this.space(level) + "<![CDATA[" + node.text + "]]>" + this.endline(node));
        };
        XMLStreamWriter2.prototype.comment = function(node, level) {
          return this.stream.write(this.space(level) + "<!-- " + node.text + " -->" + this.endline(node));
        };
        XMLStreamWriter2.prototype.declaration = function(node, level) {
          this.stream.write(this.space(level));
          this.stream.write('<?xml version="' + node.version + '"');
          if (node.encoding != null) {
            this.stream.write(' encoding="' + node.encoding + '"');
          }
          if (node.standalone != null) {
            this.stream.write(' standalone="' + node.standalone + '"');
          }
          this.stream.write(this.spacebeforeslash + "?>");
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.docType = function(node, level) {
          var child, i, len, ref;
          level || (level = 0);
          this.stream.write(this.space(level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node));
            ref = node.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              switch (false) {
                case !(child instanceof XMLDTDAttList):
                  this.dtdAttList(child, level + 1);
                  break;
                case !(child instanceof XMLDTDElement):
                  this.dtdElement(child, level + 1);
                  break;
                case !(child instanceof XMLDTDEntity):
                  this.dtdEntity(child, level + 1);
                  break;
                case !(child instanceof XMLDTDNotation):
                  this.dtdNotation(child, level + 1);
                  break;
                case !(child instanceof XMLCData):
                  this.cdata(child, level + 1);
                  break;
                case !(child instanceof XMLComment):
                  this.comment(child, level + 1);
                  break;
                case !(child instanceof XMLProcessingInstruction):
                  this.processingInstruction(child, level + 1);
                  break;
                default:
                  throw new Error("Unknown DTD node type: " + child.constructor.name);
              }
            }
            this.stream.write("]");
          }
          this.stream.write(this.spacebeforeslash + ">");
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.element = function(node, level) {
          var att, child, i, len, name, ref, ref1, space;
          level || (level = 0);
          space = this.space(level);
          this.stream.write(space + "<" + node.name);
          ref = node.attributes;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            this.attribute(att);
          }
          if (node.children.length === 0 || node.children.every(function(e) {
            return e.value === "";
          })) {
            if (this.allowEmpty) {
              this.stream.write("></" + node.name + ">");
            } else {
              this.stream.write(this.spacebeforeslash + "/>");
            }
          } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
            this.stream.write(">");
            this.stream.write(node.children[0].value);
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.newline);
            ref1 = node.children;
            for (i = 0, len = ref1.length; i < len; i++) {
              child = ref1[i];
              switch (false) {
                case !(child instanceof XMLCData):
                  this.cdata(child, level + 1);
                  break;
                case !(child instanceof XMLComment):
                  this.comment(child, level + 1);
                  break;
                case !(child instanceof XMLElement):
                  this.element(child, level + 1);
                  break;
                case !(child instanceof XMLRaw):
                  this.raw(child, level + 1);
                  break;
                case !(child instanceof XMLText):
                  this.text(child, level + 1);
                  break;
                case !(child instanceof XMLProcessingInstruction):
                  this.processingInstruction(child, level + 1);
                  break;
                default:
                  throw new Error("Unknown XML node type: " + child.constructor.name);
              }
            }
            this.stream.write(space + "</" + node.name + ">");
          }
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.processingInstruction = function(node, level) {
          this.stream.write(this.space(level) + "<?" + node.target);
          if (node.value) {
            this.stream.write(" " + node.value);
          }
          return this.stream.write(this.spacebeforeslash + "?>" + this.endline(node));
        };
        XMLStreamWriter2.prototype.raw = function(node, level) {
          return this.stream.write(this.space(level) + node.value + this.endline(node));
        };
        XMLStreamWriter2.prototype.text = function(node, level) {
          return this.stream.write(this.space(level) + node.value + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdAttList = function(node, level) {
          this.stream.write(this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType);
          if (node.defaultValueType !== "#DEFAULT") {
            this.stream.write(" " + node.defaultValueType);
          }
          if (node.defaultValue) {
            this.stream.write(' "' + node.defaultValue + '"');
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdElement = function(node, level) {
          this.stream.write(this.space(level) + "<!ELEMENT " + node.name + " " + node.value);
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdEntity = function(node, level) {
          this.stream.write(this.space(level) + "<!ENTITY");
          if (node.pe) {
            this.stream.write(" %");
          }
          this.stream.write(" " + node.name);
          if (node.value) {
            this.stream.write(' "' + node.value + '"');
          } else {
            if (node.pubID && node.sysID) {
              this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
            } else if (node.sysID) {
              this.stream.write(' SYSTEM "' + node.sysID + '"');
            }
            if (node.nData) {
              this.stream.write(" NDATA " + node.nData);
            }
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdNotation = function(node, level) {
          this.stream.write(this.space(level) + "<!NOTATION " + node.name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.pubID) {
            this.stream.write(' PUBLIC "' + node.pubID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.endline = function(node) {
          if (!node.isLastRootNode) {
            return this.newline;
          } else {
            return "";
          }
        };
        return XMLStreamWriter2;
      }(XMLWriterBase);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/index.js
var require_lib = __commonJS({
  "node_modules/xmlbuilder/lib/index.js"(exports2, module2) {
    (function() {
      var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
      ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      module2.exports.create = function(name, xmldec, doctype, options) {
        var doc, root;
        if (name == null) {
          throw new Error("Root element needs a name");
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.doctype(options);
          }
        }
        return root;
      };
      module2.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
          ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module2.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
      };
      module2.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
      };
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/builder.js
var require_builder3 = __commonJS({
  "node_modules/xml2js/lib/builder.js"(exports2) {
    (function() {
      "use strict";
      var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
      builder = require_lib();
      defaults = require_defaults().defaults;
      requiresCDATA = /* @__PURE__ */ __name(function(entry) {
        return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
      }, "requiresCDATA");
      wrapCDATA = /* @__PURE__ */ __name(function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
      }, "wrapCDATA");
      escapeCDATA = /* @__PURE__ */ __name(function(entry) {
        return entry.replace("]]>", "]]]]><![CDATA[>");
      }, "escapeCDATA");
      exports2.Builder = function() {
        function Builder(opts) {
          var key, ref, value;
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value = opts[key];
            this.options[key] = value;
          }
        }
        __name(Builder, "Builder");
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey, charkey, render, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render = function(_this) {
            return function(element, obj) {
              var attr, child, entry, index, key, value;
              if (typeof obj !== "object") {
                if (_this.options.cdata && requiresCDATA(obj)) {
                  element.raw(wrapCDATA(obj));
                } else {
                  element.txt(obj);
                }
              } else if (Array.isArray(obj)) {
                for (index in obj) {
                  if (!hasProp.call(obj, index))
                    continue;
                  child = obj[index];
                  for (key in child) {
                    entry = child[key];
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else {
                for (key in obj) {
                  if (!hasProp.call(obj, key))
                    continue;
                  child = obj[key];
                  if (key === attrkey) {
                    if (typeof child === "object") {
                      for (attr in child) {
                        value = child[attr];
                        element = element.att(attr, value);
                      }
                    }
                  } else if (key === charkey) {
                    if (_this.options.cdata && requiresCDATA(child)) {
                      element = element.raw(wrapCDATA(child));
                    } else {
                      element = element.txt(child);
                    }
                  } else if (Array.isArray(child)) {
                    for (index in child) {
                      if (!hasProp.call(child, index))
                        continue;
                      entry = child[index];
                      if (typeof entry === "string") {
                        if (_this.options.cdata && requiresCDATA(entry)) {
                          element = element.ele(key).raw(wrapCDATA(entry)).up();
                        } else {
                          element = element.ele(key, entry).up();
                        }
                      } else {
                        element = render(element.ele(key), entry).up();
                      }
                    }
                  } else if (typeof child === "object") {
                    element = render(element.ele(key), child).up();
                  } else {
                    if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                      element = element.ele(key).raw(wrapCDATA(child)).up();
                    } else {
                      if (child == null) {
                        child = "";
                      }
                      element = element.ele(key, child.toString()).up();
                    }
                  }
                }
              }
              return element;
            };
          }(this);
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars
          });
          return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
      }();
    }).call(exports2);
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports2) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      __name(SAXParser, "SAXParser");
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          __name(F, "F");
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      __name(checkBufferLength, "checkBufferLength");
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      __name(clearBuffers, "clearBuffers");
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      __name(flushBuffers, "flushBuffers");
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = __require("stream").Stream;
      } catch (ex) {
        Stream = /* @__PURE__ */ __name(function() {
        }, "Stream");
      }
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      __name(createStream, "createStream");
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      __name(SAXStream, "SAXStream");
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = __require("string_decoder").StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler2) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler2);
      };
      var whitespace = "\r\n	 ";
      var number = "0124356789";
      var letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
      var quote = `'"`;
      var attribEnd = whitespace + ">";
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      whitespace = charClass(whitespace);
      number = charClass(number);
      letter = charClass(letter);
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
      quote = charClass(quote);
      attribEnd = charClass(attribEnd);
      function charClass(str) {
        return str.split("").reduce(function(s2, c) {
          s2[c] = true;
          return s2;
        }, {});
      }
      __name(charClass, "charClass");
      function isRegExp(c) {
        return Object.prototype.toString.call(c) === "[object RegExp]";
      }
      __name(isRegExp, "isRegExp");
      function is(charclass, c) {
        return isRegExp(charclass) ? !!c.match(charclass) : charclass[c];
      }
      __name(is, "is");
      function not(charclass, c) {
        return !is(charclass, c);
      }
      __name(not, "not");
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      __name(emit, "emit");
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data);
      }
      __name(emitNode, "emitNode");
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      __name(closeText, "closeText");
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      __name(textopts, "textopts");
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      __name(error, "error");
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      __name(end, "end");
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      __name(strictFail, "strictFail");
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      __name(newTag, "newTag");
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      __name(qname, "qname");
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      __name(attrib, "attrib");
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      __name(openTag, "openTag");
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      __name(closeTag, "closeTag");
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      __name(parseEntity, "parseEntity");
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (not(whitespace, c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      __name(beginWhiteSpace, "beginWhiteSpace");
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      __name(charAt, "charAt");
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (is(whitespace, c)) {
              } else if (is(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (is(quote, c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (is(quote, c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (is(quote, c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (is(whitespace, c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && is(whitespace, c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (is(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (not(whitespace, c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (is(whitespace, c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (is(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (is(whitespace, c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (is(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (is(whitespace, c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (is(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (is(whitespace, c)) {
                continue;
              } else if (is(quote, c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (is(whitespace, c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (is(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (not(attribEnd, c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (is(whitespace, c)) {
                  continue;
                } else if (not(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (is(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (not(whitespace, c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (is(whitespace, c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      __name(write, "write");
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = /* @__PURE__ */ __name(function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          }, "fromCodePoint");
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports2 === "undefined" ? exports2.sax = {} : exports2);
  }
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS({
  "node_modules/xml2js/lib/bom.js"(exports2) {
    (function() {
      "use strict";
      exports2.stripBOM = function(str) {
        if (str[0] === "\uFEFF") {
          return str.substring(1);
        } else {
          return str;
        }
      };
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS({
  "node_modules/xml2js/lib/processors.js"(exports2) {
    (function() {
      "use strict";
      var prefixMatch;
      prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      exports2.normalize = function(str) {
        return str.toLowerCase();
      };
      exports2.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
      };
      exports2.stripPrefix = function(str) {
        return str.replace(prefixMatch, "");
      };
      exports2.parseNumbers = function(str) {
        if (!isNaN(str)) {
          str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
      };
      exports2.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
          str = str.toLowerCase() === "true";
        }
        return str;
      };
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/parser.js
var require_parser3 = __commonJS({
  "node_modules/xml2js/lib/parser.js"(exports2) {
    (function() {
      "use strict";
      var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate2, bind = /* @__PURE__ */ __name(function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, "bind"), extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      sax = require_sax();
      events = __require("events");
      bom = require_bom();
      processors = require_processors();
      setImmediate2 = __require("timers").setImmediate;
      defaults = require_defaults().defaults;
      isEmpty = /* @__PURE__ */ __name(function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
      }, "isEmpty");
      processItem = /* @__PURE__ */ __name(function(processors2, item, key) {
        var i, len, process2;
        for (i = 0, len = processors2.length; i < len; i++) {
          process2 = processors2[i];
          item = process2(item, key);
        }
        return item;
      }, "processItem");
      exports2.Parser = function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
          this.parseString = bind(this.parseString, this);
          this.reset = bind(this.reset, this);
          this.assignOrPush = bind(this.assignOrPush, this);
          this.processAsync = bind(this.processAsync, this);
          var key, ref, value;
          if (!(this instanceof exports2.Parser)) {
            return new exports2.Parser(opts);
          }
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value = opts[key];
            this.options[key] = value;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
        __name(Parser, "Parser");
        Parser.prototype.processAsync = function() {
          var chunk, err;
          try {
            if (this.remaining.length <= this.options.chunkSize) {
              chunk = this.remaining;
              this.remaining = "";
              this.saxParser = this.saxParser.write(chunk);
              return this.saxParser.close();
            } else {
              chunk = this.remaining.substr(0, this.options.chunkSize);
              this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
              this.saxParser = this.saxParser.write(chunk);
              return setImmediate2(this.processAsync);
            }
          } catch (error1) {
            err = error1;
            if (!this.saxParser.errThrown) {
              this.saxParser.errThrown = true;
              return this.emit(err);
            }
          }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return obj[key] = newValue;
            } else {
              return obj[key] = [newValue];
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
        Parser.prototype.reset = function() {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = function(_this) {
            return function(error) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error);
              }
            };
          }(this);
          this.saxParser.onend = function(_this) {
            return function() {
              if (!_this.saxParser.ended) {
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = function(_this) {
            return function(node) {
              var key, newValue, obj, processedKey, ref;
              obj = {};
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                ref = node.attributes;
                for (key in ref) {
                  if (!hasProp.call(ref, key))
                    continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = {};
                  }
                  newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          }(this);
          this.saxParser.onclosetag = function(_this) {
            return function() {
              var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                delete obj["#name"];
              }
              if (obj.cdata === true) {
                cdata = obj.cdata;
                delete obj.cdata;
              }
              s = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
              }
              if (_this.options.validator != null) {
                xpath = "/" + function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = stack.length; i < len; i++) {
                    node = stack[i];
                    results.push(node["#name"]);
                  }
                  return results;
                }().concat(nodeName).join("/");
                (function() {
                  var err;
                  try {
                    return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                  } catch (error1) {
                    err = error1;
                    return _this.emit("error", err);
                  }
                })();
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                if (!_this.options.preserveChildrenOrder) {
                  node = {};
                  if (_this.options.attrkey in obj) {
                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                    delete obj[_this.options.attrkey];
                  }
                  if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                    node[_this.options.charkey] = obj[_this.options.charkey];
                    delete obj[_this.options.charkey];
                  }
                  if (Object.getOwnPropertyNames(obj).length > 0) {
                    node[_this.options.childkey] = obj;
                  }
                  obj = node;
                } else if (s) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  objClone = {};
                  for (key in obj) {
                    if (!hasProp.call(obj, key))
                      continue;
                    objClone[key] = obj[key];
                  }
                  s[_this.options.childkey].push(objClone);
                  delete obj["#name"];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = {};
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          ontext = function(_this) {
            return function(text) {
              var charChild, s;
              s = stack[stack.length - 1];
              if (s) {
                s[charkey] += text;
                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  charChild = {
                    "#name": "__text__"
                  };
                  charChild[charkey] = text;
                  if (_this.options.normalize) {
                    charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  s[_this.options.childkey].push(charChild);
                }
                return s;
              }
            };
          }(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = function(_this) {
            return function(text) {
              var s;
              s = ontext(text);
              if (s) {
                return s.cdata = true;
              }
            };
          }(this);
        };
        Parser.prototype.parseString = function(str, cb) {
          var err;
          if (cb != null && typeof cb === "function") {
            this.on("end", function(result) {
              this.reset();
              return cb(null, result);
            });
            this.on("error", function(err2) {
              this.reset();
              return cb(err2);
            });
          }
          try {
            str = str.toString();
            if (str.trim() === "") {
              this.emit("end", null);
              return true;
            }
            str = bom.stripBOM(str);
            if (this.options.async) {
              this.remaining = str;
              setImmediate2(this.processAsync);
              return this.saxParser;
            }
            return this.saxParser.write(str).close();
          } catch (error1) {
            err = error1;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit("error", err);
              return this.saxParser.errThrown = true;
            } else if (this.saxParser.ended) {
              throw err;
            }
          }
        };
        return Parser;
      }(events.EventEmitter);
      exports2.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
          if (typeof b === "function") {
            cb = b;
          }
          if (typeof a === "object") {
            options = a;
          }
        } else {
          if (typeof a === "function") {
            cb = a;
          }
          options = {};
        }
        parser = new exports2.Parser(options);
        return parser.parseString(str, cb);
      };
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml2js/lib/xml2js.js"(exports2) {
    (function() {
      "use strict";
      var builder, defaults, parser, processors, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      defaults = require_defaults();
      builder = require_builder3();
      parser = require_parser3();
      processors = require_processors();
      exports2.defaults = defaults.defaults;
      exports2.processors = processors;
      exports2.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
          this.message = message;
        }
        __name(ValidationError, "ValidationError");
        return ValidationError;
      }(Error);
      exports2.Builder = builder.Builder;
      exports2.Parser = parser.Parser;
      exports2.parseString = parser.parseString;
    }).call(exports2);
  }
});

// node_modules/aws-sdk/lib/xml/node_parser.js
var require_node_parser = __commonJS({
  "node_modules/aws-sdk/lib/xml/node_parser.js"(exports2, module2) {
    var AWS2 = require_core();
    var util = AWS2.util;
    var Shape = AWS2.Model.Shape;
    var xml2js = require_xml2js();
    var options = {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      explicitRoot: false,
      emptyTag: null,
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      validator: null
    };
    function NodeXmlParser() {
    }
    __name(NodeXmlParser, "NodeXmlParser");
    NodeXmlParser.prototype.parse = function(xml, shape) {
      shape = shape || {};
      var result = null;
      var error = null;
      var parser = new xml2js.Parser(options);
      parser.parseString(xml, function(e, r) {
        error = e;
        result = r;
      });
      if (result) {
        var data = parseXml(result, shape);
        if (result.ResponseMetadata) {
          data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});
        }
        return data;
      } else if (error) {
        throw util.error(error, { code: "XMLParserError", retryable: true });
      } else {
        return parseXml({}, shape);
      }
    };
    function parseXml(xml, shape) {
      switch (shape.type) {
        case "structure":
          return parseStructure(xml, shape);
        case "map":
          return parseMap(xml, shape);
        case "list":
          return parseList(xml, shape);
        case void 0:
        case null:
          return parseUnknown(xml);
        default:
          return parseScalar(xml, shape);
      }
    }
    __name(parseXml, "parseXml");
    function parseStructure(xml, shape) {
      var data = {};
      if (xml === null)
        return data;
      util.each(shape.members, function(memberName, memberShape) {
        var xmlName = memberShape.name;
        if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {
          var xmlChild = xml[xmlName];
          if (!memberShape.flattened)
            xmlChild = xmlChild[0];
          data[memberName] = parseXml(xmlChild, memberShape);
        } else if (memberShape.isXmlAttribute && xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {
          data[memberName] = parseScalar(xml.$[xmlName], memberShape);
        } else if (memberShape.type === "list" && !shape.api.xmlNoDefaultLists) {
          data[memberName] = memberShape.defaultValue;
        }
      });
      return data;
    }
    __name(parseStructure, "parseStructure");
    function parseMap(xml, shape) {
      var data = {};
      if (xml === null)
        return data;
      var xmlKey = shape.key.name || "key";
      var xmlValue = shape.value.name || "value";
      var iterable = shape.flattened ? xml : xml.entry;
      if (Array.isArray(iterable)) {
        util.arrayEach(iterable, function(child) {
          data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);
        });
      }
      return data;
    }
    __name(parseMap, "parseMap");
    function parseList(xml, shape) {
      var data = [];
      var name = shape.member.name || "member";
      if (shape.flattened) {
        util.arrayEach(xml, function(xmlChild) {
          data.push(parseXml(xmlChild, shape.member));
        });
      } else if (xml && Array.isArray(xml[name])) {
        util.arrayEach(xml[name], function(child) {
          data.push(parseXml(child, shape.member));
        });
      }
      return data;
    }
    __name(parseList, "parseList");
    function parseScalar(text, shape) {
      if (text && text.$ && text.$.encoding === "base64") {
        shape = new Shape.create({ type: text.$.encoding });
      }
      if (text && text._)
        text = text._;
      if (typeof shape.toType === "function") {
        return shape.toType(text);
      } else {
        return text;
      }
    }
    __name(parseScalar, "parseScalar");
    function parseUnknown(xml) {
      if (xml === void 0 || xml === null)
        return "";
      if (typeof xml === "string")
        return xml;
      if (Array.isArray(xml)) {
        var arr = [];
        for (i = 0; i < xml.length; i++) {
          arr.push(parseXml(xml[i], {}));
        }
        return arr;
      }
      var keys = Object.keys(xml), i;
      if (keys.length === 0 || keys.length === 1 && keys[0] === "$") {
        return {};
      }
      var data = {};
      for (i = 0; i < keys.length; i++) {
        var key = keys[i], value = xml[key];
        if (key === "$")
          continue;
        if (value.length > 1) {
          data[key] = parseList(value, { member: {} });
        } else {
          data[key] = parseXml(value[0], {});
        }
      }
      return data;
    }
    __name(parseUnknown, "parseUnknown");
    module2.exports = NodeXmlParser;
  }
});

// node_modules/aws-sdk/lib/http/node.js
var require_node = __commonJS({
  "node_modules/aws-sdk/lib/http/node.js"() {
    var AWS2 = require_core();
    var Stream = AWS2.util.stream.Stream;
    var TransformStream = AWS2.util.stream.Transform;
    var ReadableStream = AWS2.util.stream.Readable;
    require_http3();
    var CONNECTION_REUSE_ENV_NAME = "AWS_NODEJS_CONNECTION_REUSE_ENABLED";
    AWS2.NodeHttpClient = AWS2.util.inherit({
      handleRequest: /* @__PURE__ */ __name(function handleRequest(httpRequest, httpOptions, callback, errCallback) {
        var self2 = this;
        var endpoint = httpRequest.endpoint;
        var pathPrefix = "";
        if (!httpOptions)
          httpOptions = {};
        if (httpOptions.proxy) {
          pathPrefix = endpoint.protocol + "//" + endpoint.hostname;
          if (endpoint.port !== 80 && endpoint.port !== 443) {
            pathPrefix += ":" + endpoint.port;
          }
          endpoint = new AWS2.Endpoint(httpOptions.proxy);
        }
        var useSSL = endpoint.protocol === "https:";
        var http = useSSL ? __require("https") : __require("http");
        var options = {
          host: endpoint.hostname,
          port: endpoint.port,
          method: httpRequest.method,
          headers: httpRequest.headers,
          path: pathPrefix + httpRequest.path
        };
        if (!httpOptions.agent) {
          options.agent = this.getAgent(useSSL, {
            keepAlive: process.env[CONNECTION_REUSE_ENV_NAME] === "1" ? true : false
          });
        }
        AWS2.util.update(options, httpOptions);
        delete options.proxy;
        delete options.timeout;
        var stream = http.request(options, function(httpResp) {
          if (stream.didCallback)
            return;
          callback(httpResp);
          httpResp.emit(
            "headers",
            httpResp.statusCode,
            httpResp.headers,
            httpResp.statusMessage
          );
        });
        httpRequest.stream = stream;
        stream.didCallback = false;
        if (httpOptions.connectTimeout) {
          var connectTimeoutId;
          stream.on("socket", function(socket) {
            if (socket.connecting) {
              connectTimeoutId = setTimeout(/* @__PURE__ */ __name(function connectTimeout() {
                if (stream.didCallback)
                  return;
                stream.didCallback = true;
                stream.abort();
                errCallback(AWS2.util.error(
                  new Error("Socket timed out without establishing a connection"),
                  { code: "TimeoutError" }
                ));
              }, "connectTimeout"), httpOptions.connectTimeout);
              socket.on("connect", function() {
                clearTimeout(connectTimeoutId);
                connectTimeoutId = null;
              });
            }
          });
        }
        stream.setTimeout(httpOptions.timeout || 0, function() {
          if (stream.didCallback)
            return;
          stream.didCallback = true;
          var msg = "Connection timed out after " + httpOptions.timeout + "ms";
          errCallback(AWS2.util.error(new Error(msg), { code: "TimeoutError" }));
          stream.abort();
        });
        stream.on("error", function(err) {
          if (connectTimeoutId) {
            clearTimeout(connectTimeoutId);
            connectTimeoutId = null;
          }
          if (stream.didCallback)
            return;
          stream.didCallback = true;
          if ("ECONNRESET" === err.code || "EPIPE" === err.code || "ETIMEDOUT" === err.code) {
            errCallback(AWS2.util.error(err, { code: "TimeoutError" }));
          } else {
            errCallback(err);
          }
        });
        var expect = httpRequest.headers.Expect || httpRequest.headers.expect;
        if (expect === "100-continue") {
          stream.once("continue", function() {
            self2.writeBody(stream, httpRequest);
          });
        } else {
          this.writeBody(stream, httpRequest);
        }
        return stream;
      }, "handleRequest"),
      writeBody: /* @__PURE__ */ __name(function writeBody(stream, httpRequest) {
        var body = httpRequest.body;
        var totalBytes = parseInt(httpRequest.headers["Content-Length"], 10);
        if (body instanceof Stream) {
          var progressStream = this.progressStream(stream, totalBytes);
          if (progressStream) {
            body.pipe(progressStream).pipe(stream);
          } else {
            body.pipe(stream);
          }
        } else if (body) {
          stream.once("finish", function() {
            stream.emit("sendProgress", {
              loaded: totalBytes,
              total: totalBytes
            });
          });
          stream.end(body);
        } else {
          stream.end();
        }
      }, "writeBody"),
      getAgent: /* @__PURE__ */ __name(function getAgent(useSSL, agentOptions) {
        var http = useSSL ? __require("https") : __require("http");
        if (useSSL) {
          if (!AWS2.NodeHttpClient.sslAgent) {
            AWS2.NodeHttpClient.sslAgent = new http.Agent(AWS2.util.merge({
              rejectUnauthorized: process.env.NODE_TLS_REJECT_UNAUTHORIZED === "0" ? false : true
            }, agentOptions || {}));
            AWS2.NodeHttpClient.sslAgent.setMaxListeners(0);
            Object.defineProperty(AWS2.NodeHttpClient.sslAgent, "maxSockets", {
              enumerable: true,
              get: function() {
                var defaultMaxSockets = 50;
                var globalAgent = http.globalAgent;
                if (globalAgent && globalAgent.maxSockets !== Infinity && typeof globalAgent.maxSockets === "number") {
                  return globalAgent.maxSockets;
                }
                return defaultMaxSockets;
              }
            });
          }
          return AWS2.NodeHttpClient.sslAgent;
        } else {
          if (!AWS2.NodeHttpClient.agent) {
            AWS2.NodeHttpClient.agent = new http.Agent(agentOptions);
          }
          return AWS2.NodeHttpClient.agent;
        }
      }, "getAgent"),
      progressStream: /* @__PURE__ */ __name(function progressStream(stream, totalBytes) {
        if (typeof TransformStream === "undefined") {
          return;
        }
        var loadedBytes = 0;
        var reporter = new TransformStream();
        reporter._transform = function(chunk, encoding, callback) {
          if (chunk) {
            loadedBytes += chunk.length;
            stream.emit("sendProgress", {
              loaded: loadedBytes,
              total: totalBytes
            });
          }
          callback(null, chunk);
        };
        return reporter;
      }, "progressStream"),
      emitter: null
    });
    AWS2.HttpClient.prototype = AWS2.NodeHttpClient.prototype;
    AWS2.HttpClient.streamsApiVersion = ReadableStream ? 2 : 1;
  }
});

// node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js
var require_token_file_web_identity_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/token_file_web_identity_credentials.js"() {
    var AWS2 = require_core();
    var fs = __require("fs");
    var STS = require_sts2();
    var iniLoader = AWS2.util.iniLoader;
    AWS2.TokenFileWebIdentityCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function TokenFileWebIdentityCredentials(clientConfig) {
        AWS2.Credentials.call(this);
        this.data = null;
        this.clientConfig = AWS2.util.copy(clientConfig || {});
      }, "TokenFileWebIdentityCredentials"),
      getParamsFromEnv: /* @__PURE__ */ __name(function getParamsFromEnv() {
        var ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE", ENV_ROLE_ARN = "AWS_ROLE_ARN";
        if (process.env[ENV_TOKEN_FILE] && process.env[ENV_ROLE_ARN]) {
          return [{
            envTokenFile: process.env[ENV_TOKEN_FILE],
            roleArn: process.env[ENV_ROLE_ARN],
            roleSessionName: process.env["AWS_ROLE_SESSION_NAME"]
          }];
        }
      }, "getParamsFromEnv"),
      getParamsFromSharedConfig: /* @__PURE__ */ __name(function getParamsFromSharedConfig() {
        var profiles = AWS2.util.getProfilesFromSharedConfig(iniLoader);
        var profileName2 = process.env.AWS_PROFILE || AWS2.util.defaultProfile;
        var profile = profiles[profileName2] || {};
        if (Object.keys(profile).length === 0) {
          throw AWS2.util.error(
            new Error("Profile " + profileName2 + " not found"),
            { code: "TokenFileWebIdentityCredentialsProviderFailure" }
          );
        }
        var paramsArray = [];
        while (!profile["web_identity_token_file"] && profile["source_profile"]) {
          paramsArray.unshift({
            roleArn: profile["role_arn"],
            roleSessionName: profile["role_session_name"]
          });
          var sourceProfile = profile["source_profile"];
          profile = profiles[sourceProfile];
        }
        paramsArray.unshift({
          envTokenFile: profile["web_identity_token_file"],
          roleArn: profile["role_arn"],
          roleSessionName: profile["role_session_name"]
        });
        return paramsArray;
      }, "getParamsFromSharedConfig"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh"),
      assumeRoleChaining: /* @__PURE__ */ __name(function assumeRoleChaining(paramsArray, callback) {
        var self2 = this;
        if (paramsArray.length === 0) {
          self2.service.credentialsFrom(self2.data, self2);
          callback();
        } else {
          var params = paramsArray.shift();
          self2.service.config.credentials = self2.service.credentialsFrom(self2.data, self2);
          self2.service.assumeRole(
            {
              RoleArn: params.roleArn,
              RoleSessionName: params.roleSessionName || "token-file-web-identity"
            },
            function(err, data) {
              self2.data = null;
              if (err) {
                callback(err);
              } else {
                self2.data = data;
                self2.assumeRoleChaining(paramsArray, callback);
              }
            }
          );
        }
      }, "assumeRoleChaining"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        try {
          var paramsArray = self2.getParamsFromEnv();
          if (!paramsArray) {
            paramsArray = self2.getParamsFromSharedConfig();
          }
          if (paramsArray) {
            var params = paramsArray.shift();
            var oidcToken = fs.readFileSync(params.envTokenFile, { encoding: "ascii" });
            if (!self2.service) {
              self2.createClients();
            }
            self2.service.assumeRoleWithWebIdentity(
              {
                WebIdentityToken: oidcToken,
                RoleArn: params.roleArn,
                RoleSessionName: params.roleSessionName || "token-file-web-identity"
              },
              function(err, data) {
                self2.data = null;
                if (err) {
                  callback(err);
                } else {
                  self2.data = data;
                  self2.assumeRoleChaining(paramsArray, callback);
                }
              }
            );
          }
        } catch (err) {
          callback(err);
        }
      }, "load"),
      createClients: function() {
        if (!this.service) {
          var stsConfig = AWS2.util.merge({}, this.clientConfig);
          this.service = new STS(stsConfig);
          this.service.retryableError = function(error) {
            if (error.code === "IDPCommunicationErrorException" || error.code === "InvalidIdentityToken") {
              return true;
            } else {
              return AWS2.Service.prototype.retryableError.call(this, error);
            }
          };
        }
      }
    });
  }
});

// node_modules/aws-sdk/lib/metadata_service/get_endpoint.js
var require_get_endpoint = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service/get_endpoint.js"(exports2, module2) {
    var getEndpoint = /* @__PURE__ */ __name(function() {
      return {
        IPv4: "http://169.254.169.254",
        IPv6: "http://[fd00:ec2::254]"
      };
    }, "getEndpoint");
    module2.exports = getEndpoint;
  }
});

// node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js
var require_get_endpoint_mode = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode.js"(exports2, module2) {
    var getEndpointMode = /* @__PURE__ */ __name(function() {
      return {
        IPv4: "IPv4",
        IPv6: "IPv6"
      };
    }, "getEndpointMode");
    module2.exports = getEndpointMode;
  }
});

// node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js
var require_get_endpoint_config_options = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service/get_endpoint_config_options.js"(exports2, module2) {
    var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
    var CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
    var getEndpointConfigOptions = /* @__PURE__ */ __name(function() {
      return {
        environmentVariableSelector: function(env) {
          return env[ENV_ENDPOINT_NAME];
        },
        configFileSelector: function(profile) {
          return profile[CONFIG_ENDPOINT_NAME];
        },
        default: void 0
      };
    }, "getEndpointConfigOptions");
    module2.exports = getEndpointConfigOptions;
  }
});

// node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js
var require_get_endpoint_mode_config_options = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service/get_endpoint_mode_config_options.js"(exports2, module2) {
    var EndpointMode = require_get_endpoint_mode()();
    var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
    var CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
    var getEndpointModeConfigOptions = /* @__PURE__ */ __name(function() {
      return {
        environmentVariableSelector: function(env) {
          return env[ENV_ENDPOINT_MODE_NAME];
        },
        configFileSelector: function(profile) {
          return profile[CONFIG_ENDPOINT_MODE_NAME];
        },
        default: EndpointMode.IPv4
      };
    }, "getEndpointModeConfigOptions");
    module2.exports = getEndpointModeConfigOptions;
  }
});

// node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js
var require_get_metadata_service_endpoint = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service/get_metadata_service_endpoint.js"(exports2, module2) {
    var AWS2 = require_core();
    var Endpoint = require_get_endpoint()();
    var EndpointMode = require_get_endpoint_mode()();
    var ENDPOINT_CONFIG_OPTIONS = require_get_endpoint_config_options()();
    var ENDPOINT_MODE_CONFIG_OPTIONS = require_get_endpoint_mode_config_options()();
    var getMetadataServiceEndpoint = /* @__PURE__ */ __name(function() {
      var endpoint = AWS2.util.loadConfig(ENDPOINT_CONFIG_OPTIONS);
      if (endpoint !== void 0)
        return endpoint;
      var endpointMode = AWS2.util.loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS);
      switch (endpointMode) {
        case EndpointMode.IPv4:
          return Endpoint.IPv4;
        case EndpointMode.IPv6:
          return Endpoint.IPv6;
        default:
          throw new Error("Unsupported endpoint mode: " + endpointMode);
      }
    }, "getMetadataServiceEndpoint");
    module2.exports = getMetadataServiceEndpoint;
  }
});

// node_modules/aws-sdk/lib/metadata_service.js
var require_metadata_service = __commonJS({
  "node_modules/aws-sdk/lib/metadata_service.js"(exports2, module2) {
    var AWS2 = require_core();
    require_http3();
    var inherit = AWS2.util.inherit;
    var getMetadataServiceEndpoint = require_get_metadata_service_endpoint();
    var URL2 = __require("url").URL;
    AWS2.MetadataService = inherit({
      endpoint: getMetadataServiceEndpoint(),
      httpOptions: { timeout: 0 },
      disableFetchToken: false,
      constructor: /* @__PURE__ */ __name(function MetadataService(options) {
        if (options && options.host) {
          options.endpoint = "http://" + options.host;
          delete options.host;
        }
        AWS2.util.update(this, options);
      }, "MetadataService"),
      request: /* @__PURE__ */ __name(function request(path, options, callback) {
        if (arguments.length === 2) {
          callback = options;
          options = {};
        }
        if (process.env[AWS2.util.imdsDisabledEnv]) {
          callback(new Error("EC2 Instance Metadata Service access disabled"));
          return;
        }
        path = path || "/";
        if (URL2) {
          new URL2(this.endpoint);
        }
        var httpRequest = new AWS2.HttpRequest(this.endpoint + path);
        httpRequest.method = options.method || "GET";
        if (options.headers) {
          httpRequest.headers = options.headers;
        }
        AWS2.util.handleRequestWithRetries(httpRequest, this, callback);
      }, "request"),
      loadCredentialsCallbacks: [],
      fetchMetadataToken: /* @__PURE__ */ __name(function fetchMetadataToken(callback) {
        var self2 = this;
        var tokenFetchPath = "/latest/api/token";
        self2.request(
          tokenFetchPath,
          {
            "method": "PUT",
            "headers": {
              "x-aws-ec2-metadata-token-ttl-seconds": "21600"
            }
          },
          callback
        );
      }, "fetchMetadataToken"),
      fetchCredentials: /* @__PURE__ */ __name(function fetchCredentials(options, cb) {
        var self2 = this;
        var basePath = "/latest/meta-data/iam/security-credentials/";
        self2.request(basePath, options, function(err, roleName) {
          if (err) {
            self2.disableFetchToken = !(err.statusCode === 401);
            cb(AWS2.util.error(
              err,
              {
                message: "EC2 Metadata roleName request returned error"
              }
            ));
            return;
          }
          roleName = roleName.split("\n")[0];
          self2.request(basePath + roleName, options, function(credErr, credData) {
            if (credErr) {
              self2.disableFetchToken = !(credErr.statusCode === 401);
              cb(AWS2.util.error(
                credErr,
                {
                  message: "EC2 Metadata creds request returned error"
                }
              ));
              return;
            }
            try {
              var credentials = JSON.parse(credData);
              cb(null, credentials);
            } catch (parseError) {
              cb(parseError);
            }
          });
        });
      }, "fetchCredentials"),
      loadCredentials: /* @__PURE__ */ __name(function loadCredentials(callback) {
        var self2 = this;
        self2.loadCredentialsCallbacks.push(callback);
        if (self2.loadCredentialsCallbacks.length > 1) {
          return;
        }
        function callbacks(err, creds) {
          var cb;
          while ((cb = self2.loadCredentialsCallbacks.shift()) !== void 0) {
            cb(err, creds);
          }
        }
        __name(callbacks, "callbacks");
        if (self2.disableFetchToken) {
          self2.fetchCredentials({}, callbacks);
        } else {
          self2.fetchMetadataToken(function(tokenError, token) {
            if (tokenError) {
              if (tokenError.code === "TimeoutError") {
                self2.disableFetchToken = true;
              } else if (tokenError.retryable === true) {
                callbacks(AWS2.util.error(
                  tokenError,
                  {
                    message: "EC2 Metadata token request returned error"
                  }
                ));
                return;
              } else if (tokenError.statusCode === 400) {
                callbacks(AWS2.util.error(
                  tokenError,
                  {
                    message: "EC2 Metadata token request returned 400"
                  }
                ));
                return;
              }
            }
            var options = {};
            if (token) {
              options.headers = {
                "x-aws-ec2-metadata-token": token
              };
            }
            self2.fetchCredentials(options, callbacks);
          });
        }
      }, "loadCredentials")
    });
    module2.exports = AWS2.MetadataService;
  }
});

// node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js
var require_ec2_metadata_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/ec2_metadata_credentials.js"() {
    var AWS2 = require_core();
    require_metadata_service();
    AWS2.EC2MetadataCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function EC2MetadataCredentials(options) {
        AWS2.Credentials.call(this);
        options = options ? AWS2.util.copy(options) : {};
        options = AWS2.util.merge(
          { maxRetries: this.defaultMaxRetries },
          options
        );
        if (!options.httpOptions)
          options.httpOptions = {};
        options.httpOptions = AWS2.util.merge(
          {
            timeout: this.defaultTimeout,
            connectTimeout: this.defaultConnectTimeout
          },
          options.httpOptions
        );
        this.metadataService = new AWS2.MetadataService(options);
        this.logger = options.logger || AWS2.config && AWS2.config.logger;
      }, "EC2MetadataCredentials"),
      defaultTimeout: 1e3,
      defaultConnectTimeout: 1e3,
      defaultMaxRetries: 3,
      originalExpiration: void 0,
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        self2.metadataService.loadCredentials(function(err, creds) {
          if (err) {
            if (self2.hasLoadedCredentials()) {
              self2.extendExpirationIfExpired();
              callback();
            } else {
              callback(err);
            }
          } else {
            self2.setCredentials(creds);
            self2.extendExpirationIfExpired();
            callback();
          }
        });
      }, "load"),
      hasLoadedCredentials: /* @__PURE__ */ __name(function hasLoadedCredentials() {
        return this.AccessKeyId && this.secretAccessKey;
      }, "hasLoadedCredentials"),
      extendExpirationIfExpired: /* @__PURE__ */ __name(function extendExpirationIfExpired() {
        if (this.needsRefresh()) {
          this.originalExpiration = this.originalExpiration || this.expireTime;
          this.expired = false;
          var nextTimeout = 15 * 60 + Math.floor(Math.random() * 5 * 60);
          var currentTime = AWS2.util.date.getDate().getTime();
          this.expireTime = new Date(currentTime + nextTimeout * 1e3);
          this.logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted again at " + this.expireTime + "\nFor more information, please visit: https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html");
        }
      }, "extendExpirationIfExpired"),
      setCredentials: /* @__PURE__ */ __name(function setCredentials(creds) {
        var currentTime = AWS2.util.date.getDate().getTime();
        var expireTime = new Date(creds.Expiration);
        this.expired = currentTime >= expireTime ? true : false;
        this.metadata = creds;
        this.accessKeyId = creds.AccessKeyId;
        this.secretAccessKey = creds.SecretAccessKey;
        this.sessionToken = creds.Token;
        this.expireTime = expireTime;
      }, "setCredentials")
    });
  }
});

// node_modules/aws-sdk/lib/credentials/remote_credentials.js
var require_remote_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/remote_credentials.js"() {
    var AWS2 = require_core();
    var ENV_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
    var ENV_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
    var ENV_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
    var FULL_URI_UNRESTRICTED_PROTOCOLS = ["https:"];
    var FULL_URI_ALLOWED_PROTOCOLS = ["http:", "https:"];
    var FULL_URI_ALLOWED_HOSTNAMES = ["localhost", "127.0.0.1"];
    var RELATIVE_URI_HOST = "169.254.170.2";
    AWS2.RemoteCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function RemoteCredentials(options) {
        AWS2.Credentials.call(this);
        options = options ? AWS2.util.copy(options) : {};
        if (!options.httpOptions)
          options.httpOptions = {};
        options.httpOptions = AWS2.util.merge(
          this.httpOptions,
          options.httpOptions
        );
        AWS2.util.update(this, options);
      }, "RemoteCredentials"),
      httpOptions: { timeout: 1e3 },
      maxRetries: 3,
      isConfiguredForEcsCredentials: /* @__PURE__ */ __name(function isConfiguredForEcsCredentials() {
        return Boolean(
          process && process.env && (process.env[ENV_RELATIVE_URI] || process.env[ENV_FULL_URI])
        );
      }, "isConfiguredForEcsCredentials"),
      getECSFullUri: /* @__PURE__ */ __name(function getECSFullUri() {
        if (process && process.env) {
          var relative = process.env[ENV_RELATIVE_URI], full = process.env[ENV_FULL_URI];
          if (relative) {
            return "http://" + RELATIVE_URI_HOST + relative;
          } else if (full) {
            var parsed = AWS2.util.urlParse(full);
            if (FULL_URI_ALLOWED_PROTOCOLS.indexOf(parsed.protocol) < 0) {
              throw AWS2.util.error(
                new Error("Unsupported protocol:  AWS.RemoteCredentials supports " + FULL_URI_ALLOWED_PROTOCOLS.join(",") + " only; " + parsed.protocol + " requested."),
                { code: "ECSCredentialsProviderFailure" }
              );
            }
            if (FULL_URI_UNRESTRICTED_PROTOCOLS.indexOf(parsed.protocol) < 0 && FULL_URI_ALLOWED_HOSTNAMES.indexOf(parsed.hostname) < 0) {
              throw AWS2.util.error(
                new Error("Unsupported hostname: AWS.RemoteCredentials only supports " + FULL_URI_ALLOWED_HOSTNAMES.join(",") + " for " + parsed.protocol + "; " + parsed.protocol + "//" + parsed.hostname + " requested."),
                { code: "ECSCredentialsProviderFailure" }
              );
            }
            return full;
          } else {
            throw AWS2.util.error(
              new Error("Variable " + ENV_RELATIVE_URI + " or " + ENV_FULL_URI + " must be set to use AWS.RemoteCredentials."),
              { code: "ECSCredentialsProviderFailure" }
            );
          }
        } else {
          throw AWS2.util.error(
            new Error("No process info available"),
            { code: "ECSCredentialsProviderFailure" }
          );
        }
      }, "getECSFullUri"),
      getECSAuthToken: /* @__PURE__ */ __name(function getECSAuthToken() {
        if (process && process.env && process.env[ENV_FULL_URI]) {
          return process.env[ENV_AUTH_TOKEN];
        }
      }, "getECSAuthToken"),
      credsFormatIsValid: /* @__PURE__ */ __name(function credsFormatIsValid(credData) {
        return !!credData.accessKeyId && !!credData.secretAccessKey && !!credData.sessionToken && !!credData.expireTime;
      }, "credsFormatIsValid"),
      formatCreds: /* @__PURE__ */ __name(function formatCreds(credData) {
        if (!!credData.credentials) {
          credData = credData.credentials;
        }
        return {
          expired: false,
          accessKeyId: credData.accessKeyId || credData.AccessKeyId,
          secretAccessKey: credData.secretAccessKey || credData.SecretAccessKey,
          sessionToken: credData.sessionToken || credData.Token,
          expireTime: new Date(credData.expiration || credData.Expiration)
        };
      }, "formatCreds"),
      request: /* @__PURE__ */ __name(function request(url, callback) {
        var httpRequest = new AWS2.HttpRequest(url);
        httpRequest.method = "GET";
        httpRequest.headers.Accept = "application/json";
        var token = this.getECSAuthToken();
        if (token) {
          httpRequest.headers.Authorization = token;
        }
        AWS2.util.handleRequestWithRetries(httpRequest, this, callback);
      }, "request"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        var fullUri;
        try {
          fullUri = this.getECSFullUri();
        } catch (err) {
          callback(err);
          return;
        }
        this.request(fullUri, function(err, data) {
          if (!err) {
            try {
              data = JSON.parse(data);
              var creds = self2.formatCreds(data);
              if (!self2.credsFormatIsValid(creds)) {
                throw AWS2.util.error(
                  new Error("Response data is not in valid format"),
                  { code: "ECSCredentialsProviderFailure" }
                );
              }
              AWS2.util.update(self2, creds);
            } catch (dataError) {
              err = dataError;
            }
          }
          callback(err, creds);
        });
      }, "load")
    });
  }
});

// node_modules/aws-sdk/lib/credentials/ecs_credentials.js
var require_ecs_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/ecs_credentials.js"() {
    var AWS2 = require_core();
    AWS2.ECSCredentials = AWS2.RemoteCredentials;
  }
});

// node_modules/aws-sdk/lib/credentials/environment_credentials.js
var require_environment_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/environment_credentials.js"() {
    var AWS2 = require_core();
    AWS2.EnvironmentCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function EnvironmentCredentials(envPrefix) {
        AWS2.Credentials.call(this);
        this.envPrefix = envPrefix;
        this.get(function() {
        });
      }, "EnvironmentCredentials"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        if (!callback)
          callback = AWS2.util.fn.callback;
        if (!process || !process.env) {
          callback(AWS2.util.error(
            new Error("No process info or environment variables available"),
            { code: "EnvironmentCredentialsProviderFailure" }
          ));
          return;
        }
        var keys = ["ACCESS_KEY_ID", "SECRET_ACCESS_KEY", "SESSION_TOKEN"];
        var values = [];
        for (var i = 0; i < keys.length; i++) {
          var prefix = "";
          if (this.envPrefix)
            prefix = this.envPrefix + "_";
          values[i] = process.env[prefix + keys[i]];
          if (!values[i] && keys[i] !== "SESSION_TOKEN") {
            callback(AWS2.util.error(
              new Error("Variable " + prefix + keys[i] + " not set."),
              { code: "EnvironmentCredentialsProviderFailure" }
            ));
            return;
          }
        }
        this.expired = false;
        AWS2.Credentials.apply(this, values);
        callback();
      }, "refresh")
    });
  }
});

// node_modules/aws-sdk/lib/credentials/file_system_credentials.js
var require_file_system_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/file_system_credentials.js"() {
    var AWS2 = require_core();
    AWS2.FileSystemCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function FileSystemCredentials(filename) {
        AWS2.Credentials.call(this);
        this.filename = filename;
        this.get(function() {
        });
      }, "FileSystemCredentials"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        if (!callback)
          callback = AWS2.util.fn.callback;
        try {
          var creds = JSON.parse(AWS2.util.readFileSync(this.filename));
          AWS2.Credentials.call(this, creds);
          if (!this.accessKeyId || !this.secretAccessKey) {
            throw AWS2.util.error(
              new Error("Credentials not set in " + this.filename),
              { code: "FileSystemCredentialsProviderFailure" }
            );
          }
          this.expired = false;
          callback();
        } catch (err) {
          callback(err);
        }
      }, "refresh")
    });
  }
});

// node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js
var require_shared_ini_file_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/shared_ini_file_credentials.js"() {
    var AWS2 = require_core();
    var STS = require_sts2();
    var iniLoader = AWS2.util.iniLoader;
    var ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
    AWS2.SharedIniFileCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function SharedIniFileCredentials(options) {
        AWS2.Credentials.call(this);
        options = options || {};
        this.filename = options.filename;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS2.util.defaultProfile;
        this.disableAssumeRole = Boolean(options.disableAssumeRole);
        this.preferStaticCredentials = Boolean(options.preferStaticCredentials);
        this.tokenCodeFn = options.tokenCodeFn || null;
        this.httpOptions = options.httpOptions || null;
        this.get(options.callback || AWS2.util.fn.noop);
      }, "SharedIniFileCredentials"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        try {
          var profiles = AWS2.util.getProfilesFromSharedConfig(iniLoader, this.filename);
          var profile = profiles[this.profile] || {};
          if (Object.keys(profile).length === 0) {
            throw AWS2.util.error(
              new Error("Profile " + this.profile + " not found"),
              { code: "SharedIniFileCredentialsProviderFailure" }
            );
          }
          var preferStaticCredentialsToRoleArn = Boolean(
            this.preferStaticCredentials && profile["aws_access_key_id"] && profile["aws_secret_access_key"]
          );
          if (profile["role_arn"] && !preferStaticCredentialsToRoleArn) {
            this.loadRoleProfile(profiles, profile, function(err, data) {
              if (err) {
                callback(err);
              } else {
                self2.expired = false;
                self2.accessKeyId = data.Credentials.AccessKeyId;
                self2.secretAccessKey = data.Credentials.SecretAccessKey;
                self2.sessionToken = data.Credentials.SessionToken;
                self2.expireTime = data.Credentials.Expiration;
                callback(null);
              }
            });
            return;
          }
          this.accessKeyId = profile["aws_access_key_id"];
          this.secretAccessKey = profile["aws_secret_access_key"];
          this.sessionToken = profile["aws_session_token"];
          if (!this.accessKeyId || !this.secretAccessKey) {
            throw AWS2.util.error(
              new Error("Credentials not set for profile " + this.profile),
              { code: "SharedIniFileCredentialsProviderFailure" }
            );
          }
          this.expired = false;
          callback(null);
        } catch (err) {
          callback(err);
        }
      }, "load"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(
          callback || AWS2.util.fn.callback,
          this.disableAssumeRole
        );
      }, "refresh"),
      loadRoleProfile: /* @__PURE__ */ __name(function loadRoleProfile(creds, roleProfile, callback) {
        if (this.disableAssumeRole) {
          throw AWS2.util.error(
            new Error("Role assumption profiles are disabled. Failed to load profile " + this.profile + " from " + creds.filename),
            { code: "SharedIniFileCredentialsProviderFailure" }
          );
        }
        var self2 = this;
        var roleArn = roleProfile["role_arn"];
        var roleSessionName = roleProfile["role_session_name"];
        var externalId = roleProfile["external_id"];
        var mfaSerial = roleProfile["mfa_serial"];
        var sourceProfileName = roleProfile["source_profile"];
        var profileRegion = roleProfile["region"] || ASSUME_ROLE_DEFAULT_REGION;
        if (!sourceProfileName) {
          throw AWS2.util.error(
            new Error("source_profile is not set using profile " + this.profile),
            { code: "SharedIniFileCredentialsProviderFailure" }
          );
        }
        var sourceProfileExistanceTest = creds[sourceProfileName];
        if (typeof sourceProfileExistanceTest !== "object") {
          throw AWS2.util.error(
            new Error("source_profile " + sourceProfileName + " using profile " + this.profile + " does not exist"),
            { code: "SharedIniFileCredentialsProviderFailure" }
          );
        }
        var sourceCredentials = new AWS2.SharedIniFileCredentials(
          AWS2.util.merge(this.options || {}, {
            profile: sourceProfileName,
            preferStaticCredentials: true
          })
        );
        this.roleArn = roleArn;
        var sts = new STS({
          credentials: sourceCredentials,
          region: profileRegion,
          httpOptions: this.httpOptions
        });
        var roleParams = {
          RoleArn: roleArn,
          RoleSessionName: roleSessionName || "aws-sdk-js-" + Date.now()
        };
        if (externalId) {
          roleParams.ExternalId = externalId;
        }
        if (mfaSerial && self2.tokenCodeFn) {
          roleParams.SerialNumber = mfaSerial;
          self2.tokenCodeFn(mfaSerial, function(err, token) {
            if (err) {
              var message;
              if (err instanceof Error) {
                message = err.message;
              } else {
                message = err;
              }
              callback(
                AWS2.util.error(
                  new Error("Error fetching MFA token: " + message),
                  { code: "SharedIniFileCredentialsProviderFailure" }
                )
              );
              return;
            }
            roleParams.TokenCode = token;
            sts.assumeRole(roleParams, callback);
          });
          return;
        }
        sts.assumeRole(roleParams, callback);
      }, "loadRoleProfile")
    });
  }
});

// node_modules/aws-sdk/lib/credentials/sso_credentials.js
var require_sso_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/sso_credentials.js"() {
    var AWS2 = require_core();
    var path = __require("path");
    var crypto2 = __require("crypto");
    var iniLoader = AWS2.util.iniLoader;
    AWS2.SsoCredentials = AWS2.util.inherit(AWS2.Credentials, {
      constructor: /* @__PURE__ */ __name(function SsoCredentials(options) {
        AWS2.Credentials.call(this);
        options = options || {};
        this.errorCode = "SsoCredentialsProviderFailure";
        this.expired = true;
        this.filename = options.filename;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS2.util.defaultProfile;
        this.service = options.ssoClient;
        this.httpOptions = options.httpOptions || null;
        this.get(options.callback || AWS2.util.fn.noop);
      }, "SsoCredentials"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        try {
          var profiles = AWS2.util.getProfilesFromSharedConfig(iniLoader, this.filename);
          var profile = profiles[this.profile] || {};
          if (Object.keys(profile).length === 0) {
            throw AWS2.util.error(
              new Error("Profile " + this.profile + " not found"),
              { code: self2.errorCode }
            );
          }
          if (profile.sso_session) {
            if (!profile.sso_account_id || !profile.sso_role_name) {
              throw AWS2.util.error(
                new Error("Profile " + this.profile + " with session " + profile.sso_session + ' does not have valid SSO credentials. Required parameters "sso_account_id", "sso_session", "sso_role_name". Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html'),
                { code: self2.errorCode }
              );
            }
          } else {
            if (!profile.sso_start_url || !profile.sso_account_id || !profile.sso_region || !profile.sso_role_name) {
              throw AWS2.util.error(
                new Error("Profile " + this.profile + ' does not have valid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html'),
                { code: self2.errorCode }
              );
            }
          }
          this.getToken(this.profile, profile, function(err, token) {
            if (err) {
              return callback(err);
            }
            var request = {
              accessToken: token,
              accountId: profile.sso_account_id,
              roleName: profile.sso_role_name
            };
            if (!self2.service || self2.service.config.region !== profile.sso_region) {
              self2.service = new AWS2.SSO({
                region: profile.sso_region,
                httpOptions: self2.httpOptions
              });
            }
            self2.service.getRoleCredentials(request, function(err2, data) {
              if (err2 || !data || !data.roleCredentials) {
                callback(AWS2.util.error(
                  err2 || new Error('Please log in using "aws sso login"'),
                  { code: self2.errorCode }
                ), null);
              } else if (!data.roleCredentials.accessKeyId || !data.roleCredentials.secretAccessKey || !data.roleCredentials.sessionToken || !data.roleCredentials.expiration) {
                throw AWS2.util.error(new Error(
                  "SSO returns an invalid temporary credential."
                ));
              } else {
                self2.expired = false;
                self2.accessKeyId = data.roleCredentials.accessKeyId;
                self2.secretAccessKey = data.roleCredentials.secretAccessKey;
                self2.sessionToken = data.roleCredentials.sessionToken;
                self2.expireTime = new Date(data.roleCredentials.expiration);
                callback(null);
              }
            });
          });
        } catch (err) {
          callback(err);
        }
      }, "load"),
      getToken: /* @__PURE__ */ __name(function getToken(profileName2, profile, callback) {
        var self2 = this;
        if (profile.sso_session) {
          var _iniLoader = AWS2.util.iniLoader;
          var ssoSessions = _iniLoader.loadSsoSessionsFrom();
          var ssoSession = ssoSessions[profile.sso_session];
          Object.assign(profile, ssoSession);
          var ssoTokenProvider = new AWS2.SSOTokenProvider({
            profile: profileName2
          });
          ssoTokenProvider.load(function(err) {
            if (err) {
              return callback(err);
            }
            return callback(null, ssoTokenProvider.token);
          });
          return;
        }
        try {
          var EXPIRE_WINDOW_MS = 15 * 60 * 1e3;
          var hasher = crypto2.createHash("sha1");
          var fileName = hasher.update(profile.sso_start_url).digest("hex") + ".json";
          var cachePath = path.join(
            iniLoader.getHomeDir(),
            ".aws",
            "sso",
            "cache",
            fileName
          );
          var cacheFile = AWS2.util.readFileSync(cachePath);
          var cacheContent = null;
          if (cacheFile) {
            cacheContent = JSON.parse(cacheFile);
          }
          if (!cacheContent) {
            throw AWS2.util.error(
              new Error("Cached credentials not found under " + this.profile + " profile. Please make sure you log in with aws sso login first"),
              { code: self2.errorCode }
            );
          }
          if (!cacheContent.startUrl || !cacheContent.region || !cacheContent.accessToken || !cacheContent.expiresAt) {
            throw AWS2.util.error(
              new Error("Cached credentials are missing required properties. Try running aws sso login.")
            );
          }
          if (new Date(cacheContent.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS) {
            throw AWS2.util.error(new Error(
              "The SSO session associated with this profile has expired. To refresh this SSO session run aws sso login with the corresponding profile."
            ));
          }
          return callback(null, cacheContent.accessToken);
        } catch (err) {
          return callback(err, null);
        }
      }, "getToken"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh")
    });
  }
});

// node_modules/aws-sdk/lib/token.js
var require_token = __commonJS({
  "node_modules/aws-sdk/lib/token.js"() {
    var AWS2 = require_core();
    AWS2.Token = AWS2.util.inherit({
      constructor: /* @__PURE__ */ __name(function Token(options) {
        AWS2.util.hideProperties(this, ["token"]);
        this.expired = false;
        this.expireTime = null;
        this.refreshCallbacks = [];
        if (arguments.length === 1) {
          var options = arguments[0];
          this.token = options.token;
          this.expireTime = options.expireTime;
        }
      }, "Token"),
      expiryWindow: 15,
      needsRefresh: /* @__PURE__ */ __name(function needsRefresh() {
        var currentTime = AWS2.util.date.getDate().getTime();
        var adjustedTime = new Date(currentTime + this.expiryWindow * 1e3);
        if (this.expireTime && adjustedTime > this.expireTime)
          return true;
        return this.expired || !this.token;
      }, "needsRefresh"),
      get: /* @__PURE__ */ __name(function get(callback) {
        var self2 = this;
        if (this.needsRefresh()) {
          this.refresh(function(err) {
            if (!err)
              self2.expired = false;
            if (callback)
              callback(err);
          });
        } else if (callback) {
          callback();
        }
      }, "get"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        this.expired = false;
        callback();
      }, "refresh"),
      coalesceRefresh: /* @__PURE__ */ __name(function coalesceRefresh(callback, sync) {
        var self2 = this;
        if (self2.refreshCallbacks.push(callback) === 1) {
          self2.load(/* @__PURE__ */ __name(function onLoad(err) {
            AWS2.util.arrayEach(self2.refreshCallbacks, function(callback2) {
              if (sync) {
                callback2(err);
              } else {
                AWS2.util.defer(function() {
                  callback2(err);
                });
              }
            });
            self2.refreshCallbacks.length = 0;
          }, "onLoad"));
        }
      }, "coalesceRefresh"),
      load: /* @__PURE__ */ __name(function load(callback) {
        callback();
      }, "load")
    });
    AWS2.Token.addPromisesToClass = /* @__PURE__ */ __name(function addPromisesToClass(PromiseDependency) {
      this.prototype.getPromise = AWS2.util.promisifyMethod("get", PromiseDependency);
      this.prototype.refreshPromise = AWS2.util.promisifyMethod("refresh", PromiseDependency);
    }, "addPromisesToClass");
    AWS2.Token.deletePromisesFromClass = /* @__PURE__ */ __name(function deletePromisesFromClass() {
      delete this.prototype.getPromise;
      delete this.prototype.refreshPromise;
    }, "deletePromisesFromClass");
    AWS2.util.addPromises(AWS2.Token);
  }
});

// node_modules/aws-sdk/lib/token/token_provider_chain.js
var require_token_provider_chain = __commonJS({
  "node_modules/aws-sdk/lib/token/token_provider_chain.js"() {
    var AWS2 = require_core();
    AWS2.TokenProviderChain = AWS2.util.inherit(AWS2.Token, {
      constructor: /* @__PURE__ */ __name(function TokenProviderChain(providers) {
        if (providers) {
          this.providers = providers;
        } else {
          this.providers = AWS2.TokenProviderChain.defaultProviders.slice(0);
        }
        this.resolveCallbacks = [];
      }, "TokenProviderChain"),
      resolve: /* @__PURE__ */ __name(function resolve(callback) {
        var self2 = this;
        if (self2.providers.length === 0) {
          callback(new Error("No providers"));
          return self2;
        }
        if (self2.resolveCallbacks.push(callback) === 1) {
          let resolveNext2 = function(err, token) {
            if (!err && token || index === providers.length) {
              AWS2.util.arrayEach(self2.resolveCallbacks, function(callback2) {
                callback2(err, token);
              });
              self2.resolveCallbacks.length = 0;
              return;
            }
            var provider = providers[index++];
            if (typeof provider === "function") {
              token = provider.call();
            } else {
              token = provider;
            }
            if (token.get) {
              token.get(function(getErr) {
                resolveNext2(getErr, getErr ? null : token);
              });
            } else {
              resolveNext2(null, token);
            }
          };
          var resolveNext = resolveNext2;
          __name(resolveNext2, "resolveNext");
          var index = 0;
          var providers = self2.providers.slice(0);
          resolveNext2();
        }
        return self2;
      }, "resolve")
    });
    AWS2.TokenProviderChain.defaultProviders = [];
    AWS2.TokenProviderChain.addPromisesToClass = /* @__PURE__ */ __name(function addPromisesToClass(PromiseDependency) {
      this.prototype.resolvePromise = AWS2.util.promisifyMethod("resolve", PromiseDependency);
    }, "addPromisesToClass");
    AWS2.TokenProviderChain.deletePromisesFromClass = /* @__PURE__ */ __name(function deletePromisesFromClass() {
      delete this.prototype.resolvePromise;
    }, "deletePromisesFromClass");
    AWS2.util.addPromises(AWS2.TokenProviderChain);
  }
});

// node_modules/aws-sdk/lib/token/sso_token_provider.js
var require_sso_token_provider = __commonJS({
  "node_modules/aws-sdk/lib/token/sso_token_provider.js"() {
    var AWS2 = require_core();
    var crypto2 = __require("crypto");
    var fs = __require("fs");
    var path = __require("path");
    var iniLoader = AWS2.util.iniLoader;
    var lastRefreshAttemptTime = 0;
    var validateTokenKey = /* @__PURE__ */ __name(function validateTokenKey2(token, key) {
      if (!token[key]) {
        throw AWS2.util.error(
          new Error('Key "' + key + '" not present in SSO Token'),
          { code: "SSOTokenProviderFailure" }
        );
      }
    }, "validateTokenKey");
    var refreshUnsuccessful = /* @__PURE__ */ __name(function refreshUnsuccessful2(currentTime, tokenExpireTime, callback) {
      if (tokenExpireTime > currentTime) {
        callback(null);
      } else {
        throw AWS2.util.error(
          new Error('SSO Token refresh failed. Please log in using "aws sso login"'),
          { code: "SSOTokenProviderFailure" }
        );
      }
    }, "refreshUnsuccessful");
    AWS2.SSOTokenProvider = AWS2.util.inherit(AWS2.Token, {
      expiryWindow: 5 * 60,
      constructor: /* @__PURE__ */ __name(function SSOTokenProvider(options) {
        AWS2.Token.call(this);
        options = options || {};
        this.expired = true;
        this.profile = options.profile || process.env.AWS_PROFILE || AWS2.util.defaultProfile;
        this.get(options.callback || AWS2.util.fn.noop);
      }, "SSOTokenProvider"),
      load: /* @__PURE__ */ __name(function load(callback) {
        var self2 = this;
        var profiles = iniLoader.loadFrom({ isConfig: true });
        var profile = profiles[this.profile] || {};
        if (Object.keys(profile).length === 0) {
          throw AWS2.util.error(
            new Error('Profile "' + this.profile + '" not found'),
            { code: "SSOTokenProviderFailure" }
          );
        } else if (!profile["sso_session"]) {
          throw AWS2.util.error(
            new Error('Profile "' + profileName + '" is missing required property "sso_session".'),
            { code: "SSOTokenProviderFailure" }
          );
        }
        var ssoSessionName = profile["sso_session"];
        var ssoSessions = iniLoader.loadSsoSessionsFrom();
        var ssoSession = ssoSessions[ssoSessionName];
        if (!ssoSession) {
          throw AWS2.util.error(
            new Error('Sso session "' + ssoSessionName + '" not found'),
            { code: "SSOTokenProviderFailure" }
          );
        } else if (!ssoSession["sso_start_url"]) {
          throw AWS2.util.error(
            new Error('Sso session "' + profileName + '" is missing required property "sso_start_url".'),
            { code: "SSOTokenProviderFailure" }
          );
        } else if (!ssoSession["sso_region"]) {
          throw AWS2.util.error(
            new Error('Sso session "' + profileName + '" is missing required property "sso_region".'),
            { code: "SSOTokenProviderFailure" }
          );
        }
        var hasher = crypto2.createHash("sha1");
        var fileName = hasher.update(ssoSessionName).digest("hex") + ".json";
        var cachePath = path.join(iniLoader.getHomeDir(), ".aws", "sso", "cache", fileName);
        var tokenFromCache = JSON.parse(fs.readFileSync(cachePath));
        if (!tokenFromCache) {
          throw AWS2.util.error(
            new Error('Cached token not found. Please log in using "aws sso login" for profile "' + this.profile + '".'),
            { code: "SSOTokenProviderFailure" }
          );
        }
        validateTokenKey(tokenFromCache, "accessToken");
        validateTokenKey(tokenFromCache, "expiresAt");
        var currentTime = AWS2.util.date.getDate().getTime();
        var adjustedTime = new Date(currentTime + this.expiryWindow * 1e3);
        var tokenExpireTime = new Date(tokenFromCache["expiresAt"]);
        if (tokenExpireTime > adjustedTime) {
          self2.token = tokenFromCache.accessToken;
          self2.expireTime = tokenExpireTime;
          self2.expired = false;
          callback(null);
          return;
        }
        if (currentTime - lastRefreshAttemptTime < 30 * 1e3) {
          refreshUnsuccessful(currentTime, tokenExpireTime, callback);
          return;
        }
        validateTokenKey(tokenFromCache, "clientId");
        validateTokenKey(tokenFromCache, "clientSecret");
        validateTokenKey(tokenFromCache, "refreshToken");
        if (!self2.service || self2.service.config.region !== ssoSession.sso_region) {
          self2.service = new AWS2.SSOOIDC({ region: ssoSession.sso_region });
        }
        var params = {
          clientId: tokenFromCache.clientId,
          clientSecret: tokenFromCache.clientSecret,
          refreshToken: tokenFromCache.refreshToken,
          grantType: "refresh_token"
        };
        lastRefreshAttemptTime = AWS2.util.date.getDate().getTime();
        self2.service.createToken(params, function(err, data) {
          if (err || !data) {
            refreshUnsuccessful(currentTime, tokenExpireTime, callback);
          } else {
            try {
              validateTokenKey(data, "accessToken");
              validateTokenKey(data, "expiresIn");
              self2.expired = false;
              self2.token = data.accessToken;
              self2.expireTime = new Date(Date.now() + data.expiresIn * 1e3);
              callback(null);
              try {
                tokenFromCache.accessToken = data.accessToken;
                tokenFromCache.expiresAt = self2.expireTime.toISOString();
                tokenFromCache.refreshToken = data.refreshToken;
                fs.writeFileSync(cachePath, JSON.stringify(tokenFromCache, null, 2));
              } catch (error) {
              }
            } catch (error) {
              refreshUnsuccessful(currentTime, tokenExpireTime, callback);
            }
          }
        });
      }, "load"),
      refresh: /* @__PURE__ */ __name(function refresh(callback) {
        iniLoader.clearCachedFiles();
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      }, "refresh")
    });
  }
});

// node_modules/aws-sdk/lib/node_loader.js
var require_node_loader = __commonJS({
  "node_modules/aws-sdk/lib/node_loader.js"(exports2, module2) {
    var util = require_util9();
    var region_utils = require_utils3();
    var isFipsRegion = region_utils.isFipsRegion;
    var getRealRegion = region_utils.getRealRegion;
    util.isBrowser = function() {
      return false;
    };
    util.isNode = function() {
      return true;
    };
    util.crypto.lib = __require("crypto");
    util.Buffer = __require("buffer").Buffer;
    util.domain = __require("domain");
    util.stream = __require("stream");
    util.url = __require("url");
    util.querystring = __require("querystring");
    util.environment = "nodejs";
    util.createEventStream = util.stream.Readable ? require_streaming_create_event_stream().createEventStream : require_buffered_create_event_stream().createEventStream;
    util.realClock = require_nodeClock();
    util.clientSideMonitoring = {
      Publisher: require_publisher().Publisher,
      configProvider: require_configuration()
    };
    util.iniLoader = require_shared_ini().iniLoader;
    util.getSystemErrorName = __require("util").getSystemErrorName;
    util.loadConfig = function(options) {
      var envValue = options.environmentVariableSelector(process.env);
      if (envValue !== void 0) {
        return envValue;
      }
      var configFile = {};
      try {
        configFile = util.iniLoader ? util.iniLoader.loadFrom({
          isConfig: true,
          filename: process.env[util.sharedConfigFileEnv]
        }) : {};
      } catch (e) {
      }
      var sharedFileConfig = configFile[process.env.AWS_PROFILE || util.defaultProfile] || {};
      var configValue = options.configFileSelector(sharedFileConfig);
      if (configValue !== void 0) {
        return configValue;
      }
      if (typeof options.default === "function") {
        return options.default();
      }
      return options.default;
    };
    var AWS2;
    module2.exports = AWS2 = require_core();
    require_credentials();
    require_credential_provider_chain();
    require_temporary_credentials();
    require_chainable_temporary_credentials();
    require_web_identity_credentials();
    require_cognito_identity_credentials();
    require_saml_credentials();
    require_process_credentials();
    AWS2.XML.Parser = require_node_parser();
    require_node();
    require_ini_loader();
    require_token_file_web_identity_credentials();
    require_ec2_metadata_credentials();
    require_remote_credentials();
    require_ecs_credentials();
    require_environment_credentials();
    require_file_system_credentials();
    require_shared_ini_file_credentials();
    require_process_credentials();
    require_sso_credentials();
    AWS2.CredentialProviderChain.defaultProviders = [
      function() {
        return new AWS2.EnvironmentCredentials("AWS");
      },
      function() {
        return new AWS2.EnvironmentCredentials("AMAZON");
      },
      function() {
        return new AWS2.SsoCredentials();
      },
      function() {
        return new AWS2.SharedIniFileCredentials();
      },
      function() {
        return new AWS2.ECSCredentials();
      },
      function() {
        return new AWS2.ProcessCredentials();
      },
      function() {
        return new AWS2.TokenFileWebIdentityCredentials();
      },
      function() {
        return new AWS2.EC2MetadataCredentials();
      }
    ];
    require_token();
    require_token_provider_chain();
    require_sso_token_provider();
    AWS2.TokenProviderChain.defaultProviders = [
      function() {
        return new AWS2.SSOTokenProvider();
      }
    ];
    var getRegion = /* @__PURE__ */ __name(function() {
      var env = process.env;
      var region = env.AWS_REGION || env.AMAZON_REGION;
      if (env[AWS2.util.configOptInEnv]) {
        var toCheck = [
          { filename: env[AWS2.util.sharedCredentialsFileEnv] },
          { isConfig: true, filename: env[AWS2.util.sharedConfigFileEnv] }
        ];
        var iniLoader = AWS2.util.iniLoader;
        while (!region && toCheck.length) {
          var configFile = {};
          var fileInfo = toCheck.shift();
          try {
            configFile = iniLoader.loadFrom(fileInfo);
          } catch (err) {
            if (fileInfo.isConfig)
              throw err;
          }
          var profile = configFile[env.AWS_PROFILE || AWS2.util.defaultProfile];
          region = profile && profile.region;
        }
      }
      return region;
    }, "getRegion");
    var getBooleanValue = /* @__PURE__ */ __name(function(value) {
      return value === "true" ? true : value === "false" ? false : void 0;
    }, "getBooleanValue");
    var USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: function(env) {
        return getBooleanValue(env["AWS_USE_FIPS_ENDPOINT"]);
      },
      configFileSelector: function(profile) {
        return getBooleanValue(profile["use_fips_endpoint"]);
      },
      default: false
    };
    var USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: function(env) {
        return getBooleanValue(env["AWS_USE_DUALSTACK_ENDPOINT"]);
      },
      configFileSelector: function(profile) {
        return getBooleanValue(profile["use_dualstack_endpoint"]);
      },
      default: false
    };
    AWS2.util.update(AWS2.Config.prototype.keys, {
      credentials: function() {
        var credentials = null;
        new AWS2.CredentialProviderChain([
          function() {
            return new AWS2.EnvironmentCredentials("AWS");
          },
          function() {
            return new AWS2.EnvironmentCredentials("AMAZON");
          },
          function() {
            return new AWS2.SharedIniFileCredentials({ disableAssumeRole: true });
          }
        ]).resolve(function(err, creds) {
          if (!err)
            credentials = creds;
        });
        return credentials;
      },
      credentialProvider: function() {
        return new AWS2.CredentialProviderChain();
      },
      logger: function() {
        return process.env.AWSJS_DEBUG ? console : null;
      },
      region: function() {
        var region = getRegion();
        return region ? getRealRegion(region) : void 0;
      },
      tokenProvider: function() {
        return new AWS2.TokenProviderChain();
      },
      useFipsEndpoint: function() {
        var region = getRegion();
        return isFipsRegion(region) ? true : util.loadConfig(USE_FIPS_ENDPOINT_CONFIG_OPTIONS);
      },
      useDualstackEndpoint: function() {
        return util.loadConfig(USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS);
      }
    });
    AWS2.config = new AWS2.Config();
  }
});

// node_modules/aws-sdk/apis/kms-2014-11-01.min.json
var require_kms_2014_11_01_min = __commonJS({
  "node_modules/aws-sdk/apis/kms-2014-11-01.min.json"(exports2, module2) {
    module2.exports = {
      version: "2.0",
      metadata: {
        apiVersion: "2014-11-01",
        endpointPrefix: "kms",
        jsonVersion: "1.1",
        protocol: "json",
        serviceAbbreviation: "KMS",
        serviceFullName: "AWS Key Management Service",
        serviceId: "KMS",
        signatureVersion: "v4",
        targetPrefix: "TrentService",
        uid: "kms-2014-11-01"
      },
      operations: {
        CancelKeyDeletion: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {}
            }
          },
          output: {
            type: "structure",
            members: {
              KeyId: {}
            }
          }
        },
        ConnectCustomKeyStore: {
          input: {
            type: "structure",
            required: [
              "CustomKeyStoreId"
            ],
            members: {
              CustomKeyStoreId: {}
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        CreateAlias: {
          input: {
            type: "structure",
            required: [
              "AliasName",
              "TargetKeyId"
            ],
            members: {
              AliasName: {},
              TargetKeyId: {}
            }
          }
        },
        CreateCustomKeyStore: {
          input: {
            type: "structure",
            required: [
              "CustomKeyStoreName"
            ],
            members: {
              CustomKeyStoreName: {},
              CloudHsmClusterId: {},
              TrustAnchorCertificate: {},
              KeyStorePassword: {
                shape: "Sd"
              },
              CustomKeyStoreType: {},
              XksProxyUriEndpoint: {},
              XksProxyUriPath: {},
              XksProxyVpcEndpointServiceName: {},
              XksProxyAuthenticationCredential: {
                shape: "Si"
              },
              XksProxyConnectivity: {}
            }
          },
          output: {
            type: "structure",
            members: {
              CustomKeyStoreId: {}
            }
          }
        },
        CreateGrant: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "GranteePrincipal",
              "Operations"
            ],
            members: {
              KeyId: {},
              GranteePrincipal: {},
              RetiringPrincipal: {},
              Operations: {
                shape: "Sp"
              },
              Constraints: {
                shape: "Sr"
              },
              GrantTokens: {
                shape: "Sv"
              },
              Name: {}
            }
          },
          output: {
            type: "structure",
            members: {
              GrantToken: {},
              GrantId: {}
            }
          }
        },
        CreateKey: {
          input: {
            type: "structure",
            members: {
              Policy: {},
              Description: {},
              KeyUsage: {},
              CustomerMasterKeySpec: {
                shape: "S14",
                deprecated: true,
                deprecatedMessage: "This parameter has been deprecated. Instead, use the KeySpec parameter."
              },
              KeySpec: {},
              Origin: {},
              CustomKeyStoreId: {},
              BypassPolicyLockoutSafetyCheck: {
                type: "boolean"
              },
              Tags: {
                shape: "S18"
              },
              MultiRegion: {
                type: "boolean"
              },
              XksKeyId: {}
            }
          },
          output: {
            type: "structure",
            members: {
              KeyMetadata: {
                shape: "S1f"
              }
            }
          }
        },
        Decrypt: {
          input: {
            type: "structure",
            required: [
              "CiphertextBlob"
            ],
            members: {
              CiphertextBlob: {
                type: "blob"
              },
              EncryptionContext: {
                shape: "Ss"
              },
              GrantTokens: {
                shape: "Sv"
              },
              KeyId: {},
              EncryptionAlgorithm: {}
            }
          },
          output: {
            type: "structure",
            members: {
              KeyId: {},
              Plaintext: {
                shape: "S22"
              },
              EncryptionAlgorithm: {}
            }
          }
        },
        DeleteAlias: {
          input: {
            type: "structure",
            required: [
              "AliasName"
            ],
            members: {
              AliasName: {}
            }
          }
        },
        DeleteCustomKeyStore: {
          input: {
            type: "structure",
            required: [
              "CustomKeyStoreId"
            ],
            members: {
              CustomKeyStoreId: {}
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        DeleteImportedKeyMaterial: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {}
            }
          }
        },
        DescribeCustomKeyStores: {
          input: {
            type: "structure",
            members: {
              CustomKeyStoreId: {},
              CustomKeyStoreName: {},
              Limit: {
                type: "integer"
              },
              Marker: {}
            }
          },
          output: {
            type: "structure",
            members: {
              CustomKeyStores: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    CustomKeyStoreId: {},
                    CustomKeyStoreName: {},
                    CloudHsmClusterId: {},
                    TrustAnchorCertificate: {},
                    ConnectionState: {},
                    ConnectionErrorCode: {},
                    CreationDate: {
                      type: "timestamp"
                    },
                    CustomKeyStoreType: {},
                    XksProxyConfiguration: {
                      type: "structure",
                      members: {
                        Connectivity: {},
                        AccessKeyId: {
                          shape: "Sj"
                        },
                        UriEndpoint: {},
                        UriPath: {},
                        VpcEndpointServiceName: {}
                      }
                    }
                  }
                }
              },
              NextMarker: {},
              Truncated: {
                type: "boolean"
              }
            }
          }
        },
        DescribeKey: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {},
              GrantTokens: {
                shape: "Sv"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              KeyMetadata: {
                shape: "S1f"
              }
            }
          }
        },
        DisableKey: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {}
            }
          }
        },
        DisableKeyRotation: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {}
            }
          }
        },
        DisconnectCustomKeyStore: {
          input: {
            type: "structure",
            required: [
              "CustomKeyStoreId"
            ],
            members: {
              CustomKeyStoreId: {}
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        EnableKey: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {}
            }
          }
        },
        EnableKeyRotation: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {}
            }
          }
        },
        Encrypt: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "Plaintext"
            ],
            members: {
              KeyId: {},
              Plaintext: {
                shape: "S22"
              },
              EncryptionContext: {
                shape: "Ss"
              },
              GrantTokens: {
                shape: "Sv"
              },
              EncryptionAlgorithm: {}
            }
          },
          output: {
            type: "structure",
            members: {
              CiphertextBlob: {
                type: "blob"
              },
              KeyId: {},
              EncryptionAlgorithm: {}
            }
          }
        },
        GenerateDataKey: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {},
              EncryptionContext: {
                shape: "Ss"
              },
              NumberOfBytes: {
                type: "integer"
              },
              KeySpec: {},
              GrantTokens: {
                shape: "Sv"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              CiphertextBlob: {
                type: "blob"
              },
              Plaintext: {
                shape: "S22"
              },
              KeyId: {}
            }
          }
        },
        GenerateDataKeyPair: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "KeyPairSpec"
            ],
            members: {
              EncryptionContext: {
                shape: "Ss"
              },
              KeyId: {},
              KeyPairSpec: {},
              GrantTokens: {
                shape: "Sv"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              PrivateKeyCiphertextBlob: {
                type: "blob"
              },
              PrivateKeyPlaintext: {
                shape: "S22"
              },
              PublicKey: {
                type: "blob"
              },
              KeyId: {},
              KeyPairSpec: {}
            }
          }
        },
        GenerateDataKeyPairWithoutPlaintext: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "KeyPairSpec"
            ],
            members: {
              EncryptionContext: {
                shape: "Ss"
              },
              KeyId: {},
              KeyPairSpec: {},
              GrantTokens: {
                shape: "Sv"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              PrivateKeyCiphertextBlob: {
                type: "blob"
              },
              PublicKey: {
                type: "blob"
              },
              KeyId: {},
              KeyPairSpec: {}
            }
          }
        },
        GenerateDataKeyWithoutPlaintext: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {},
              EncryptionContext: {
                shape: "Ss"
              },
              KeySpec: {},
              NumberOfBytes: {
                type: "integer"
              },
              GrantTokens: {
                shape: "Sv"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              CiphertextBlob: {
                type: "blob"
              },
              KeyId: {}
            }
          }
        },
        GenerateMac: {
          input: {
            type: "structure",
            required: [
              "Message",
              "KeyId",
              "MacAlgorithm"
            ],
            members: {
              Message: {
                shape: "S22"
              },
              KeyId: {},
              MacAlgorithm: {},
              GrantTokens: {
                shape: "Sv"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Mac: {
                type: "blob"
              },
              MacAlgorithm: {},
              KeyId: {}
            }
          }
        },
        GenerateRandom: {
          input: {
            type: "structure",
            members: {
              NumberOfBytes: {
                type: "integer"
              },
              CustomKeyStoreId: {}
            }
          },
          output: {
            type: "structure",
            members: {
              Plaintext: {
                shape: "S22"
              }
            }
          }
        },
        GetKeyPolicy: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "PolicyName"
            ],
            members: {
              KeyId: {},
              PolicyName: {}
            }
          },
          output: {
            type: "structure",
            members: {
              Policy: {}
            }
          }
        },
        GetKeyRotationStatus: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {}
            }
          },
          output: {
            type: "structure",
            members: {
              KeyRotationEnabled: {
                type: "boolean"
              }
            }
          }
        },
        GetParametersForImport: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "WrappingAlgorithm",
              "WrappingKeySpec"
            ],
            members: {
              KeyId: {},
              WrappingAlgorithm: {},
              WrappingKeySpec: {}
            }
          },
          output: {
            type: "structure",
            members: {
              KeyId: {},
              ImportToken: {
                type: "blob"
              },
              PublicKey: {
                shape: "S22"
              },
              ParametersValidTo: {
                type: "timestamp"
              }
            }
          }
        },
        GetPublicKey: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {},
              GrantTokens: {
                shape: "Sv"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              KeyId: {},
              PublicKey: {
                type: "blob"
              },
              CustomerMasterKeySpec: {
                shape: "S14",
                deprecated: true,
                deprecatedMessage: "This field has been deprecated. Instead, use the KeySpec field."
              },
              KeySpec: {},
              KeyUsage: {},
              EncryptionAlgorithms: {
                shape: "S1m"
              },
              SigningAlgorithms: {
                shape: "S1o"
              }
            }
          }
        },
        ImportKeyMaterial: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "ImportToken",
              "EncryptedKeyMaterial"
            ],
            members: {
              KeyId: {},
              ImportToken: {
                type: "blob"
              },
              EncryptedKeyMaterial: {
                type: "blob"
              },
              ValidTo: {
                type: "timestamp"
              },
              ExpirationModel: {}
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        ListAliases: {
          input: {
            type: "structure",
            members: {
              KeyId: {},
              Limit: {
                type: "integer"
              },
              Marker: {}
            }
          },
          output: {
            type: "structure",
            members: {
              Aliases: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    AliasName: {},
                    AliasArn: {},
                    TargetKeyId: {},
                    CreationDate: {
                      type: "timestamp"
                    },
                    LastUpdatedDate: {
                      type: "timestamp"
                    }
                  }
                }
              },
              NextMarker: {},
              Truncated: {
                type: "boolean"
              }
            }
          }
        },
        ListGrants: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              Limit: {
                type: "integer"
              },
              Marker: {},
              KeyId: {},
              GrantId: {},
              GranteePrincipal: {}
            }
          },
          output: {
            shape: "S3o"
          }
        },
        ListKeyPolicies: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {},
              Limit: {
                type: "integer"
              },
              Marker: {}
            }
          },
          output: {
            type: "structure",
            members: {
              PolicyNames: {
                type: "list",
                member: {}
              },
              NextMarker: {},
              Truncated: {
                type: "boolean"
              }
            }
          }
        },
        ListKeys: {
          input: {
            type: "structure",
            members: {
              Limit: {
                type: "integer"
              },
              Marker: {}
            }
          },
          output: {
            type: "structure",
            members: {
              Keys: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    KeyId: {},
                    KeyArn: {}
                  }
                }
              },
              NextMarker: {},
              Truncated: {
                type: "boolean"
              }
            }
          }
        },
        ListResourceTags: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {},
              Limit: {
                type: "integer"
              },
              Marker: {}
            }
          },
          output: {
            type: "structure",
            members: {
              Tags: {
                shape: "S18"
              },
              NextMarker: {},
              Truncated: {
                type: "boolean"
              }
            }
          }
        },
        ListRetirableGrants: {
          input: {
            type: "structure",
            required: [
              "RetiringPrincipal"
            ],
            members: {
              Limit: {
                type: "integer"
              },
              Marker: {},
              RetiringPrincipal: {}
            }
          },
          output: {
            shape: "S3o"
          }
        },
        PutKeyPolicy: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "PolicyName",
              "Policy"
            ],
            members: {
              KeyId: {},
              PolicyName: {},
              Policy: {},
              BypassPolicyLockoutSafetyCheck: {
                type: "boolean"
              }
            }
          }
        },
        ReEncrypt: {
          input: {
            type: "structure",
            required: [
              "CiphertextBlob",
              "DestinationKeyId"
            ],
            members: {
              CiphertextBlob: {
                type: "blob"
              },
              SourceEncryptionContext: {
                shape: "Ss"
              },
              SourceKeyId: {},
              DestinationKeyId: {},
              DestinationEncryptionContext: {
                shape: "Ss"
              },
              SourceEncryptionAlgorithm: {},
              DestinationEncryptionAlgorithm: {},
              GrantTokens: {
                shape: "Sv"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              CiphertextBlob: {
                type: "blob"
              },
              SourceKeyId: {},
              KeyId: {},
              SourceEncryptionAlgorithm: {},
              DestinationEncryptionAlgorithm: {}
            }
          }
        },
        ReplicateKey: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "ReplicaRegion"
            ],
            members: {
              KeyId: {},
              ReplicaRegion: {},
              Policy: {},
              BypassPolicyLockoutSafetyCheck: {
                type: "boolean"
              },
              Description: {},
              Tags: {
                shape: "S18"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              ReplicaKeyMetadata: {
                shape: "S1f"
              },
              ReplicaPolicy: {},
              ReplicaTags: {
                shape: "S18"
              }
            }
          }
        },
        RetireGrant: {
          input: {
            type: "structure",
            members: {
              GrantToken: {},
              KeyId: {},
              GrantId: {}
            }
          }
        },
        RevokeGrant: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "GrantId"
            ],
            members: {
              KeyId: {},
              GrantId: {}
            }
          }
        },
        ScheduleKeyDeletion: {
          input: {
            type: "structure",
            required: [
              "KeyId"
            ],
            members: {
              KeyId: {},
              PendingWindowInDays: {
                type: "integer"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              KeyId: {},
              DeletionDate: {
                type: "timestamp"
              },
              KeyState: {},
              PendingWindowInDays: {
                type: "integer"
              }
            }
          }
        },
        Sign: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "Message",
              "SigningAlgorithm"
            ],
            members: {
              KeyId: {},
              Message: {
                shape: "S22"
              },
              MessageType: {},
              GrantTokens: {
                shape: "Sv"
              },
              SigningAlgorithm: {}
            }
          },
          output: {
            type: "structure",
            members: {
              KeyId: {},
              Signature: {
                type: "blob"
              },
              SigningAlgorithm: {}
            }
          }
        },
        TagResource: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "Tags"
            ],
            members: {
              KeyId: {},
              Tags: {
                shape: "S18"
              }
            }
          }
        },
        UntagResource: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "TagKeys"
            ],
            members: {
              KeyId: {},
              TagKeys: {
                type: "list",
                member: {}
              }
            }
          }
        },
        UpdateAlias: {
          input: {
            type: "structure",
            required: [
              "AliasName",
              "TargetKeyId"
            ],
            members: {
              AliasName: {},
              TargetKeyId: {}
            }
          }
        },
        UpdateCustomKeyStore: {
          input: {
            type: "structure",
            required: [
              "CustomKeyStoreId"
            ],
            members: {
              CustomKeyStoreId: {},
              NewCustomKeyStoreName: {},
              KeyStorePassword: {
                shape: "Sd"
              },
              CloudHsmClusterId: {},
              XksProxyUriEndpoint: {},
              XksProxyUriPath: {},
              XksProxyVpcEndpointServiceName: {},
              XksProxyAuthenticationCredential: {
                shape: "Si"
              },
              XksProxyConnectivity: {}
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        UpdateKeyDescription: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "Description"
            ],
            members: {
              KeyId: {},
              Description: {}
            }
          }
        },
        UpdatePrimaryRegion: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "PrimaryRegion"
            ],
            members: {
              KeyId: {},
              PrimaryRegion: {}
            }
          }
        },
        Verify: {
          input: {
            type: "structure",
            required: [
              "KeyId",
              "Message",
              "Signature",
              "SigningAlgorithm"
            ],
            members: {
              KeyId: {},
              Message: {
                shape: "S22"
              },
              MessageType: {},
              Signature: {
                type: "blob"
              },
              SigningAlgorithm: {},
              GrantTokens: {
                shape: "Sv"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              KeyId: {},
              SignatureValid: {
                type: "boolean"
              },
              SigningAlgorithm: {}
            }
          }
        },
        VerifyMac: {
          input: {
            type: "structure",
            required: [
              "Message",
              "KeyId",
              "MacAlgorithm",
              "Mac"
            ],
            members: {
              Message: {
                shape: "S22"
              },
              KeyId: {},
              MacAlgorithm: {},
              Mac: {
                type: "blob"
              },
              GrantTokens: {
                shape: "Sv"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              KeyId: {},
              MacValid: {
                type: "boolean"
              },
              MacAlgorithm: {}
            }
          }
        }
      },
      shapes: {
        Sd: {
          type: "string",
          sensitive: true
        },
        Si: {
          type: "structure",
          required: [
            "AccessKeyId",
            "RawSecretAccessKey"
          ],
          members: {
            AccessKeyId: {
              shape: "Sj"
            },
            RawSecretAccessKey: {
              type: "string",
              sensitive: true
            }
          }
        },
        Sj: {
          type: "string",
          sensitive: true
        },
        Sp: {
          type: "list",
          member: {}
        },
        Sr: {
          type: "structure",
          members: {
            EncryptionContextSubset: {
              shape: "Ss"
            },
            EncryptionContextEquals: {
              shape: "Ss"
            }
          }
        },
        Ss: {
          type: "map",
          key: {},
          value: {}
        },
        Sv: {
          type: "list",
          member: {}
        },
        S14: {
          type: "string",
          deprecated: true,
          deprecatedMessage: "This enum has been deprecated. Instead, use the KeySpec enum."
        },
        S18: {
          type: "list",
          member: {
            type: "structure",
            required: [
              "TagKey",
              "TagValue"
            ],
            members: {
              TagKey: {},
              TagValue: {}
            }
          }
        },
        S1f: {
          type: "structure",
          required: [
            "KeyId"
          ],
          members: {
            AWSAccountId: {},
            KeyId: {},
            Arn: {},
            CreationDate: {
              type: "timestamp"
            },
            Enabled: {
              type: "boolean"
            },
            Description: {},
            KeyUsage: {},
            KeyState: {},
            DeletionDate: {
              type: "timestamp"
            },
            ValidTo: {
              type: "timestamp"
            },
            Origin: {},
            CustomKeyStoreId: {},
            CloudHsmClusterId: {},
            ExpirationModel: {},
            KeyManager: {},
            CustomerMasterKeySpec: {
              shape: "S14",
              deprecated: true,
              deprecatedMessage: "This field has been deprecated. Instead, use the KeySpec field."
            },
            KeySpec: {},
            EncryptionAlgorithms: {
              shape: "S1m"
            },
            SigningAlgorithms: {
              shape: "S1o"
            },
            MultiRegion: {
              type: "boolean"
            },
            MultiRegionConfiguration: {
              type: "structure",
              members: {
                MultiRegionKeyType: {},
                PrimaryKey: {
                  shape: "S1s"
                },
                ReplicaKeys: {
                  type: "list",
                  member: {
                    shape: "S1s"
                  }
                }
              }
            },
            PendingDeletionWindowInDays: {
              type: "integer"
            },
            MacAlgorithms: {
              type: "list",
              member: {}
            },
            XksKeyConfiguration: {
              type: "structure",
              members: {
                Id: {}
              }
            }
          }
        },
        S1m: {
          type: "list",
          member: {}
        },
        S1o: {
          type: "list",
          member: {}
        },
        S1s: {
          type: "structure",
          members: {
            Arn: {},
            Region: {}
          }
        },
        S22: {
          type: "blob",
          sensitive: true
        },
        S3o: {
          type: "structure",
          members: {
            Grants: {
              type: "list",
              member: {
                type: "structure",
                members: {
                  KeyId: {},
                  GrantId: {},
                  Name: {},
                  CreationDate: {
                    type: "timestamp"
                  },
                  GranteePrincipal: {},
                  RetiringPrincipal: {},
                  IssuingAccount: {},
                  Operations: {
                    shape: "Sp"
                  },
                  Constraints: {
                    shape: "Sr"
                  }
                }
              }
            },
            NextMarker: {},
            Truncated: {
              type: "boolean"
            }
          }
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/kms-2014-11-01.paginators.json
var require_kms_2014_11_01_paginators = __commonJS({
  "node_modules/aws-sdk/apis/kms-2014-11-01.paginators.json"(exports2, module2) {
    module2.exports = {
      pagination: {
        DescribeCustomKeyStores: {
          input_token: "Marker",
          limit_key: "Limit",
          output_token: "NextMarker",
          result_key: "CustomKeyStores"
        },
        ListAliases: {
          input_token: "Marker",
          limit_key: "Limit",
          output_token: "NextMarker",
          result_key: "Aliases"
        },
        ListGrants: {
          input_token: "Marker",
          limit_key: "Limit",
          output_token: "NextMarker",
          result_key: "Grants"
        },
        ListKeyPolicies: {
          input_token: "Marker",
          limit_key: "Limit",
          output_token: "NextMarker",
          result_key: "PolicyNames"
        },
        ListKeys: {
          input_token: "Marker",
          limit_key: "Limit",
          output_token: "NextMarker",
          result_key: "Keys"
        },
        ListResourceTags: {
          input_token: "Marker",
          limit_key: "Limit",
          output_token: "NextMarker",
          result_key: "Tags"
        },
        ListRetirableGrants: {
          input_token: "Marker",
          limit_key: "Limit",
          output_token: "NextMarker",
          result_key: "Grants"
        }
      }
    };
  }
});

// node_modules/aws-sdk/clients/kms.js
var require_kms = __commonJS({
  "node_modules/aws-sdk/clients/kms.js"(exports2, module2) {
    require_node_loader();
    var AWS2 = require_core();
    var Service = AWS2.Service;
    var apiLoader = AWS2.apiLoader;
    apiLoader.services["kms"] = {};
    AWS2.KMS = Service.defineService("kms", ["2014-11-01"]);
    Object.defineProperty(apiLoader.services["kms"], "2014-11-01", {
      get: /* @__PURE__ */ __name(function get() {
        var model = require_kms_2014_11_01_min();
        model.paginators = require_kms_2014_11_01_paginators().pagination;
        return model;
      }, "get"),
      enumerable: true,
      configurable: true
    });
    module2.exports = AWS2.KMS;
  }
});

// node_modules/datadog-lambda-js/dist/metrics/kms-service.js
var require_kms_service = __commonJS({
  "node_modules/datadog-lambda-js/dist/metrics/kms-service.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KMSService = void 0;
    var utils_1 = require_utils2();
    var KMSService = function() {
      function KMSService2() {
      }
      __name(KMSService2, "KMSService");
      KMSService2.prototype.decrypt = function(ciphertext) {
        var _a;
        return __awaiter(this, void 0, void 0, function() {
          var kms, kmsClient, buffer, result, _b, encryptionContext, err_1, errorMsg;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                _c.trys.push([0, 6, , 7]);
                kms = require_kms();
                kmsClient = new kms();
                buffer = Buffer.from(ciphertext, "base64");
                result = void 0;
                _c.label = 1;
              case 1:
                _c.trys.push([1, 3, , 5]);
                return [4, kmsClient.decrypt({ CiphertextBlob: buffer }).promise()];
              case 2:
                result = _c.sent();
                return [3, 5];
              case 3:
                _b = _c.sent();
                encryptionContext = { LambdaFunctionName: (_a = process.env.AWS_LAMBDA_FUNCTION_NAME) !== null && _a !== void 0 ? _a : "" };
                return [4, kmsClient.decrypt({ CiphertextBlob: buffer, EncryptionContext: encryptionContext }).promise()];
              case 4:
                result = _c.sent();
                return [3, 5];
              case 5:
                if (result.Plaintext === void 0) {
                  throw Error();
                }
                return [2, result.Plaintext.toString("ascii")];
              case 6:
                err_1 = _c.sent();
                if (err_1.code === "MODULE_NOT_FOUND") {
                  errorMsg = "optional dependency aws-sdk not installed. KMS key decryption will not work";
                  (0, utils_1.logError)(errorMsg);
                  throw Error(errorMsg);
                }
                throw Error("Couldn't decrypt ciphertext");
              case 7:
                return [2];
            }
          });
        });
      };
      return KMSService2;
    }();
    exports2.KMSService = KMSService;
  }
});

// node_modules/datadog-lambda-js/dist/constants.js
var require_constants3 = __commonJS({
  "node_modules/datadog-lambda-js/dist/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.datadogLambdaVersion = void 0;
    exports2.datadogLambdaVersion = "6.87.0";
  }
});

// node_modules/datadog-lambda-js/dist/utils/arn.js
var require_arn = __commonJS({
  "node_modules/datadog-lambda-js/dist/utils/arn.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseTagsFromARN = exports2.parseLambdaARN = void 0;
    function parseLambdaARN(arn, version) {
      var _a;
      var region;
      var account_id;
      var functionname;
      var alias;
      var splitArn = arn.split(":");
      _a = __read(splitArn, 8), region = _a[3], account_id = _a[4], functionname = _a[6], alias = _a[7];
      var tags = { region, account_id, functionname };
      if (alias !== void 0) {
        if (alias.startsWith("$")) {
          alias = alias.substring(1);
        } else if (!Number(alias)) {
          tags.executedversion = version;
        }
        tags.resource = functionname + ":" + alias;
      } else {
        tags.resource = functionname;
      }
      return tags;
    }
    __name(parseLambdaARN, "parseLambdaARN");
    exports2.parseLambdaARN = parseLambdaARN;
    function makeTagStringsFromObject(tags) {
      return Object.entries(tags).map(function(_a) {
        var _b = __read(_a, 2), tagKey = _b[0], tagValue = _b[1];
        return "".concat(tagKey, ":").concat(tagValue);
      });
    }
    __name(makeTagStringsFromObject, "makeTagStringsFromObject");
    function parseTagsFromARN(arn, version) {
      return makeTagStringsFromObject(parseLambdaARN(arn, version));
    }
    __name(parseTagsFromARN, "parseTagsFromARN");
    exports2.parseTagsFromARN = parseTagsFromARN;
  }
});

// node_modules/datadog-lambda-js/dist/utils/process-version.js
var require_process_version = __commonJS({
  "node_modules/datadog-lambda-js/dist/utils/process-version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProcessVersion = void 0;
    function getProcessVersion() {
      return process.version;
    }
    __name(getProcessVersion, "getProcessVersion");
    exports2.getProcessVersion = getProcessVersion;
  }
});

// node_modules/datadog-lambda-js/dist/metrics/enhanced-metrics.js
var require_enhanced_metrics = __commonJS({
  "node_modules/datadog-lambda-js/dist/metrics/enhanced-metrics.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.incrementErrorsMetric = exports2.incrementInvocationsMetric = exports2.getEnhancedMetricTags = exports2.getRuntimeTag = exports2.getVersionTag = void 0;
    var constants_1 = require_constants3();
    var arn_1 = require_arn();
    var cold_start_1 = require_cold_start();
    var process_version_1 = require_process_version();
    var RuntimeTagValues;
    (function(RuntimeTagValues2) {
      RuntimeTagValues2["Node12"] = "nodejs12.x";
      RuntimeTagValues2["Node14"] = "nodejs14.x";
      RuntimeTagValues2["Node16"] = "nodejs16.x";
      RuntimeTagValues2["Node18"] = "nodejs18.x";
    })(RuntimeTagValues || (RuntimeTagValues = {}));
    function getVersionTag() {
      return "datadog_lambda:v".concat(constants_1.datadogLambdaVersion);
    }
    __name(getVersionTag, "getVersionTag");
    exports2.getVersionTag = getVersionTag;
    function getRuntimeTag() {
      var processVersion = (0, process_version_1.getProcessVersion)();
      var processVersionTagString = null;
      if (processVersion.startsWith("v12")) {
        processVersionTagString = RuntimeTagValues.Node12;
      }
      if (processVersion.startsWith("v14")) {
        processVersionTagString = RuntimeTagValues.Node14;
      }
      if (processVersion.startsWith("v16")) {
        processVersionTagString = RuntimeTagValues.Node16;
      }
      if (processVersion.startsWith("v18")) {
        processVersionTagString = RuntimeTagValues.Node18;
      }
      if (!processVersionTagString) {
        return null;
      }
      return "runtime:".concat(processVersionTagString);
    }
    __name(getRuntimeTag, "getRuntimeTag");
    exports2.getRuntimeTag = getRuntimeTag;
    function getEnhancedMetricTags(context) {
      var arnTags = ["functionname:".concat(context.functionName)];
      if (context.invokedFunctionArn) {
        arnTags = (0, arn_1.parseTagsFromARN)(context.invokedFunctionArn, context.functionVersion);
      }
      var tags = __spreadArray(__spreadArray([], __read(arnTags), false), [(0, cold_start_1.getColdStartTag)(), "memorysize:".concat(context.memoryLimitInMB), getVersionTag()], false);
      var runtimeTag = getRuntimeTag();
      if (runtimeTag) {
        tags.push(runtimeTag);
      }
      return tags;
    }
    __name(getEnhancedMetricTags, "getEnhancedMetricTags");
    exports2.getEnhancedMetricTags = getEnhancedMetricTags;
    function incrementEnhancedMetric(listener, metricName, context) {
      listener.sendDistributionMetric.apply(listener, __spreadArray(["aws.lambda.enhanced.".concat(metricName), 1, true], __read(getEnhancedMetricTags(context)), false));
    }
    __name(incrementEnhancedMetric, "incrementEnhancedMetric");
    function incrementInvocationsMetric(listener, context) {
      incrementEnhancedMetric(listener, "invocations", context);
    }
    __name(incrementInvocationsMetric, "incrementInvocationsMetric");
    exports2.incrementInvocationsMetric = incrementInvocationsMetric;
    function incrementErrorsMetric(listener, context) {
      incrementEnhancedMetric(listener, "errors", context);
    }
    __name(incrementErrorsMetric, "incrementErrorsMetric");
    exports2.incrementErrorsMetric = incrementErrorsMetric;
  }
});

// node_modules/datadog-lambda-js/dist/metrics/index.js
var require_metrics2 = __commonJS({
  "node_modules/datadog-lambda-js/dist/metrics/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.incrementInvocationsMetric = exports2.incrementErrorsMetric = exports2.KMSService = exports2.MetricsListener = void 0;
    var listener_1 = require_listener();
    Object.defineProperty(exports2, "MetricsListener", { enumerable: true, get: function() {
      return listener_1.MetricsListener;
    } });
    var kms_service_1 = require_kms_service();
    Object.defineProperty(exports2, "KMSService", { enumerable: true, get: function() {
      return kms_service_1.KMSService;
    } });
    var enhanced_metrics_1 = require_enhanced_metrics();
    Object.defineProperty(exports2, "incrementErrorsMetric", { enumerable: true, get: function() {
      return enhanced_metrics_1.incrementErrorsMetric;
    } });
    Object.defineProperty(exports2, "incrementInvocationsMetric", { enumerable: true, get: function() {
      return enhanced_metrics_1.incrementInvocationsMetric;
    } });
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        __name(BigNumber2, "BigNumber");
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          __name(toBaseOut, "toBaseOut");
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          __name(multiply, "multiply");
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          __name(compare2, "compare");
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          __name(subtract, "subtract");
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        __name(format, "format");
        function maxOrMin(args, method) {
          var n, i = 1, m = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            n = new BigNumber2(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        __name(maxOrMin, "maxOrMin");
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        __name(normalise, "normalise");
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        __name(round, "round");
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        __name(valueOf, "valueOf");
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      __name(clone, "clone");
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      __name(bitFloor, "bitFloor");
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      __name(coeffToString, "coeffToString");
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      __name(compare, "compare");
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      __name(intCheck, "intCheck");
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      __name(isOdd, "isOdd");
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      __name(toExponential, "toExponential");
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      __name(toFixedPoint, "toFixedPoint");
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// node_modules/datadog-lambda-js/dist/trace/constants.js
var require_constants4 = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.authorizingRequestIdHeader = exports2.parentSpanFinishTimeHeader = exports2.apiGatewayEventV2 = exports2.ddtraceVersion = exports2.awsXrayDaemonAddressEnvVar = exports2.xrayTraceEnvVar = exports2.xraySubsegmentNamespace = exports2.xrayLambdaFunctionTagsKey = exports2.xrayBaggageSubsegmentKey = exports2.xraySubsegmentKey = exports2.xraySubsegmentName = exports2.samplingPriorityHeader = exports2.parentIDHeader = exports2.traceIDHeader = exports2.Source = exports2.SampleMode = void 0;
    var SampleMode;
    (function(SampleMode2) {
      SampleMode2[SampleMode2["USER_REJECT"] = -1] = "USER_REJECT";
      SampleMode2[SampleMode2["AUTO_REJECT"] = 0] = "AUTO_REJECT";
      SampleMode2[SampleMode2["AUTO_KEEP"] = 1] = "AUTO_KEEP";
      SampleMode2[SampleMode2["USER_KEEP"] = 2] = "USER_KEEP";
    })(SampleMode = exports2.SampleMode || (exports2.SampleMode = {}));
    var Source;
    (function(Source2) {
      Source2["Xray"] = "xray";
      Source2["Event"] = "event";
      Source2["DDTrace"] = "ddtrace";
    })(Source = exports2.Source || (exports2.Source = {}));
    exports2.traceIDHeader = "x-datadog-trace-id";
    exports2.parentIDHeader = "x-datadog-parent-id";
    exports2.samplingPriorityHeader = "x-datadog-sampling-priority";
    exports2.xraySubsegmentName = "datadog-metadata";
    exports2.xraySubsegmentKey = "trace";
    exports2.xrayBaggageSubsegmentKey = "root_span_metadata";
    exports2.xrayLambdaFunctionTagsKey = "lambda_function_tags";
    exports2.xraySubsegmentNamespace = "datadog";
    exports2.xrayTraceEnvVar = "_X_AMZN_TRACE_ID";
    exports2.awsXrayDaemonAddressEnvVar = "AWS_XRAY_DAEMON_ADDRESS";
    exports2.ddtraceVersion = "";
    exports2.apiGatewayEventV2 = "2.0";
    exports2.parentSpanFinishTimeHeader = "x-datadog-parent-span-finish-time";
    exports2.authorizingRequestIdHeader = "x-datadog-authorizing-requestid";
  }
});

// node_modules/datadog-lambda-js/dist/utils/event-type-guards.js
var require_event_type_guards = __commonJS({
  "node_modules/datadog-lambda-js/dist/utils/event-type-guards.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isLambdaUrlEvent = exports2.isEventBridgeEvent = exports2.isAppSyncResolverEvent = exports2.isSNSSQSEvent = exports2.isSQSEvent = exports2.isSNSEvent = exports2.isS3Event = exports2.isKinesisStreamEvent = exports2.isDynamoDBStreamEvent = exports2.isCloudFrontRequestEvent = exports2.isCloudWatchEvent = exports2.isCloudWatchLogsEvent = exports2.isALBEvent = exports2.isAPIGatewayWebsocketEvent = exports2.isAPIGatewayEventV2 = exports2.isAPIGatewayEvent = void 0;
    var constants_1 = require_constants4();
    function isAPIGatewayEvent(event) {
      var _a;
      return ((_a = event.requestContext) === null || _a === void 0 ? void 0 : _a.stage) !== void 0 && event.httpMethod !== void 0 && event.resource !== void 0;
    }
    __name(isAPIGatewayEvent, "isAPIGatewayEvent");
    exports2.isAPIGatewayEvent = isAPIGatewayEvent;
    function isAPIGatewayEventV2(event) {
      return event.requestContext !== void 0 && event.version === constants_1.apiGatewayEventV2 && event.rawQueryString !== void 0 && !event.requestContext.domainName.includes("lambda-url");
    }
    __name(isAPIGatewayEventV2, "isAPIGatewayEventV2");
    exports2.isAPIGatewayEventV2 = isAPIGatewayEventV2;
    function isAPIGatewayWebsocketEvent(event) {
      return event.requestContext !== void 0 && event.requestContext.messageDirection !== void 0;
    }
    __name(isAPIGatewayWebsocketEvent, "isAPIGatewayWebsocketEvent");
    exports2.isAPIGatewayWebsocketEvent = isAPIGatewayWebsocketEvent;
    function isALBEvent(event) {
      return event.requestContext !== void 0 && event.requestContext.elb !== void 0;
    }
    __name(isALBEvent, "isALBEvent");
    exports2.isALBEvent = isALBEvent;
    function isCloudWatchLogsEvent(event) {
      return event.awslogs !== void 0;
    }
    __name(isCloudWatchLogsEvent, "isCloudWatchLogsEvent");
    exports2.isCloudWatchLogsEvent = isCloudWatchLogsEvent;
    function isCloudWatchEvent(event) {
      return event.source !== void 0 && event.source === "aws.events";
    }
    __name(isCloudWatchEvent, "isCloudWatchEvent");
    exports2.isCloudWatchEvent = isCloudWatchEvent;
    function isCloudFrontRequestEvent(event) {
      return Array.isArray(event.Records) && event.Records.length > 0 && event.Records[0].cf !== void 0;
    }
    __name(isCloudFrontRequestEvent, "isCloudFrontRequestEvent");
    exports2.isCloudFrontRequestEvent = isCloudFrontRequestEvent;
    function isDynamoDBStreamEvent(event) {
      return Array.isArray(event.Records) && event.Records.length > 0 && event.Records[0].dynamodb !== void 0;
    }
    __name(isDynamoDBStreamEvent, "isDynamoDBStreamEvent");
    exports2.isDynamoDBStreamEvent = isDynamoDBStreamEvent;
    function isKinesisStreamEvent(event) {
      return Array.isArray(event.Records) && event.Records.length > 0 && event.Records[0].kinesis !== void 0;
    }
    __name(isKinesisStreamEvent, "isKinesisStreamEvent");
    exports2.isKinesisStreamEvent = isKinesisStreamEvent;
    function isS3Event(event) {
      return Array.isArray(event.Records) && event.Records.length > 0 && event.Records[0].s3 !== void 0;
    }
    __name(isS3Event, "isS3Event");
    exports2.isS3Event = isS3Event;
    function isSNSEvent(event) {
      return Array.isArray(event.Records) && event.Records.length > 0 && event.Records[0].Sns !== void 0;
    }
    __name(isSNSEvent, "isSNSEvent");
    exports2.isSNSEvent = isSNSEvent;
    function isSQSEvent(event) {
      return Array.isArray(event.Records) && event.Records.length > 0 && event.Records[0].eventSource === "aws:sqs";
    }
    __name(isSQSEvent, "isSQSEvent");
    exports2.isSQSEvent = isSQSEvent;
    function isSNSSQSEvent(event) {
      if (Array.isArray(event.Records) && event.Records.length > 0 && event.Records[0].eventSource === "aws:sqs") {
        try {
          var body = JSON.parse(event.Records[0].body);
          if (body.Type === "Notification" && body.TopicArn) {
            return true;
          }
        } catch (e) {
          return false;
        }
      }
      return false;
    }
    __name(isSNSSQSEvent, "isSNSSQSEvent");
    exports2.isSNSSQSEvent = isSNSSQSEvent;
    function isAppSyncResolverEvent(event) {
      return event.info !== void 0 && event.info.selectionSetGraphQL !== void 0;
    }
    __name(isAppSyncResolverEvent, "isAppSyncResolverEvent");
    exports2.isAppSyncResolverEvent = isAppSyncResolverEvent;
    function isEventBridgeEvent(event) {
      return event["detail-type"] !== void 0;
    }
    __name(isEventBridgeEvent, "isEventBridgeEvent");
    exports2.isEventBridgeEvent = isEventBridgeEvent;
    function isLambdaUrlEvent(event) {
      var _a, _b;
      return (_b = (_a = event === null || event === void 0 ? void 0 : event.requestContext) === null || _a === void 0 ? void 0 : _a.domainName) === null || _b === void 0 ? void 0 : _b.includes("lambda-url");
    }
    __name(isLambdaUrlEvent, "isLambdaUrlEvent");
    exports2.isLambdaUrlEvent = isLambdaUrlEvent;
  }
});

// node_modules/datadog-lambda-js/dist/trace/trigger.js
var require_trigger = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/trigger.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractHTTPStatusCodeTag = exports2.extractTriggerTags = exports2.parseEventSourceARN = exports2.parseEventSource = exports2.parseEventSourceSubType = exports2.eventSubTypes = exports2.eventTypes = void 0;
    var eventType = __importStar(require_event_type_guards());
    var utils_1 = require_utils2();
    var zlib_1 = __require("zlib");
    function isHTTPTriggerEvent(eventSource) {
      return eventSource === "api-gateway" || eventSource === "application-load-balancer" || eventSource === "lambda-function-url";
    }
    __name(isHTTPTriggerEvent, "isHTTPTriggerEvent");
    function getAWSPartitionByRegion(region) {
      if (region.startsWith("us-gov-")) {
        return "aws-us-gov";
      } else if (region.startsWith("cn-")) {
        return "aws-cn";
      } else {
        return "aws";
      }
    }
    __name(getAWSPartitionByRegion, "getAWSPartitionByRegion");
    function extractAPIGatewayRequestContext(event) {
      return event.requestContext;
    }
    __name(extractAPIGatewayRequestContext, "extractAPIGatewayRequestContext");
    function extractCloudFrontRequestEventDistributionId(event) {
      return event.Records[0].cf.config.distributionId;
    }
    __name(extractCloudFrontRequestEventDistributionId, "extractCloudFrontRequestEventDistributionId");
    function extractCloudWatchLogsEventDecodedLogs(event) {
      var buffer = Buffer.from(event.awslogs.data, "base64");
      var decompressed = (0, zlib_1.gunzipSync)(buffer).toString();
      return JSON.parse(decompressed);
    }
    __name(extractCloudWatchLogsEventDecodedLogs, "extractCloudWatchLogsEventDecodedLogs");
    function extractALBEventARN(event) {
      return event.requestContext.elb.targetGroupArn;
    }
    __name(extractALBEventARN, "extractALBEventARN");
    function extractCloudWatchEventARN(event) {
      return event.resources[0];
    }
    __name(extractCloudWatchEventARN, "extractCloudWatchEventARN");
    function extractDynamoDBStreamEventARN(event) {
      return event.Records[0].eventSourceARN;
    }
    __name(extractDynamoDBStreamEventARN, "extractDynamoDBStreamEventARN");
    function extractKinesisStreamEventARN(event) {
      return event.Records[0].eventSourceARN;
    }
    __name(extractKinesisStreamEventARN, "extractKinesisStreamEventARN");
    function extractS3EventARN(event) {
      return event.Records[0].s3.bucket.arn;
    }
    __name(extractS3EventARN, "extractS3EventARN");
    function extractSNSEventARN(event) {
      return event.Records[0].Sns.TopicArn;
    }
    __name(extractSNSEventARN, "extractSNSEventARN");
    function extractSQSEventARN(event) {
      return event.Records[0].eventSourceARN;
    }
    __name(extractSQSEventARN, "extractSQSEventARN");
    function extractEventBridgeARN(event) {
      return event.source;
    }
    __name(extractEventBridgeARN, "extractEventBridgeARN");
    var eventTypes;
    (function(eventTypes2) {
      eventTypes2["apiGateway"] = "api-gateway";
      eventTypes2["applicationLoadBalancer"] = "application-load-balancer";
      eventTypes2["cloudFront"] = "cloudfront";
      eventTypes2["cloudWatchEvents"] = "cloudwatch-events";
      eventTypes2["cloudWatchLogs"] = "cloudwatch-logs";
      eventTypes2["cloudWatch"] = "cloudwatch";
      eventTypes2["dynamoDB"] = "dynamodb";
      eventTypes2["eventBridge"] = "eventbridge";
      eventTypes2["kinesis"] = "kinesis";
      eventTypes2["lambdaUrl"] = "lambda-function-url";
      eventTypes2["s3"] = "s3";
      eventTypes2["sns"] = "sns";
      eventTypes2["sqs"] = "sqs";
    })(eventTypes = exports2.eventTypes || (exports2.eventTypes = {}));
    var eventSubTypes;
    (function(eventSubTypes2) {
      eventSubTypes2["apiGatewayV1"] = "api-gateway-rest-api";
      eventSubTypes2["apiGatewayV2"] = "api-gateway-http-api";
      eventSubTypes2["apiGatewayWebsocket"] = "api-gateway-websocket";
      eventSubTypes2["unknown"] = "unknown-sub-type";
    })(eventSubTypes = exports2.eventSubTypes || (exports2.eventSubTypes = {}));
    function parseEventSourceSubType(event) {
      if (eventType.isAPIGatewayEvent(event)) {
        return eventSubTypes.apiGatewayV1;
      }
      if (eventType.isAPIGatewayEventV2(event)) {
        return eventSubTypes.apiGatewayV2;
      }
      if (eventType.isAPIGatewayWebsocketEvent(event)) {
        return eventSubTypes.apiGatewayWebsocket;
      }
      return eventSubTypes.unknown;
    }
    __name(parseEventSourceSubType, "parseEventSourceSubType");
    exports2.parseEventSourceSubType = parseEventSourceSubType;
    function parseEventSource(event) {
      if (eventType.isLambdaUrlEvent(event)) {
        return eventTypes.lambdaUrl;
      }
      if (eventType.isAPIGatewayEvent(event) || eventType.isAPIGatewayEventV2(event) || eventType.isAPIGatewayWebsocketEvent(event)) {
        return eventTypes.apiGateway;
      }
      if (eventType.isALBEvent(event)) {
        return eventTypes.applicationLoadBalancer;
      }
      if (eventType.isCloudWatchLogsEvent(event)) {
        return eventTypes.cloudWatchLogs;
      }
      if (eventType.isCloudWatchEvent(event)) {
        return eventTypes.cloudWatchEvents;
      }
      if (eventType.isCloudFrontRequestEvent(event)) {
        return eventTypes.cloudFront;
      }
      if (eventType.isDynamoDBStreamEvent(event)) {
        return eventTypes.dynamoDB;
      }
      if (eventType.isKinesisStreamEvent(event)) {
        return eventTypes.kinesis;
      }
      if (eventType.isS3Event(event)) {
        return eventTypes.s3;
      }
      if (eventType.isSNSEvent(event)) {
        return eventTypes.sns;
      }
      if (eventType.isSQSEvent(event)) {
        return eventTypes.sqs;
      }
      if (eventType.isEventBridgeEvent(event)) {
        return eventTypes.eventBridge;
      }
    }
    __name(parseEventSource, "parseEventSource");
    exports2.parseEventSource = parseEventSource;
    function parseEventSourceARN(source, event, context) {
      var splitFunctionArn = context.invokedFunctionArn.split(":");
      var region = splitFunctionArn[3];
      var accountId = splitFunctionArn[4];
      var awsARN = getAWSPartitionByRegion(region);
      var eventSourceARN;
      if (source === "s3") {
        eventSourceARN = extractS3EventARN(event);
      }
      if (source === "sns") {
        eventSourceARN = extractSNSEventARN(event);
      }
      if (source === "sqs") {
        eventSourceARN = extractSQSEventARN(event);
      }
      if (source === "cloudfront") {
        var distributionId = extractCloudFrontRequestEventDistributionId(event);
        eventSourceARN = "arn:".concat(awsARN, ":cloudfront::").concat(accountId, ":distribution/").concat(distributionId);
      }
      if (source === "api-gateway") {
        var requestContext = extractAPIGatewayRequestContext(event);
        eventSourceARN = "arn:".concat(awsARN, ":apigateway:").concat(region, "::/restapis/").concat(requestContext.apiId, "/stages/").concat(requestContext.stage);
      }
      if (source === "application-load-balancer") {
        eventSourceARN = extractALBEventARN(event);
      }
      if (source === "cloudwatch-logs") {
        var logs = extractCloudWatchLogsEventDecodedLogs(event);
        eventSourceARN = "arn:".concat(awsARN, ":logs:").concat(region, ":").concat(accountId, ":log-group:").concat(logs.logGroup);
      }
      if (source === "cloudwatch-events") {
        eventSourceARN = extractCloudWatchEventARN(event);
      }
      if (source === "dynamodb") {
        eventSourceARN = extractDynamoDBStreamEventARN(event);
      }
      if (source === "kinesis") {
        eventSourceARN = extractKinesisStreamEventARN(event);
      }
      if (source === "eventbridge") {
        eventSourceARN = extractEventBridgeARN(event);
      }
      return eventSourceARN;
    }
    __name(parseEventSourceARN, "parseEventSourceARN");
    exports2.parseEventSourceARN = parseEventSourceARN;
    function extractHTTPTags(event) {
      var _a, _b, _c;
      var httpTags = {};
      if (eventType.isAPIGatewayEvent(event)) {
        var requestContext = event.requestContext;
        if (requestContext.domainName) {
          httpTags["http.url"] = requestContext.domainName;
        }
        httpTags["http.url_details.path"] = requestContext.path;
        httpTags["http.method"] = requestContext.httpMethod;
        if ((_a = event.headers) === null || _a === void 0 ? void 0 : _a.Referer) {
          httpTags["http.referer"] = event.headers.Referer;
        }
        return httpTags;
      }
      if (eventType.isAPIGatewayEventV2(event)) {
        var requestContext = event.requestContext;
        httpTags["http.url"] = requestContext.domainName;
        httpTags["http.url_details.path"] = requestContext.http.path;
        httpTags["http.method"] = requestContext.http.method;
        if ((_b = event.headers) === null || _b === void 0 ? void 0 : _b.Referer) {
          httpTags["http.referer"] = event.headers.Referer;
        }
        return httpTags;
      }
      if (eventType.isALBEvent(event)) {
        httpTags["http.url_details.path"] = event.path;
        httpTags["http.method"] = event.httpMethod;
        if (event.headers && event.headers.Referer) {
          httpTags["http.referer"] = event.headers.Referer;
        }
        return httpTags;
      }
      if (eventType.isLambdaUrlEvent(event)) {
        var requestContext = event.requestContext;
        if (requestContext.domainName) {
          httpTags["http.url"] = requestContext.domainName;
        }
        httpTags["http.url_details.path"] = requestContext.http.path;
        httpTags["http.method"] = requestContext.http.method;
        if ((_c = event.headers) === null || _c === void 0 ? void 0 : _c.Referer) {
          httpTags["http.referer"] = event.headers.Referer;
        }
        return httpTags;
      }
    }
    __name(extractHTTPTags, "extractHTTPTags");
    function extractTriggerTags(event, context) {
      var triggerTags = {};
      var eventSource = parseEventSource(event);
      if (eventSource) {
        triggerTags["function_trigger.event_source"] = eventSource;
        var eventSourceARN = void 0;
        try {
          eventSourceARN = parseEventSourceARN(eventSource, event, context);
        } catch (error) {
          (0, utils_1.logDebug)("failed to extract ".concat(eventSource, " arn from the event"), { error });
        }
        if (eventSourceARN) {
          triggerTags["function_trigger.event_source_arn"] = eventSourceARN;
        }
      }
      if (isHTTPTriggerEvent(eventSource)) {
        try {
          triggerTags = __assign(__assign({}, triggerTags), extractHTTPTags(event));
        } catch (error) {
          (0, utils_1.logDebug)("failed to extract http tags from ".concat(eventSource, " event"));
        }
      }
      return triggerTags;
    }
    __name(extractTriggerTags, "extractTriggerTags");
    exports2.extractTriggerTags = extractTriggerTags;
    function extractHTTPStatusCodeTag(triggerTags, result) {
      var eventSource;
      triggerTags ? eventSource = triggerTags["function_trigger.event_source"] : eventSource = void 0;
      if (!isHTTPTriggerEvent(eventSource)) {
        return;
      }
      var resultStatusCode = result === null || result === void 0 ? void 0 : result.statusCode;
      if (result === void 0) {
        return "502";
      } else if (resultStatusCode) {
        if (typeof resultStatusCode === "number") {
          return resultStatusCode.toString();
        }
      } else {
        return "200";
      }
    }
    __name(extractHTTPStatusCodeTag, "extractHTTPStatusCodeTag");
    exports2.extractHTTPStatusCodeTag = extractHTTPStatusCodeTag;
  }
});

// node_modules/ts-md5/dist/esm/md5.js
var Md5;
var init_md5 = __esm({
  "node_modules/ts-md5/dist/esm/md5.js"() {
    Md5 = class {
      constructor() {
        this._dataLength = 0;
        this._bufferLength = 0;
        this._state = new Int32Array(4);
        this._buffer = new ArrayBuffer(68);
        this._buffer8 = new Uint8Array(this._buffer, 0, 68);
        this._buffer32 = new Uint32Array(this._buffer, 0, 17);
        this.start();
      }
      static hashStr(str, raw = false) {
        return this.onePassHasher.start().appendStr(str).end(raw);
      }
      static hashAsciiStr(str, raw = false) {
        return this.onePassHasher.start().appendAsciiStr(str).end(raw);
      }
      static _hex(x) {
        const hc = Md5.hexChars;
        const ho = Md5.hexOut;
        let n;
        let offset;
        let j;
        let i;
        for (i = 0; i < 4; i += 1) {
          offset = i * 8;
          n = x[i];
          for (j = 0; j < 8; j += 2) {
            ho[offset + 1 + j] = hc.charAt(n & 15);
            n >>>= 4;
            ho[offset + 0 + j] = hc.charAt(n & 15);
            n >>>= 4;
          }
        }
        return ho.join("");
      }
      static _md5cycle(x, k) {
        let a = x[0];
        let b = x[1];
        let c = x[2];
        let d = x[3];
        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
      }
      start() {
        this._dataLength = 0;
        this._bufferLength = 0;
        this._state.set(Md5.stateIdentity);
        return this;
      }
      appendStr(str) {
        const buf8 = this._buffer8;
        const buf32 = this._buffer32;
        let bufLen = this._bufferLength;
        let code;
        let i;
        for (i = 0; i < str.length; i += 1) {
          code = str.charCodeAt(i);
          if (code < 128) {
            buf8[bufLen++] = code;
          } else if (code < 2048) {
            buf8[bufLen++] = (code >>> 6) + 192;
            buf8[bufLen++] = code & 63 | 128;
          } else if (code < 55296 || code > 56319) {
            buf8[bufLen++] = (code >>> 12) + 224;
            buf8[bufLen++] = code >>> 6 & 63 | 128;
            buf8[bufLen++] = code & 63 | 128;
          } else {
            code = (code - 55296) * 1024 + (str.charCodeAt(++i) - 56320) + 65536;
            if (code > 1114111) {
              throw new Error("Unicode standard supports code points up to U+10FFFF");
            }
            buf8[bufLen++] = (code >>> 18) + 240;
            buf8[bufLen++] = code >>> 12 & 63 | 128;
            buf8[bufLen++] = code >>> 6 & 63 | 128;
            buf8[bufLen++] = code & 63 | 128;
          }
          if (bufLen >= 64) {
            this._dataLength += 64;
            Md5._md5cycle(this._state, buf32);
            bufLen -= 64;
            buf32[0] = buf32[16];
          }
        }
        this._bufferLength = bufLen;
        return this;
      }
      appendAsciiStr(str) {
        const buf8 = this._buffer8;
        const buf32 = this._buffer32;
        let bufLen = this._bufferLength;
        let i;
        let j = 0;
        for (; ; ) {
          i = Math.min(str.length - j, 64 - bufLen);
          while (i--) {
            buf8[bufLen++] = str.charCodeAt(j++);
          }
          if (bufLen < 64) {
            break;
          }
          this._dataLength += 64;
          Md5._md5cycle(this._state, buf32);
          bufLen = 0;
        }
        this._bufferLength = bufLen;
        return this;
      }
      appendByteArray(input) {
        const buf8 = this._buffer8;
        const buf32 = this._buffer32;
        let bufLen = this._bufferLength;
        let i;
        let j = 0;
        for (; ; ) {
          i = Math.min(input.length - j, 64 - bufLen);
          while (i--) {
            buf8[bufLen++] = input[j++];
          }
          if (bufLen < 64) {
            break;
          }
          this._dataLength += 64;
          Md5._md5cycle(this._state, buf32);
          bufLen = 0;
        }
        this._bufferLength = bufLen;
        return this;
      }
      getState() {
        const s = this._state;
        return {
          buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)),
          buflen: this._bufferLength,
          length: this._dataLength,
          state: [s[0], s[1], s[2], s[3]]
        };
      }
      setState(state) {
        const buf = state.buffer;
        const x = state.state;
        const s = this._state;
        let i;
        this._dataLength = state.length;
        this._bufferLength = state.buflen;
        s[0] = x[0];
        s[1] = x[1];
        s[2] = x[2];
        s[3] = x[3];
        for (i = 0; i < buf.length; i += 1) {
          this._buffer8[i] = buf.charCodeAt(i);
        }
      }
      end(raw = false) {
        const bufLen = this._bufferLength;
        const buf8 = this._buffer8;
        const buf32 = this._buffer32;
        const i = (bufLen >> 2) + 1;
        this._dataLength += bufLen;
        const dataBitsLen = this._dataLength * 8;
        buf8[bufLen] = 128;
        buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
        buf32.set(Md5.buffer32Identity.subarray(i), i);
        if (bufLen > 55) {
          Md5._md5cycle(this._state, buf32);
          buf32.set(Md5.buffer32Identity);
        }
        if (dataBitsLen <= 4294967295) {
          buf32[14] = dataBitsLen;
        } else {
          const matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
          if (matches === null) {
            return;
          }
          const lo = parseInt(matches[2], 16);
          const hi = parseInt(matches[1], 16) || 0;
          buf32[14] = lo;
          buf32[15] = hi;
        }
        Md5._md5cycle(this._state, buf32);
        return raw ? this._state : Md5._hex(this._state);
      }
    };
    __name(Md5, "Md5");
    Md5.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
    Md5.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Md5.hexChars = "0123456789abcdef";
    Md5.hexOut = [];
    Md5.onePassHasher = new Md5();
    if (Md5.hashStr("hello") !== "5d41402abc4b2a76b9719d911017c592") {
      throw new Error("Md5 self test failed.");
    }
  }
});

// node_modules/ts-md5/dist/esm/md5_file_hasher.js
var Md5FileHasher;
var init_md5_file_hasher = __esm({
  "node_modules/ts-md5/dist/esm/md5_file_hasher.js"() {
    init_md5();
    Md5FileHasher = class {
      constructor(_callback, _async = true, _partSize = 1048576) {
        this._callback = _callback;
        this._async = _async;
        this._partSize = _partSize;
        this._configureReader();
      }
      hash(blob) {
        const self2 = this;
        self2._blob = blob;
        self2._part = 0;
        self2._md5 = new Md5();
        self2._processPart();
      }
      _fail() {
        this._callback({
          success: false,
          result: "data read failed"
        });
      }
      _hashData(e) {
        let self2 = this;
        self2._md5.appendByteArray(new Uint8Array(e.target.result));
        if (self2._part * self2._partSize >= self2._blob.size) {
          self2._callback({
            success: true,
            result: self2._md5.end()
          });
        } else {
          self2._processPart();
        }
      }
      _processPart() {
        const self2 = this;
        let endbyte = 0;
        let current_part;
        self2._part += 1;
        if (self2._blob.size > self2._partSize) {
          endbyte = self2._part * self2._partSize;
          if (endbyte > self2._blob.size) {
            endbyte = self2._blob.size;
          }
          current_part = self2._blob.slice((self2._part - 1) * self2._partSize, endbyte);
        } else {
          current_part = self2._blob;
        }
        if (self2._async) {
          self2._reader.readAsArrayBuffer(current_part);
        } else {
          setTimeout(() => {
            try {
              self2._hashData({
                target: {
                  result: self2._reader.readAsArrayBuffer(current_part)
                }
              });
            } catch (e) {
              self2._fail();
            }
          }, 0);
        }
      }
      _configureReader() {
        const self2 = this;
        if (self2._async) {
          self2._reader = new FileReader();
          self2._reader.onload = self2._hashData.bind(self2);
          self2._reader.onerror = self2._fail.bind(self2);
          self2._reader.onabort = self2._fail.bind(self2);
        } else {
          self2._reader = new FileReaderSync();
        }
      }
    };
    __name(Md5FileHasher, "Md5FileHasher");
  }
});

// node_modules/ts-md5/dist/esm/parallel_hasher.js
var ParallelHasher;
var init_parallel_hasher = __esm({
  "node_modules/ts-md5/dist/esm/parallel_hasher.js"() {
    ParallelHasher = class {
      constructor(workerUri, workerOptions) {
        this._queue = [];
        this._ready = true;
        const self2 = this;
        if (Worker) {
          self2._hashWorker = new Worker(workerUri, workerOptions);
          self2._hashWorker.onmessage = self2._recievedMessage.bind(self2);
          self2._hashWorker.onerror = (err) => {
            self2._ready = false;
            console.error("Hash worker failure", err);
          };
        } else {
          self2._ready = false;
          console.error("Web Workers are not supported in this browser");
        }
      }
      hash(blob) {
        const self2 = this;
        let promise;
        promise = new Promise((resolve, reject) => {
          self2._queue.push({
            blob,
            resolve,
            reject
          });
          self2._processNext();
        });
        return promise;
      }
      terminate() {
        this._ready = false;
        this._hashWorker.terminate();
      }
      _processNext() {
        if (this._ready && !this._processing && this._queue.length > 0) {
          this._processing = this._queue.pop();
          this._hashWorker.postMessage(this._processing.blob);
        }
      }
      _recievedMessage(evt) {
        var _a, _b;
        const data = evt.data;
        if (data.success) {
          (_a = this._processing) === null || _a === void 0 ? void 0 : _a.resolve(data.result);
        } else {
          (_b = this._processing) === null || _b === void 0 ? void 0 : _b.reject(data.result);
        }
        this._processing = void 0;
        this._processNext();
      }
    };
    __name(ParallelHasher, "ParallelHasher");
  }
});

// node_modules/ts-md5/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Md5: () => Md5,
  Md5FileHasher: () => Md5FileHasher,
  ParallelHasher: () => ParallelHasher
});
var init_esm = __esm({
  "node_modules/ts-md5/dist/esm/index.js"() {
    init_md5();
    init_md5_file_hasher();
    init_parallel_hasher();
  }
});

// node_modules/datadog-lambda-js/dist/trace/context.js
var require_context = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/context.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertToAPMParentID = exports2.convertToAPMTraceID = exports2.convertToSampleMode = exports2.readStepFunctionContextFromEvent = exports2.readTraceContextFromXray = exports2.readTraceFromEvent = exports2.readTraceFromHTTPEvent = exports2.getInjectedAuthorizerData = exports2.readTraceFromLambdaContext = exports2.readTraceFromSNSEvent = exports2.readTraceFromEventbridgeEvent = exports2.readTraceFromKinesisEvent = exports2.readTraceFromSNSSQSEvent = exports2.readTraceFromSQSEvent = exports2.readTraceFromAppSyncEvent = exports2.sendXraySubsegment = exports2.generateXraySubsegment = exports2.addXrayMetadata = exports2.addLambdaFunctionTagsToXray = exports2.addStepFunctionContextToXray = exports2.addTraceContextToXray = exports2.extractTraceContext = exports2.deterministicMd5HashToBigIntString = exports2.deterministicMd5HashInBinary = exports2.hexToBinary = exports2.readTraceFromStepFunctionsContext = void 0;
    var bignumber_js_1 = require_bignumber();
    var crypto_1 = __require("crypto");
    var dgram_1 = __require("dgram");
    var utils_1 = require_utils2();
    var event_type_guards_1 = require_event_type_guards();
    var constants_1 = require_constants4();
    var trigger_1 = require_trigger();
    var ts_md5_1 = (init_esm(), __toCommonJS(esm_exports));
    function readTraceFromStepFunctionsContext(stepFunctionContext) {
      return {
        traceID: deterministicMd5HashToBigIntString(stepFunctionContext["step_function.execution_id"]),
        parentID: deterministicMd5HashToBigIntString(stepFunctionContext["step_function.execution_id"] + "#" + stepFunctionContext["step_function.state_name"] + "#" + stepFunctionContext["step_function.state_entered_time"]),
        sampleMode: constants_1.SampleMode.AUTO_KEEP.valueOf(),
        source: constants_1.Source.Event
      };
    }
    __name(readTraceFromStepFunctionsContext, "readTraceFromStepFunctionsContext");
    exports2.readTraceFromStepFunctionsContext = readTraceFromStepFunctionsContext;
    function hexToBinary(hex) {
      return parseInt(hex, 16).toString(2).padStart(4, "0");
    }
    __name(hexToBinary, "hexToBinary");
    exports2.hexToBinary = hexToBinary;
    function deterministicMd5HashInBinary(s) {
      var hex = ts_md5_1.Md5.hashStr(s);
      var binary = "";
      for (var i = 0; i < hex.length; i++) {
        var ch = hex.charAt(i);
        binary = binary + hexToBinary(ch);
      }
      var res = "0" + binary.substring(1, 64);
      if (res === "0".repeat(64)) {
        return "1";
      }
      return res;
    }
    __name(deterministicMd5HashInBinary, "deterministicMd5HashInBinary");
    exports2.deterministicMd5HashInBinary = deterministicMd5HashInBinary;
    function deterministicMd5HashToBigIntString(s) {
      var binaryString = deterministicMd5HashInBinary(s);
      return BigInt("0b" + binaryString).toString();
    }
    __name(deterministicMd5HashToBigIntString, "deterministicMd5HashToBigIntString");
    exports2.deterministicMd5HashToBigIntString = deterministicMd5HashToBigIntString;
    function extractTraceContext(event, context, extractor, decodeAuthorizerContext) {
      if (decodeAuthorizerContext === void 0) {
        decodeAuthorizerContext = true;
      }
      var trace;
      if (extractor) {
        try {
          trace = extractor(event, context);
          (0, utils_1.logDebug)("extracted trace context from the custom extractor", { trace });
        } catch (error) {
          if (error instanceof Error) {
            (0, utils_1.logError)("custom extractor function failed", error);
          }
        }
      }
      if (!trace) {
        trace = readTraceFromEvent(event, decodeAuthorizerContext);
      }
      if (!trace) {
        trace = readTraceFromLambdaContext(context);
      }
      var stepFuncContext = readStepFunctionContextFromEvent(event);
      if (stepFuncContext) {
        try {
          addStepFunctionContextToXray(stepFuncContext);
        } catch (error) {
          if (error instanceof Error) {
            (0, utils_1.logError)("couldn't add step function metadata to xray", error);
          }
        }
        if (trace === void 0) {
          trace = readTraceFromStepFunctionsContext(stepFuncContext);
          if (trace !== void 0) {
            return trace;
          }
        }
      }
      if (trace !== void 0) {
        try {
          addTraceContextToXray(trace);
          (0, utils_1.logDebug)("added trace context to xray metadata", { trace });
        } catch (error) {
          if (error instanceof Error) {
            (0, utils_1.logError)("couldn't add trace context to xray metadata", error);
          }
        }
        return trace;
      }
      return readTraceContextFromXray();
    }
    __name(extractTraceContext, "extractTraceContext");
    exports2.extractTraceContext = extractTraceContext;
    function addTraceContextToXray(traceContext) {
      var val = {
        "parent-id": traceContext.parentID,
        "sampling-priority": traceContext.sampleMode.toString(10),
        "trace-id": traceContext.traceID
      };
      addXrayMetadata(constants_1.xraySubsegmentKey, val);
    }
    __name(addTraceContextToXray, "addTraceContextToXray");
    exports2.addTraceContextToXray = addTraceContextToXray;
    function addStepFunctionContextToXray(context) {
      addXrayMetadata(constants_1.xrayBaggageSubsegmentKey, context);
    }
    __name(addStepFunctionContextToXray, "addStepFunctionContextToXray");
    exports2.addStepFunctionContextToXray = addStepFunctionContextToXray;
    function addLambdaFunctionTagsToXray(triggerTags) {
      addXrayMetadata(constants_1.xrayLambdaFunctionTagsKey, triggerTags);
    }
    __name(addLambdaFunctionTagsToXray, "addLambdaFunctionTagsToXray");
    exports2.addLambdaFunctionTagsToXray = addLambdaFunctionTagsToXray;
    function addXrayMetadata(key, metadata) {
      var segment = generateXraySubsegment(key, metadata);
      if (segment === void 0) {
        return;
      }
      sendXraySubsegment(segment);
    }
    __name(addXrayMetadata, "addXrayMetadata");
    exports2.addXrayMetadata = addXrayMetadata;
    function generateXraySubsegment(key, metadata) {
      var _a, _b;
      var header = process.env[constants_1.xrayTraceEnvVar];
      if (header === void 0) {
        (0, utils_1.logDebug)("couldn't read xray trace header from env");
        return;
      }
      var context = parseXrayTraceContextHeader(header);
      if (context === void 0) {
        (0, utils_1.logDebug)("couldn't parse xray trace header from env");
        return;
      }
      var sampled = convertToSampleMode(parseInt(context.xraySampled, 10));
      if (sampled === constants_1.SampleMode.USER_REJECT || sampled === constants_1.SampleMode.AUTO_REJECT) {
        (0, utils_1.logDebug)("discarding xray metadata subsegment due to sampling");
        return;
      }
      var time = Date.now() * 1e-3;
      return JSON.stringify({
        id: (0, crypto_1.randomBytes)(8).toString("hex"),
        trace_id: context.xrayTraceID,
        parent_id: context.xrayParentID,
        name: constants_1.xraySubsegmentName,
        start_time: time,
        end_time: time,
        type: "subsegment",
        metadata: (_a = {}, _a[constants_1.xraySubsegmentNamespace] = (_b = {}, _b[key] = metadata, _b), _a)
      });
    }
    __name(generateXraySubsegment, "generateXraySubsegment");
    exports2.generateXraySubsegment = generateXraySubsegment;
    function sendXraySubsegment(segment) {
      var xrayDaemonEnv = process.env[constants_1.awsXrayDaemonAddressEnvVar];
      if (xrayDaemonEnv === void 0) {
        (0, utils_1.logDebug)("X-Ray daemon env var not set, not sending sub-segment");
        return;
      }
      var parts = xrayDaemonEnv.split(":");
      if (parts.length <= 1) {
        (0, utils_1.logDebug)("X-Ray daemon env var has invalid format, not sending sub-segment");
        return;
      }
      var port = parseInt(parts[1], 10);
      var address = parts[0];
      var message = Buffer.from('{"format": "json", "version": 1}\n'.concat(segment));
      var client;
      try {
        client = (0, dgram_1.createSocket)("udp4");
        client.send(message, 0, message.length, port, address, function(error, bytes) {
          client === null || client === void 0 ? void 0 : client.close();
          (0, utils_1.logDebug)("Xray daemon received metadata payload", { error, bytes });
        });
      } catch (error) {
        if (error instanceof Error) {
          client === null || client === void 0 ? void 0 : client.close();
          (0, utils_1.logDebug)("Error occurred submitting to xray daemon", error);
        }
      }
    }
    __name(sendXraySubsegment, "sendXraySubsegment");
    exports2.sendXraySubsegment = sendXraySubsegment;
    function readTraceFromAppSyncEvent(event) {
      event.headers = event.request.headers;
      return readTraceFromHTTPEvent(event, false);
    }
    __name(readTraceFromAppSyncEvent, "readTraceFromAppSyncEvent");
    exports2.readTraceFromAppSyncEvent = readTraceFromAppSyncEvent;
    function readTraceFromSQSEvent(event) {
      var _a, _b, _c, _d;
      if ((_d = (_c = (_b = (_a = event === null || event === void 0 ? void 0 : event.Records) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.messageAttributes) === null || _c === void 0 ? void 0 : _c._datadog) === null || _d === void 0 ? void 0 : _d.stringValue) {
        var traceHeaders = event.Records[0].messageAttributes._datadog.stringValue;
        try {
          var trace = exportTraceData(JSON.parse(traceHeaders));
          (0, utils_1.logDebug)("extracted trace context from sqs event", { trace, event });
          return trace;
        } catch (err) {
          if (err instanceof Error) {
            (0, utils_1.logDebug)("Error parsing SQS message trace data", err);
          }
          return;
        }
      }
      return;
    }
    __name(readTraceFromSQSEvent, "readTraceFromSQSEvent");
    exports2.readTraceFromSQSEvent = readTraceFromSQSEvent;
    function readTraceFromSNSSQSEvent(event) {
      var _a, _b;
      if ((_b = (_a = event === null || event === void 0 ? void 0 : event.Records) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.body) {
        try {
          var parsedBody = JSON.parse(event.Records[0].body);
          if (parsedBody.MessageAttributes && parsedBody.MessageAttributes._datadog && parsedBody.MessageAttributes._datadog.Value) {
            var traceData = void 0;
            if (parsedBody.MessageAttributes._datadog.Type === "String") {
              traceData = JSON.parse(parsedBody.MessageAttributes._datadog.Value);
            } else {
              var b64Decoded = Buffer.from(parsedBody.MessageAttributes._datadog.Value, "base64").toString("ascii");
              traceData = JSON.parse(b64Decoded);
            }
            var trace = exportTraceData(traceData);
            (0, utils_1.logDebug)("extracted trace context from SNS SQS event", { trace, event });
            return trace;
          }
        } catch (err) {
          if (err instanceof Error) {
            (0, utils_1.logDebug)("Error parsing SNS SQS message trace data", err);
          }
          return;
        }
      }
    }
    __name(readTraceFromSNSSQSEvent, "readTraceFromSNSSQSEvent");
    exports2.readTraceFromSNSSQSEvent = readTraceFromSNSSQSEvent;
    function readTraceFromKinesisEvent(event) {
      var _a, _b, _c;
      if ((_c = (_b = (_a = event === null || event === void 0 ? void 0 : event.Records) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.kinesis) === null || _c === void 0 ? void 0 : _c.data) {
        try {
          var parsedBody = JSON.parse(Buffer.from(event.Records[0].kinesis.data, "base64").toString("ascii"));
          if (parsedBody && parsedBody._datadog) {
            var trace = exportTraceData(parsedBody._datadog);
            (0, utils_1.logDebug)("extracted trace context from Kinesis event", { trace });
            return trace;
          }
        } catch (err) {
          if (err instanceof Error) {
            (0, utils_1.logDebug)("Error parsing Kinesis message trace data", err);
          }
          return;
        }
      }
    }
    __name(readTraceFromKinesisEvent, "readTraceFromKinesisEvent");
    exports2.readTraceFromKinesisEvent = readTraceFromKinesisEvent;
    function readTraceFromEventbridgeEvent(event) {
      var _a;
      if ((_a = event === null || event === void 0 ? void 0 : event.detail) === null || _a === void 0 ? void 0 : _a._datadog) {
        try {
          var trace = exportTraceData(event.detail._datadog);
          (0, utils_1.logDebug)("extracted trace context from Eventbridge event", { trace, event });
          return trace;
        } catch (err) {
          if (err instanceof Error) {
            (0, utils_1.logDebug)("Error parsing Eventbridge trace data", err);
          }
          return;
        }
      }
    }
    __name(readTraceFromEventbridgeEvent, "readTraceFromEventbridgeEvent");
    exports2.readTraceFromEventbridgeEvent = readTraceFromEventbridgeEvent;
    function readTraceFromSNSEvent(event) {
      var _a, _b, _c, _d, _e;
      if ((_e = (_d = (_c = (_b = (_a = event === null || event === void 0 ? void 0 : event.Records) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.Sns) === null || _c === void 0 ? void 0 : _c.MessageAttributes) === null || _d === void 0 ? void 0 : _d._datadog) === null || _e === void 0 ? void 0 : _e.Value) {
        try {
          var traceData = void 0;
          if (event.Records[0].Sns.MessageAttributes._datadog.Type === "String") {
            traceData = JSON.parse(event.Records[0].Sns.MessageAttributes._datadog.Value);
          } else {
            var b64Decoded = Buffer.from(event.Records[0].Sns.MessageAttributes._datadog.Value, "base64").toString("ascii");
            traceData = JSON.parse(b64Decoded);
          }
          var trace = exportTraceData(traceData);
          (0, utils_1.logDebug)("extracted trace context from SNS event", { trace, event });
          return trace;
        } catch (err) {
          if (err instanceof Error) {
            (0, utils_1.logDebug)("Error parsing SNS SQS message trace data", err);
          }
          return;
        }
      }
    }
    __name(readTraceFromSNSEvent, "readTraceFromSNSEvent");
    exports2.readTraceFromSNSEvent = readTraceFromSNSEvent;
    function readTraceFromLambdaContext(context) {
      var _a;
      if (!context || typeof context !== "object") {
        return;
      }
      var custom = (_a = context.clientContext) === null || _a === void 0 ? void 0 : _a.custom;
      if (!custom || typeof custom !== "object") {
        return;
      }
      var traceData = null;
      if (custom.hasOwnProperty("_datadog") && typeof custom._datadog === "object" && custom._datadog.hasOwnProperty(constants_1.traceIDHeader) && custom._datadog.hasOwnProperty(constants_1.parentIDHeader) && custom._datadog.hasOwnProperty(constants_1.samplingPriorityHeader)) {
        traceData = custom._datadog;
      } else if (custom.hasOwnProperty(constants_1.traceIDHeader) && custom.hasOwnProperty(constants_1.parentIDHeader) && custom.hasOwnProperty(constants_1.samplingPriorityHeader)) {
        traceData = custom;
      } else {
        return;
      }
      var trace = exportTraceData(traceData);
      (0, utils_1.logDebug)("extracted trace context from lambda context", { trace, context });
      return trace;
    }
    __name(readTraceFromLambdaContext, "readTraceFromLambdaContext");
    exports2.readTraceFromLambdaContext = readTraceFromLambdaContext;
    function getInjectedAuthorizerData(event, eventSourceSubType) {
      var _a;
      var authorizerHeaders = (_a = event === null || event === void 0 ? void 0 : event.requestContext) === null || _a === void 0 ? void 0 : _a.authorizer;
      if (!authorizerHeaders)
        return null;
      var rawDatadogData = eventSourceSubType === trigger_1.eventSubTypes.apiGatewayV2 ? authorizerHeaders.lambda._datadog : authorizerHeaders._datadog;
      if (!rawDatadogData)
        return null;
      var injectedData = JSON.parse(Buffer.from(rawDatadogData, "base64").toString());
      if (authorizerHeaders.integrationLatency > 0 || event.requestContext.requestId === injectedData[constants_1.authorizingRequestIdHeader]) {
        return injectedData;
      } else {
        return null;
      }
    }
    __name(getInjectedAuthorizerData, "getInjectedAuthorizerData");
    exports2.getInjectedAuthorizerData = getInjectedAuthorizerData;
    function readTraceFromHTTPEvent(event, decodeAuthorizerContext) {
      var e_1, _a;
      if (decodeAuthorizerContext === void 0) {
        decodeAuthorizerContext = true;
      }
      if (decodeAuthorizerContext) {
        try {
          var eventSourceSubType = (0, trigger_1.parseEventSourceSubType)(event);
          var injectedAuthorizerData = getInjectedAuthorizerData(event, eventSourceSubType);
          if (injectedAuthorizerData !== null) {
            return exportTraceData(injectedAuthorizerData);
          }
        } catch (error) {
          (0, utils_1.logDebug)("unable to extract trace context from authorizer event.", { error });
        }
      }
      var headers = event.headers;
      var lowerCaseHeaders = {};
      try {
        for (var _b = __values(Object.keys(headers)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          lowerCaseHeaders[key.toLowerCase()] = headers[key];
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var trace = exportTraceData(lowerCaseHeaders);
      (0, utils_1.logDebug)("extracted trace context from http event", { trace, event });
      return trace;
    }
    __name(readTraceFromHTTPEvent, "readTraceFromHTTPEvent");
    exports2.readTraceFromHTTPEvent = readTraceFromHTTPEvent;
    function readTraceFromEvent(event, decodeAuthorizerContext) {
      if (decodeAuthorizerContext === void 0) {
        decodeAuthorizerContext = true;
      }
      if (!event || typeof event !== "object") {
        return;
      }
      if (event.headers !== null && typeof event.headers === "object") {
        return readTraceFromHTTPEvent(event, decodeAuthorizerContext);
      }
      if ((0, event_type_guards_1.isSNSEvent)(event)) {
        return readTraceFromSNSEvent(event);
      }
      if ((0, event_type_guards_1.isSNSSQSEvent)(event)) {
        return readTraceFromSNSSQSEvent(event);
      }
      if ((0, event_type_guards_1.isAppSyncResolverEvent)(event)) {
        return readTraceFromAppSyncEvent(event);
      }
      if ((0, event_type_guards_1.isSQSEvent)(event)) {
        return readTraceFromSQSEvent(event);
      }
      if ((0, event_type_guards_1.isKinesisStreamEvent)(event)) {
        return readTraceFromKinesisEvent(event);
      }
      if ((0, event_type_guards_1.isEventBridgeEvent)(event)) {
        return readTraceFromEventbridgeEvent(event);
      }
      return;
    }
    __name(readTraceFromEvent, "readTraceFromEvent");
    exports2.readTraceFromEvent = readTraceFromEvent;
    function readTraceContextFromXray() {
      var header = process.env[constants_1.xrayTraceEnvVar];
      if (header === void 0) {
        (0, utils_1.logDebug)("couldn't read xray trace header from env");
        return;
      }
      var context = parseXrayTraceContextHeader(header);
      if (context === void 0) {
        (0, utils_1.logError)("couldn't read xray trace context from env, variable had invalid format");
        return void 0;
      }
      var parentID = convertToAPMParentID(context.xrayParentID);
      if (parentID === void 0) {
        (0, utils_1.logDebug)("couldn't parse xray parent ID", context);
        return;
      }
      var traceID = convertToAPMTraceID(context.xrayTraceID);
      if (traceID === void 0) {
        (0, utils_1.logDebug)("couldn't parse xray trace ID", context);
        return;
      }
      var sampleMode = convertToSampleMode(parseInt(context.xraySampled, 10));
      var trace = {
        parentID,
        sampleMode,
        source: constants_1.Source.Xray,
        traceID
      };
      (0, utils_1.logDebug)("extracted trace context from xray context", { trace, header });
      return trace;
    }
    __name(readTraceContextFromXray, "readTraceContextFromXray");
    exports2.readTraceContextFromXray = readTraceContextFromXray;
    function parseXrayTraceContextHeader(header) {
      (0, utils_1.logDebug)("Reading trace context from env var ".concat(header));
      var _a = __read(header.split(";"), 3), root = _a[0], parent = _a[1], sampled = _a[2];
      if (parent === void 0 || sampled === void 0) {
        return;
      }
      var _b = __read(root.split("="), 2), xrayTraceID = _b[1];
      var _c = __read(parent.split("="), 2), xrayParentID = _c[1];
      var _d = __read(sampled.split("="), 2), xraySampled = _d[1];
      if (xraySampled === void 0 || xrayParentID === void 0 || xrayTraceID === void 0) {
        return;
      }
      return {
        xrayTraceID,
        xraySampled,
        xrayParentID
      };
    }
    __name(parseXrayTraceContextHeader, "parseXrayTraceContextHeader");
    function readStepFunctionContextFromEvent(event) {
      if (typeof event !== "object") {
        return;
      }
      var execution = event.Execution;
      if (typeof execution !== "object") {
        (0, utils_1.logDebug)("event.Execution is not an object.");
        return;
      }
      var executionID = execution.Id;
      if (typeof executionID !== "string") {
        (0, utils_1.logDebug)("event.Execution.Id is not a string.");
        return;
      }
      var executionInput = execution.Input;
      var executionName = execution.Name;
      if (typeof executionName !== "string") {
        (0, utils_1.logDebug)("event.Execution.Name is not a string.");
        return;
      }
      var executionRoleArn = execution.RoleArn;
      if (typeof executionRoleArn !== "string") {
        (0, utils_1.logDebug)("event.Execution.RoleArn is not a string.");
        return;
      }
      var executionStartTime = execution.StartTime;
      if (typeof executionStartTime !== "string") {
        (0, utils_1.logDebug)("event.Execution.StartTime is not a string.");
        return;
      }
      var state = event.State;
      if (typeof state !== "object") {
        (0, utils_1.logDebug)("event.State is not an object.");
        return;
      }
      var stateRetryCount = state.RetryCount;
      if (typeof stateRetryCount !== "number") {
        (0, utils_1.logDebug)("event.State.RetryCount is not a string.");
        return;
      }
      var stateEnteredTime = state.EnteredTime;
      if (typeof stateEnteredTime !== "string") {
        (0, utils_1.logDebug)("event.State.EnteredTime is not a string.");
        return;
      }
      var stateName = state.Name;
      if (typeof stateName !== "string") {
        (0, utils_1.logDebug)("event.State.Name is not a string.");
        return;
      }
      var stateMachine = event.StateMachine;
      if (typeof stateMachine !== "object") {
        (0, utils_1.logDebug)("event.StateMachine is not an object.");
        return;
      }
      var stateMachineArn = stateMachine.Id;
      if (typeof stateMachineArn !== "string") {
        (0, utils_1.logDebug)("event.StateMachine.Id is not a string.");
        return;
      }
      var stateMachineName = stateMachine.Name;
      if (typeof stateMachineName !== "string") {
        (0, utils_1.logDebug)("event.StateMachine.Name is not a string.");
        return;
      }
      return {
        "step_function.execution_name": executionName,
        "step_function.execution_id": executionID,
        "step_function.execution_input": executionInput !== null && executionInput !== void 0 ? executionInput : {},
        "step_function.execution_role_arn": executionRoleArn,
        "step_function.execution_start_time": executionStartTime,
        "step_function.state_entered_time": stateEnteredTime,
        "step_function.state_machine_arn": stateMachineArn,
        "step_function.state_machine_name": stateMachineName,
        "step_function.state_name": stateName,
        "step_function.state_retry_count": stateRetryCount
      };
    }
    __name(readStepFunctionContextFromEvent, "readStepFunctionContextFromEvent");
    exports2.readStepFunctionContextFromEvent = readStepFunctionContextFromEvent;
    function convertToSampleMode(xraySampled) {
      return xraySampled === 1 ? constants_1.SampleMode.USER_KEEP : constants_1.SampleMode.USER_REJECT;
    }
    __name(convertToSampleMode, "convertToSampleMode");
    exports2.convertToSampleMode = convertToSampleMode;
    function convertToAPMTraceID(xrayTraceID) {
      var parts = xrayTraceID.split("-");
      if (parts.length < 3) {
        return;
      }
      var lastPart = parts[2];
      if (lastPart.length !== 24) {
        return;
      }
      var hex = new bignumber_js_1.BigNumber(lastPart, 16);
      if (hex.isNaN()) {
        return;
      }
      var last63Bits = hex.mod(new bignumber_js_1.BigNumber("8000000000000000", 16));
      return last63Bits.toString(10);
    }
    __name(convertToAPMTraceID, "convertToAPMTraceID");
    exports2.convertToAPMTraceID = convertToAPMTraceID;
    function convertToAPMParentID(xrayParentID) {
      if (xrayParentID.length !== 16) {
        return;
      }
      var hex = new bignumber_js_1.BigNumber(xrayParentID, 16);
      if (hex.isNaN()) {
        return;
      }
      return hex.toString(10);
    }
    __name(convertToAPMParentID, "convertToAPMParentID");
    exports2.convertToAPMParentID = convertToAPMParentID;
    function exportTraceData(traceData) {
      var traceID = traceData[constants_1.traceIDHeader];
      var parentID = traceData[constants_1.parentIDHeader];
      var sampledHeader = traceData[constants_1.samplingPriorityHeader];
      if (typeof traceID !== "string" || typeof parentID !== "string" || typeof sampledHeader !== "string") {
        return;
      }
      var sampleMode = parseInt(sampledHeader, 10);
      return {
        parentID,
        sampleMode,
        source: constants_1.Source.Event,
        traceID
      };
    }
    __name(exportTraceData, "exportTraceData");
  }
});

// node_modules/shimmer/index.js
var require_shimmer2 = __commonJS({
  "node_modules/shimmer/index.js"(exports2, module2) {
    "use strict";
    function isFunction(funktion) {
      return typeof funktion === "function";
    }
    __name(isFunction, "isFunction");
    var logger = console.error.bind(console);
    function defineProperty(obj, name, value) {
      var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable,
        writable: true,
        value
      });
    }
    __name(defineProperty, "defineProperty");
    function shimmer(options) {
      if (options && options.logger) {
        if (!isFunction(options.logger))
          logger("new logger isn't a function, not replacing");
        else
          logger = options.logger;
      }
    }
    __name(shimmer, "shimmer");
    function wrap(nodule, name, wrapper) {
      if (!nodule || !nodule[name]) {
        logger("no original function " + name + " to wrap");
        return;
      }
      if (!wrapper) {
        logger("no wrapper function");
        logger(new Error().stack);
        return;
      }
      if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
        logger("original object and wrapper must be functions");
        return;
      }
      var original = nodule[name];
      var wrapped = wrapper(original, name);
      defineProperty(wrapped, "__original", original);
      defineProperty(wrapped, "__unwrap", function() {
        if (nodule[name] === wrapped)
          defineProperty(nodule, name, original);
      });
      defineProperty(wrapped, "__wrapped", true);
      defineProperty(nodule, name, wrapped);
      return wrapped;
    }
    __name(wrap, "wrap");
    function massWrap(nodules, names, wrapper) {
      if (!nodules) {
        logger("must provide one or more modules to patch");
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger("must provide one or more functions to wrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          wrap(nodule, name, wrapper);
        });
      });
    }
    __name(massWrap, "massWrap");
    function unwrap(nodule, name) {
      if (!nodule || !nodule[name]) {
        logger("no function to unwrap.");
        logger(new Error().stack);
        return;
      }
      if (!nodule[name].__unwrap) {
        logger("no original to unwrap to -- has " + name + " already been unwrapped?");
      } else {
        return nodule[name].__unwrap();
      }
    }
    __name(unwrap, "unwrap");
    function massUnwrap(nodules, names) {
      if (!nodules) {
        logger("must provide one or more modules to patch");
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger("must provide one or more functions to unwrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          unwrap(nodule, name);
        });
      });
    }
    __name(massUnwrap, "massUnwrap");
    shimmer.wrap = wrap;
    shimmer.massWrap = massWrap;
    shimmer.unwrap = unwrap;
    shimmer.massUnwrap = massUnwrap;
    module2.exports = shimmer;
  }
});

// node_modules/datadog-lambda-js/dist/trace/patch-http.js
var require_patch_http = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/patch-http.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unpatchHttp = exports2.patchHttp = void 0;
    var http_1 = __importDefault(__require("http"));
    var https_1 = __importDefault(__require("https"));
    var shimmer = __importStar(require_shimmer2());
    var url_1 = __require("url");
    function patchHttp(contextService) {
      patchMethod(http_1.default, "request", contextService);
      patchMethod(http_1.default, "get", contextService);
      patchMethod(https_1.default, "request", contextService);
      patchMethod(https_1.default, "get", contextService);
    }
    __name(patchHttp, "patchHttp");
    exports2.patchHttp = patchHttp;
    function unpatchHttp() {
      unpatchMethod(http_1.default, "request");
      unpatchMethod(http_1.default, "get");
      unpatchMethod(https_1.default, "request");
      unpatchMethod(https_1.default, "get");
    }
    __name(unpatchHttp, "unpatchHttp");
    exports2.unpatchHttp = unpatchHttp;
    function patchMethod(mod2, method, contextService) {
      shimmer.wrap(mod2, method, function(original) {
        var fn = /* @__PURE__ */ __name(function(arg1, arg2, arg3) {
          var _a;
          _a = __read(addTraceContextToArgs(contextService, arg1, arg2, arg3), 3), arg1 = _a[0], arg2 = _a[1], arg3 = _a[2];
          if (arg3 === void 0 || arg3 === null) {
            return original(arg1, arg2);
          } else {
            return original(arg1, arg2, arg3);
          }
        }, "fn");
        return fn;
      });
    }
    __name(patchMethod, "patchMethod");
    function unpatchMethod(mod2, method) {
      if (mod2[method].__wrapped !== void 0) {
        shimmer.unwrap(mod2, method);
      }
    }
    __name(unpatchMethod, "unpatchMethod");
    function addTraceContextToArgs(contextService, arg1, arg2, arg3) {
      var requestOpts;
      if (typeof arg1 === "string" || arg1 instanceof url_1.URL) {
        if (arg2 === void 0 || arg2 === null) {
          requestOpts = {
            method: "GET"
          };
          requestOpts = getRequestOptionsWithTraceContext(requestOpts, contextService);
          return [arg1, requestOpts, arg3];
        } else if (typeof arg2 === "function") {
          requestOpts = {
            method: "GET"
          };
          requestOpts = getRequestOptionsWithTraceContext(requestOpts, contextService);
          return [arg1, requestOpts, arg2];
        } else {
          requestOpts = arg2;
          requestOpts = getRequestOptionsWithTraceContext(requestOpts, contextService);
          return [arg1, requestOpts, arg3];
        }
      } else {
        requestOpts = getRequestOptionsWithTraceContext(arg1, contextService);
        return [requestOpts, arg2, arg3];
      }
    }
    __name(addTraceContextToArgs, "addTraceContextToArgs");
    function getRequestOptionsWithTraceContext(options, traceService) {
      var headers = options.headers;
      if (headers === void 0) {
        headers = {};
      }
      var traceHeaders = traceService.currentTraceHeaders;
      headers = __assign(__assign({}, headers), traceHeaders);
      var requestOpts = __assign(__assign({}, options), { headers });
      if (isIntegrationTest()) {
        _logHttpRequest(requestOpts, traceHeaders);
      }
      return requestOpts;
    }
    __name(getRequestOptionsWithTraceContext, "getRequestOptionsWithTraceContext");
    function isIntegrationTest() {
      var integrationTestEnvVar = process.env.DD_INTEGRATION_TEST;
      if (typeof integrationTestEnvVar !== "string") {
        return false;
      }
      return integrationTestEnvVar.toLowerCase() === "true";
    }
    __name(isIntegrationTest, "isIntegrationTest");
    function _logHttpRequest(options, traceHeaders) {
      var headerMessage = "TraceHeaders: []";
      if (traceHeaders) {
        var headerStrings = Object.entries(traceHeaders).map(function(_a) {
          var _b = __read(_a, 2), name = _b[0], value = _b[1];
          return "".concat(name, ":").concat(value);
        });
        headerStrings.sort();
        headerMessage = "TraceHeaders: ".concat(JSON.stringify(headerStrings));
      }
      var url = "".concat(options.protocol, "//").concat(options.host || options.hostname).concat(options.path);
      var requestMessage = "HTTP ".concat(options.method, " ").concat(url, " ").concat(headerMessage, "\n");
      process.stdout.write(requestMessage);
    }
    __name(_logHttpRequest, "_logHttpRequest");
  }
});

// node_modules/datadog-lambda-js/dist/trace/trace-context-service.js
var require_trace_context_service = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/trace-context-service.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceContextService = void 0;
    var utils_1 = require_utils2();
    var constants_1 = require_constants4();
    var context_1 = require_context();
    var TraceContextService = function() {
      function TraceContextService2(tracerWrapper) {
        this.tracerWrapper = tracerWrapper;
      }
      __name(TraceContextService2, "TraceContextService");
      TraceContextService2.prototype.extractHeadersFromContext = function(event, context, extractor, decodeAuthorizerContext) {
        if (decodeAuthorizerContext === void 0) {
          decodeAuthorizerContext = true;
        }
        this.rootTraceContext = (0, context_1.extractTraceContext)(event, context, extractor, decodeAuthorizerContext);
        return this.currentTraceHeaders;
      };
      Object.defineProperty(TraceContextService2.prototype, "currentTraceContext", {
        get: function() {
          if (this.rootTraceContext === void 0) {
            return;
          }
          var traceContext = __assign({}, this.rootTraceContext);
          var datadogContext = this.tracerWrapper.traceContext();
          if (datadogContext) {
            (0, utils_1.logDebug)("set trace context from dd-trace with parent ".concat(datadogContext.parentID));
            return datadogContext;
          }
          return traceContext;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TraceContextService2.prototype, "currentTraceHeaders", {
        get: function() {
          var _a;
          var traceContext = this.currentTraceContext;
          if (traceContext === void 0) {
            return {};
          }
          return _a = {}, _a[constants_1.traceIDHeader] = traceContext.traceID, _a[constants_1.parentIDHeader] = traceContext.parentID, _a[constants_1.samplingPriorityHeader] = traceContext.sampleMode.toString(10), _a;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TraceContextService2.prototype, "rootTraceHeaders", {
        get: function() {
          var _a;
          var rootTraceContext = this.rootTraceContext;
          if (rootTraceContext === void 0) {
            return {};
          }
          return _a = {}, _a[constants_1.traceIDHeader] = rootTraceContext.traceID, _a[constants_1.parentIDHeader] = rootTraceContext.parentID, _a[constants_1.samplingPriorityHeader] = rootTraceContext.sampleMode.toString(10), _a;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TraceContextService2.prototype, "traceSource", {
        get: function() {
          return this.rootTraceContext !== void 0 ? this.rootTraceContext.source : void 0;
        },
        enumerable: false,
        configurable: true
      });
      return TraceContextService2;
    }();
    exports2.TraceContextService = TraceContextService;
  }
});

// node_modules/datadog-lambda-js/dist/trace/span-wrapper.js
var require_span_wrapper = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/span-wrapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SpanWrapper = void 0;
    var SpanWrapper = function() {
      function SpanWrapper2(span, options) {
        this.span = span;
        this.options = options;
      }
      __name(SpanWrapper2, "SpanWrapper");
      SpanWrapper2.prototype.isAsync = function() {
        return this.options.isAsync || false;
      };
      SpanWrapper2.prototype.startTime = function() {
        return this.span._startTime;
      };
      SpanWrapper2.prototype.endTime = function() {
        if (this.span._endTime) {
          return this.span._endTime;
        }
        if (this.span._duration && this.span._startTime) {
          return this.span._startTime + this.span._duration;
        }
        throw new Error("_endTime not defined");
      };
      SpanWrapper2.prototype.finish = function(timestamp) {
        if (timestamp === void 0) {
          timestamp = Date.now();
        }
        this.span.finish(timestamp);
      };
      SpanWrapper2.prototype.setTag = function(tagName, val) {
        this.span.setTag(tagName, val);
      };
      return SpanWrapper2;
    }();
    exports2.SpanWrapper = SpanWrapper;
  }
});

// node_modules/datadog-lambda-js/dist/trace/cold-start-tracer.js
var require_cold_start_tracer = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/cold-start-tracer.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColdStartTracer = void 0;
    var span_wrapper_1 = require_span_wrapper();
    var ColdStartTracer = function() {
      function ColdStartTracer2(coldStartTracerConfig) {
        this.tracerWrapper = coldStartTracerConfig.tracerWrapper;
        this.parentSpan = coldStartTracerConfig.parentSpan;
        this.lambdaFunctionName = coldStartTracerConfig.lambdaFunctionName;
        this.coldStartSpanFinishTime = coldStartTracerConfig.coldStartSpanFinishTime;
        this.minDuration = coldStartTracerConfig.minDuration;
        this.ignoreLibs = coldStartTracerConfig.ignoreLibs.split(",");
      }
      __name(ColdStartTracer2, "ColdStartTracer");
      ColdStartTracer2.prototype.trace = function(rootNodes) {
        var e_1, _a;
        var _b;
        var coldStartSpanStartTime = (_b = rootNodes[0]) === null || _b === void 0 ? void 0 : _b.startTime;
        var coldStartSpan = this.createColdStartSpan(coldStartSpanStartTime, this.parentSpan);
        try {
          for (var rootNodes_1 = __values(rootNodes), rootNodes_1_1 = rootNodes_1.next(); !rootNodes_1_1.done; rootNodes_1_1 = rootNodes_1.next()) {
            var coldStartNode = rootNodes_1_1.value;
            this.traceTree(coldStartNode, coldStartSpan);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (rootNodes_1_1 && !rootNodes_1_1.done && (_a = rootNodes_1.return))
              _a.call(rootNodes_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      };
      ColdStartTracer2.prototype.createColdStartSpan = function(startTime, parentSpan) {
        var options = {
          tags: {
            service: "aws.lambda",
            operation_name: "aws.lambda.require",
            resource_names: this.lambdaFunctionName,
            "resource.name": this.lambdaFunctionName
          },
          startTime
        };
        if (parentSpan) {
          options.childOf = parentSpan.span;
        }
        var newSpan = new span_wrapper_1.SpanWrapper(this.tracerWrapper.startSpan("aws.lambda.load", options), {});
        newSpan.finish(this.coldStartSpanFinishTime);
        return newSpan;
      };
      ColdStartTracer2.prototype.coldStartSpanOperationName = function(filename) {
        if (filename.startsWith("/opt/")) {
          return "aws.lambda.require_layer";
        } else if (filename.startsWith("/var/runtime/")) {
          return "aws.lambda.require_runtime";
        } else if (filename.includes("/")) {
          return "aws.lambda.require";
        } else {
          return "aws.lambda.require_core_module";
        }
      };
      ColdStartTracer2.prototype.traceTree = function(reqNode, parentSpan) {
        var e_2, _a;
        if (reqNode.endTime - reqNode.startTime < this.minDuration) {
          return;
        }
        if (this.ignoreLibs.includes(reqNode.id)) {
          return;
        }
        var options = {
          tags: {
            service: "aws.lambda",
            operation_name: this.coldStartSpanOperationName(reqNode.filename),
            resource_names: reqNode.id,
            "resource.name": reqNode.id,
            filename: reqNode.filename
          },
          startTime: reqNode.startTime
        };
        if (parentSpan) {
          options.childOf = parentSpan.span;
        }
        var newSpan = new span_wrapper_1.SpanWrapper(this.tracerWrapper.startSpan(this.coldStartSpanOperationName(reqNode.filename), options), {});
        if (reqNode.endTime - reqNode.startTime > this.minDuration) {
          try {
            for (var _b = __values(reqNode.children || []), _c = _b.next(); !_c.done; _c = _b.next()) {
              var node = _c.value;
              this.traceTree(node, newSpan);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        newSpan === null || newSpan === void 0 ? void 0 : newSpan.finish(reqNode.endTime);
      };
      return ColdStartTracer2;
    }();
    exports2.ColdStartTracer = ColdStartTracer;
  }
});

// node_modules/datadog-lambda-js/dist/trace/patch-console.js
var require_patch_console = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/patch-console.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unpatchConsole = exports2.patchConsole = void 0;
    var shimmer = __importStar(require_shimmer2());
    var util_1 = __require("util");
    var log_1 = require_log4();
    function patchConsole(cnsle, contextService) {
      patchMethod(cnsle, "log", contextService);
      patchMethod(cnsle, "info", contextService);
      patchMethod(cnsle, "debug", contextService);
      patchMethod(cnsle, "error", contextService);
      patchMethod(cnsle, "warn", contextService);
      patchMethod(cnsle, "trace", contextService);
    }
    __name(patchConsole, "patchConsole");
    exports2.patchConsole = patchConsole;
    function unpatchConsole(cnsle) {
      unpatchMethod(cnsle, "log");
      unpatchMethod(cnsle, "info");
      unpatchMethod(cnsle, "debug");
      unpatchMethod(cnsle, "error");
      unpatchMethod(cnsle, "warn");
      unpatchMethod(cnsle, "trace");
    }
    __name(unpatchConsole, "unpatchConsole");
    exports2.unpatchConsole = unpatchConsole;
    function patchMethod(mod2, method, contextService) {
      if (mod2[method].__wrapped !== void 0) {
        return;
      }
      shimmer.wrap(mod2, method, function(original) {
        var isLogging = false;
        return /* @__PURE__ */ __name(function emitWithContext(message) {
          var optionalParams = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
          }
          if (isLogging) {
            return original.apply(this, arguments);
          }
          isLogging = true;
          var prefix = "";
          var oldLogLevel = (0, log_1.getLogLevel)();
          (0, log_1.setLogLevel)(log_1.LogLevel.NONE);
          try {
            var context = contextService.currentTraceContext;
            if (context !== void 0) {
              var traceID = context.traceID, parentID = context.parentID;
              prefix = "[dd.trace_id=".concat(traceID, " dd.span_id=").concat(parentID, "]");
              if (arguments.length === 0) {
                arguments.length = 1;
                arguments[0] = prefix;
              } else {
                var logContent = arguments[0];
                if (typeof logContent !== "string") {
                  logContent = (0, util_1.inspect)(logContent);
                }
                arguments[0] = "".concat(prefix, " ").concat(logContent);
              }
            }
          } catch (error) {
          }
          (0, log_1.setLogLevel)(oldLogLevel);
          isLogging = false;
          return original.apply(this, arguments);
        }, "emitWithContext");
      });
    }
    __name(patchMethod, "patchMethod");
    function unpatchMethod(mod2, method) {
      if (mod2[method].__wrapped !== void 0) {
        shimmer.unwrap(mod2, method);
      }
    }
    __name(unpatchMethod, "unpatchMethod");
  }
});

// node_modules/datadog-lambda-js/dist/trace/tracer-wrapper.js
var require_tracer_wrapper = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/tracer-wrapper.js"(exports2, module2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TracerWrapper = void 0;
    var utils_1 = require_utils2();
    var constants_1 = require_constants4();
    var TracerWrapper = function() {
      function TracerWrapper2() {
        try {
          var path = __require.resolve("dd-trace", { paths: __spreadArray(["/var/task/node_modules"], __read(module2.paths), false) });
          this.tracer = __require(path);
          return;
        } catch (err) {
          if (err instanceof Object || err instanceof Error) {
            (0, utils_1.logDebug)("Couldn't require dd-trace from main", err);
          }
        }
      }
      __name(TracerWrapper2, "TracerWrapper");
      Object.defineProperty(TracerWrapper2.prototype, "isTracerAvailable", {
        get: function() {
          return this.tracer !== void 0 && this.tracer._tracer !== void 0 && "_service" in this.tracer._tracer;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TracerWrapper2.prototype, "currentSpan", {
        get: function() {
          if (!this.isTracerAvailable) {
            return null;
          }
          return this.tracer.scope().active();
        },
        enumerable: false,
        configurable: true
      });
      TracerWrapper2.prototype.extract = function(event) {
        if (!this.isTracerAvailable) {
          return null;
        }
        return this.tracer.extract("http_headers", event);
      };
      TracerWrapper2.prototype.wrap = function(name, options, fn) {
        if (!this.isTracerAvailable) {
          return fn;
        }
        return this.tracer.wrap(name, options, fn);
      };
      TracerWrapper2.prototype.startSpan = function(name, options) {
        if (!this.isTracerAvailable) {
          return null;
        }
        return this.tracer.startSpan(name, options);
      };
      TracerWrapper2.prototype.traceContext = function() {
        if (!this.isTracerAvailable) {
          return;
        }
        var span = this.currentSpan;
        if (span === null) {
          return;
        }
        var parentID = span.context().toSpanId();
        var traceID = span.context().toTraceId();
        return {
          parentID,
          sampleMode: constants_1.SampleMode.AUTO_KEEP,
          source: constants_1.Source.Event,
          traceID
        };
      };
      TracerWrapper2.prototype.injectSpan = function(span) {
        var dest = {};
        this.tracer.inject(span, "text_map", dest);
        return dest;
      };
      return TracerWrapper2;
    }();
    exports2.TracerWrapper = TracerWrapper;
  }
});

// node_modules/datadog-lambda-js/dist/trace/span-inferrer.js
var require_span_inferrer = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/span-inferrer.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SpanInferrer = void 0;
    var trigger_1 = require_trigger();
    var span_wrapper_1 = require_span_wrapper();
    var constants_1 = require_constants4();
    var utils_1 = require_utils2();
    var context_1 = require_context();
    var SpanInferrer = function() {
      function SpanInferrer2(traceWrapper) {
        this.traceWrapper = traceWrapper;
      }
      __name(SpanInferrer2, "SpanInferrer");
      SpanInferrer2.prototype.createInferredSpan = function(event, context, parentSpanContext, decodeAuthorizerContext) {
        if (decodeAuthorizerContext === void 0) {
          decodeAuthorizerContext = true;
        }
        var eventSource = (0, trigger_1.parseEventSource)(event);
        if (eventSource === trigger_1.eventTypes.lambdaUrl) {
          return this.createInferredSpanForLambdaUrl(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.apiGateway) {
          return this.createInferredSpanForApiGateway(event, context, parentSpanContext, decodeAuthorizerContext);
        }
        if (eventSource === trigger_1.eventTypes.sns) {
          return this.createInferredSpanForSns(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.dynamoDB) {
          return this.createInferredSpanForDynamoDBStreamEvent(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.sqs) {
          return this.createInferredSpanForSqs(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.kinesis) {
          return this.createInferredSpanForKinesis(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.s3) {
          return this.createInferredSpanForS3(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.eventBridge) {
          return this.createInferredSpanForEventBridge(event, context, parentSpanContext);
        }
      };
      SpanInferrer2.prototype.isApiGatewayAsync = function(event) {
        if (event.headers && event.headers["X-Amz-Invocation-Type"] && event.headers["X-Amz-Invocation-Type"] === "Event") {
          return "async";
        }
        return "sync";
      };
      SpanInferrer2.prototype.createInferredSpanForApiGateway = function(event, context, parentSpanContext, decodeAuthorizerContext) {
        if (decodeAuthorizerContext === void 0) {
          decodeAuthorizerContext = true;
        }
        var options = {};
        var domain = event.requestContext.domainName;
        var path = event.rawPath || event.requestContext.path || event.requestContext.routeKey;
        var resourcePath = event.rawPath || event.requestContext.resourcePath || event.requestContext.routeKey;
        var method;
        if (event.requestContext.httpMethod) {
          method = event.requestContext.httpMethod;
        } else if (event.requestContext.http) {
          method = event.requestContext.http.method;
        }
        var resourceName = [method || domain, resourcePath].join(" ");
        options.tags = {
          operation_name: "aws.apigateway",
          "http.url": domain + path,
          endpoint: path,
          resource_names: resourceName,
          request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
          "span.type": "http",
          "resource.name": resourceName,
          "service.name": domain,
          apiid: event.requestContext.apiId,
          service: domain,
          _inferred_span: {
            tag_source: "self",
            synchronicity: this.isApiGatewayAsync(event)
          }
        };
        if (method) {
          options.tags["http.method"] = method;
          options.tags.stage = event.requestContext.stage;
          options.tags.domain_name = domain;
        }
        if (event.requestContext.messageDirection) {
          options.tags.message_direction = event.requestContext.messageDirection;
          options.tags.connection_id = event.requestContext.connectionId;
          options.tags.event_type = event.requestContext.eventType;
        }
        var upstreamAuthorizerSpan;
        var eventSourceSubType = (0, trigger_1.parseEventSourceSubType)(event);
        if (decodeAuthorizerContext) {
          try {
            var parsedUpstreamContext = (0, context_1.getInjectedAuthorizerData)(event, eventSourceSubType);
            if (parsedUpstreamContext) {
              var upstreamSpanOptions = {};
              var startTime = parsedUpstreamContext[constants_1.parentSpanFinishTimeHeader] / 1e6;
              if (eventSourceSubType === trigger_1.eventSubTypes.apiGatewayV2) {
                options.startTime = startTime;
                options.tags.operation_name = "aws.httpapi";
              } else {
                upstreamSpanOptions = {
                  startTime,
                  childOf: parentSpanContext,
                  tags: __assign({ operation_name: "aws.apigateway.authorizer" }, options.tags)
                };
                upstreamAuthorizerSpan = new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.apigateway.authorizer", upstreamSpanOptions), { isAsync: false });
                var endTime = event.requestContext.requestTimeEpoch + event.requestContext.authorizer.integrationLatency;
                upstreamAuthorizerSpan.finish(endTime);
                options.startTime = endTime;
              }
            }
          } catch (error) {
            (0, utils_1.logDebug)("Error decoding authorizer span", error);
          }
        }
        if (!options.startTime) {
          if (eventSourceSubType === trigger_1.eventSubTypes.apiGatewayV1 || eventSourceSubType === trigger_1.eventSubTypes.apiGatewayWebsocket) {
            options.startTime = event.requestContext.requestTimeEpoch;
          } else {
            options.startTime = event.requestContext.timeEpoch;
          }
        }
        options.childOf = upstreamAuthorizerSpan ? upstreamAuthorizerSpan.span : parentSpanContext;
        var spanWrapperOptions = {
          isAsync: this.isApiGatewayAsync(event) === "async"
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.apigateway", options), spanWrapperOptions);
      };
      SpanInferrer2.prototype.createInferredSpanForLambdaUrl = function(event, context, parentSpanContext) {
        var options = {};
        var domain = event.requestContext.domainName;
        var path = event.rawPath;
        var method;
        if (event.requestContext.httpMethod) {
          method = event.requestContext.httpMethod;
        } else if (event.requestContext.http) {
          method = event.requestContext.http.method;
        }
        var resourceName = [method || domain, path].join(" ");
        options.tags = {
          operation_name: "aws.lambda.url",
          "http.url": domain + path,
          endpoint: path,
          "http.method": event.requestContext.http.method,
          resource_names: resourceName,
          request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
          "span.type": "http",
          "resource.name": resourceName,
          "service.name": domain,
          _inferred_span: {
            tag_source: "self",
            synchronicity: "sync"
          }
        };
        options.startTime = event.requestContext.timeEpoch;
        var spanWrapperOptions = {
          isAsync: false
        };
        if (parentSpanContext) {
          options.childOf = parentSpanContext;
        }
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.lambda.url", options), spanWrapperOptions);
      };
      SpanInferrer2.prototype.createInferredSpanForDynamoDBStreamEvent = function(event, context, parentSpanContext) {
        var _a;
        var options = {};
        var Records = event.Records;
        var referenceRecord = Records[0];
        var eventSourceARN = referenceRecord.eventSourceARN, eventName = referenceRecord.eventName, eventVersion = referenceRecord.eventVersion, eventID = referenceRecord.eventID, dynamodb = referenceRecord.dynamodb;
        var _b = __read((eventSourceARN === null || eventSourceARN === void 0 ? void 0 : eventSourceARN.split("/")) || [void 0, void 0], 2), tableArn = _b[0], tableName = _b[1];
        var resourceName = "".concat(eventName, " ").concat(tableName);
        options.tags = {
          operation_name: "aws.dynamodb",
          tablename: tableName,
          resource_names: resourceName,
          request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
          "span.type": "web",
          "resource.name": resourceName,
          service: "aws.dynamodb",
          _inferred_span: {
            tag_source: "self",
            synchronicity: "async"
          },
          event_name: eventName,
          event_version: eventVersion,
          event_source_arn: eventSourceARN,
          event_id: eventID
        };
        if (dynamodb) {
          options.tags.stream_view_type = dynamodb.StreamViewType;
          options.tags.size_bytes = dynamodb.SizeBytes;
        }
        if (parentSpanContext) {
          options.childOf = parentSpanContext;
        }
        options.startTime = Number((_a = referenceRecord.dynamodb) === null || _a === void 0 ? void 0 : _a.ApproximateCreationDateTime) * 1e3;
        var spanWrapperOptions = {
          isAsync: true
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.dynamodb", options), spanWrapperOptions);
      };
      SpanInferrer2.prototype.createInferredSpanForSns = function(event, context, parentSpanContext) {
        var options = {};
        var Records = event.Records;
        var referenceRecord = Records[0];
        var EventSubscriptionArn = referenceRecord.EventSubscriptionArn, _a = referenceRecord.Sns, TopicArn = _a.TopicArn, Timestamp = _a.Timestamp, Type = _a.Type, Subject = _a.Subject, MessageId = _a.MessageId;
        var topicName = TopicArn === null || TopicArn === void 0 ? void 0 : TopicArn.split(":").pop();
        var resourceName = topicName;
        options.tags = {
          operation_name: "aws.sns",
          resource_names: resourceName,
          request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
          "span.type": "sns",
          "resource.name": resourceName,
          service: "sns",
          _inferred_span: {
            tag_source: "self",
            synchronicity: "async"
          },
          type: Type,
          subject: Subject,
          message_id: MessageId,
          topicname: topicName,
          topic_arn: TopicArn,
          event_subscription_arn: EventSubscriptionArn
        };
        if (parentSpanContext) {
          options.childOf = parentSpanContext;
        }
        options.startTime = Date.parse(Timestamp);
        var spanWrapperOptions = {
          isAsync: true
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.sns", options), spanWrapperOptions);
      };
      SpanInferrer2.prototype.createInferredSpanForSqsSns = function(event, context, parentSpanContext) {
        var options = {};
        var TopicArn = event.TopicArn, Timestamp = event.Timestamp, Type = event.Type, Subject = event.Subject, MessageId = event.MessageId;
        var topicName = TopicArn === null || TopicArn === void 0 ? void 0 : TopicArn.split(":").pop();
        var resourceName = topicName;
        options.tags = {
          operation_name: "aws.sns",
          resource_names: resourceName,
          "span.type": "sns",
          "resource.name": resourceName,
          service: "sns",
          _inferred_span: {
            tag_source: "self",
            synchronicity: "async"
          },
          type: Type,
          subject: Subject,
          message_id: MessageId,
          topicname: topicName,
          topic_arn: TopicArn
        };
        if (parentSpanContext) {
          options.childOf = parentSpanContext;
        }
        options.startTime = Date.parse(Timestamp);
        var spanWrapperOptions = {
          isAsync: true
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.sns", options), spanWrapperOptions);
      };
      SpanInferrer2.prototype.createInferredSpanForSqs = function(event, context, parentSpanContext) {
        var options = {};
        var Records = event.Records;
        var referenceRecord = Records[0];
        var _a = referenceRecord.attributes, SentTimestamp = _a.SentTimestamp, ApproximateReceiveCount = _a.ApproximateReceiveCount, SenderId = _a.SenderId, eventSourceARN = referenceRecord.eventSourceARN, receiptHandle = referenceRecord.receiptHandle, body = referenceRecord.body;
        var queueName = eventSourceARN === null || eventSourceARN === void 0 ? void 0 : eventSourceARN.split(":").pop();
        var resourceName = queueName;
        options.tags = {
          operation_name: "aws.sqs",
          resource_names: resourceName,
          request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
          "span.type": "web",
          "resource.name": resourceName,
          "service.name": resourceName,
          service: "sqs",
          _inferred_span: {
            tag_source: "self",
            synchronicity: "async"
          },
          queuename: queueName,
          event_source_arn: eventSourceARN,
          receipt_handle: receiptHandle,
          sender_id: SenderId
        };
        if (ApproximateReceiveCount && Number(ApproximateReceiveCount) > 0) {
          options.tags.retry_count = Number(ApproximateReceiveCount);
        }
        var upstreamSnsSpan = null;
        try {
          var upstreamSnsMessage = void 0;
          upstreamSnsMessage = JSON.parse(body);
          if (upstreamSnsMessage && upstreamSnsMessage.TopicArn && upstreamSnsMessage.Timestamp) {
            upstreamSnsSpan = this.createInferredSpanForSqsSns(upstreamSnsMessage, context, parentSpanContext);
            upstreamSnsSpan.finish(Number(SentTimestamp));
          }
        } catch (e) {
        }
        options.childOf = upstreamSnsSpan ? upstreamSnsSpan.span : parentSpanContext;
        options.startTime = Number(SentTimestamp);
        var spanWrapperOptions = {
          isAsync: true
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.sqs", options), spanWrapperOptions);
      };
      SpanInferrer2.prototype.createInferredSpanForKinesis = function(event, context, parentSpanContext) {
        var options = {};
        var Records = event.Records;
        var referenceRecord = Records[0];
        var _a = referenceRecord.kinesis, approximateArrivalTimestamp = _a.approximateArrivalTimestamp, partitionKey = _a.partitionKey, eventSourceARN = referenceRecord.eventSourceARN, eventName = referenceRecord.eventName, eventVersion = referenceRecord.eventVersion, eventID = referenceRecord.eventID;
        var streamName = eventSourceARN === null || eventSourceARN === void 0 ? void 0 : eventSourceARN.split(":").pop();
        var shardId = eventID.split(":").pop();
        options.tags = {
          operation_name: "aws.kinesis",
          resource_names: streamName,
          request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
          "span.type": "web",
          "resource.name": streamName,
          service: "kinesis",
          _inferred_span: {
            tag_source: "self",
            synchronicity: "async"
          },
          streamname: streamName,
          event_id: eventID,
          event_name: eventName,
          event_source_arn: eventSourceARN,
          event_version: eventVersion,
          partition_key: partitionKey,
          shardid: shardId
        };
        if (parentSpanContext) {
          options.childOf = parentSpanContext;
        }
        options.startTime = Number(approximateArrivalTimestamp) * 1e3;
        var spanWrapperOptions = {
          isAsync: true
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.kinesis", options), spanWrapperOptions);
      };
      SpanInferrer2.prototype.createInferredSpanForS3 = function(event, context, parentSpanContext) {
        var options = {};
        var Records = event.Records;
        var referenceRecord = Records[0];
        var _a = referenceRecord.s3, _b = _a.bucket, bucketName = _b.name, arn = _b.arn, _c = _a.object, key = _c.key, size = _c.size, eTag = _c.eTag, eventTime = referenceRecord.eventTime, eventName = referenceRecord.eventName;
        options.tags = {
          operation_name: "aws.s3",
          resource_names: bucketName,
          request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
          "span.type": "web",
          "resource.name": bucketName,
          service: "s3",
          _inferred_span: {
            tag_source: "self",
            synchronicity: "async"
          },
          bucketname: bucketName,
          bucket_arn: arn,
          event_name: eventName,
          object_key: key,
          object_size: size,
          object_etag: eTag
        };
        if (parentSpanContext) {
          options.childOf = parentSpanContext;
        }
        options.startTime = Date.parse(eventTime);
        var spanWrapperOptions = {
          isAsync: true
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.s3", options), spanWrapperOptions);
      };
      SpanInferrer2.prototype.createInferredSpanForEventBridge = function(event, context, parentSpanContext) {
        var options = {};
        var _a = event, time = _a.time, source = _a.source;
        options.tags = {
          operation_name: "aws.eventbridge",
          resource_names: source,
          request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
          "span.type": "web",
          "resource.name": source,
          service: "eventbridge",
          _inferred_span: {
            tag_source: "self",
            synchronicity: "async"
          }
        };
        if (parentSpanContext) {
          options.childOf = parentSpanContext;
        }
        options.startTime = Date.parse(time);
        var spanWrapperOptions = {
          isAsync: true
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.eventbridge", options), spanWrapperOptions);
      };
      return SpanInferrer2;
    }();
    exports2.SpanInferrer = SpanInferrer;
  }
});

// node_modules/datadog-lambda-js/dist/runtime/errors.js
var require_errors2 = __commonJS({
  "node_modules/datadog-lambda-js/dist/runtime/errors.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = /* @__PURE__ */ __name(function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      }, "extendStatics");
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnhandledPromiseRejection = exports2.UserCodeSyntaxError = exports2.MalformedHandlerName = exports2.HandlerNotFound = exports2.ImportModuleError = exports2.ExtendedError = exports2.toFormatted = exports2.toRuntimeResponse = exports2.isError = void 0;
    var util_1 = __importDefault(__require("util"));
    function isError(obj) {
      return obj && obj.name && obj.message && obj.stack && typeof obj.name === "string" && typeof obj.message === "string" && typeof obj.stack === "string";
    }
    __name(isError, "isError");
    exports2.isError = isError;
    function toRuntimeResponse(error) {
      try {
        if (util_1.default.types.isNativeError(error) || isError(error)) {
          if (!error.stack) {
            throw new Error("Error stack is missing.");
          }
          return {
            errorType: error.name,
            errorMessage: error.message,
            trace: error.stack.split("\n") || []
          };
        } else {
          return {
            errorType: typeof error,
            errorMessage: error.toString(),
            trace: []
          };
        }
      } catch (_err) {
        return {
          errorType: "handled",
          errorMessage: "callback called with Error argument, but there was a problem while retrieving one or more of its message, name, and stack",
          trace: []
        };
      }
    }
    __name(toRuntimeResponse, "toRuntimeResponse");
    exports2.toRuntimeResponse = toRuntimeResponse;
    var toFormatted = /* @__PURE__ */ __name(function(error) {
      try {
        return "	" + JSON.stringify(error, function(_k, v) {
          return _withEnumerableProperties(v);
        });
      } catch (err) {
        return "	" + JSON.stringify(toRuntimeResponse(error));
      }
    }, "toFormatted");
    exports2.toFormatted = toFormatted;
    function _withEnumerableProperties(error) {
      if (error instanceof Error) {
        var extendedError = error;
        var ret = Object.assign({
          errorType: extendedError.name,
          errorMessage: extendedError.message,
          code: extendedError.code
        }, extendedError);
        if (typeof extendedError.stack == "string") {
          ret.stack = extendedError.stack.split("\n");
        }
        return ret;
      } else {
        return error;
      }
    }
    __name(_withEnumerableProperties, "_withEnumerableProperties");
    var ExtendedError = function(_super) {
      __extends(ExtendedError2, _super);
      function ExtendedError2(reason) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, reason) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
      }
      __name(ExtendedError2, "ExtendedError");
      return ExtendedError2;
    }(Error);
    exports2.ExtendedError = ExtendedError;
    var ImportModuleError = function(_super) {
      __extends(ImportModuleError2, _super);
      function ImportModuleError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(ImportModuleError2, "ImportModuleError");
      return ImportModuleError2;
    }(ExtendedError);
    exports2.ImportModuleError = ImportModuleError;
    var HandlerNotFound = function(_super) {
      __extends(HandlerNotFound2, _super);
      function HandlerNotFound2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(HandlerNotFound2, "HandlerNotFound");
      return HandlerNotFound2;
    }(ExtendedError);
    exports2.HandlerNotFound = HandlerNotFound;
    var MalformedHandlerName = function(_super) {
      __extends(MalformedHandlerName2, _super);
      function MalformedHandlerName2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(MalformedHandlerName2, "MalformedHandlerName");
      return MalformedHandlerName2;
    }(ExtendedError);
    exports2.MalformedHandlerName = MalformedHandlerName;
    var UserCodeSyntaxError = function(_super) {
      __extends(UserCodeSyntaxError2, _super);
      function UserCodeSyntaxError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(UserCodeSyntaxError2, "UserCodeSyntaxError");
      return UserCodeSyntaxError2;
    }(ExtendedError);
    exports2.UserCodeSyntaxError = UserCodeSyntaxError;
    var UnhandledPromiseRejection = function(_super) {
      __extends(UnhandledPromiseRejection2, _super);
      function UnhandledPromiseRejection2(reason, promise) {
        var _this = _super.call(this, reason) || this;
        _this.reason = reason;
        _this.promise = promise;
        return _this;
      }
      __name(UnhandledPromiseRejection2, "UnhandledPromiseRejection");
      return UnhandledPromiseRejection2;
    }(ExtendedError);
    exports2.UnhandledPromiseRejection = UnhandledPromiseRejection;
    var errorClasses = [
      ImportModuleError,
      HandlerNotFound,
      MalformedHandlerName,
      UserCodeSyntaxError,
      UnhandledPromiseRejection
    ];
    errorClasses.forEach(function(e) {
      e.prototype.name = "Runtime.".concat(e.name);
    });
  }
});

// node_modules/datadog-lambda-js/dist/runtime/module_importer.js
var require_module_importer = __commonJS({
  "node_modules/datadog-lambda-js/dist/runtime/module_importer.js"(exports2, module2) {
    var { logDebug } = require_utils2();
    exports2.import = function(path) {
      return import(path);
    };
    exports2.initTracer = function() {
      const path = __require.resolve("dd-trace", { paths: ["/var/task/node_modules", ...module2.paths] });
      const tracer2 = __require(path).init({
        tags: {
          "_dd.origin": "lambda"
        }
      });
      logDebug("automatically initialized dd-trace");
      tracer2.use("http", {
        blocklist: /:8124\/lambda/
      });
      return tracer2;
    };
  }
});

// node_modules/datadog-lambda-js/dist/runtime/user-function.js
var require_user_function = __commonJS({
  "node_modules/datadog-lambda-js/dist/runtime/user-function.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadSync = exports2.load = void 0;
    var path_1 = __importDefault(__require("path"));
    var fs_1 = __importDefault(__require("fs"));
    var errors_1 = require_errors2();
    var module_importer = require_module_importer();
    var FUNCTION_EXPR = /^([^.]*)\.(.*)$/;
    var RELATIVE_PATH_SUBSTRING = "..";
    function _moduleRootAndHandler(fullHandlerString) {
      var handlerString = path_1.default.basename(fullHandlerString);
      var moduleRoot = fullHandlerString.substring(0, fullHandlerString.indexOf(handlerString));
      return [moduleRoot, handlerString];
    }
    __name(_moduleRootAndHandler, "_moduleRootAndHandler");
    function _splitHandlerString(handler2) {
      var match = handler2.match(FUNCTION_EXPR);
      if (!match || match.length != 3) {
        throw new errors_1.MalformedHandlerName("Bad handler");
      }
      return [match[1], match[2]];
    }
    __name(_splitHandlerString, "_splitHandlerString");
    function _resolveHandler(object, nestedProperty) {
      return nestedProperty.split(".").reduce(function(nested, key) {
        return nested && nested[key];
      }, object);
    }
    __name(_resolveHandler, "_resolveHandler");
    function _tryRequireFile(file, extension) {
      var path = file + (extension || "");
      return fs_1.default.existsSync(path) ? __require(path) : void 0;
    }
    __name(_tryRequireFile, "_tryRequireFile");
    function _tryAwaitImport(file, extension) {
      return __awaiter(this, void 0, void 0, function() {
        var path;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              path = file + (extension || "");
              if (!fs_1.default.existsSync(path))
                return [3, 2];
              return [4, module_importer.import(path)];
            case 1:
              return [2, _a.sent()];
            case 2:
              return [2];
          }
        });
      });
    }
    __name(_tryAwaitImport, "_tryAwaitImport");
    function _hasFolderPackageJsonTypeModule(folder) {
      if (folder.endsWith("/node_modules")) {
        return false;
      }
      var pj = path_1.default.join(folder, "/package.json");
      if (fs_1.default.existsSync(pj)) {
        try {
          var pkg = JSON.parse(fs_1.default.readFileSync(pj, "utf-8"));
          if (pkg) {
            if (pkg.type === "module") {
              return true;
            } else {
              return false;
            }
          }
        } catch (e) {
          console.warn("".concat(pj, " cannot be read, it will be ignored for ES module detection purposes."), e);
          return false;
        }
      }
      if (folder === "/") {
        return false;
      }
      return _hasFolderPackageJsonTypeModule(path_1.default.resolve(folder, ".."));
    }
    __name(_hasFolderPackageJsonTypeModule, "_hasFolderPackageJsonTypeModule");
    function _hasPackageJsonTypeModule(file) {
      var jsPath = file + ".js";
      return fs_1.default.existsSync(jsPath) ? _hasFolderPackageJsonTypeModule(path_1.default.resolve(path_1.default.dirname(jsPath))) : false;
    }
    __name(_hasPackageJsonTypeModule, "_hasPackageJsonTypeModule");
    function _tryRequire(appRoot, moduleRoot, module3) {
      return __awaiter(this, void 0, void 0, function() {
        var lambdaStylePath, extensionless, pjHasModule, loaded_1, loaded, _a, _b, nodeStylePath;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              lambdaStylePath = path_1.default.resolve(appRoot, moduleRoot, module3);
              extensionless = _tryRequireFile(lambdaStylePath);
              if (extensionless) {
                return [2, extensionless];
              }
              pjHasModule = _hasPackageJsonTypeModule(lambdaStylePath);
              if (!pjHasModule) {
                loaded_1 = _tryRequireFile(lambdaStylePath, ".js");
                if (loaded_1) {
                  return [2, loaded_1];
                }
              }
              _b = pjHasModule;
              if (!_b)
                return [3, 2];
              return [4, _tryAwaitImport(lambdaStylePath, ".js")];
            case 1:
              _b = _c.sent();
              _c.label = 2;
            case 2:
              _a = _b;
              if (_a)
                return [3, 4];
              return [4, _tryAwaitImport(lambdaStylePath, ".mjs")];
            case 3:
              _a = _c.sent();
              _c.label = 4;
            case 4:
              loaded = _a || _tryRequireFile(lambdaStylePath, ".cjs");
              if (loaded) {
                return [2, loaded];
              }
              nodeStylePath = __require.resolve(module3, {
                paths: [appRoot, moduleRoot]
              });
              return [2, __require(nodeStylePath)];
          }
        });
      });
    }
    __name(_tryRequire, "_tryRequire");
    function _tryRequireSync(appRoot, moduleRoot, module3) {
      var lambdaStylePath = path_1.default.resolve(appRoot, moduleRoot, module3);
      var extensionless = _tryRequireFile(lambdaStylePath);
      if (extensionless) {
        return extensionless;
      }
      var pjHasModule = _hasPackageJsonTypeModule(lambdaStylePath);
      if (!pjHasModule) {
        var loaded_2 = _tryRequireFile(lambdaStylePath, ".js");
        if (loaded_2) {
          return loaded_2;
        }
      }
      var loaded = _tryRequireFile(lambdaStylePath, ".cjs");
      if (loaded) {
        return loaded;
      }
      var nodeStylePath = __require.resolve(module3, {
        paths: [appRoot, moduleRoot]
      });
      return __require(nodeStylePath);
    }
    __name(_tryRequireSync, "_tryRequireSync");
    function _loadUserApp(appRoot, moduleRoot, module3) {
      return __awaiter(this, void 0, void 0, function() {
        var e_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([0, 2, , 3]);
              return [4, _tryRequire(appRoot, moduleRoot, module3)];
            case 1:
              return [2, _a.sent()];
            case 2:
              e_1 = _a.sent();
              if (e_1 instanceof SyntaxError) {
                throw new errors_1.UserCodeSyntaxError(e_1);
              } else if (e_1.code !== void 0 && e_1.code === "MODULE_NOT_FOUND") {
                throw new errors_1.ImportModuleError(e_1);
              } else {
                throw e_1;
              }
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    }
    __name(_loadUserApp, "_loadUserApp");
    function _loadUserAppSync(appRoot, moduleRoot, module3) {
      try {
        return _tryRequireSync(appRoot, moduleRoot, module3);
      } catch (e) {
        if (e instanceof SyntaxError) {
          throw new errors_1.UserCodeSyntaxError(e);
        } else if (e.code !== void 0 && e.code === "MODULE_NOT_FOUND") {
          throw new errors_1.ImportModuleError(e);
        } else {
          throw e;
        }
      }
    }
    __name(_loadUserAppSync, "_loadUserAppSync");
    function _throwIfInvalidHandler(fullHandlerString) {
      if (fullHandlerString.includes(RELATIVE_PATH_SUBSTRING)) {
        throw new errors_1.MalformedHandlerName("'".concat(fullHandlerString, "' is not a valid handler name.Use absolute paths when specifying root directories in handler names."));
      }
    }
    __name(_throwIfInvalidHandler, "_throwIfInvalidHandler");
    var load = /* @__PURE__ */ __name(function(appRoot, fullHandlerString) {
      return __awaiter(this, void 0, void 0, function() {
        var _a, moduleRoot, moduleAndHandler, _b, module3, handlerPath, userApp, handlerFunc;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _throwIfInvalidHandler(fullHandlerString);
              _a = __read(_moduleRootAndHandler(fullHandlerString), 2), moduleRoot = _a[0], moduleAndHandler = _a[1];
              _b = __read(_splitHandlerString(moduleAndHandler), 2), module3 = _b[0], handlerPath = _b[1];
              return [4, _loadUserApp(appRoot, moduleRoot, module3)];
            case 1:
              userApp = _c.sent();
              handlerFunc = _resolveHandler(userApp, handlerPath);
              if (!handlerFunc) {
                throw new errors_1.HandlerNotFound("".concat(fullHandlerString, " is undefined or not exported"));
              }
              if (typeof handlerFunc !== "function") {
                throw new errors_1.HandlerNotFound("".concat(fullHandlerString, " is not a function"));
              }
              return [2, handlerFunc];
          }
        });
      });
    }, "load");
    exports2.load = load;
    var loadSync = /* @__PURE__ */ __name(function(appRoot, fullHandlerString) {
      _throwIfInvalidHandler(fullHandlerString);
      var _a = __read(_moduleRootAndHandler(fullHandlerString), 2), moduleRoot = _a[0], moduleAndHandler = _a[1];
      var _b = __read(_splitHandlerString(moduleAndHandler), 2), module3 = _b[0], handlerPath = _b[1];
      var userApp = _loadUserAppSync(appRoot, moduleRoot, module3);
      var handlerFunc = _resolveHandler(userApp, handlerPath);
      if (!handlerFunc) {
        throw new errors_1.HandlerNotFound("".concat(fullHandlerString, " is undefined or not exported"));
      }
      if (typeof handlerFunc !== "function") {
        throw new errors_1.HandlerNotFound("".concat(fullHandlerString, " is not a function"));
      }
      return handlerFunc;
    }, "loadSync");
    exports2.loadSync = loadSync;
  }
});

// node_modules/datadog-lambda-js/dist/runtime/require-tracer.js
var require_require_tracer = __commonJS({
  "node_modules/datadog-lambda-js/dist/runtime/require-tracer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTraceTree = exports2.subscribeToDC = exports2.RequireNode = void 0;
    var dc = __require("diagnostics_channel");
    var RequireNode = function() {
      function RequireNode2(id, filename, startTime) {
        this.id = id;
        this.filename = filename;
        this.startTime = startTime;
        this.endTime = startTime;
        this.children = [];
      }
      __name(RequireNode2, "RequireNode");
      Object.defineProperty(RequireNode2.prototype, "setEnd", {
        set: function(endTime) {
          this.endTime = endTime;
        },
        enumerable: false,
        configurable: true
      });
      return RequireNode2;
    }();
    exports2.RequireNode = RequireNode;
    var moduleLoadStartChannel = dc.channel("dd-trace:moduleLoadStart");
    var moduleLoadEndChannel = dc.channel("dd-trace:moduleLoadEnd");
    var rootNodes = [];
    var requireStack = [];
    var pushNode = /* @__PURE__ */ __name(function(data) {
      var startTime = Date.now();
      var reqNode = new RequireNode(data.request, data.filename, startTime);
      var maybeParent = requireStack[requireStack.length - 1];
      if (maybeParent) {
        maybeParent.children.push(reqNode);
      }
      requireStack.push(reqNode);
    }, "pushNode");
    var popNode = /* @__PURE__ */ __name(function() {
      var endTime = Date.now();
      var reqNode = requireStack.pop();
      if (reqNode) {
        reqNode.endTime = endTime;
      }
      if (requireStack.length <= 0 && reqNode) {
        rootNodes.push(reqNode);
      }
    }, "popNode");
    var subscribeToDC = /* @__PURE__ */ __name(function() {
      moduleLoadStartChannel.subscribe(pushNode);
      moduleLoadEndChannel.subscribe(popNode);
    }, "subscribeToDC");
    exports2.subscribeToDC = subscribeToDC;
    var getTraceTree = /* @__PURE__ */ __name(function() {
      return rootNodes;
    }, "getTraceTree");
    exports2.getTraceTree = getTraceTree;
  }
});

// node_modules/datadog-lambda-js/dist/runtime/index.js
var require_runtime = __commonJS({
  "node_modules/datadog-lambda-js/dist/runtime/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RequireNode = exports2.getTraceTree = exports2.subscribeToDC = exports2.loadSync = exports2.load = void 0;
    var user_function_1 = require_user_function();
    Object.defineProperty(exports2, "load", { enumerable: true, get: function() {
      return user_function_1.load;
    } });
    Object.defineProperty(exports2, "loadSync", { enumerable: true, get: function() {
      return user_function_1.loadSync;
    } });
    var require_tracer_1 = require_require_tracer();
    Object.defineProperty(exports2, "subscribeToDC", { enumerable: true, get: function() {
      return require_tracer_1.subscribeToDC;
    } });
    Object.defineProperty(exports2, "getTraceTree", { enumerable: true, get: function() {
      return require_tracer_1.getTraceTree;
    } });
    Object.defineProperty(exports2, "RequireNode", { enumerable: true, get: function() {
      return require_tracer_1.RequireNode;
    } });
  }
});

// node_modules/datadog-lambda-js/dist/trace/listener.js
var require_listener2 = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/listener.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceListener = void 0;
    var context_1 = require_context();
    var patch_http_1 = require_patch_http();
    var trace_context_service_1 = require_trace_context_service();
    var trigger_1 = require_trigger();
    var cold_start_tracer_1 = require_cold_start_tracer();
    var utils_1 = require_utils2();
    var cold_start_1 = require_cold_start();
    var constants_1 = require_constants3();
    var constants_2 = require_constants4();
    var patch_console_1 = require_patch_console();
    var tracer_wrapper_1 = require_tracer_wrapper();
    var span_inferrer_1 = require_span_inferrer();
    var span_wrapper_1 = require_span_wrapper();
    var index_1 = require_runtime();
    var TraceListener = function() {
      function TraceListener2(config) {
        this.config = config;
        this.tracerWrapper = new tracer_wrapper_1.TracerWrapper();
        this.contextService = new trace_context_service_1.TraceContextService(this.tracerWrapper);
        this.inferrer = new span_inferrer_1.SpanInferrer(this.tracerWrapper);
      }
      __name(TraceListener2, "TraceListener");
      Object.defineProperty(TraceListener2.prototype, "currentTraceHeaders", {
        get: function() {
          return this.contextService.currentTraceHeaders;
        },
        enumerable: false,
        configurable: true
      });
      TraceListener2.prototype.onStartInvocation = function(event, context) {
        var _a, _b;
        var tracerInitialized = this.tracerWrapper.isTracerAvailable;
        if (this.config.injectLogContext) {
          (0, patch_console_1.patchConsole)(console, this.contextService);
          (0, utils_1.logDebug)("Patched console output with trace context");
        } else {
          (0, utils_1.logDebug)("Didn't patch console output with trace context");
        }
        if (this.config.autoPatchHTTP && !tracerInitialized) {
          (0, utils_1.logDebug)("Patching HTTP libraries");
          (0, patch_http_1.patchHttp)(this.contextService);
        } else {
          (0, utils_1.logDebug)("Not patching HTTP libraries", { autoPatchHTTP: this.config.autoPatchHTTP, tracerInitialized });
        }
        var rootTraceHeaders = this.contextService.extractHeadersFromContext(event, context, this.config.traceExtractor, this.config.decodeAuthorizerContext);
        var parentSpanContext;
        if (this.contextService.traceSource === constants_2.Source.Event || this.config.mergeDatadogXrayTraces) {
          parentSpanContext = rootTraceHeaders ? (_a = this.tracerWrapper.extract(rootTraceHeaders)) !== null && _a !== void 0 ? _a : void 0 : void 0;
          (0, utils_1.logDebug)("Attempting to find parent for the aws.lambda span");
        } else {
          (0, utils_1.logDebug)("Didn't attempt to find parent for aws.lambda span", {
            mergeDatadogXrayTraces: this.config.mergeDatadogXrayTraces,
            traceSource: this.contextService.traceSource
          });
        }
        if (this.config.createInferredSpan) {
          this.inferredSpan = this.inferrer.createInferredSpan(event, context, parentSpanContext, this.config.encodeAuthorizerContext);
        }
        this.lambdaSpanParentContext = ((_b = this.inferredSpan) === null || _b === void 0 ? void 0 : _b.span) || parentSpanContext;
        this.context = context;
        this.triggerTags = (0, trigger_1.extractTriggerTags)(event, context);
        this.stepFunctionContext = (0, context_1.readStepFunctionContextFromEvent)(event);
      };
      TraceListener2.prototype.onEndingInvocation = function(event, result, shouldTagPayload) {
        var _a, _b;
        if (shouldTagPayload === void 0) {
          shouldTagPayload = false;
        }
        if (!this.tracerWrapper.currentSpan)
          return false;
        this.wrappedCurrentSpan = new span_wrapper_1.SpanWrapper(this.tracerWrapper.currentSpan, {});
        if (shouldTagPayload) {
          (0, utils_1.tagObject)(this.tracerWrapper.currentSpan, "function.request", event);
          (0, utils_1.tagObject)(this.tracerWrapper.currentSpan, "function.response", result);
        }
        var coldStartNodes = (0, index_1.getTraceTree)();
        if (coldStartNodes.length > 0 && (0, cold_start_1.didFunctionColdStart)()) {
          var coldStartConfig = {
            tracerWrapper: this.tracerWrapper,
            coldStartSpanFinishTime: (_a = this.wrappedCurrentSpan) === null || _a === void 0 ? void 0 : _a.startTime(),
            parentSpan: this.inferredSpan || this.wrappedCurrentSpan,
            lambdaFunctionName: (_b = this.context) === null || _b === void 0 ? void 0 : _b.functionName,
            minDuration: this.config.minColdStartTraceDuration,
            ignoreLibs: this.config.coldStartTraceSkipLib
          };
          var coldStartTracer = new cold_start_tracer_1.ColdStartTracer(coldStartConfig);
          coldStartTracer.trace(coldStartNodes);
        }
        if (this.triggerTags) {
          var statusCode = (0, trigger_1.extractHTTPStatusCodeTag)(this.triggerTags, result);
          this.triggerTags["http.status_code"] = statusCode;
          if (this.tracerWrapper.currentSpan) {
            this.tracerWrapper.currentSpan.setTag("http.status_code", statusCode);
          }
          if (this.inferredSpan) {
            this.inferredSpan.setTag("http.status_code", statusCode);
            if ((statusCode === null || statusCode === void 0 ? void 0 : statusCode.length) === 3 && (statusCode === null || statusCode === void 0 ? void 0 : statusCode.startsWith("5"))) {
              this.wrappedCurrentSpan.setTag("error", 1);
              return true;
            }
          }
        }
        return false;
      };
      TraceListener2.prototype.injectAuthorizerSpan = function(result, requestId, finishTime) {
        var _a;
        var _b, _c;
        if (!result.context) {
          result.context = {};
        }
        var injectedHeaders = __assign(__assign({}, this.tracerWrapper.injectSpan(((_b = this.inferredSpan) === null || _b === void 0 ? void 0 : _b.span) || ((_c = this.wrappedCurrentSpan) === null || _c === void 0 ? void 0 : _c.span))), (_a = {}, _a[constants_2.parentSpanFinishTimeHeader] = finishTime * 1e6, _a));
        if (requestId) {
          injectedHeaders[constants_2.authorizingRequestIdHeader] = requestId;
        }
        result.context._datadog = Buffer.from(JSON.stringify(injectedHeaders)).toString("base64");
      };
      TraceListener2.prototype.onCompleteInvocation = function(error, result, event) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function() {
          var tracerInitialized, finishTime;
          return __generator(this, function(_d) {
            if (this.triggerTags) {
              (0, context_1.addLambdaFunctionTagsToXray)(this.triggerTags);
            }
            tracerInitialized = this.tracerWrapper.isTracerAvailable;
            if (this.config.autoPatchHTTP && !tracerInitialized) {
              (0, utils_1.logDebug)("Unpatching HTTP libraries");
              (0, patch_http_1.unpatchHttp)();
            }
            finishTime = (_a = this.wrappedCurrentSpan) === null || _a === void 0 ? void 0 : _a.endTime();
            if (this.inferredSpan) {
              (0, utils_1.logDebug)("Finishing inferred span");
              if (error && !this.inferredSpan.isAsync()) {
                (0, utils_1.logDebug)("Setting error tag to inferred span");
                this.inferredSpan.setTag("error", error);
              }
              if (this.inferredSpan.isAsync()) {
                finishTime = ((_b = this.wrappedCurrentSpan) === null || _b === void 0 ? void 0 : _b.startTime()) || Date.now();
              } else {
                finishTime = Date.now();
              }
              this.inferredSpan.finish(finishTime);
            }
            if (this.config.encodeAuthorizerContext && (result === null || result === void 0 ? void 0 : result.principalId) && (result === null || result === void 0 ? void 0 : result.policyDocument)) {
              this.injectAuthorizerSpan(result, (_c = event === null || event === void 0 ? void 0 : event.requestContext) === null || _c === void 0 ? void 0 : _c.requestId, finishTime || Date.now());
            }
            return [2];
          });
        });
      };
      TraceListener2.prototype.onWrap = function(func) {
        var _a, _b, _c;
        var options = {};
        if (this.context) {
          (0, utils_1.logDebug)("Creating the aws.lambda span");
          var functionArn = ((_a = this.context.invokedFunctionArn) !== null && _a !== void 0 ? _a : "").toLowerCase();
          var tk = functionArn.split(":");
          options.tags = {
            cold_start: (0, cold_start_1.didFunctionColdStart)(),
            function_arn: tk.length > 7 ? tk.slice(0, 7).join(":") : functionArn,
            function_version: tk.length > 7 ? tk[7] : "$LATEST",
            request_id: this.context.awsRequestId,
            resource_names: this.context.functionName,
            functionname: (_c = (_b = this.context) === null || _b === void 0 ? void 0 : _b.functionName) === null || _c === void 0 ? void 0 : _c.toLowerCase(),
            datadog_lambda: constants_1.datadogLambdaVersion,
            dd_trace: constants_2.ddtraceVersion
          };
          if (this.contextService.traceSource === constants_2.Source.Xray && this.config.mergeDatadogXrayTraces || this.contextService.traceSource === constants_2.Source.Event) {
            options.tags["_dd.parent_source"] = this.contextService.traceSource;
          }
          if (this.triggerTags) {
            options.tags = __assign(__assign({}, options.tags), this.triggerTags);
          }
        }
        if (this.stepFunctionContext) {
          (0, utils_1.logDebug)("Applying step function context to the aws.lambda span");
          options.tags = __assign(__assign({}, options.tags), this.stepFunctionContext);
        }
        if (this.lambdaSpanParentContext) {
          options.childOf = this.lambdaSpanParentContext;
        }
        options.type = "serverless";
        options.service = "aws.lambda";
        if (this.context) {
          options.resource = this.context.functionName;
        }
        return this.tracerWrapper.wrap("aws.lambda", options, func);
      };
      return TraceListener2;
    }();
    exports2.TraceListener = TraceListener;
  }
});

// node_modules/datadog-lambda-js/dist/trace/index.js
var require_trace = __commonJS({
  "node_modules/datadog-lambda-js/dist/trace/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceListener = void 0;
    var listener_1 = require_listener2();
    Object.defineProperty(exports2, "TraceListener", { enumerable: true, get: function() {
      return listener_1.TraceListener;
    } });
  }
});

// node_modules/datadog-lambda-js/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/datadog-lambda-js/dist/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnvValue = exports2.getTraceHeaders = exports2.sendDistributionMetric = exports2.sendDistributionMetricWithDate = exports2.datadog = exports2.defaultConfig = exports2.coldStartTraceSkipLibEnvVar = exports2.minColdStartTraceDurationEnvVar = exports2.coldStartTracingEnvVar = exports2.decodeAuthorizerContextEnvVar = exports2.encodeAuthorizerContextEnvVar = exports2.defaultSiteURL = exports2.traceExtractorEnvVar = exports2.mergeXrayTracesEnvVar = exports2.lambdaTaskRootEnvVar = exports2.datadogHandlerEnvVar = exports2.enhancedMetricsEnvVar = exports2.logInjectionEnvVar = exports2.logForwardingEnvVar = exports2.logLevelEnvVar = exports2.siteURLEnvVar = exports2.traceManagedServicesEnvVar = exports2.captureLambdaPayloadEnvVar = exports2.apiKeyKMSEnvVar = exports2.apiKeyEnvVar = void 0;
    var metrics_1 = require_metrics2();
    var trace_1 = require_trace();
    var runtime_1 = require_runtime();
    var utils_1 = require_utils2();
    exports2.apiKeyEnvVar = "DD_API_KEY";
    exports2.apiKeyKMSEnvVar = "DD_KMS_API_KEY";
    exports2.captureLambdaPayloadEnvVar = "DD_CAPTURE_LAMBDA_PAYLOAD";
    exports2.traceManagedServicesEnvVar = "DD_TRACE_MANAGED_SERVICES";
    exports2.siteURLEnvVar = "DD_SITE";
    exports2.logLevelEnvVar = "DD_LOG_LEVEL";
    exports2.logForwardingEnvVar = "DD_FLUSH_TO_LOG";
    exports2.logInjectionEnvVar = "DD_LOGS_INJECTION";
    exports2.enhancedMetricsEnvVar = "DD_ENHANCED_METRICS";
    exports2.datadogHandlerEnvVar = "DD_LAMBDA_HANDLER";
    exports2.lambdaTaskRootEnvVar = "LAMBDA_TASK_ROOT";
    exports2.mergeXrayTracesEnvVar = "DD_MERGE_XRAY_TRACES";
    exports2.traceExtractorEnvVar = "DD_TRACE_EXTRACTOR";
    exports2.defaultSiteURL = "datadoghq.com";
    exports2.encodeAuthorizerContextEnvVar = "DD_ENCODE_AUTHORIZER_CONTEXT";
    exports2.decodeAuthorizerContextEnvVar = "DD_DECODE_AUTHORIZER_CONTEXT";
    exports2.coldStartTracingEnvVar = "DD_COLD_START_TRACING";
    exports2.minColdStartTraceDurationEnvVar = "DD_MIN_COLD_START_DURATION";
    exports2.coldStartTraceSkipLibEnvVar = "DD_COLD_START_TRACE_SKIP_LIB";
    exports2.defaultConfig = {
      apiKey: "",
      apiKeyKMS: "",
      autoPatchHTTP: true,
      captureLambdaPayload: false,
      createInferredSpan: true,
      debugLogging: false,
      encodeAuthorizerContext: true,
      decodeAuthorizerContext: true,
      enhancedMetrics: true,
      forceWrap: false,
      injectLogContext: true,
      logForwarding: false,
      mergeDatadogXrayTraces: false,
      shouldRetryMetrics: false,
      siteURL: "",
      minColdStartTraceDuration: 3,
      coldStartTraceSkipLib: ""
    };
    var currentMetricsListener;
    var currentTraceListener;
    if (getEnvValue(exports2.coldStartTracingEnvVar, "true")) {
      (0, runtime_1.subscribeToDC)();
    }
    function datadog2(handler2, config) {
      var _this = this;
      var finalConfig = getConfig(config);
      var metricsListener = new metrics_1.MetricsListener(new metrics_1.KMSService(), finalConfig);
      var traceListener = new trace_1.TraceListener(finalConfig);
      var _ddWrappedKey = "_ddWrapped";
      if (handler2[_ddWrappedKey] !== void 0 && !finalConfig.forceWrap) {
        return handler2;
      }
      (0, utils_1.setLogLevel)(finalConfig.debugLogging ? utils_1.LogLevel.DEBUG : utils_1.LogLevel.ERROR);
      if (finalConfig.logger) {
        (0, utils_1.setLogger)(finalConfig.logger);
      }
      var promHandler = (0, utils_1.promisifiedHandler)(handler2);
      var wrappedFunc = /* @__PURE__ */ __name(function(event, context) {
        return __awaiter(_this, void 0, void 0, function() {
          var err_1, result, localResult, error, didThrow, err_2, err_3;
          var _this2 = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                (0, utils_1.setColdStart)();
                currentMetricsListener = metricsListener;
                currentTraceListener = traceListener;
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                traceListener.onStartInvocation(event, context);
                return [4, metricsListener.onStartInvocation(event)];
              case 2:
                _a.sent();
                if (finalConfig.enhancedMetrics) {
                  (0, metrics_1.incrementInvocationsMetric)(metricsListener, context);
                }
                return [3, 4];
              case 3:
                err_1 = _a.sent();
                if (err_1 instanceof Error) {
                  (0, utils_1.logDebug)("Failed to start listeners", err_1);
                }
                return [3, 4];
              case 4:
                didThrow = false;
                _a.label = 5;
              case 5:
                _a.trys.push([5, 7, , 8]);
                return [4, traceListener.onWrap(function(localEvent, localContext) {
                  return __awaiter(_this2, void 0, void 0, function() {
                    var responseIs5xxError;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          _a2.trys.push([0, , 2, 3]);
                          return [4, promHandler(localEvent, localContext)];
                        case 1:
                          localResult = _a2.sent();
                          return [3, 3];
                        case 2:
                          responseIs5xxError = traceListener.onEndingInvocation(localEvent, localResult, finalConfig.captureLambdaPayload);
                          if (responseIs5xxError) {
                            (0, metrics_1.incrementErrorsMetric)(metricsListener, context);
                          }
                          return [7];
                        case 3:
                          return [2, localResult];
                      }
                    });
                  });
                })(event, context)];
              case 6:
                result = _a.sent();
                return [3, 8];
              case 7:
                err_2 = _a.sent();
                didThrow = true;
                error = err_2;
                return [3, 8];
              case 8:
                _a.trys.push([8, 11, , 12]);
                if (didThrow && finalConfig.enhancedMetrics) {
                  (0, metrics_1.incrementErrorsMetric)(metricsListener, context);
                }
                return [4, metricsListener.onCompleteInvocation()];
              case 9:
                _a.sent();
                return [4, traceListener.onCompleteInvocation(error, result, event)];
              case 10:
                _a.sent();
                return [3, 12];
              case 11:
                err_3 = _a.sent();
                if (err_3 instanceof Error) {
                  (0, utils_1.logDebug)("Failed to complete listeners", err_3);
                }
                return [3, 12];
              case 12:
                currentMetricsListener = void 0;
                currentTraceListener = void 0;
                if (didThrow) {
                  throw error;
                }
                return [2, result];
            }
          });
        });
      }, "wrappedFunc");
      wrappedFunc[_ddWrappedKey] = true;
      return wrappedFunc;
    }
    __name(datadog2, "datadog");
    exports2.datadog = datadog2;
    function sendDistributionMetricWithDate(name, value, metricTime) {
      var tags = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        tags[_i - 3] = arguments[_i];
      }
      tags = __spreadArray(__spreadArray([], __read(tags), false), [getRuntimeTag()], false);
      if (currentMetricsListener !== void 0) {
        currentMetricsListener.sendDistributionMetricWithDate.apply(currentMetricsListener, __spreadArray([name, value, metricTime, false], __read(tags), false));
      } else {
        (0, utils_1.logError)("handler not initialized");
      }
    }
    __name(sendDistributionMetricWithDate, "sendDistributionMetricWithDate");
    exports2.sendDistributionMetricWithDate = sendDistributionMetricWithDate;
    function sendDistributionMetric(name, value) {
      var tags = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        tags[_i - 2] = arguments[_i];
      }
      tags = __spreadArray(__spreadArray([], __read(tags), false), [getRuntimeTag()], false);
      if (currentMetricsListener !== void 0) {
        currentMetricsListener.sendDistributionMetric.apply(currentMetricsListener, __spreadArray([name, value, false], __read(tags), false));
      } else {
        (0, utils_1.logError)("handler not initialized");
      }
    }
    __name(sendDistributionMetric, "sendDistributionMetric");
    exports2.sendDistributionMetric = sendDistributionMetric;
    function getTraceHeaders() {
      if (currentTraceListener === void 0) {
        return {};
      }
      return currentTraceListener.currentTraceHeaders;
    }
    __name(getTraceHeaders, "getTraceHeaders");
    exports2.getTraceHeaders = getTraceHeaders;
    function getConfig(userConfig) {
      var config;
      if (userConfig === void 0) {
        config = exports2.defaultConfig;
      } else {
        config = __assign(__assign({}, exports2.defaultConfig), userConfig);
      }
      if (config.apiKey === "") {
        config.apiKey = getEnvValue(exports2.apiKeyEnvVar, "");
      }
      if (config.siteURL === "") {
        config.siteURL = getEnvValue(exports2.siteURLEnvVar, exports2.defaultSiteURL);
      }
      if (config.apiKeyKMS === "") {
        config.apiKeyKMS = getEnvValue(exports2.apiKeyKMSEnvVar, "");
      }
      if (userConfig === void 0 || userConfig.injectLogContext === void 0) {
        var result = getEnvValue(exports2.logInjectionEnvVar, "true").toLowerCase();
        config.injectLogContext = result === "true";
      }
      if (userConfig === void 0 || userConfig.debugLogging === void 0) {
        var result = getEnvValue(exports2.logLevelEnvVar, "ERROR").toLowerCase();
        config.debugLogging = result === "debug";
      }
      if (userConfig === void 0 || userConfig.logForwarding === void 0) {
        var result = getEnvValue(exports2.logForwardingEnvVar, "false").toLowerCase();
        config.logForwarding = result === "true";
      }
      if (userConfig === void 0 || userConfig.enhancedMetrics === void 0) {
        var result = getEnvValue(exports2.enhancedMetricsEnvVar, "true").toLowerCase();
        config.enhancedMetrics = result === "true";
      }
      if (userConfig === void 0 || userConfig.mergeDatadogXrayTraces === void 0) {
        var result = getEnvValue(exports2.mergeXrayTracesEnvVar, "false").toLowerCase();
        config.mergeDatadogXrayTraces = result === "true";
      }
      if (userConfig === void 0 || userConfig.captureLambdaPayload === void 0) {
        var result = getEnvValue(exports2.captureLambdaPayloadEnvVar, "false").toLowerCase();
        config.captureLambdaPayload = result === "true";
      }
      if (userConfig === void 0 || userConfig.createInferredSpan === void 0) {
        var result = getEnvValue(exports2.traceManagedServicesEnvVar, "true").toLowerCase();
        config.createInferredSpan = result === "true";
      }
      if (userConfig === void 0 || userConfig.encodeAuthorizerContext === void 0) {
        var result = getEnvValue(exports2.encodeAuthorizerContextEnvVar, "true").toLowerCase();
        config.encodeAuthorizerContext = result === "true";
      }
      if (userConfig === void 0 || userConfig.decodeAuthorizerContext === void 0) {
        var result = getEnvValue(exports2.decodeAuthorizerContextEnvVar, "true").toLowerCase();
        config.decodeAuthorizerContext = result === "true";
      }
      if (userConfig === void 0 || userConfig.minColdStartTraceDuration === void 0) {
        config.minColdStartTraceDuration = Number(getEnvValue(exports2.minColdStartTraceDurationEnvVar, "3"));
      }
      if (userConfig === void 0 || userConfig.minColdStartTraceDuration === void 0) {
        config.coldStartTraceSkipLib = getEnvValue(exports2.coldStartTraceSkipLibEnvVar, "./opentracing/tracer");
      }
      return config;
    }
    __name(getConfig, "getConfig");
    function getEnvValue(key, defaultValue) {
      var val = process.env[key];
      return val !== void 0 ? val : defaultValue;
    }
    __name(getEnvValue, "getEnvValue");
    exports2.getEnvValue = getEnvValue;
    function getRuntimeTag() {
      var version = process.version;
      return "dd_lambda_layer:datadog-node".concat(version);
    }
    __name(getRuntimeTag, "getRuntimeTag");
  }
});

// packages/functions/index.ts
var import_dd_trace = __toESM(require_dd_trace2(), 1);
var import_datadog_lambda_js = __toESM(require_dist3(), 1);
import_dd_trace.default.init();
import_dd_trace.default.use("http", {});
var sleep = import_dd_trace.default.wrap("sleep", (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
});
var ddHandler = /* @__PURE__ */ __name(async (event) => {
  const sandwich = import_dd_trace.default.trace("hello.world", () => {
    console.log("Hello, World!");
  });
  await sleep(100);
  const response = {
    statusCode: 200,
    body: JSON.stringify("Hello from example Lambda!")
  };
  return response;
}, "ddHandler");
var handler = (0, import_datadog_lambda_js.datadog)(ddHandler);
export {
  handler
};
/*! Bundled license information:

methods/index.js:
  (*!
   * methods
   * Copyright(c) 2013-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
